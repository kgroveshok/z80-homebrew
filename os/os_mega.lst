# File debug_level2.asm
0000			 
0000			; DEBUG Level 2 - All useful debug on and memory courruption guards 
0000			 
0000			; Odd specific debug points for testing hardware dev 
0000			 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL0: equ 0 
0000			;DEBUG_LEVEL2: equ 1 
0000			DEBUG_LEVEL: equ '2' 
0000			 
0000			DEBUG_SOUND: equ 0      
0000			DEBUG_STK_FAULT: equ 0 
0000			DEBUG_INPUT: equ 0     ; Debug input entry code 
0000			DEBUG_INPUTV2: equ 0     ; Debug input entry code 
0000			DEBUG_KEYCINWAIT: equ 0 
0000			DEBUG_KEYCIN: equ 0 
0000			DEBUG_KEY: equ 0 
0000			DEBUG_KEY_MATRIX: equ 0 
0000			DEBUG_STORECF: equ 0 
0000			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.  
0000			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A 
0000			DEBUG_SPI: equ 0    ; low level spi tests 
0000			 
0000			; Enable many break points 
0000			 
0000			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6 
0000			DEBUG_FORTH_PARSE_NEXTWORD: equ 0 
0000			DEBUG_FORTH_JP: equ 0    ; 4 
0000			DEBUG_FORTH_MALLOC: equ 0 
0000			DEBUG_FORTH_MALLOC_INT: equ 0 
0000			DEBUG_FORTH_DOT: equ 1 
0000			DEBUG_FORTH_DOT_WAIT: equ 0 
0000			DEBUG_FORTH_MATHS: equ 0 
0000			DEBUG_FORTH_TOK: equ 0    ; 4 
0000			DEBUG_FORTH_PARSE: equ 0    ; 3 
0000			DEBUG_FORTH: equ 0  ;2 
0000			DEBUG_FORTH_WORDS: equ 1   ; 1 
0000			DEBUG_FORTH_PUSH: equ 1   ; 1 
0000			DEBUG_FORTH_UWORD: equ 1   ; 1 
0000			 
0000			; Enable key point breakpoints 
0000			 
0000			DEBUG_FORTH_DOT_KEY: equ 0 
0000			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5 
0000			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1 
0000			 
0000			; Debug stack imbalances 
0000			 
0000			ON: equ 1 
0000			OFF: equ 0 
0000			 
0000			DEBUG_STACK_IMB: equ 0 
0000			STACK_IMB_STORE: equ 20 
0000			 
0000			; House keeping and protections 
0000			 
0000			DEBUG_FORTH_STACK_GUARD: equ 1    ; under/over flows 
0000			DEBUG_FORTH_MALLOC_GUARD: equ 1 
0000			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual! 
0000			FORTH_ENABLE_FREE: equ 0 
0000			FORTH_ENABLE_MALLOCFREE: equ 1 
0000			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away 
0000			FORTH_ENABLE_FLOATMATH: equ 0 
0000			; eof 
# End of file debug_level2.asm
# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			STARTUP_V1: equ 0 
0000			STARTUP_V2: equ 1 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			  
0000			; now handled by SPI support 
0000			SOUND_ENABLE: equ 0    
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 ec 1b			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			 
0003 ..			buildtime: db   "Build: " 
000a					include "romtimestamp.asm" 
000a ..			db '2025-09-11 17:03' 
# End of file romtimestamp.asm
001a 00				   db 0 
001b .. 32 00		debuglevel: db   "DL",DEBUG_LEVEL, 0 
001f			 
001f			 
001f			 
001f			;        nop  
001f			;        nop 
001f			;;	org 05h		; null out bdos call 
001f			; 
001f			;        nop  
001f			;        nop  
001f			;        nop 
001f			;;	org 08h 
001f			;;; 
001f			;;	jp cin		; rst 8 - char in 
001f			;;; 
001f			; 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;        nop 
001f			;	org 010h 
001f			;; 
001f			;	jp cout		; rest 010h  - char out 
001f			;; 
001f			;	org 01bh   
001f			; 
001f			;	;jp  		; rst 01bh   - write string to display 
001f			;	jp str_at_display 
001f			; 
001f			; 
001f			;	org 020h 
001f			; 
001f			;	; jp		 ; rst 020h - read char at screen location 
001f			; 
001f			;	org 028h 
001f			 
001f				; jp		 ; rst 028h  - storage i/o 
001f			 
001f			; 	org 030h 
001f			;	jp break_point_state 
001f			  
001f			; $30  
001f			; org 038h 
001f			; $38 
001f			 
001f			; TODO any more important entry points to add to jump table for easier coding use? 
001f			 
001f			if BASE_KEV = 1  
001f			 
001f				; need to be at $66 for nmi support 
001f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0025 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
002b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0031 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0037 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
003d 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0043 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0049 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
004f 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0055 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
005b 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0061 00 ff 00 ff 00 ff		db 0,255,0,255,0,255 
0067 00 ff			db 0,255 
0069 c3 95 77			jp nmi 
006c			endif 
006c			 
006c			include "firmware.asm" 
006c			  
006c			; main constants (used here and in firmware)  
006c			  
006c			; TODO have page 0 of storage as bios  
006c			  
006c			Device_A: equ 0h  
006c			Device_B: equ 040h          ; Sound  
006c			  
006c			if BASE_KEV  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_SC114  
006c			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			; TODO fixup for CPM  
006c			Device_C: equ 080h          ; Storage and ext cart devices  
006c			endif  
006c			  
006c			Device_D: equ 0c0h             ; Keyboard and LCD  
006c			  
006c			; Odd specific debug points for testing hardware dev  
006c			  
006c			;if DEBUG_LEVEL0  
006c			;	include "debug_level0.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL1  
006c			;	include "debug_level1.asm"  
006c			;endif  
006c			;if DEBUG_LEVEL2  
006c			;	include "debug_level2.asm"  
006c			;endif  
006c			  
006c			  
006c			CALLMONITOR: macro  
006c			;	call break_point_state  
006c			; now use the break point debug vector  
006c				call debug_vector  
006c				endm  
006c			  
006c			MALLOC_1: equ 1        ; from dk88   
006c			MALLOC_2: equ 0           ; broke  
006c			MALLOC_3: equ 0           ; really broke  
006c			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
006c			  
006c			if BASE_KEV   
006c			;stacksize: equ 256  
006c			; each stack entry is three bytes (type + word)  
006c			stacksize: equ 3*150  
006c			  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 512  
006c			endif  
006c			if BASE_SC114  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			if BASE_CPM  
006c			;tos:	equ 0f000h  
006c			stacksize: equ 256  
006c			STACK_RET_SIZE: equ 64  
006c			STACK_LOOP_SIZE: equ 128  
006c			STACK_DATA_SIZE: equ 256  
006c			endif  
006c			  
006c			;if STORAGE_SE == 0  
006c			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
006c			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
006c			;endif  
006c			  
006c			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
006c			  
006c			STORE_0_AUTORUN: equ $20  
006c			  
006c			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
006c			  
006c			STORE_0_AUTOFILE: equ $21  
006c			STORE_0_BANKRUN: equ $23  
006c			STORE_0_FILERUN: equ $24  
006c			STORE_0_BANKRUNN: equ $25   ; human readable bank id  
006c			  
006c			; Block 0 offsets for settings  
006c			  
006c			; if set then skip prompt for start up and accept all  
006c			  
006c			STORE_0_QUICKSTART: equ $25  
006c			  
006c			; Blocks where directory table is held  
006c			  
006c			; Reducing the number of entries increases the max file size  
006c			  
006c			;STORE_DIR_START: equ 1  
006c			;STORE_DIR_END: equ 33  
006c			  
006c			; Blocks from where file data is stored  
006c			  
006c			;STORE_DATA_START: equ STORE_DIR_END + 1  
006c			  
006c			; Block indicators (<32 are data files)  
006c			  
006c			;STORE_BLOCK_CFG: equ $8f       ; config block  
006c			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
006c			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
006c			;STORE_BLOCK_FREE: equ $85       ; data block free  
006c			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
006c			  
006c			  
006c			  
006c			; Directory entry flags  
006c			  
006c			;STORE_DIR_FREE: equ 0  
006c			;STORE_DIR_FILE:  equ 1  
006c			  
006c			; Structure offsets to directory entries  
006c			;STORE_DE_FLAG: equ 0  
006c			;STORE_DE_MAXEXT: equ 1  
006c			;STORE_DE_FILENAME: equ 2  
006c			  
006c			; Structure offsets to block 0  
006c			  
006c			;STORE_BK0_ISFOR: equ 1  
006c			;STORE_BK0_LABEL: equ 3  
006c			  
006c			; memory allocation   
006c			  
006c			chk_stund: equ tos+2           ; underflow check word  
006c			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
006c			  
006c			; keyscan table needs rows x cols buffer  
006c			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
006c			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
006c			  
006c			keyscan_table_row1: equ chk_stovr -key_cols-1  
006c			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
006c			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
006c			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
006c			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
006c			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
006c			keyscan_scancol: equ keyscan_table-key_cols  
006c			;keyscan_table_len: equ key_rows*key_cols  
006c			;keybufptr: equ keyscan_table - 2  
006c			;keysymbol: equ keybufptr - 1  
006c			key_held: equ keyscan_scancol-1	; currently held  
006c			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
006c			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
006c			key_fa: equ key_repeat_ct -1 ;  
006c			key_fb: equ key_fa -1 ;  
006c			key_fc: equ key_fb -1 ;  
006c			key_fd: equ key_fc -1 ;  
006c			key_face_held: equ key_fd - 1   
006c			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
006c			  
006c			hardware_config: equ key_face_held - 10  
006c			  
006c			; hardware config switches  
006c			; TODO add bitmasks on includes for hardware  
006c			; high byte for expansion ids  
006c			;     0000 0000  no card inserted  
006c			;     0000 0001  storage card inserted  
006c			;     0000 0010  spi sd card active  
006c			  
006c			;       
006c			; low byte:  
006c			;     0000 0001   4x4 keypad  
006c			;     0000 0010   full keyboard  
006c			;     0000 0011   spi/ext keyboard  
006c			;     0000 0100   20x4 lcd  
006c			;     0000 1000   40x4 lcd  
006c			;     0000 1100   spi/ext display  
006c			;     0001 0000   ide interface available  
006c			  
006c			hardware_word: equ hardware_config - 2  
006c			  
006c			; debug marker - optional display of debug point on the debug screens  
006c			  
006c			nmi_vector:  equ hardware_word - 3   ; vector to the nmi handler  
006c			debug_vector:  equ nmi_vector - 3   ; vector to the debug handler  
006c			parse_vector:  equ debug_vector - 3 ; vector to the parser vector  
006c			  
006c			debug_umark: equ parse_vector - 6  ; current user mark  
006c			debug_mark: equ debug_umark - 4    ; internal word debug points  
006c			  
006c			; input_str vars  
006c			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
006c			input_start:  equ input_ptr - 2    ; ptr to the start of string   
006c			input_size: equ input_start -1  ; number of chars  
006c			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
006c			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
006c			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
006c			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
006c			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
006c			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
006c			input_len: equ input_cur_onoff - 5 ; length of current input  
006c			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
006c			  
006c			; cursor blink rate  
006c			CUR_BLINK_RATE: equ $09  
006c			;CUR_BLINK_RATE: equ 15  
006c			  
006c			key_actual_pressed: equ input_cursor - 1   
006c			key_symbol: equ key_actual_pressed - 1   
006c			key_shift: equ key_symbol - 1   
006c			  
006c			; Display allocation  
006c			  
006c			;display_rows: equ 4     ; move out to mini and mega files  
006c			;display_cols: equ 20  
006c			  
006c			display_fb_len: equ display_rows*display_cols  
006c			  
006c			; primary frame buffer     
006c			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
006c			; working frame buffers  
006c			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
006c			display_fb3: equ  display_fb1-display_fb_len - 1  
006c			display_fb2: equ  display_fb3-display_fb_len - 1  
006c			;  
006c			; pointer to active frame buffer  
006c			display_fb_active: equ display_fb2 - 2  
006c			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
006c			display_write_tmp: equ display_lcde1e2 - 2  
006c			display_active:  equ display_write_tmp-3   ; current state of activity char (plus room to write string)  
006c			  
006c			;  
006c			  
006c			;; can load into de directory  
006c			cursor_col: equ display_active-1  
006c			cursor_row: equ cursor_col-1  
006c			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
006c			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
006c			  
006c			; maths vars  
006c			  
006c			LFSRSeed: equ cursor_shape -20   
006c			randData: equ LFSRSeed - 2  
006c			xrandc: equ randData - 2  
006c			stackstore: equ xrandc - 2  
006c			seed1: equ  stackstore -2   
006c			seed2: equ seed1 - 2  
006c			  
006c			; cf storage vars  
006c			  
006c			iErrorNum:  equ seed2-1         ;Error number  
006c			iErrorReg:  equ iErrorNum -1              ;Error register  
006c			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
006c			  
006c			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
006c			  
006c			STORE_BLOCK_LOG:  equ   280      ; TODO remove.... Logical block size     
006c			  
006c			store_page: equ store_bank_active-STORE_BLOCK_LOG-1            ; bigger than page size for eeprom so we can join multiple blocks if they are continuation records  
006c			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
006c			store_readptr: equ store_page-2       ; tracks the file extent during storage_read of continuation blocks  
006c			store_readbuf: equ store_readptr-2       ; tracks the position for the buffer during storage_read of continuation blocks  
006c			store_longread: equ store_readbuf -1 ;   if zero then only read one block. If not zero then do a read for as long as required  
006c			store_tmp1: equ store_longread - 2      ; temp pointer holders during ops  
006c			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
006c			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
006c			store_tmpid: equ store_tmp3 - 1		; page temp id  
006c			store_tmpext: equ store_tmpid - 1		; file extent temp  
006c			store_readcont: equ store_tmpid - 1		; If current read results in an overflow buffer to next record flag it up  
006c			store_openaddr: equ store_readcont - 2		; file block address of current opened file for read  
006c			store_openext: equ store_openaddr - 1		; file extent of current opened file for read  
006c			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
006c			store_filecache: equ store_openmaxext-2   ;  TODO (using just one for now)  file id + extent count cache * 5  
006c			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
006c			;  
006c			; spi vars  
006c			  
006c			  
006c			spi_clktime: equ store_tmppageid - 1      ; holds the number of ms that happens between spi clock pulses  
006c			spi_cartdev: equ spi_clktime - 1      ; holds bit mask to send to portb (ext spi) devices  
006c			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
006c			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
006c			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
006c			spi_device_id: equ spi_device - 1    ; human readable bank number  
006c			  
006c			;;;;; forth cli params  
006c			  
006c			; TODO use a different frame buffer for forth???  
006c			  
006c			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
006c			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
006c			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
006c			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
006c			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
006c			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
006c			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
006c			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
006c			  
006c			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
006c			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
006c			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
006c			cli_var_array2: equ cli_var_array - ( 26 * 2 ) ; word or string pointer variables using VAR word  
006c			cli_ret_sp: equ cli_var_array2 - 2    ; ret stack pointer  
006c			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
006c			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
006c			  
006c			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
006c			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
006c			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
006c			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
006c			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
006c			chk_data_ovr: equ cli_data_stack -2; overflow check word  
006c			  
006c			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
006c			  
006c			; os/forth token vars  
006c			  
006c			os_last_cmd: equ os_var_array-255  
006c			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
006c			os_current_i: equ os_cli_cmd-2  
006c			os_cur_ptr: equ os_current_i-2  
006c			os_word_scratch: equ os_cur_ptr-30  
006c			os_tok_len: equ os_word_scratch - 2  
006c			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
006c			os_tok_malloc: equ os_tok_ptr - 2  
006c			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
006c			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
006c			execscratch: equ os_input-255        ; exec cmd eval buffer  
006c			scratch: equ execscratch-255  
006c			  
006c			os_stack_1: equ scratch - 3       ; stack holding area 1  
006c			os_stack_2: equ os_stack_1 - 3       ; stack holding area 2  
006c			os_stack_3: equ os_stack_2 - 3       ; stack holding area 3  
006c			os_stack_4: equ os_stack_3 - 3       ; stack holding area 4  
006c			  
006c			  
006c			; temp locations for new word processing to save on adding more   
006c			  
006c			os_new_malloc: equ os_stack_4-2  
006c			os_new_parse_len: equ os_new_malloc - 2  
006c			os_new_word_len: equ os_new_parse_len - 2  
006c			os_new_work_ptr: equ os_new_word_len - 2  
006c			os_new_src_ptr: equ os_new_work_ptr - 2  
006c			os_new_exec: equ os_new_src_ptr - 2  
006c			os_new_exec_ptr: equ os_new_exec - 2  
006c			  
006c			; resume memory alloocations....  
006c			  
006c			;os_view_disable: equ os_new_exec_ptr - 1  
006c			os_view_af: equ os_new_exec_ptr - 2  
006c			os_view_hl: equ os_view_af -2  
006c			os_view_de: equ os_view_hl - 2  
006c			os_view_bc: equ os_view_de - 2  
006c			  
006c			; stack checksum word  
006c			if DEBUG_STACK_IMB  
006c				curframe: equ  os_view_de - 5  
006c				store_sp: equ curframe - (STACK_IMB_STORE*4)  
006c				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			else  
006c				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
006c			endif  
006c			  
006c			; with data stack could see memory filled with junk. need some memory management   
006c			; malloc and free entry points added  
006c			  
006c			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
006c			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			;heap_end: equ free_list-1  ; Starting address of heap  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			  
006c			;heap_start: equ free_list - heap_size  ; Starting address of heap  
006c			heap_end: equ chk_word-1  ; Starting address of heap  
006c			  
006c			  
006c			;if BASE_KEV   
006c			;heap_start: equ 0800eh  ; Starting address of heap  
006c			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;heap_start: equ baseram+15  ; Starting address of heap  
006c			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
006c			;endif  
006c			  
006c			  
006c			;;;;  
006c			  
006c			  
006c			; change below to point to last memory alloc above  
006c			topusermem:  equ   heap_start  
006c			  
006c			;if BASE_KEV   
006c			;baseusermem: equ 08000h  
006c			;endif  
006c			  
006c			;if BASE_SC114  
006c			;;aseusermem:     equ    12  
006c			;baseusermem:     equ    prompt  
006c			;;baseusermem:     equ    endofcode  
006c			;endif  
006c			  
006c			  
006c			; **********************************************************************  
006c			; **  Constants  
006c			; **********************************************************************  
006c			  
006c			; Constants used by this code module  
006c			kDataReg:   EQU Device_D           ;PIO port A data register  
006c			kContReg:   EQU Device_D+2           ;PIO port A control register  
006c			  
006c			  
006c			portbdata:  equ Device_D+1    ; port b data  
006c			portbctl:   equ Device_D+3    ; port b control  
006c			  
006c			  
006c			;KEY_SHIFT:   equ 5  
006c			;KEY_SYMBOLSHIFT:  equ 6  
006c			  
006c			KEY_SHIFTLOCK: equ 4  
006c			  
006c			  
006c			KEY_UP: equ 5  
006c			KEY_NEXTWORD: equ 6  
006c			KEY_PREVWORD: equ 7  
006c			KEY_BS: equ 8  
006c			KEY_TAB:  equ 9  
006c			KEY_DOWN: equ 10  
006c			KEY_LEFT: equ 11  
006c			KEY_RIGHT: equ 12  
006c			KEY_CR:   equ 13  
006c			KEY_HOME: equ 14  
006c			KEY_END: equ 15  
006c			  
006c			KEY_F1: equ 16  
006c			KEY_F2: equ 17  
006c			KEY_F3: equ 18  
006c			KEY_F4: equ 19  
006c			  
006c			KEY_F5: equ 20  
006c			KEY_F6: equ 21  
006c			KEY_F7: equ 22  
006c			KEY_F8: equ 23  
006c			  
006c			KEY_F9: equ 24  
006c			KEY_F10: equ 25  
006c			KEY_F11: equ 26  
006c			KEY_F12: equ 27  
006c			  
006c			;if DEBUG_KEY  
006c			;	KEY_MATRIX_NO_PRESS: equ '.'  
006c			;	KEY_SHIFT:   equ '.'  
006c			;	KEY_SYMBOLSHIFT:  equ '.'  
006c			;else  
006c				KEY_SHIFT:   equ '~'  
006c				KEY_SYMBOLSHIFT:  equ '~'  
006c				KEY_MATRIX_NO_PRESS: equ '~'  
006c			;endi  
006c			  
006c			  
006c			  
006c			  
006c			; Macro to make adding debug marks easier  
006c			  
006c			DMARK: macro str  
006c				push af  
006c				ld a, (.dmark)  
006c				ld (debug_mark),a  
006c				ld a, (.dmark+1)  
006c				ld (debug_mark+1),a  
006c				ld a, (.dmark+2)  
006c				ld (debug_mark+2),a  
006c				jr .pastdmark  
006c			.dmark: db str  
006c			.pastdmark: pop af  
006c			  
006c			endm  
006c			  
006c			  
006c			; macro to detect for stack imbalances  
006c			  
006c			include "stackimbal.asm"  
006c			; Macro and code to detect stock imbalances 
006c			 
006c			SPPUSH: equ 0 
006c			 
006c			; Add a stack frame which can be checked before return 
006c			 
006c			STACKFRAME: macro onoff frame1 frame2 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c						exx 
006c			 
006c						ld de, frame1 
006c						ld a, d 
006c						ld hl, curframe 
006c						call hexout 
006c						ld a, e 
006c						ld hl, curframe+2 
006c						call hexout 
006c			  
006c						ld hl, frame1 
006c						push hl 
006c						ld hl, frame2 
006c						push hl 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			endm 
006c			 
006c			STACKFRAMECHK: macro onoff frame1 frame2 
006c			 
006c					 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						exx 
006c						; check stack frame SP 
006c			 
006c						ld hl, frame2 
006c						pop de   ; frame2 
006c			 
006c						call cmp16 
006c						jr nz, .spnosame 
006c						 
006c			 
006c						ld hl, frame1 
006c						pop de   ; frame1 
006c			 
006c						call cmp16 
006c						jr z, .spfrsame 
006c			 
006c						.spnosame: call showsperror 
006c			 
006c						.spfrsame: nop 
006c			 
006c						exx 
006c					endif 
006c					 
006c				endif 
006c			 
006c			 
006c			endm 
006c			 
006c			 
006c			; for a sub routine, wrap SP collection and comparisons 
006c			 
006c			; Usage: 
006c			; 
006c			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
006c			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
006c			 
006c			SAVESP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c						; save current SP 
006c			 
006c						ld (store_sp+(storeword*4)), sp 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			CHECKSP: macro onoff storeword 
006c			 
006c				if DEBUG_STACK_IMB 
006c					if onoff 
006c			 
006c						; save SP after last save 
006c				 
006c						ld (store_sp+(storeword*4)+2), sp 
006c			 
006c						push hl 
006c						ld hl, store_sp+(storeword*4) 
006c						call check_stack_sp  
006c						pop hl 
006c			 
006c			 
006c					endif 
006c					 
006c				endif 
006c			 
006c			endm 
006c			 
006c			if DEBUG_STACK_IMB 
006c			 
006c			check_stack_sp: 
006c					push de 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					push de 
006c			 
006c			 
006c					ld e, (hl) 
006c					inc hl 
006c					ld d, (hl) 
006c					inc hl 
006c			 
006c					pop hl 
006c			 
006c			 
006c					; check to see if the same 
006c			 
006c					call cmp16 
006c					jr z, .spsame 
006c			 
006c					; not same 
006c			 
006c					call showsperror 
006c			.spsame: 
006c			 
006c					pop de 
006c			 
006c					ret 
006c			 
006c			.sperr:  db "Stack imbalance",0 
006c			 
006c			 
006c			showsperror: 
006c			 
006c			 
006c				push hl 
006c				push af 
006c				push de 
006c				call clear_display 
006c				ld de, .sperr 
006c				ld a,0 
006c			;	ld de,os_word_scratch 
006c				call str_at_display 
006c				ld a, display_row_1+17 
006c				ld de, debug_mark 
006c				call str_at_display 
006c				ld a, 0 
006c				ld (curframe+4),a 
006c				ld hl, curframe 
006c				ld de, os_word_scratch 
006c				ld a, display_row_4 
006c				call str_at_display 
006c				call update_display 
006c				;call break_point_state 
006c				call cin_wait 
006c			 
006c			;	ld a, ' ' 
006c			;	ld (os_view_disable), a 
006c				call bp_on 
006c				pop de	 
006c				pop af 
006c				pop hl 
006c				CALLMONITOR 
006c				ret 
006c			 
006c			endif 
006c			 
006c			 
006c			 
006c			; eof 
# End of file stackimbal.asm
006c			  
006c			;TODO macro to calc col and row offset into screen  
006c			  
006c			  
006c			  
006c			hardware_init:  
006c			  
006c				  
006c			  
006c					;ld a, 0  
006c					;ld (hardware_diag), a  
006c			  
006c					; clear all the buffers  
006c			  
006c 21 42 fc				ld hl, display_fb1  
006f 22 fe fa				ld (display_fb_active), hl  
0072			  
0072 cd 7c 0d				call clear_display  
0075			  
0075 21 00 fb				ld hl, display_fb2  
0078 22 fe fa				ld (display_fb_active), hl  
007b			  
007b cd 7c 0d				call clear_display  
007e			  
007e					; init primary frame buffer area  
007e 21 e3 fc				ld hl, display_fb0  
0081 22 fe fa				ld (display_fb_active), hl  
0084			  
0084 cd 7c 0d				call clear_display  
0087			  
0087			  
0087 cd a2 77				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
008a			  
008a cd 39 7a			call key_init  
008d cd 42 02			call storage_init  
0090			  
0090				; setup malloc functions  
0090			  
0090				if MALLOC_1  
0090 cd 54 13				call  heap_init  
0093				endif  
0093				if MALLOC_4  
0093					call  heap_init  
0093				endif  
0093			  
0093				; init sound hardware if present  
0093			  
0093				if SOUND_ENABLE  
0093					call sound_init  
0093				endif  
0093			  
0093				; lcd test sequence  
0093					  
0093 cd 9e 0d			call update_display  
0096 cd c0 0c			call delay1s  
0099 3e 2b			ld a,'+'  
009b cd 81 0d			call fill_display  
009e cd 9e 0d			call update_display  
00a1 cd c0 0c			call delay1s  
00a4 3e 2a			ld a,'*'  
00a6 cd 81 0d			call fill_display  
00a9 cd 9e 0d			call update_display  
00ac cd c0 0c			call delay1s  
00af 3e 2d			ld a,'-'  
00b1 cd 81 0d			call fill_display  
00b4 cd 9e 0d			call update_display  
00b7 cd c0 0c			call delay1s  
00ba			  
00ba			; boot splash screen  
00ba			if display_cols == 20	  
00ba			        ld a, display_row_1    
00ba			else  
00ba 3e 0a		        ld a, display_row_1 +10   
00bc			endif  
00bc 11 a9 1a			ld de, prom_bootmsg  
00bf cd 8e 0d			call str_at_display  
00c2 cd 9e 0d			call update_display  
00c5			  
00c5			  
00c5 cd c0 0c			call delay1s  
00c8 cd c0 0c			call delay1s  
00cb			if display_cols == 20	  
00cb			            LD   A, display_row_3+2  
00cb			else  
00cb 3e 5c		            LD   A, display_row_3+12  
00cd			endif  
00cd 11 be 1a			ld de, prom_bootmsg1  
00d0 cd 8e 0d			call str_at_display  
00d3			; display debug level  
00d3 3e 78		            LD   A, display_row_4  
00d5 11 1b 00			ld de, debuglevel  
00d8 cd 8e 0d			call str_at_display  
00db			  
00db cd 9e 0d			call update_display  
00de cd c0 0c			call delay1s  
00e1 cd c0 0c			call delay1s  
00e4			  
00e4			;	ld a, display_row_4+3  
00e4			;	ld de, bootmsg2  
00e4			;	call str_at_display  
00e4			;	call update_display  
00e4			;	call delay1s  
00e4			;	call delay1s  
00e4			  
00e4			; debug mark setup  
00e4			  
00e4 3e 5f		ld a, '_'  
00e6 32 9d fd		ld (debug_mark),a  
00e9 32 9e fd		ld (debug_mark+1),a  
00ec 32 9f fd		ld (debug_mark+2),a  
00ef 3e 00		ld a,0  
00f1 32 a0 fd		ld (debug_mark+3),a  
00f4 32 a1 fd		ld (debug_umark),a  
00f7			  
00f7 c9					ret  
00f8			  
00f8			  
00f8			;bootmsg2:	db "Firmware v0.1",0  
00f8			  
00f8			; a 4x20 lcd  
00f8			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00f8			  
00f8			;if display_cols == 20  
00f8			;	include "firmware_lcd_4x20.asm"  
00f8			;endif  
00f8			  
00f8			;if display_cols == 40  
00f8			;	include "firmware_lcd_4x40.asm"  
00f8			;endif  
00f8			  
00f8			;  
00f8			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00f8			; TODO abstract the bit bang video out interface for dual display  
00f8			; TODO wire video out to tx pin on rc2014 bus  
00f8			  
00f8			; must supply cin, and cin_wait for low level hardware abstraction   
00f8			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00f8			; test scancode  
00f8			  
00f8			;;;;;  
00f8			;;;  
00f8			; Moved out to mini and maxi versions  
00f8			;  
00f8			; include "firmware_key_4x4.asm"  
00f8			; using existing 4 wire x 4 resistor array for input  
00f8			;include "firmware_key_4x10.asm"  
00f8			; need to mod the board for 5 rows due to resistor array  
00f8			;include "firmware_key_5x10.asm"  
00f8			  
00f8			; storage hardware interface  
00f8			  
00f8			; use microchip serial eeprom for storage  
00f8			  
00f8			  
00f8			if STORAGE_SE  
00f8				include "firmware_spi.asm"  
00f8			; my spi protocol (used by storage) 
00f8			 
00f8			; SPI pins 
00f8			 
00f8			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00f8			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00f8			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00f8			 
00f8			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00f8			; chip pin 4 gnd 
00f8			 
00f8			 
00f8			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00f8			SPI_CE1: equ 1      ;    port a1 pin 14  
00f8			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00f8			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00f8			SPI_CE4: equ 4      ; port a4     pin 10 
00f8			 
00f8			; active low AND masks 
00f8			 
00f8			;SPI_CE0_MASK: equ    255-1 
00f8			;SPI_CE1_MASK: equ   255-2 
00f8			;SPI_CE2_MASK: equ   255-4 
00f8			;SPI_CE3_MASK: equ   255-8 
00f8			;SPI_CE4_MASK: equ   255-16 
00f8			SPI_CE_HIGH:  equ 255 
00f8			 
00f8			 
00f8			 
00f8			;  Perform SCLK wait pulse 
00f8			 
00f8			spi_clk: 
00f8 f5				push af 
00f9 3a 96 f9			ld a, (spi_clktime) 
00fc			;	cp 0 
00fc b7				or a 
00fd 28 03			jr z, .scskip 
00ff cd a5 0c			call aDelayInMS 
0102			.scskip: 
0102 f1				pop af 
0103 c9				ret 
0104			 
0104			 
0104			 
0104			; TODO store port id for spi device ie dev c 
0104			; TODO store pin for SO 
0104			; TODO store pin for SI 
0104			; TODO store pin for SCLK 
0104			 
0104			; 
0104			 
0104			; ensure that spi bus is in a stable state with default pins  
0104			 
0104			se_stable_spi:   
0104			 
0104				 ; set DI high, CE high , SCLK low 
0104				;ld a, SPI_DI | SPI_CE0 
0104 3e 07			ld a, SPI_DI  
0106 cd fd 01			call spi_ce_high 
0109 d3 80			 out (storage_adata),a 
010b 32 93 f9			ld (spi_portbyte),a 
010e			 
010e				if DEBUG_SPI 
010e					push hl 
010e					ld l, a 
010e					DMARK "SPI" 
010e					CALLMONITOR 
010e					pop hl 
010e				endif 
010e c9				ret 
010f			 
010f			; byte to send in a 
010f			 
010f			spi_send_byte: 
010f				; save byte to send for bit mask shift out 
010f 4f			        ld c,a 
0110 3a 93 f9			ld a,(spi_portbyte) 
0113				  
0113				; clock out	each bit of the byte msb first 
0113			 
0113 06 08			ld b, 8 
0115			.ssb1: 
0115				; clear so bit  
0115 cb bf			res SPI_DI, a 
0117 cb 11			rl c 
0119				; if bit 7 is set then carry is set 
0119 30 02			jr nc, .ssb2 
011b cb ff			set SPI_DI,a 
011d			.ssb2:  ; output bit to ensure it is stable 
011d d3 80			out (storage_adata),a 
011f			;	nop 
011f				; clock bit high 
011f cb ef			set SPI_SCLK,a 
0121 d3 80			out (storage_adata),a 
0123			;	nop 
0123 cd f8 00			call spi_clk 
0126				; then low 
0126 cb af			res SPI_SCLK,a 
0128 d3 80			out (storage_adata),a 
012a			;	nop 
012a cd f8 00			call spi_clk 
012d 10 e6			djnz .ssb1 
012f			 
012f 32 93 f9			ld (spi_portbyte),a 
0132 c9				ret 
0133			 
0133			; TODO low level get byte into A on spi 
0133			 
0133			spi_read_byte:  
0133			 
0133				; save byte to send for bit mask shift out 
0133 0e 00		    ld c,0 
0135 3a 93 f9			ld a,(spi_portbyte) 
0138				  
0138				; clock out	each bit of the byte msb first 
0138			 
0138			 
0138				; clock bit high 
0138 cb ef			set SPI_SCLK,a 
013a d3 80			out (storage_adata),a 
013c			;	nop 
013c cd f8 00			call spi_clk 
013f			 
013f			    ; read DO  
013f			 
013f cb f9		    set 7,c 
0141 db 80			in a,(storage_adata) 
0143 cb 77		    bit SPI_DO,a 
0145 20 02		    jr nz, .b7 
0147 cb b9		    res 7,c 
0149			.b7: 
0149				; then low 
0149 cb af			res SPI_SCLK,a 
014b d3 80			out (storage_adata),a 
014d			;	nop 
014d cd f8 00			call spi_clk 
0150			     
0150			 
0150				; clock bit high 
0150 cb ef			set SPI_SCLK,a 
0152 d3 80			out (storage_adata),a 
0154			;	nop 
0154 cd f8 00			call spi_clk 
0157			 
0157			    ; read DO  
0157			 
0157 cb f1		    set 6,c 
0159 db 80			in a,(storage_adata) 
015b cb 77		    bit SPI_DO,a 
015d 20 02		    jr nz, .b6 
015f cb b1		    res 6,c 
0161			.b6: 
0161				; then low 
0161 cb af			res SPI_SCLK,a 
0163 d3 80			out (storage_adata),a 
0165			;	nop 
0165 cd f8 00			call spi_clk 
0168			 
0168				; clock bit high 
0168 cb ef			set SPI_SCLK,a 
016a d3 80			out (storage_adata),a 
016c			;	nop 
016c cd f8 00			call spi_clk 
016f			 
016f			 
016f			    ; read DO  
016f			 
016f cb e9		    set 5,c 
0171 db 80			in a,(storage_adata) 
0173 cb 77		    bit SPI_DO,a 
0175 20 02		    jr nz, .b5 
0177 cb a9		    res 5,c 
0179			.b5: 
0179				; then low 
0179 cb af			res SPI_SCLK,a 
017b d3 80			out (storage_adata),a 
017d			;	nop 
017d cd f8 00			call spi_clk 
0180				; clock bit high 
0180 cb ef			set SPI_SCLK,a 
0182 d3 80			out (storage_adata),a 
0184			;	nop 
0184 cd f8 00			call spi_clk 
0187			 
0187			    ; read DO  
0187			 
0187 cb e1		    set 4,c 
0189 db 80			in a,(storage_adata) 
018b cb 77		    bit SPI_DO,a 
018d 20 02		    jr nz, .b4 
018f cb a1		    res 4,c 
0191			.b4: 
0191				; then low 
0191 cb af			res SPI_SCLK,a 
0193 d3 80			out (storage_adata),a 
0195			;	nop 
0195 cd f8 00			call spi_clk 
0198				; clock bit high 
0198 cb ef			set SPI_SCLK,a 
019a d3 80			out (storage_adata),a 
019c			;	nop 
019c cd f8 00			call spi_clk 
019f			 
019f			    ; read DO  
019f			 
019f cb d9		    set 3,c 
01a1 db 80			in a,(storage_adata) 
01a3 cb 77		    bit SPI_DO,a 
01a5 20 02		    jr nz, .b3 
01a7 cb 99		    res 3,c 
01a9			.b3: 
01a9				; then low 
01a9 cb af			res SPI_SCLK,a 
01ab d3 80			out (storage_adata),a 
01ad			;	nop 
01ad cd f8 00			call spi_clk 
01b0				; clock bit high 
01b0 cb ef			set SPI_SCLK,a 
01b2 d3 80			out (storage_adata),a 
01b4			;	nop 
01b4 cd f8 00			call spi_clk 
01b7			 
01b7			    ; read DO  
01b7			 
01b7 cb d1		    set 2,c 
01b9 db 80			in a,(storage_adata) 
01bb cb 77		    bit SPI_DO,a 
01bd 20 02		    jr nz, .b2 
01bf cb 91		    res 2,c 
01c1			.b2: 
01c1				; then low 
01c1 cb af			res SPI_SCLK,a 
01c3 d3 80			out (storage_adata),a 
01c5			;	nop 
01c5 cd f8 00			call spi_clk 
01c8				; clock bit high 
01c8 cb ef			set SPI_SCLK,a 
01ca d3 80			out (storage_adata),a 
01cc			;	nop 
01cc cd f8 00			call spi_clk 
01cf			 
01cf			    ; read DO  
01cf			 
01cf cb c9		    set 1,c 
01d1 db 80			in a,(storage_adata) 
01d3 cb 77		    bit SPI_DO,a 
01d5 20 02		    jr nz, .b1 
01d7 cb 89		    res 1,c 
01d9			.b1: 
01d9				; then low 
01d9 cb af			res SPI_SCLK,a 
01db d3 80			out (storage_adata),a 
01dd			;	nop 
01dd cd f8 00			call spi_clk 
01e0				; clock bit high 
01e0 cb ef			set SPI_SCLK,a 
01e2 d3 80			out (storage_adata),a 
01e4			;	nop 
01e4 cd f8 00			call spi_clk 
01e7			 
01e7			    ; read DO  
01e7			 
01e7 cb c1		    set 0,c 
01e9 db 80			in a,(storage_adata) 
01eb cb 77		    bit SPI_DO,a 
01ed 20 02		    jr nz, .b0 
01ef cb 81		    res 0,c 
01f1			.b0: 
01f1				; then low 
01f1 cb af			res SPI_SCLK,a 
01f3 d3 80			out (storage_adata),a 
01f5			;	nop 
01f5 cd f8 00			call spi_clk 
01f8			 
01f8			 
01f8 32 93 f9			ld (spi_portbyte),a 
01fb			 
01fb			    ; return byte 
01fb 79			    ld a,c 
01fc			 
01fc			 
01fc c9				ret 
01fd			 
01fd			 
01fd			 
01fd			spi_ce_high: 
01fd			 
01fd				if DEBUG_SPI_HARD_CE0 
01fd			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
01fd					ret 
01fd			 
01fd				endif 
01fd			 
01fd			 
01fd f5				push af 
01fe			 
01fe				; send direct ce to port b 
01fe 3e ff			ld a, 255 
0200 d3 81			out (storage_bdata), a 
0202			 
0202 f1				pop af 
0203			 
0203				; for port a that shares with spi lines AND the mask 
0203			  
0203				if DEBUG_SPI 
0203					push hl 
0203					ld h, a 
0203				endif 
0203			;	ld c, SPI_CE_HIGH 
0203			;	and c 
0203 cb c7			set SPI_CE0, a 
0205 cb cf			set SPI_CE1, a 
0207 cb d7			set SPI_CE2, a 
0209 cb df			set SPI_CE3, a 
020b cb e7			set SPI_CE4, a 
020d			 
020d				if DEBUG_SPI 
020d					ld l, a 
020d					DMARK "CEh" 
020d					CALLMONITOR 
020d					pop hl 
020d				endif 
020d c9				ret 
020e			 
020e			 
020e			spi_ce_low: 
020e			 
020e				if DEBUG_SPI_HARD_CE0 
020e			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e					ret 
020e			 
020e				endif 
020e			 
020e c5				push bc 
020f f5				push af 
0210			 
0210				; send direct ce to port b 
0210 3a 95 f9			ld a, (spi_cartdev) 
0213 d3 81			out (storage_bdata), a 
0215			 
0215			 
0215			 
0215				; for port a that shares with spi lines AND the mask 
0215			 
0215 3a 92 f9			ld a, (spi_device)  
0218 4f				ld c, a 
0219			 
0219 f1				pop af 
021a			 
021a				; detect CEx 
021a			 
021a				if DEBUG_SPI 
021a					push hl 
021a					ld h, a 
021a				endif 
021a			 
021a cb 41			bit SPI_CE0, c 
021c 20 04			jr nz, .cel1 
021e cb 87			res SPI_CE0, a 
0220 18 1e			jr .celn 
0222			.cel1: 
0222 cb 49			bit SPI_CE1, c 
0224 20 04			jr nz, .cel2 
0226 cb 8f			res SPI_CE1, a 
0228 18 16			jr .celn 
022a			.cel2: 
022a cb 51			bit SPI_CE2, c 
022c 20 04			jr nz, .cel3 
022e cb 97			res SPI_CE2, a 
0230 18 0e			jr .celn 
0232			.cel3: 
0232 cb 59			bit SPI_CE3, c 
0234 20 04			jr nz, .cel4 
0236 cb 9f			res SPI_CE3, a 
0238 18 06			jr .celn 
023a			.cel4: 
023a cb 61			bit SPI_CE4, c 
023c 20 02			jr nz, .celn 
023e cb a7			res SPI_CE4, a 
0240			.celn: 
0240			 
0240			 
0240			 
0240			;	add c 
0240			 
0240				if DEBUG_SPI 
0240					ld l, a 
0240					DMARK "CEl" 
0240					CALLMONITOR 
0240					pop hl 
0240				endif 
0240 c1				pop bc 
0241 c9				ret 
0242			 
0242			 
0242			 
0242			; eof 
0242			 
0242			 
0242			 
0242			 
0242			 
# End of file firmware_spi.asm
0242				include "firmware_seeprom.asm"  
0242			; 
0242			; persisent storage interface via microchip serial eeprom 
0242			 
0242			; port a pio 2 
0242			; pa 7 - si 
0242			; pa 6 - sclk  
0242			; pa 5 - so 
0242			; pa 4 - cs 
0242			; pa 3 - cs 
0242			; pa 2 - cs 
0242			; pa 1 - cs 
0242			; pa 0 - cs 
0242			; 
0242			; TODO get block 
0242			; TODO save block 
0242			; TODO load file 
0242			; TODO save file 
0242			; TODO get dir  
0242			 
0242			;  
0242			storage_adata: equ Device_C    ; device c port a - onboard storage 
0242			storage_actl: equ Device_C+2     ; device c port a 
0242			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
0242			storage_bctl: equ Device_C+3     ; device c port b 
0242			 
0242			 
0242			; TODO move these to hardware driver file 
0242			 
0242			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
0242			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
0242			; storage bank file system format 
0242			; 
0242			; first page of bank: 
0242			; 	addr 0 - status check 
0242			;       addr 1 - write protect flag 
0242			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
0242			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
0242			;         TODO see if scanning whole of for available next file id is fast enough 
0242			;	addr 4 > zero term string of bank label 
0242			; 
0242			;        
0242			;  
0242			; first page of any file: 
0242			;      byte 0 - file id  
0242			;      byte 1-17 - fixed file name  
0242			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
0242			; 
0242			; other pages of any file: 
0242			;      byte 0 - file id 
0242			;      byte 1> - file data 
0242			; 
0242			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
0242			;  
0242			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
0242			 
0242			 
0242			;storage_so_bit: 5 
0242			;storage_si_bit: 7 
0242			;storage_sclk_bit: 6 
0242			  
0242			 
0242			; init storage pio 
0242			 
0242			storage_init: 
0242			 
0242			 
0242					; set default SPI clk pulse time as disabled 
0242			 
0242 3e 00				ld a, 0 
0244 32 96 f9				ld (spi_clktime), a 
0247			 
0247					; init hardware 
0247			 
0247 3e cf		            LD   A, 11001111b 
0249 d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
024b 3e 00		            LD   A, 00000000b 
024d cb f7			set SPI_DO,a 
024f			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
024f d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
0251			 
0251 3e cf		            LD   A, 11001111b 
0253 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
0255 3e 00		            LD   A, 00000000b 
0257 d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
0259			 
0259				; set all external spi devices off  
0259 3e ff			ld a, 255 
025b 32 92 f9			ld (spi_device), a 
025e 32 95 f9			ld (spi_cartdev), a 
0261			 
0261					; ensure the spi bus is in a default stable state 
0261 cd 04 01				call se_stable_spi 
0264			 
0264			; TODO scan spi bus and gather which storage banks are present 
0264			 
0264			; populate store_bank_active  
0264			; for each ce line activate and attempt to write first byte of bank and read back 
0264			; if zero is returned then bank is empty 
0264			;   
0264			; 
0264			 
0264					; init file extent cache to save on slow reads 
0264			 
0264			;	ld hl, store_filecache 
0264			;	ld de, 0 
0264			;	ld hl,(de)	 
0264			 
0264			 
0264 c9			    ret 
0265			 
0265			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
0265			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
0265			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
0265			 
0265			; INSTRUCTION SET 
0265			; READ 0000 0011 Read data from memory array beginning at selected address 
0265			; WRITE 0000 0010 Write data to memory array beginning at selected address 
0265			; WREN 0000 0110 Set the write enable latch (enable write operations) 
0265			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
0265			; RDSR 0000 0101 Read STATUS register 
0265			; WRSR 0000 0001 Write STATUS register 
0265			; PE 0100 0010 Page Erase – erase one page in memory array 
0265			; SE 1101 1000 Sector Erase – erase one sector in memory array 
0265			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
0265			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
0265			 
0265			; TODO send byte steam for page without setting the address for every single byte 
0265			; TODO read byte  
0265			 
0265			; byte in a 
0265			; address in hl  
0265			se_writebyte: 
0265			        
0265			    ;   ld c, a 
0265 f5			        push af 
0266 e5			        push hl 
0267			 
0267			    ; initi write mode 
0267			    ; 
0267			    ;CS low 
0267			 
0267 3a 93 f9		       ld a,(spi_portbyte) 
026a cd 0e 02			call spi_ce_low 
026d			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
026d d3 80		       out (storage_adata),a 
026f 32 93 f9		       ld (spi_portbyte), a 
0272			 
0272			    ;clock out wren instruction 
0272			 
0272 3e 06		    ld a, store_wren_ins 
0274 cd 0f 01		    call spi_send_byte  
0277			 
0277			    ;cs high to enable write latch 
0277			 
0277 3a 93 f9		       ld a,(spi_portbyte) 
027a cd fd 01			call spi_ce_high 
027d			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
027d d3 80		       out (storage_adata),a 
027f 32 93 f9		       ld (spi_portbyte), a 
0282			 
0282			;	nop 
0282			    ; 
0282			    ; intial write data 
0282			    ; 
0282			    ; cs low 
0282			     
0282			;       ld a,(spi_portbyte) 
0282 cd 0e 02			call spi_ce_low 
0285			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0285 d3 80		       out (storage_adata),a 
0287 32 93 f9		       ld (spi_portbyte), a 
028a			 
028a			    ; clock out write instruction 
028a			     
028a 3e 02		    ld a, store_write_ins  
028c cd 0f 01		    call spi_send_byte  
028f			 
028f			    ; clock out address (depending on address size) 
028f			     
028f e1			    pop hl 
0290 7c			    ld a,h    ; address out msb first 
0291 cd 0f 01		    call spi_send_byte  
0294 7d			    ld a,l 
0295 cd 0f 01		    call spi_send_byte  
0298			 
0298			    ; clock out byte(s) for page 
0298			 
0298 f1			    pop af 
0299 cd 0f 01		    call spi_send_byte  
029c			 
029c			    ; end write with ce high 
029c 3a 93 f9		       ld a,(spi_portbyte) 
029f			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
029f cd fd 01			call spi_ce_high 
02a2 d3 80		       out (storage_adata),a 
02a4 32 93 f9		       ld (spi_portbyte), a 
02a7			 
02a7				; pause for internal write cycle 
02a7 3e 0a			ld a, 10 
02a9 cd a5 0c			call aDelayInMS 
02ac c9			    ret 
02ad			 
02ad			; buffer to write in de 
02ad			; address in hl  
02ad			se_writepage: 
02ad			        
02ad			    ;   ld c, a 
02ad d5				push de 
02ae e5			        push hl 
02af			 
02af			    ; initi write mode 
02af			    ; 
02af			    ;CS low 
02af			 
02af 3a 93 f9		       ld a,(spi_portbyte) 
02b2 cd 0e 02			call spi_ce_low 
02b5			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02b5 d3 80		       out (storage_adata),a 
02b7 32 93 f9		       ld (spi_portbyte), a 
02ba			 
02ba			    ;clock out wren instruction 
02ba			 
02ba 3e 06		    ld a, store_wren_ins 
02bc cd 0f 01		    call spi_send_byte  
02bf			 
02bf			    ;cs high to enable write latch 
02bf			 
02bf 3a 93 f9		       ld a,(spi_portbyte) 
02c2 cd fd 01			call spi_ce_high 
02c5			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
02c5 d3 80		       out (storage_adata),a 
02c7 32 93 f9		       ld (spi_portbyte), a 
02ca			 
02ca			;	nop 
02ca			    ; 
02ca			    ; intial write data 
02ca			    ; 
02ca			    ; cs low 
02ca			     
02ca			;       ld a,(spi_portbyte) 
02ca			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
02ca cd 0e 02			call spi_ce_low 
02cd d3 80		       out (storage_adata),a 
02cf 32 93 f9		       ld (spi_portbyte), a 
02d2			 
02d2			    ; clock out write instruction 
02d2			     
02d2 3e 02		    ld a, store_write_ins  
02d4 cd 0f 01		    call spi_send_byte  
02d7			 
02d7			    ; clock out address (depending on address size) 
02d7			     
02d7 e1			    pop hl 
02d8 7c			    ld a,h    ; address out msb first 
02d9 cd 0f 01		    call spi_send_byte  
02dc 7d			    ld a,l 
02dd cd 0f 01		    call spi_send_byte  
02e0			 
02e0			    ; clock out byte(s) for page 
02e0			 
02e0 e1				pop hl 
02e1 06 40			ld b, STORE_BLOCK_PHY 
02e3			.bytewrite: 
02e3			 
02e3 7e				ld a,(hl) 
02e4 e5			    push hl 
02e5 c5				push bc 
02e6 cd 0f 01		    call spi_send_byte  
02e9 c1				pop bc 
02ea e1				pop hl 
02eb			 
02eb			    ; end write with ce high 
02eb 3a 93 f9		       ld a,(spi_portbyte) 
02ee cd fd 01			call spi_ce_high 
02f1			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02f1 d3 80		       out (storage_adata),a 
02f3 32 93 f9		       ld (spi_portbyte), a 
02f6			 
02f6 23				inc hl 
02f7 10 ea			djnz .bytewrite 
02f9			 
02f9				; pause for internal write cycle 
02f9 3e 64			ld a, 100 
02fb cd a5 0c			call aDelayInMS 
02fe c9			    ret 
02ff			; returns byte in a 
02ff			; address in hl  
02ff			se_readbyte: 
02ff d5				push de 
0300 c5				push bc 
0301			 
0301			    ;   ld c, a 
0301 e5			        push hl 
0302			 
0302			    ; initi write mode 
0302			    ; 
0302			    ;CS low 
0302			 
0302 3a 93 f9		       ld a,(spi_portbyte) 
0305 cd 0e 02			call spi_ce_low 
0308			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0308 d3 80		       out (storage_adata),a 
030a 32 93 f9		       ld (spi_portbyte), a 
030d			 
030d			    ;clock out wren instruction 
030d			 
030d 3e 03		    ld a, store_read_ins 
030f cd 0f 01		    call spi_send_byte  
0312			 
0312			 
0312			    ; clock out address (depending on address size) 
0312			     
0312 e1			    pop hl 
0313 7c			    ld a,h    ; address out msb first 
0314 cd 0f 01		    call spi_send_byte  
0317 7d			    ld a,l 
0318 cd 0f 01		    call spi_send_byte  
031b			 
031b			    ; clock in byte(s) for page 
031b			 
031b cd 33 01		    call spi_read_byte  
031e f5				push af 
031f			 
031f			    ; end write with ce high 
031f 3a 93 f9		       ld a,(spi_portbyte) 
0322			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0322 cd fd 01			call spi_ce_high 
0325 d3 80		       out (storage_adata),a 
0327 32 93 f9		       ld (spi_portbyte), a 
032a			 
032a f1				pop af 
032b			 
032b c1				pop bc 
032c d1				pop de 
032d			 
032d c9			    ret 
032e			 
032e			if DEBUG_STORESE 
032e			 
032e			storageput:  
032e			 
032e			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
032e			 
032e 21 f5 f0			ld hl,scratch+2 
0331 cd 5e 12			call get_word_hl 
0334			 
0334				; stuff it here for the moment as it will be overwritten later anyway 
0334			 
0334 22 16 f4			ld (os_cur_ptr),hl	 
0337			 
0337			 
0337			; get pointer to start of string 
0337			 
0337 21 fa f0			ld hl, scratch+7 
033a			 
033a			; loop writing char of string to eeprom 
033a			 
033a 7e			.writestr:	ld a,(hl) 
033b			;		cp 0 
033b b7					or a 
033c 28 12				jr z, .wsdone		; done writing 
033e e5					push hl 
033f 2a 16 f4				ld hl,(os_cur_ptr) 
0342 cd 65 02				call se_writebyte 
0345			 
0345 2a 16 f4				ld hl,(os_cur_ptr)	 ; save next eeprom address 
0348 23					inc hl 
0349 22 16 f4				ld (os_cur_ptr),hl 
034c			 
034c					; restore string pointer and get next char 
034c			 
034c e1					pop hl 
034d 23					inc hl 
034e 18 ea				jr .writestr 
0350			 
0350			 
0350			 
0350			.wsdone: 
0350			 
0350			 
0350			; when done load first page into a buffer  
0350			 
0350 21 00 80				ld hl,08000h		; start in ram 
0353 22 16 f4				ld (os_cur_ptr),hl 
0356 21 00 00				ld hl, 0		 ; start of page 
0359 22 1b f1				ld (scratch+40),hl	; hang on to it 
035c			 
035c 06 80				ld b, 128		; actually get more then one page 
035e c5			.wsload:	push bc 
035f 2a 1b f1				ld hl,(scratch+40) 
0362 e5					push hl 
0363 cd ff 02				call se_readbyte 
0366			 
0366					; a now as the byte 
0366			 
0366 2a 16 f4				ld hl,(os_cur_ptr) 
0369 77					ld (hl),a 
036a					; inc next buffer area 
036a 23					inc hl 
036b 22 16 f4				ld (os_cur_ptr),hl 
036e			 
036e					; get eeprom position, inc and save for next round 
036e e1					pop hl		 
036f 23					inc hl 
0370 22 1b f1				ld (scratch+40),hl 
0373 c1					pop bc 
0374 10 e8				djnz .wsload 
0376			 
0376			; set 'd' pointer to start of buffer 
0376			 
0376 21 00 80				ld hl,08000h 
0379 22 16 f4				ld (os_cur_ptr),hl 
037c			 
037c			 
037c c9			ret 
037d			 
037d			 
037d c9			storageread: ret 
037e			 
037e			 
037e			 
037e			 
037e			 
037e			 
037e			endif 
037e			 
037e			 
037e			 
# End of file firmware_seeprom.asm
037e			else  
037e			   ; create some stubs for the labels  
037e			se_readbyte: ret  
037e			se_writebyte: ret  
037e			storage_init: ret  
037e			  
037e			endif  
037e			  
037e			; use cf card for storage - throwing timeout errors. Hardware or software?????  
037e			;include "firmware_cf.asm"  
037e			  
037e			; load up high level storage hardward abstractions  
037e			include "firmware_storage.asm"  
037e			 
037e			; persisent storage hardware abstraction layer  
037e			 
037e			 
037e			 
037e			; Block 0 on storage is a config state 
037e			 
037e			 
037e			 
037e			; TODO add read phy block and write phy block functions 
037e			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
037e			 
037e			; Abstraction layer  
037e			 
037e			; Logocial block size is same size as physical size - using tape concept 
037e			 
037e			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
037e			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
037e			 
037e			 
037e			 
037e			; Filesystem layout (Logical layout) 
037e			; 
037e			; Block 0 - Bank config  
037e			; 
037e			;      Byte - 0 file id counter 
037e			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
037e			;      Byte - 3-20 zero terminated bank label 
037e			; 
037e			; Block 1 > File storage 
037e			; 
037e			;      Byte 0 file id    - block 0 file details 
037e			;      Byte 1 block id - block 0 is file  
037e			;            Byte 2-15 - File name 
037e			; 
037e			;       - to end of block data 
037e			; 
037e			 
037e			; Get ID for the file named in pointer held HL 
037e			; Returns ID in HL = 255 if no file found 
037e			 
037e			storage_getid: 
037e			 
037e 22 a5 f9			ld (store_tmp1), hl 
0381			 
0381				if DEBUG_STORESE 
0381					DMARK "SGI" 
0381 f5				push af  
0382 3a 96 03			ld a, (.dmark)  
0385 32 9d fd			ld (debug_mark),a  
0388 3a 97 03			ld a, (.dmark+1)  
038b 32 9e fd			ld (debug_mark+1),a  
038e 3a 98 03			ld a, (.dmark+2)  
0391 32 9f fd			ld (debug_mark+2),a  
0394 18 03			jr .pastdmark  
0396 ..			.dmark: db "SGI"  
0399 f1			.pastdmark: pop af  
039a			endm  
# End of macro DMARK
039a					CALLMONITOR 
039a cd aa fd			call debug_vector  
039d				endm  
# End of macro CALLMONITOR
039d				endif 
039d				; get block 0 and set counter for number of files to scan 
039d			 
039d cd 05 05			call storage_get_block_0 
03a0			 
03a0 3a ac f9			ld a, (store_page) 
03a3 47				ld b, a 
03a4			 
03a4				; get extent 0 of each file id 
03a4			 
03a4				if DEBUG_STORESE 
03a4					DMARK "SGc" 
03a4 f5				push af  
03a5 3a b9 03			ld a, (.dmark)  
03a8 32 9d fd			ld (debug_mark),a  
03ab 3a ba 03			ld a, (.dmark+1)  
03ae 32 9e fd			ld (debug_mark+1),a  
03b1 3a bb 03			ld a, (.dmark+2)  
03b4 32 9f fd			ld (debug_mark+2),a  
03b7 18 03			jr .pastdmark  
03b9 ..			.dmark: db "SGc"  
03bc f1			.pastdmark: pop af  
03bd			endm  
# End of macro DMARK
03bd					CALLMONITOR 
03bd cd aa fd			call debug_vector  
03c0				endm  
# End of macro CALLMONITOR
03c0				endif 
03c0 60			.getloop:	ld h, b 
03c1 2e 00				ld l, 0 
03c3 c5					push bc 
03c4			 
03c4 11 ac f9				ld de, store_page 
03c7				if DEBUG_STORESE 
03c7					DMARK "SGr" 
03c7 f5				push af  
03c8 3a dc 03			ld a, (.dmark)  
03cb 32 9d fd			ld (debug_mark),a  
03ce 3a dd 03			ld a, (.dmark+1)  
03d1 32 9e fd			ld (debug_mark+1),a  
03d4 3a de 03			ld a, (.dmark+2)  
03d7 32 9f fd			ld (debug_mark+2),a  
03da 18 03			jr .pastdmark  
03dc ..			.dmark: db "SGr"  
03df f1			.pastdmark: pop af  
03e0			endm  
# End of macro DMARK
03e0					CALLMONITOR 
03e0 cd aa fd			call debug_vector  
03e3				endm  
# End of macro CALLMONITOR
03e3				endif 
03e3 cd a7 09				call storage_read 
03e6 cd d5 0f				call ishlzero 
03e9 28 2d				jr z, .gap 
03eb					 
03eb					; have a file name read. Is it one we want. 
03eb			 
03eb 2a a5 f9				ld hl, (store_tmp1) 
03ee 11 af f9				ld de, store_page+3   ; file name 
03f1			 
03f1				if DEBUG_STORESE 
03f1					DMARK "SGc" 
03f1 f5				push af  
03f2 3a 06 04			ld a, (.dmark)  
03f5 32 9d fd			ld (debug_mark),a  
03f8 3a 07 04			ld a, (.dmark+1)  
03fb 32 9e fd			ld (debug_mark+1),a  
03fe 3a 08 04			ld a, (.dmark+2)  
0401 32 9f fd			ld (debug_mark+2),a  
0404 18 03			jr .pastdmark  
0406 ..			.dmark: db "SGc"  
0409 f1			.pastdmark: pop af  
040a			endm  
# End of macro DMARK
040a					CALLMONITOR 
040a cd aa fd			call debug_vector  
040d				endm  
# End of macro CALLMONITOR
040d				endif 
040d cd 3c 13				call strcmp 
0410 20 06				jr nz, .gap   ; not this one 
0412			 
0412 c1				        pop bc 
0413			 
0413 26 00				ld h, 0 
0415 68					ld l, b 
0416 18 22				jr .getdone 
0418						 
0418			 
0418			 
0418			 
0418			.gap: 
0418				if DEBUG_STORESE 
0418					DMARK "SGg" 
0418 f5				push af  
0419 3a 2d 04			ld a, (.dmark)  
041c 32 9d fd			ld (debug_mark),a  
041f 3a 2e 04			ld a, (.dmark+1)  
0422 32 9e fd			ld (debug_mark+1),a  
0425 3a 2f 04			ld a, (.dmark+2)  
0428 32 9f fd			ld (debug_mark+2),a  
042b 18 03			jr .pastdmark  
042d ..			.dmark: db "SGg"  
0430 f1			.pastdmark: pop af  
0431			endm  
# End of macro DMARK
0431					CALLMONITOR 
0431 cd aa fd			call debug_vector  
0434				endm  
# End of macro CALLMONITOR
0434				endif 
0434			 
0434 c1					pop bc 
0435 10 89				djnz .getloop 
0437 21 ff 00				ld hl, 255 
043a			.getdone: 
043a			 
043a				if DEBUG_STORESE 
043a					DMARK "SGe" 
043a f5				push af  
043b 3a 4f 04			ld a, (.dmark)  
043e 32 9d fd			ld (debug_mark),a  
0441 3a 50 04			ld a, (.dmark+1)  
0444 32 9e fd			ld (debug_mark+1),a  
0447 3a 51 04			ld a, (.dmark+2)  
044a 32 9f fd			ld (debug_mark+2),a  
044d 18 03			jr .pastdmark  
044f ..			.dmark: db "SGe"  
0452 f1			.pastdmark: pop af  
0453			endm  
# End of macro DMARK
0453					CALLMONITOR 
0453 cd aa fd			call debug_vector  
0456				endm  
# End of macro CALLMONITOR
0456				endif 
0456			 
0456 c9				ret 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			 
0457			; Read Block 
0457			; ---------- 
0457			; 
0457			; With current bank 
0457			;  
0457			; Get block number to read 
0457			; Load physical blocks starting at start block into buffer 
0457			 
0457			; de points to buffer to use 
0457			; hl holds logical block number  
0457			 
0457			storage_read_block: 
0457			 
0457				; TODO bank selection 
0457			 
0457				; for each of the physical blocks read it into the buffer 
0457 06 40			ld b, STORE_BLOCK_PHY 
0459			 
0459				if DEBUG_STORESE 
0459 d5					push de 
045a				endif 
045a				 
045a			.rl1:    
045a			 
045a				; read physical block at hl into de 
045a			        ; increment hl and de to next read position on exit 
045a			 
045a e5				push hl 
045b d5				push de	 
045c c5				push bc 
045d			;	if DEBUG_STORESE 
045d			;		push af 
045d			;		ld a, 'R' 
045d			;		ld (debug_mark),a 
045d			;		pop af 
045d			;		CALLMONITOR 
045d			;	endif 
045d cd ff 02			call se_readbyte 
0460			;	if DEBUG_STORESE 
0460			;		ld a,(spi_portbyte) 
0460			;		ld l, a 
0460			;		push af 
0460			;		ld a, '1' 
0460			;		ld (debug_mark),a 
0460			;		pop af 
0460			;		CALLMONITOR 
0460			;	endif 
0460 c1				pop bc 
0461 d1				pop de 
0462 e1				pop hl 
0463 12				ld (de),a 
0464 23				inc hl 
0465 13				inc de 
0466			 
0466			;	if DEBUG_STORESE 
0466			;		push af 
0466			;		ld a, 'r' 
0466			;		ld (debug_mark),a 
0466			;		pop af 
0466			;		CALLMONITOR 
0466			;	endif 
0466			 
0466 10 f2			djnz .rl1 
0468			 
0468				if DEBUG_STORESE 
0468					DMARK "SRB" 
0468 f5				push af  
0469 3a 7d 04			ld a, (.dmark)  
046c 32 9d fd			ld (debug_mark),a  
046f 3a 7e 04			ld a, (.dmark+1)  
0472 32 9e fd			ld (debug_mark+1),a  
0475 3a 7f 04			ld a, (.dmark+2)  
0478 32 9f fd			ld (debug_mark+2),a  
047b 18 03			jr .pastdmark  
047d ..			.dmark: db "SRB"  
0480 f1			.pastdmark: pop af  
0481			endm  
# End of macro DMARK
0481 d1					pop de 
0482			; 
0482			;		push af 
0482			;		ld a, 'R' 
0482			;		ld (debug_mark),a 
0482			;		pop af 
0482					CALLMONITOR 
0482 cd aa fd			call debug_vector  
0485				endm  
# End of macro CALLMONITOR
0485				endif 
0485 c9				ret	 
0486				 
0486			 
0486			; File Size 
0486			; --------- 
0486			; 
0486			;   hl file id 
0486			; 
0486			;  returns in hl the number of blocks 
0486			 
0486			storage_file_size: 
0486 5d				ld e, l 
0487 16 00			ld d, 0 
0489 21 40 00			ld hl, STORE_BLOCK_PHY 
048c					if DEBUG_FORTH_WORDS 
048c						DMARK "SIZ" 
048c f5				push af  
048d 3a a1 04			ld a, (.dmark)  
0490 32 9d fd			ld (debug_mark),a  
0493 3a a2 04			ld a, (.dmark+1)  
0496 32 9e fd			ld (debug_mark+1),a  
0499 3a a3 04			ld a, (.dmark+2)  
049c 32 9f fd			ld (debug_mark+2),a  
049f 18 03			jr .pastdmark  
04a1 ..			.dmark: db "SIZ"  
04a4 f1			.pastdmark: pop af  
04a5			endm  
# End of macro DMARK
04a5						CALLMONITOR 
04a5 cd aa fd			call debug_vector  
04a8				endm  
# End of macro CALLMONITOR
04a8					endif 
04a8 cd 83 07			call storage_findnextid 
04ab			 
04ab cd d5 0f			call ishlzero 
04ae			;	ld a, l 
04ae			;	add h 
04ae			;	cp 0 
04ae c8				ret z			; block not found so EOF 
04af			 
04af 11 ac f9			ld de, store_page 
04b2 cd 57 04			call storage_read_block 
04b5			 
04b5 3a ae f9			ld a, (store_page+2)	 ; get extent count 
04b8 6f				ld l, a 
04b9 26 00			ld h, 0 
04bb c9			 	ret 
04bc			 
04bc			 
04bc			; Write Block 
04bc			; ----------- 
04bc			; 
04bc			; With current bank 
04bc			;  
04bc			; Get block number to write 
04bc			; Write physical blocks starting at start block from buffer 
04bc			  
04bc			storage_write_block: 
04bc				; TODO bank selection 
04bc			 
04bc				; for each of the physical blocks read it into the buffer 
04bc 06 40			ld b, STORE_BLOCK_PHY 
04be			 
04be				if DEBUG_STORESE 
04be					DMARK "SWB" 
04be f5				push af  
04bf 3a d3 04			ld a, (.dmark)  
04c2 32 9d fd			ld (debug_mark),a  
04c5 3a d4 04			ld a, (.dmark+1)  
04c8 32 9e fd			ld (debug_mark+1),a  
04cb 3a d5 04			ld a, (.dmark+2)  
04ce 32 9f fd			ld (debug_mark+2),a  
04d1 18 03			jr .pastdmark  
04d3 ..			.dmark: db "SWB"  
04d6 f1			.pastdmark: pop af  
04d7			endm  
# End of macro DMARK
04d7			 
04d7					;push af 
04d7					;ld a, 'W' 
04d7					;ld (debug_mark),a 
04d7					;pop af 
04d7					CALLMONITOR 
04d7 cd aa fd			call debug_vector  
04da				endm  
# End of macro CALLMONITOR
04da				endif 
04da			 
04da			; might not be working 
04da			;	call se_writepage 
04da			 
04da			;	ret 
04da			; 
04da			 
04da			 
04da			 
04da			.wl1:    
04da			 
04da				; read physical block at hl into de 
04da			        ; increment hl and de to next read position on exit 
04da			 
04da e5				push hl 
04db d5				push de	 
04dc c5				push bc 
04dd 1a				ld a,(de) 
04de				;if DEBUG_STORESE 
04de			;		push af 
04de			;		ld a, 'W' 
04de			;		ld (debug_mark),a 
04de			;		pop af 
04de			;		CALLMONITOR 
04de			;	endif 
04de cd 65 02			call se_writebyte 
04e1			;	call delay250ms 
04e1			;	nop 
04e1			;	nop 
04e1			;	nop 
04e1			;	if DEBUG_STORESE 
04e1			;		push af 
04e1			;		ld a, 'w' 
04e1			;		ld (debug_mark),a 
04e1			;		pop af 
04e1			;		CALLMONITOR 
04e1			;	endif 
04e1 c1				pop bc 
04e2 d1				pop de 
04e3 e1				pop hl 
04e4 23				inc hl 
04e5 13				inc de 
04e6			 
04e6			 
04e6 10 f2			djnz .wl1 
04e8			 
04e8				if DEBUG_STORESE 
04e8					DMARK "SW2" 
04e8 f5				push af  
04e9 3a fd 04			ld a, (.dmark)  
04ec 32 9d fd			ld (debug_mark),a  
04ef 3a fe 04			ld a, (.dmark+1)  
04f2 32 9e fd			ld (debug_mark+1),a  
04f5 3a ff 04			ld a, (.dmark+2)  
04f8 32 9f fd			ld (debug_mark+2),a  
04fb 18 03			jr .pastdmark  
04fd ..			.dmark: db "SW2"  
0500 f1			.pastdmark: pop af  
0501			endm  
# End of macro DMARK
0501			 
0501					;push af 
0501					;ld a, 'W' 
0501					;ld (debug_mark),a 
0501					;pop af 
0501					CALLMONITOR 
0501 cd aa fd			call debug_vector  
0504				endm  
# End of macro CALLMONITOR
0504				endif 
0504 c9				ret	 
0505			 
0505			; Init bank 
0505			; --------- 
0505			; 
0505			; With current bank 
0505			; 
0505			; Setup block 0 config 
0505			;     Set 0 file id counter 
0505			;     Set formatted byte pattern 
0505			;     Zero out bank label 
0505			;      
0505			; For every logical block write 0-1 byte as null 
0505			 
0505			storage_get_block_0: 
0505			 
0505				; TODO check presence 
0505			 
0505				; get block 0 config 
0505			 
0505 21 00 00			ld hl, 0 
0508 11 ac f9			ld de, store_page 
050b cd 57 04			call storage_read_block 
050e			 
050e				if DEBUG_STORESE 
050e					DMARK "SB0" 
050e f5				push af  
050f 3a 23 05			ld a, (.dmark)  
0512 32 9d fd			ld (debug_mark),a  
0515 3a 24 05			ld a, (.dmark+1)  
0518 32 9e fd			ld (debug_mark+1),a  
051b 3a 25 05			ld a, (.dmark+2)  
051e 32 9f fd			ld (debug_mark+2),a  
0521 18 03			jr .pastdmark  
0523 ..			.dmark: db "SB0"  
0526 f1			.pastdmark: pop af  
0527			endm  
# End of macro DMARK
0527 11 ac f9				ld de, store_page 
052a			;		push af 
052a			;		ld a, 'i' 
052a			;		ld (debug_mark),a 
052a			;		pop af 
052a					CALLMONITOR 
052a cd aa fd			call debug_vector  
052d				endm  
# End of macro CALLMONITOR
052d				endif 
052d			 
052d				; is this area formatted? 
052d			 
052d			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
052d 2a ad f9			ld hl, (store_page+1) 
0530 3e 80			ld a,0x80 
0532 bd				cp l 
0533 20 22			jr nz, .ininotformatted 
0535				; do a double check 
0535 3e 27			ld a, 0x27 
0537 bc				cp h 
0538 20 1d			jr nz, .ininotformatted 
053a			 
053a				; formatted then 
053a			 
053a				if DEBUG_STORESE 
053a					DMARK "SB1" 
053a f5				push af  
053b 3a 4f 05			ld a, (.dmark)  
053e 32 9d fd			ld (debug_mark),a  
0541 3a 50 05			ld a, (.dmark+1)  
0544 32 9e fd			ld (debug_mark+1),a  
0547 3a 51 05			ld a, (.dmark+2)  
054a 32 9f fd			ld (debug_mark+2),a  
054d 18 03			jr .pastdmark  
054f ..			.dmark: db "SB1"  
0552 f1			.pastdmark: pop af  
0553			endm  
# End of macro DMARK
0553					;push af 
0553					;ld a, 'I' 
0553					;ld (debug_mark),a 
0553					;pop af 
0553					CALLMONITOR 
0553 cd aa fd			call debug_vector  
0556				endm  
# End of macro CALLMONITOR
0556				endif 
0556 c9				ret 
0557			 
0557			.ininotformatted: 
0557				; bank not formatted so poke various bits to make sure 
0557			 
0557				if DEBUG_STORESE 
0557					DMARK "SB2" 
0557 f5				push af  
0558 3a 6c 05			ld a, (.dmark)  
055b 32 9d fd			ld (debug_mark),a  
055e 3a 6d 05			ld a, (.dmark+1)  
0561 32 9e fd			ld (debug_mark+1),a  
0564 3a 6e 05			ld a, (.dmark+2)  
0567 32 9f fd			ld (debug_mark+2),a  
056a 18 03			jr .pastdmark  
056c ..			.dmark: db "SB2"  
056f f1			.pastdmark: pop af  
0570			endm  
# End of macro DMARK
0570					;push af 
0570					;ld a, 'f' 
0570					;ld (debug_mark),a 
0570					;pop af 
0570					CALLMONITOR 
0570 cd aa fd			call debug_vector  
0573				endm  
# End of macro CALLMONITOR
0573				endif 
0573			 
0573 cd 84 0c			call storage_clear_page 
0576			 
0576 21 ac f9			ld hl, store_page 
0579			;	ld a, 0 
0579				 
0579 36 00			ld (hl),0   ; reset file counter 
057b			 
057b 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
057e 22 ad f9		 	ld (store_page+1), hl	 
0581			 
0581				; set default label 
0581			 
0581 21 1a 06			ld hl, .defaultbanklabl 
0584 11 af f9		 	ld de, store_page+3 
0587 01 0f 00			ld bc, 15 
058a ed b0			ldir 
058c			 
058c				; Append the current bank id 
058c 21 b8 f9			ld hl, store_page+3+9 
058f 3a 91 f9			ld a, (spi_device_id) 
0592 77				ld (hl), a 
0593			 
0593				; save default page 0 
0593			 
0593 21 00 00			ld hl, 0 
0596 11 ac f9			ld de, store_page 
0599				if DEBUG_STORESE 
0599					DMARK "SB3" 
0599 f5				push af  
059a 3a ae 05			ld a, (.dmark)  
059d 32 9d fd			ld (debug_mark),a  
05a0 3a af 05			ld a, (.dmark+1)  
05a3 32 9e fd			ld (debug_mark+1),a  
05a6 3a b0 05			ld a, (.dmark+2)  
05a9 32 9f fd			ld (debug_mark+2),a  
05ac 18 03			jr .pastdmark  
05ae ..			.dmark: db "SB3"  
05b1 f1			.pastdmark: pop af  
05b2			endm  
# End of macro DMARK
05b2			;		push af 
05b2			;		ld a, 'F' 
05b2			;		ld (debug_mark),a 
05b2			;		pop af 
05b2					CALLMONITOR 
05b2 cd aa fd			call debug_vector  
05b5				endm  
# End of macro CALLMONITOR
05b5				endif 
05b5 cd bc 04			call storage_write_block 
05b8				if DEBUG_STORESE 
05b8					DMARK "SB4" 
05b8 f5				push af  
05b9 3a cd 05			ld a, (.dmark)  
05bc 32 9d fd			ld (debug_mark),a  
05bf 3a ce 05			ld a, (.dmark+1)  
05c2 32 9e fd			ld (debug_mark+1),a  
05c5 3a cf 05			ld a, (.dmark+2)  
05c8 32 9f fd			ld (debug_mark+2),a  
05cb 18 03			jr .pastdmark  
05cd ..			.dmark: db "SB4"  
05d0 f1			.pastdmark: pop af  
05d1			endm  
# End of macro DMARK
05d1			;		push af 
05d1			;		ld a, '>' 
05d1			;		ld (debug_mark),a 
05d1			;		pop af 
05d1					CALLMONITOR 
05d1 cd aa fd			call debug_vector  
05d4				endm  
# End of macro CALLMONITOR
05d4				endif 
05d4			 
05d4			;	nop 
05d4			;	nop 
05d4			;	nop 
05d4			 
05d4				; now set 0 in every page to mark as a free block 
05d4			 
05d4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05d6 21 40 00			ld hl, STORE_BLOCK_PHY 
05d9			 
05d9 3e 00		.setmark1:   	ld a,0 
05db e5					push hl 
05dc c5					push bc 
05dd cd 65 02				call se_writebyte 
05e0 3e 0a			ld a, 10 
05e2 cd a5 0c			call aDelayInMS 
05e5 23				inc hl 
05e6 cd 65 02				call se_writebyte 
05e9 3e 0a			ld a, 10 
05eb cd a5 0c			call aDelayInMS 
05ee 2b				dec hl 
05ef c1					pop bc 
05f0 e1					pop hl 
05f1 3e 40				ld a, STORE_BLOCK_PHY 
05f3 cd ac 0f				call addatohl 
05f6 10 e1				djnz .setmark1 
05f8			 
05f8 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05fa 3e 00		.setmark2:   	ld a,0 
05fc e5					push hl 
05fd c5					push bc 
05fe cd 65 02				call se_writebyte 
0601 3e 0a			ld a, 10 
0603 cd a5 0c			call aDelayInMS 
0606 23				inc hl 
0607 cd 65 02				call se_writebyte 
060a 3e 0a			ld a, 10 
060c cd a5 0c			call aDelayInMS 
060f 2b				dec hl 
0610 c1					pop bc 
0611 e1					pop hl 
0612 3e 40				ld a, STORE_BLOCK_PHY 
0614 cd ac 0f				call addatohl 
0617 10 e1				djnz .setmark2 
0619			 
0619					 
0619			 
0619			 
0619 c9				ret 
061a			 
061a			 
061a			 
061a			 
061a .. 00		.defaultbanklabl:   db "BankLabel_",0 
0625			 
0625			 
0625			 
0625			; Label Bank 
0625			; ---------- 
0625			; 
0625			; With current bank 
0625			; Read block 0 
0625			; Set label 
0625			; Write block 0 
0625			 
0625			; label str pointer in hl 
0625			 
0625			storage_label:     
0625			 
0625				if DEBUG_STORESE 
0625					DMARK "LBL" 
0625 f5				push af  
0626 3a 3a 06			ld a, (.dmark)  
0629 32 9d fd			ld (debug_mark),a  
062c 3a 3b 06			ld a, (.dmark+1)  
062f 32 9e fd			ld (debug_mark+1),a  
0632 3a 3c 06			ld a, (.dmark+2)  
0635 32 9f fd			ld (debug_mark+2),a  
0638 18 03			jr .pastdmark  
063a ..			.dmark: db "LBL"  
063d f1			.pastdmark: pop af  
063e			endm  
# End of macro DMARK
063e					CALLMONITOR 
063e cd aa fd			call debug_vector  
0641				endm  
# End of macro CALLMONITOR
0641				endif 
0641			 
0641 e5				push hl 
0642			 
0642 cd 05 05			call storage_get_block_0 
0645			 
0645				; set default label 
0645			 
0645 e1				pop hl 
0646			 
0646 11 af f9		 	ld de, store_page+3 
0649 01 0f 00			ld bc, 15 
064c				if DEBUG_STORESE 
064c					DMARK "LB3" 
064c f5				push af  
064d 3a 61 06			ld a, (.dmark)  
0650 32 9d fd			ld (debug_mark),a  
0653 3a 62 06			ld a, (.dmark+1)  
0656 32 9e fd			ld (debug_mark+1),a  
0659 3a 63 06			ld a, (.dmark+2)  
065c 32 9f fd			ld (debug_mark+2),a  
065f 18 03			jr .pastdmark  
0661 ..			.dmark: db "LB3"  
0664 f1			.pastdmark: pop af  
0665			endm  
# End of macro DMARK
0665					CALLMONITOR 
0665 cd aa fd			call debug_vector  
0668				endm  
# End of macro CALLMONITOR
0668				endif 
0668 ed b0			ldir 
066a				; save default page 0 
066a			 
066a 21 00 00			ld hl, 0 
066d 11 ac f9			ld de, store_page 
0670				if DEBUG_STORESE 
0670					DMARK "LBW" 
0670 f5				push af  
0671 3a 85 06			ld a, (.dmark)  
0674 32 9d fd			ld (debug_mark),a  
0677 3a 86 06			ld a, (.dmark+1)  
067a 32 9e fd			ld (debug_mark+1),a  
067d 3a 87 06			ld a, (.dmark+2)  
0680 32 9f fd			ld (debug_mark+2),a  
0683 18 03			jr .pastdmark  
0685 ..			.dmark: db "LBW"  
0688 f1			.pastdmark: pop af  
0689			endm  
# End of macro DMARK
0689					CALLMONITOR 
0689 cd aa fd			call debug_vector  
068c				endm  
# End of macro CALLMONITOR
068c				endif 
068c cd bc 04			call storage_write_block 
068f			 
068f c9				ret 
0690			 
0690			 
0690			 
0690			; Read Block 0 - Config 
0690			; --------------------- 
0690			; 
0690			; With current bank 
0690			; Call presence test 
0690			;    If not present format/init bank  
0690			; Read block 0  
0690			;  
0690			 
0690			 
0690			; Dir 
0690			; --- 
0690			; 
0690			; With current bank 
0690			; Load Block 0 Config 
0690			; Get max file id number 
0690			; For each logical block 
0690			;    Read block read byte 2 
0690			;      if first block of file 
0690			;         Display file name 
0690			;         Display type flags for file 
0690			;        
0690			 
0690			; moving to words as this requires stack control 
0690			 
0690			 
0690			; Delete File 
0690			; ----------- 
0690			; 
0690			; With current bank 
0690			; 
0690			; Load Block 0 Config 
0690			; Get max file id number 
0690			; For each logical block 
0690			;    Read block file id 
0690			;      If first block of file and dont have file id 
0690			;         if file to delete 
0690			;         Save file id 
0690			;         Null file id 
0690			;         Write this block back 
0690			;      If file id is one saved 
0690			;         Null file id 
0690			;         Write this block back 
0690			 
0690			 
0690			.se_done: 
0690 e1				pop hl 
0691 c9				ret 
0692			 
0692			storage_erase: 
0692			 
0692				; hl contains the file id 
0692			 
0692 5d				ld e, l 
0693 16 00			ld d, 0 
0695 21 40 00			ld hl, STORE_BLOCK_PHY 
0698					if DEBUG_FORTH_WORDS 
0698						DMARK "ERA" 
0698 f5				push af  
0699 3a ad 06			ld a, (.dmark)  
069c 32 9d fd			ld (debug_mark),a  
069f 3a ae 06			ld a, (.dmark+1)  
06a2 32 9e fd			ld (debug_mark+1),a  
06a5 3a af 06			ld a, (.dmark+2)  
06a8 32 9f fd			ld (debug_mark+2),a  
06ab 18 03			jr .pastdmark  
06ad ..			.dmark: db "ERA"  
06b0 f1			.pastdmark: pop af  
06b1			endm  
# End of macro DMARK
06b1						CALLMONITOR 
06b1 cd aa fd			call debug_vector  
06b4				endm  
# End of macro CALLMONITOR
06b4					endif 
06b4 cd 83 07			call storage_findnextid 
06b7 cd d5 0f			call ishlzero 
06ba c8				ret z 
06bb			 
06bb e5				push hl 
06bc			 
06bc				; TODO check file not found 
06bc			 
06bc 11 ac f9			ld de, store_page 
06bf cd 57 04			call storage_read_block 
06c2			 
06c2 cd d5 0f			call ishlzero 
06c5 ca 90 06			jp z,.se_done 
06c8			 
06c8					if DEBUG_FORTH_WORDS 
06c8						DMARK "ER1" 
06c8 f5				push af  
06c9 3a dd 06			ld a, (.dmark)  
06cc 32 9d fd			ld (debug_mark),a  
06cf 3a de 06			ld a, (.dmark+1)  
06d2 32 9e fd			ld (debug_mark+1),a  
06d5 3a df 06			ld a, (.dmark+2)  
06d8 32 9f fd			ld (debug_mark+2),a  
06db 18 03			jr .pastdmark  
06dd ..			.dmark: db "ER1"  
06e0 f1			.pastdmark: pop af  
06e1			endm  
# End of macro DMARK
06e1						CALLMONITOR 
06e1 cd aa fd			call debug_vector  
06e4				endm  
# End of macro CALLMONITOR
06e4					endif 
06e4 3a ac f9			ld a, (store_page)	; get file id 
06e7 32 a0 f9			ld (store_tmpid), a 
06ea			 
06ea 3a ae f9			ld a, (store_page+2)    ; get count of extends 
06ed 32 9f f9			ld (store_tmpext), a 
06f0			 
06f0				; wipe file header 
06f0			 
06f0 e1				pop hl 
06f1 3e 00			ld a, 0 
06f3 32 ac f9			ld (store_page), a 
06f6 32 ad f9			ld (store_page+1),a 
06f9 11 ac f9			ld de, store_page 
06fc					if DEBUG_FORTH_WORDS 
06fc						DMARK "ER2" 
06fc f5				push af  
06fd 3a 11 07			ld a, (.dmark)  
0700 32 9d fd			ld (debug_mark),a  
0703 3a 12 07			ld a, (.dmark+1)  
0706 32 9e fd			ld (debug_mark+1),a  
0709 3a 13 07			ld a, (.dmark+2)  
070c 32 9f fd			ld (debug_mark+2),a  
070f 18 03			jr .pastdmark  
0711 ..			.dmark: db "ER2"  
0714 f1			.pastdmark: pop af  
0715			endm  
# End of macro DMARK
0715						CALLMONITOR 
0715 cd aa fd			call debug_vector  
0718				endm  
# End of macro CALLMONITOR
0718					endif 
0718 cd bc 04			call storage_write_block 
071b			 
071b			 
071b				; wipe file extents 
071b			 
071b 3a 9f f9			ld a, (store_tmpext) 
071e 47				ld b, a 
071f			 
071f			.eraext:	  
071f c5				push bc 
0720			 
0720 21 40 00			ld hl, STORE_BLOCK_PHY 
0723 3a a0 f9			ld a,(store_tmpid) 
0726 5f				ld e, a 
0727 50				ld d, b	 
0728					if DEBUG_FORTH_WORDS 
0728						DMARK "ER3" 
0728 f5				push af  
0729 3a 3d 07			ld a, (.dmark)  
072c 32 9d fd			ld (debug_mark),a  
072f 3a 3e 07			ld a, (.dmark+1)  
0732 32 9e fd			ld (debug_mark+1),a  
0735 3a 3f 07			ld a, (.dmark+2)  
0738 32 9f fd			ld (debug_mark+2),a  
073b 18 03			jr .pastdmark  
073d ..			.dmark: db "ER3"  
0740 f1			.pastdmark: pop af  
0741			endm  
# End of macro DMARK
0741						CALLMONITOR 
0741 cd aa fd			call debug_vector  
0744				endm  
# End of macro CALLMONITOR
0744					endif 
0744 cd 83 07			call storage_findnextid 
0747 cd d5 0f			call ishlzero 
074a ca 90 06			jp z,.se_done 
074d			 
074d e5				push hl 
074e 11 ac f9			ld de, store_page 
0751 cd 57 04			call storage_read_block 
0754			 
0754				; free block	 
0754			 
0754 3e 00			ld a, 0 
0756 32 ac f9			ld (store_page), a 
0759 32 ad f9			ld (store_page+1),a 
075c 11 ac f9			ld de, store_page 
075f e1				pop hl 
0760					if DEBUG_FORTH_WORDS 
0760						DMARK "ER4" 
0760 f5				push af  
0761 3a 75 07			ld a, (.dmark)  
0764 32 9d fd			ld (debug_mark),a  
0767 3a 76 07			ld a, (.dmark+1)  
076a 32 9e fd			ld (debug_mark+1),a  
076d 3a 77 07			ld a, (.dmark+2)  
0770 32 9f fd			ld (debug_mark+2),a  
0773 18 03			jr .pastdmark  
0775 ..			.dmark: db "ER4"  
0778 f1			.pastdmark: pop af  
0779			endm  
# End of macro DMARK
0779						CALLMONITOR 
0779 cd aa fd			call debug_vector  
077c				endm  
# End of macro CALLMONITOR
077c					endif 
077c cd bc 04			call storage_write_block 
077f			 
077f c1				pop bc 
0780 10 9d			djnz .eraext 
0782			 
0782 c9				ret 
0783			 
0783			 
0783			; Find Free Block 
0783			; --------------- 
0783			; 
0783			; With current bank 
0783			;  
0783			; From given starting logical block 
0783			;    Read block  
0783			;    If no file id 
0783			;         Return block id 
0783			 
0783			 
0783			; hl starting page number 
0783			; hl contains free page number or zero if no pages free 
0783			; e contains the file id to locate 
0783			; d contains the block number 
0783			 
0783			; TODO change to find file id and use zero for free block 
0783			 
0783			storage_findnextid: 
0783			 
0783				; now locate first 0 page to mark as a free block 
0783			 
0783 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0785			;	ld hl, STORE_BLOCK_PHY 
0785			 
0785					if DEBUG_FORTH_WORDS 
0785					DMARK "FNI" 
0785 f5				push af  
0786 3a 9a 07			ld a, (.dmark)  
0789 32 9d fd			ld (debug_mark),a  
078c 3a 9b 07			ld a, (.dmark+1)  
078f 32 9e fd			ld (debug_mark+1),a  
0792 3a 9c 07			ld a, (.dmark+2)  
0795 32 9f fd			ld (debug_mark+2),a  
0798 18 03			jr .pastdmark  
079a ..			.dmark: db "FNI"  
079d f1			.pastdmark: pop af  
079e			endm  
# End of macro DMARK
079e						CALLMONITOR 
079e cd aa fd			call debug_vector  
07a1				endm  
# End of macro CALLMONITOR
07a1					endif 
07a1			.ff1:   	 
07a1 e5					push hl 
07a2 c5					push bc 
07a3 d5					push de 
07a4 cd ff 02				call se_readbyte 
07a7 5f					ld e,a 
07a8 23					inc hl 
07a9 cd ff 02				call se_readbyte 
07ac 57					ld d, a 
07ad e1					pop hl 
07ae e5					push hl 
07af cd ca 0f				call cmp16 
07b2 28 49				jr z, .fffound 
07b4			 
07b4 d1					pop de 
07b5 c1					pop bc 
07b6 e1					pop hl 
07b7			 
07b7					; is found? 
07b7					;cp e 
07b7					;ret z 
07b7			 
07b7 3e 40				ld a, STORE_BLOCK_PHY 
07b9 cd ac 0f				call addatohl 
07bc 10 e3				djnz .ff1 
07be			 
07be 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
07c0			.ff2:   	 
07c0			 
07c0 e5					push hl 
07c1 c5					push bc 
07c2 d5					push de 
07c3 cd ff 02				call se_readbyte 
07c6 5f					ld e,a 
07c7 23					inc hl 
07c8 cd ff 02				call se_readbyte 
07cb 57					ld d, a 
07cc			 
07cc e1					pop hl 
07cd e5					push hl 
07ce cd ca 0f				call cmp16 
07d1 28 2a				jr z, .fffound 
07d3			 
07d3 d1					pop de 
07d4 c1					pop bc 
07d5 e1					pop hl 
07d6					; is found? 
07d6					;cp e 
07d6					;ret z 
07d6			 
07d6 3e 40				ld a, STORE_BLOCK_PHY 
07d8 cd ac 0f				call addatohl 
07db 10 e3				djnz .ff2 
07dd			 
07dd			 
07dd					if DEBUG_FORTH_WORDS 
07dd					DMARK "FN-" 
07dd f5				push af  
07de 3a f2 07			ld a, (.dmark)  
07e1 32 9d fd			ld (debug_mark),a  
07e4 3a f3 07			ld a, (.dmark+1)  
07e7 32 9e fd			ld (debug_mark+1),a  
07ea 3a f4 07			ld a, (.dmark+2)  
07ed 32 9f fd			ld (debug_mark+2),a  
07f0 18 03			jr .pastdmark  
07f2 ..			.dmark: db "FN-"  
07f5 f1			.pastdmark: pop af  
07f6			endm  
# End of macro DMARK
07f6					;	push af 
07f6					;	ld a, 'n' 
07f6					;	ld (debug_mark),a 
07f6					;	pop af 
07f6						CALLMONITOR 
07f6 cd aa fd			call debug_vector  
07f9				endm  
# End of macro CALLMONITOR
07f9					endif 
07f9				; no free marks! 
07f9 21 00 00				ld hl, 0 
07fc c9				ret 
07fd			.fffound: 
07fd				 
07fd			 
07fd d1					pop de 
07fe c1					pop bc 
07ff e1					pop hl 
0800					if DEBUG_FORTH_WORDS 
0800					DMARK "FNF" 
0800 f5				push af  
0801 3a 15 08			ld a, (.dmark)  
0804 32 9d fd			ld (debug_mark),a  
0807 3a 16 08			ld a, (.dmark+1)  
080a 32 9e fd			ld (debug_mark+1),a  
080d 3a 17 08			ld a, (.dmark+2)  
0810 32 9f fd			ld (debug_mark+2),a  
0813 18 03			jr .pastdmark  
0815 ..			.dmark: db "FNF"  
0818 f1			.pastdmark: pop af  
0819			endm  
# End of macro DMARK
0819					;	push af 
0819					;	ld a, 'n' 
0819					;	ld (debug_mark),a 
0819					;	pop af 
0819						CALLMONITOR 
0819 cd aa fd			call debug_vector  
081c				endm  
# End of macro CALLMONITOR
081c					endif 
081c c9				ret 
081d			 
081d			 
081d			 
081d			; Free Space 
081d			; ---------- 
081d			; 
081d			; With current bank 
081d			; 
081d			; Set block count to zero 
081d			; Starting with first logical block 
081d			;      Find free block  
081d			;      If block id given, increment block count 
081d			; 
081d			;  
081d			 
081d			 
081d			; hl contains count of free blocks 
081d			 
081d			storage_freeblocks: 
081d			 
081d				; now locate first 0 page to mark as a free block 
081d			 
081d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
081f 21 40 00			ld hl, STORE_BLOCK_PHY 
0822 11 00 00			ld de, 0 
0825			 
0825			.fb1:   	 
0825 e5					push hl 
0826 c5					push bc 
0827 d5					push de 
0828 cd ff 02				call se_readbyte 
082b d1					pop de 
082c c1					pop bc 
082d e1					pop hl 
082e			 
082e					; is free? 
082e			;		cp 0 
082e b7					or a 
082f 20 01				jr nz, .ff1cont 
0831 13					inc de 
0832			 
0832			.ff1cont: 
0832			 
0832			 
0832 3e 40				ld a, STORE_BLOCK_PHY 
0834 cd ac 0f				call addatohl 
0837 10 ec				djnz .fb1 
0839			 
0839 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
083b			.fb2:   	 
083b e5					push hl 
083c c5					push bc 
083d d5					push de 
083e cd ff 02				call se_readbyte 
0841 d1					pop de 
0842 c1					pop bc 
0843 e1					pop hl 
0844			 
0844					; is free? 
0844			;		cp 0 
0844 b7					or a 
0845 20 01				jr nz, .ff2cont 
0847 13					inc de 
0848			 
0848			.ff2cont: 
0848			 
0848 3e 40				ld a, STORE_BLOCK_PHY 
084a cd ac 0f				call addatohl 
084d 10 ec				djnz .fb2 
084f			 
084f eb				ex de, hl 
0850 c9				ret 
0851			 
0851			; Get File ID 
0851			; ----------- 
0851			; 
0851			; With current bank 
0851			;  
0851			; Load Block 0 Config 
0851			; Get max file id number 
0851			; For each logical block 
0851			;    Read block file id 
0851			;      If first block of file and dont have file id 
0851			;         if file get id and exit 
0851			 
0851			 
0851			 
0851			 
0851			; Create File 
0851			; ----------- 
0851			; 
0851			; With current bank  
0851			; Load Block 0 Config 
0851			; Get max file id number 
0851			; Increment file id number 
0851			; Save Config 
0851			; Find free block 
0851			; Set buffer with file name and file id 
0851			; Write buffer to free block  
0851			 
0851			 
0851			; hl point to file name 
0851			; hl returns file id 
0851			 
0851			; file format: 
0851			; byte 0 - file id 
0851			; byte 1 - extent number 
0851			; byte 2-> data 
0851			 
0851			; format for extent number 0: 
0851			; 
0851			; byte 0 - file id 
0851			; byte 1 - extent 0 
0851			; byte 2 - extent count 
0851			; byte 3 -> file name and meta data 
0851			 
0851			 
0851			storage_create: 
0851				if DEBUG_STORESE 
0851					DMARK "SCR" 
0851 f5				push af  
0852 3a 66 08			ld a, (.dmark)  
0855 32 9d fd			ld (debug_mark),a  
0858 3a 67 08			ld a, (.dmark+1)  
085b 32 9e fd			ld (debug_mark+1),a  
085e 3a 68 08			ld a, (.dmark+2)  
0861 32 9f fd			ld (debug_mark+2),a  
0864 18 03			jr .pastdmark  
0866 ..			.dmark: db "SCR"  
0869 f1			.pastdmark: pop af  
086a			endm  
# End of macro DMARK
086a					CALLMONITOR 
086a cd aa fd			call debug_vector  
086d				endm  
# End of macro CALLMONITOR
086d				endif 
086d			 
086d e5				push hl		; save file name pointer 
086e			 
086e cd 05 05			call storage_get_block_0 
0871			 
0871 3a ac f9			ld a,(store_page)	; get current file id 
0874 3c				inc a 
0875 32 ac f9			ld (store_page),a 
0878				 
0878 32 a0 f9			ld (store_tmpid),a			; save id 
087b			 
087b 21 00 00			ld hl, 0 
087e 11 ac f9			ld de, store_page 
0881				if DEBUG_STORESE 
0881					DMARK "SCw" 
0881 f5				push af  
0882 3a 96 08			ld a, (.dmark)  
0885 32 9d fd			ld (debug_mark),a  
0888 3a 97 08			ld a, (.dmark+1)  
088b 32 9e fd			ld (debug_mark+1),a  
088e 3a 98 08			ld a, (.dmark+2)  
0891 32 9f fd			ld (debug_mark+2),a  
0894 18 03			jr .pastdmark  
0896 ..			.dmark: db "SCw"  
0899 f1			.pastdmark: pop af  
089a			endm  
# End of macro DMARK
089a					CALLMONITOR 
089a cd aa fd			call debug_vector  
089d				endm  
# End of macro CALLMONITOR
089d				endif 
089d cd bc 04			call storage_write_block	 ; save update 
08a0			 
08a0				if DEBUG_STORESE 
08a0 11 ac f9				ld de, store_page 
08a3					DMARK "SCC" 
08a3 f5				push af  
08a4 3a b8 08			ld a, (.dmark)  
08a7 32 9d fd			ld (debug_mark),a  
08aa 3a b9 08			ld a, (.dmark+1)  
08ad 32 9e fd			ld (debug_mark+1),a  
08b0 3a ba 08			ld a, (.dmark+2)  
08b3 32 9f fd			ld (debug_mark+2),a  
08b6 18 03			jr .pastdmark  
08b8 ..			.dmark: db "SCC"  
08bb f1			.pastdmark: pop af  
08bc			endm  
# End of macro DMARK
08bc					CALLMONITOR 
08bc cd aa fd			call debug_vector  
08bf				endm  
# End of macro CALLMONITOR
08bf				endif 
08bf				;  
08bf				 
08bf 21 40 00			ld hl, STORE_BLOCK_PHY 
08c2 11 00 00			ld de, 0 
08c5 cd 83 07			call storage_findnextid 
08c8			 
08c8 22 97 f9			ld (store_tmppageid), hl    ; save page to use  
08cb			 
08cb				; TODO detect 0 = no spare blocks 
08cb			 
08cb				; hl now contains the free page to use for the file header page 
08cb			 
08cb				if DEBUG_STORESE 
08cb				DMARK "SCF" 
08cb f5				push af  
08cc 3a e0 08			ld a, (.dmark)  
08cf 32 9d fd			ld (debug_mark),a  
08d2 3a e1 08			ld a, (.dmark+1)  
08d5 32 9e fd			ld (debug_mark+1),a  
08d8 3a e2 08			ld a, (.dmark+2)  
08db 32 9f fd			ld (debug_mark+2),a  
08de 18 03			jr .pastdmark  
08e0 ..			.dmark: db "SCF"  
08e3 f1			.pastdmark: pop af  
08e4			endm  
# End of macro DMARK
08e4					CALLMONITOR 
08e4 cd aa fd			call debug_vector  
08e7				endm  
# End of macro CALLMONITOR
08e7				endif 
08e7			 
08e7 22 97 f9			ld (store_tmppageid), hl 
08ea				 
08ea 3a a0 f9			ld a,(store_tmpid)    ; get file id 
08ed			;	ld a, (store_filecache)			; save to cache 
08ed			 
08ed 32 ac f9			ld (store_page),a    ; set page id 
08f0 3e 00			ld a, 0			 ; extent 0 is file header 
08f2 32 ad f9			ld (store_page+1), a   ; set file extent 
08f5			 
08f5 32 ae f9			ld (store_page+2), a   ; extent count for the file 
08f8			 
08f8			;	inc hl 		; init block 0 of file 
08f8			;	inc hl   		; skip file and extent id 
08f8			 ;       ld a, 0 
08f8			;	ld (hl),a 
08f8			;	ld a, (store_filecache+1)  	; save to cache 
08f8			 
08f8			;	inc hl    ; file name 
08f8				 
08f8				 
08f8 11 af f9			ld de, store_page+3    ; get buffer for term string to use as file name 
08fb				if DEBUG_STORESE 
08fb					DMARK "SCc" 
08fb f5				push af  
08fc 3a 10 09			ld a, (.dmark)  
08ff 32 9d fd			ld (debug_mark),a  
0902 3a 11 09			ld a, (.dmark+1)  
0905 32 9e fd			ld (debug_mark+1),a  
0908 3a 12 09			ld a, (.dmark+2)  
090b 32 9f fd			ld (debug_mark+2),a  
090e 18 03			jr .pastdmark  
0910 ..			.dmark: db "SCc"  
0913 f1			.pastdmark: pop af  
0914			endm  
# End of macro DMARK
0914					CALLMONITOR 
0914 cd aa fd			call debug_vector  
0917				endm  
# End of macro CALLMONITOR
0917				endif 
0917 e1				pop hl    ; get zero term string 
0918 e5				push hl 
0919 3e 00			ld a, 0 
091b cd 0f 13			call strlent 
091e 23				inc hl   ; cover zero term 
091f 06 00			ld b,0 
0921 4d				ld c,l 
0922 e1				pop hl 
0923				;ex de, hl 
0923				if DEBUG_STORESE 
0923					DMARK "SCa" 
0923 f5				push af  
0924 3a 38 09			ld a, (.dmark)  
0927 32 9d fd			ld (debug_mark),a  
092a 3a 39 09			ld a, (.dmark+1)  
092d 32 9e fd			ld (debug_mark+1),a  
0930 3a 3a 09			ld a, (.dmark+2)  
0933 32 9f fd			ld (debug_mark+2),a  
0936 18 03			jr .pastdmark  
0938 ..			.dmark: db "SCa"  
093b f1			.pastdmark: pop af  
093c			endm  
# End of macro DMARK
093c					;push af 
093c					;ld a, 'a' 
093c					;ld (debug_mark),a 
093c					;pop af 
093c					CALLMONITOR 
093c cd aa fd			call debug_vector  
093f				endm  
# End of macro CALLMONITOR
093f				endif 
093f ed b0			ldir    ; copy zero term string 
0941				if DEBUG_STORESE 
0941					DMARK "SCA" 
0941 f5				push af  
0942 3a 56 09			ld a, (.dmark)  
0945 32 9d fd			ld (debug_mark),a  
0948 3a 57 09			ld a, (.dmark+1)  
094b 32 9e fd			ld (debug_mark+1),a  
094e 3a 58 09			ld a, (.dmark+2)  
0951 32 9f fd			ld (debug_mark+2),a  
0954 18 03			jr .pastdmark  
0956 ..			.dmark: db "SCA"  
0959 f1			.pastdmark: pop af  
095a			endm  
# End of macro DMARK
095a					CALLMONITOR 
095a cd aa fd			call debug_vector  
095d				endm  
# End of macro CALLMONITOR
095d				endif 
095d			 
095d				; write file header page 
095d			 
095d 2a 97 f9			ld hl,(store_tmppageid) 
0960 11 ac f9			ld de, store_page 
0963				if DEBUG_STORESE 
0963					DMARK "SCb" 
0963 f5				push af  
0964 3a 78 09			ld a, (.dmark)  
0967 32 9d fd			ld (debug_mark),a  
096a 3a 79 09			ld a, (.dmark+1)  
096d 32 9e fd			ld (debug_mark+1),a  
0970 3a 7a 09			ld a, (.dmark+2)  
0973 32 9f fd			ld (debug_mark+2),a  
0976 18 03			jr .pastdmark  
0978 ..			.dmark: db "SCb"  
097b f1			.pastdmark: pop af  
097c			endm  
# End of macro DMARK
097c					;push af 
097c					;ld a, 'b' 
097c					;ld (debug_mark),a 
097c					;pop af 
097c					CALLMONITOR 
097c cd aa fd			call debug_vector  
097f				endm  
# End of macro CALLMONITOR
097f				endif 
097f cd bc 04			call storage_write_block 
0982			 
0982 3a a0 f9			ld a, (store_tmpid) 
0985 6f				ld l, a 
0986 26 00			ld h,0 
0988				if DEBUG_STORESE 
0988					DMARK "SCz" 
0988 f5				push af  
0989 3a 9d 09			ld a, (.dmark)  
098c 32 9d fd			ld (debug_mark),a  
098f 3a 9e 09			ld a, (.dmark+1)  
0992 32 9e fd			ld (debug_mark+1),a  
0995 3a 9f 09			ld a, (.dmark+2)  
0998 32 9f fd			ld (debug_mark+2),a  
099b 18 03			jr .pastdmark  
099d ..			.dmark: db "SCz"  
09a0 f1			.pastdmark: pop af  
09a1			endm  
# End of macro DMARK
09a1					CALLMONITOR 
09a1 cd aa fd			call debug_vector  
09a4				endm  
# End of macro CALLMONITOR
09a4				endif 
09a4 c9				ret 
09a5				 
09a5			 
09a5			 
09a5			; 
09a5			; Read File 
09a5			; 
09a5			; h - file id to locate 
09a5			; l - extent to locate 
09a5			; de - pointer to string to read into 
09a5			; 
09a5			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
09a5			 
09a5			.sr_fail: 
09a5 d1				pop de 
09a6 c9				ret 
09a7			 
09a7			storage_read: 
09a7			 
09a7			 
09a7 d5				push de 
09a8			 
09a8			; TODO BUG the above push is it popped before the RET Z? 
09a8			 
09a8			; TODO how to handle multiple part blocks 
09a8			 
09a8				; locate file extent to read 
09a8			 
09a8 5c				ld e, h 
09a9 55				ld d, l 
09aa			 
09aa			.srext: 
09aa 22 aa f9			ld (store_readptr), hl     ; save the current extent to load 
09ad ed 53 a8 f9		ld (store_readbuf), de     ; save the current buffer to load in to 
09b1			 
09b1 21 40 00			ld hl, STORE_BLOCK_PHY 
09b4				if DEBUG_STORESE 
09b4					DMARK "sre" 
09b4 f5				push af  
09b5 3a c9 09			ld a, (.dmark)  
09b8 32 9d fd			ld (debug_mark),a  
09bb 3a ca 09			ld a, (.dmark+1)  
09be 32 9e fd			ld (debug_mark+1),a  
09c1 3a cb 09			ld a, (.dmark+2)  
09c4 32 9f fd			ld (debug_mark+2),a  
09c7 18 03			jr .pastdmark  
09c9 ..			.dmark: db "sre"  
09cc f1			.pastdmark: pop af  
09cd			endm  
# End of macro DMARK
09cd					CALLMONITOR 
09cd cd aa fd			call debug_vector  
09d0				endm  
# End of macro CALLMONITOR
09d0				endif 
09d0 cd 83 07			call storage_findnextid 
09d3			 
09d3				if DEBUG_STORESE 
09d3					DMARK "srf" 
09d3 f5				push af  
09d4 3a e8 09			ld a, (.dmark)  
09d7 32 9d fd			ld (debug_mark),a  
09da 3a e9 09			ld a, (.dmark+1)  
09dd 32 9e fd			ld (debug_mark+1),a  
09e0 3a ea 09			ld a, (.dmark+2)  
09e3 32 9f fd			ld (debug_mark+2),a  
09e6 18 03			jr .pastdmark  
09e8 ..			.dmark: db "srf"  
09eb f1			.pastdmark: pop af  
09ec			endm  
# End of macro DMARK
09ec					CALLMONITOR 
09ec cd aa fd			call debug_vector  
09ef				endm  
# End of macro CALLMONITOR
09ef				endif 
09ef cd d5 0f			call ishlzero 
09f2			;	ld a, l 
09f2			;	add h 
09f2			;	cp 0 
09f2 28 b1			jr z,.sr_fail			; block not found so EOF 
09f4			 
09f4				; save current address for use by higher level words etc 
09f4			 
09f4 22 9d f9			ld (store_openaddr),hl 
09f7			 
09f7			 
09f7				; hl contains page number to load 
09f7 d1				pop de   ; get storage 
09f8 ed 53 a8 f9		ld (store_readbuf), de     ; current buffer to load in to 
09fc d5				push de 
09fd				if DEBUG_STORESE 
09fd					DMARK "srg" 
09fd f5				push af  
09fe 3a 12 0a			ld a, (.dmark)  
0a01 32 9d fd			ld (debug_mark),a  
0a04 3a 13 0a			ld a, (.dmark+1)  
0a07 32 9e fd			ld (debug_mark+1),a  
0a0a 3a 14 0a			ld a, (.dmark+2)  
0a0d 32 9f fd			ld (debug_mark+2),a  
0a10 18 03			jr .pastdmark  
0a12 ..			.dmark: db "srg"  
0a15 f1			.pastdmark: pop af  
0a16			endm  
# End of macro DMARK
0a16					CALLMONITOR 
0a16 cd aa fd			call debug_vector  
0a19				endm  
# End of macro CALLMONITOR
0a19				endif 
0a19 cd 57 04			call storage_read_block 
0a1c			 
0a1c				; if this a continuation read??? 
0a1c			 
0a1c 2a a8 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a1f			 
0a1f 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a21 cd ac 0f			call addatohl 
0a24 7e				ld a,(hl) 
0a25			;	cp 0 
0a25 b7				or a 
0a26 28 02			jr z, .markiscont 
0a28 3e ff			ld a, 255 
0a2a			 
0a2a			.markiscont: 
0a2a 32 9f f9			ld (store_readcont), a 
0a2d			 
0a2d				if DEBUG_STORESE 
0a2d					DMARK "srC" 
0a2d f5				push af  
0a2e 3a 42 0a			ld a, (.dmark)  
0a31 32 9d fd			ld (debug_mark),a  
0a34 3a 43 0a			ld a, (.dmark+1)  
0a37 32 9e fd			ld (debug_mark+1),a  
0a3a 3a 44 0a			ld a, (.dmark+2)  
0a3d 32 9f fd			ld (debug_mark+2),a  
0a40 18 03			jr .pastdmark  
0a42 ..			.dmark: db "srC"  
0a45 f1			.pastdmark: pop af  
0a46			endm  
# End of macro DMARK
0a46					CALLMONITOR 
0a46 cd aa fd			call debug_vector  
0a49				endm  
# End of macro CALLMONITOR
0a49				endif 
0a49				; only short reads enabled 
0a49			 
0a49 3a a7 f9			ld a, (store_longread) 
0a4c			;	cp 0 
0a4c b7				or a 
0a4d ca 19 0b			jp z, .readdone 
0a50			 
0a50			; TODO if block has no zeros then need to read next block  
0a50			; this code appears to be very buggy. Have added above a flag to disable/enable the following code for later debug 
0a50			; check last byte of physical block. 
0a50			; if not zero then the next block needs to be loaded 
0a50			 
0a50			 
0a50 2a a8 f9			ld hl, (store_readbuf)     ; current buffer to load in to 
0a53			 
0a53 3e 3f			ld a, STORE_BLOCK_PHY-1 
0a55 cd ac 0f			call addatohl 
0a58				;dec hl 
0a58 7e				ld a,(hl) 
0a59				if DEBUG_STORESE 
0a59					DMARK "sr?" 
0a59 f5				push af  
0a5a 3a 6e 0a			ld a, (.dmark)  
0a5d 32 9d fd			ld (debug_mark),a  
0a60 3a 6f 0a			ld a, (.dmark+1)  
0a63 32 9e fd			ld (debug_mark+1),a  
0a66 3a 70 0a			ld a, (.dmark+2)  
0a69 32 9f fd			ld (debug_mark+2),a  
0a6c 18 03			jr .pastdmark  
0a6e ..			.dmark: db "sr?"  
0a71 f1			.pastdmark: pop af  
0a72			endm  
# End of macro DMARK
0a72					CALLMONITOR 
0a72 cd aa fd			call debug_vector  
0a75				endm  
# End of macro CALLMONITOR
0a75				endif 
0a75			;	cp 0 
0a75 b7				or a 
0a76 ca 19 0b			jp z, .readdone 
0a79			 
0a79				; last byte is not zero so there is more in the next extent. Load it on the end.	 
0a79			 
0a79 23				inc hl 
0a7a			 
0a7a 22 a8 f9			ld (store_readbuf), hl     ; save the current buffer to load in to 
0a7d			 
0a7d ed 5b aa f9		ld de, (store_readptr)     ; save the current extent to load 
0a81			 
0a81 eb				ex de, hl 
0a82			 
0a82				; next ext 
0a82			 
0a82 23				inc hl 
0a83 22 aa f9			ld  (store_readptr), hl     ; save the current extent to load 
0a86			 
0a86				if DEBUG_STORESE 
0a86					DMARK "sF2" 
0a86 f5				push af  
0a87 3a 9b 0a			ld a, (.dmark)  
0a8a 32 9d fd			ld (debug_mark),a  
0a8d 3a 9c 0a			ld a, (.dmark+1)  
0a90 32 9e fd			ld (debug_mark+1),a  
0a93 3a 9d 0a			ld a, (.dmark+2)  
0a96 32 9f fd			ld (debug_mark+2),a  
0a99 18 03			jr .pastdmark  
0a9b ..			.dmark: db "sF2"  
0a9e f1			.pastdmark: pop af  
0a9f			endm  
# End of macro DMARK
0a9f					CALLMONITOR 
0a9f cd aa fd			call debug_vector  
0aa2				endm  
# End of macro CALLMONITOR
0aa2				endif 
0aa2			 
0aa2				; get and load block 
0aa2			 
0aa2 cd 83 07			call storage_findnextid 
0aa5			 
0aa5				if DEBUG_STORESE 
0aa5					DMARK "sf2" 
0aa5 f5				push af  
0aa6 3a ba 0a			ld a, (.dmark)  
0aa9 32 9d fd			ld (debug_mark),a  
0aac 3a bb 0a			ld a, (.dmark+1)  
0aaf 32 9e fd			ld (debug_mark+1),a  
0ab2 3a bc 0a			ld a, (.dmark+2)  
0ab5 32 9f fd			ld (debug_mark+2),a  
0ab8 18 03			jr .pastdmark  
0aba ..			.dmark: db "sf2"  
0abd f1			.pastdmark: pop af  
0abe			endm  
# End of macro DMARK
0abe					CALLMONITOR 
0abe cd aa fd			call debug_vector  
0ac1				endm  
# End of macro CALLMONITOR
0ac1				endif 
0ac1 cd d5 0f			call ishlzero 
0ac4			;	ld a, l 
0ac4			;	add h 
0ac4			;	cp 0 
0ac4 ca a5 09			jp z,.sr_fail			; block not found so EOF 
0ac7				 
0ac7				; save current address for use by higher level words etc 
0ac7			 
0ac7 22 9d f9			ld (store_openaddr),hl 
0aca			 
0aca cd 57 04			call storage_read_block 
0acd			 
0acd				; on a continuation block, we now have the file id and ext in the middle of the block 
0acd				; we need to pull everything back  
0acd			 
0acd ed 5b a8 f9		ld de, (store_readbuf)     ; current buffer to nudge into 
0ad1 2a a8 f9			ld hl, (store_readbuf)     ; current buffer where data actually exists 
0ad4 23				inc hl 
0ad5 23				inc hl     ; skip id and ext 
0ad6 01 40 00			ld bc, STORE_BLOCK_PHY 
0ad9				if DEBUG_STORESE 
0ad9					DMARK "SR<" 
0ad9 f5				push af  
0ada 3a ee 0a			ld a, (.dmark)  
0add 32 9d fd			ld (debug_mark),a  
0ae0 3a ef 0a			ld a, (.dmark+1)  
0ae3 32 9e fd			ld (debug_mark+1),a  
0ae6 3a f0 0a			ld a, (.dmark+2)  
0ae9 32 9f fd			ld (debug_mark+2),a  
0aec 18 03			jr .pastdmark  
0aee ..			.dmark: db "SR<"  
0af1 f1			.pastdmark: pop af  
0af2			endm  
# End of macro DMARK
0af2					CALLMONITOR 
0af2 cd aa fd			call debug_vector  
0af5				endm  
# End of macro CALLMONITOR
0af5				endif 
0af5 ed b0			ldir     ; copy data 
0af7			 
0af7				; move the pointer back and pretend we have a full buffer for next recheck 
0af7			 
0af7 1b				dec de 
0af8 1b				dec de 
0af9			 
0af9			; TODO do pop below now short circuit loop????? 
0af9 c1				pop bc     ; get rid of spare de on stack 
0afa				if DEBUG_STORESE 
0afa					DMARK "SR>" 
0afa f5				push af  
0afb 3a 0f 0b			ld a, (.dmark)  
0afe 32 9d fd			ld (debug_mark),a  
0b01 3a 10 0b			ld a, (.dmark+1)  
0b04 32 9e fd			ld (debug_mark+1),a  
0b07 3a 11 0b			ld a, (.dmark+2)  
0b0a 32 9f fd			ld (debug_mark+2),a  
0b0d 18 03			jr .pastdmark  
0b0f ..			.dmark: db "SR>"  
0b12 f1			.pastdmark: pop af  
0b13			endm  
# End of macro DMARK
0b13					CALLMONITOR 
0b13 cd aa fd			call debug_vector  
0b16				endm  
# End of macro CALLMONITOR
0b16				endif 
0b16 c3 aa 09			jp .srext 
0b19			 
0b19			 
0b19			 
0b19			 
0b19			 
0b19			.readdone:		 
0b19 e1				pop hl 		 ; return start of data to show as not EOF 
0b1a 23				inc hl   ; past file id 
0b1b 23				inc hl   ; past ext 
0b1c				if DEBUG_STORESE 
0b1c					DMARK "SRe" 
0b1c f5				push af  
0b1d 3a 31 0b			ld a, (.dmark)  
0b20 32 9d fd			ld (debug_mark),a  
0b23 3a 32 0b			ld a, (.dmark+1)  
0b26 32 9e fd			ld (debug_mark+1),a  
0b29 3a 33 0b			ld a, (.dmark+2)  
0b2c 32 9f fd			ld (debug_mark+2),a  
0b2f 18 03			jr .pastdmark  
0b31 ..			.dmark: db "SRe"  
0b34 f1			.pastdmark: pop af  
0b35			endm  
# End of macro DMARK
0b35					CALLMONITOR 
0b35 cd aa fd			call debug_vector  
0b38				endm  
# End of macro CALLMONITOR
0b38				endif 
0b38 c9					ret 
0b39			 
0b39			 
0b39			 
0b39			; 
0b39			; Append File 
0b39			; 
0b39			; hl - file id to locate 
0b39			; de - pointer to (multi block) string to write 
0b39			 
0b39			.sa_notfound: 
0b39 d1				pop de 
0b3a c9				ret 
0b3b			 
0b3b			 
0b3b			storage_append: 
0b3b				; hl -  file id to append to 
0b3b				; de - string to append 
0b3b			 
0b3b d5				push de 
0b3c				 
0b3c				if DEBUG_STORESE 
0b3c					DMARK "AP1" 
0b3c f5				push af  
0b3d 3a 51 0b			ld a, (.dmark)  
0b40 32 9d fd			ld (debug_mark),a  
0b43 3a 52 0b			ld a, (.dmark+1)  
0b46 32 9e fd			ld (debug_mark+1),a  
0b49 3a 53 0b			ld a, (.dmark+2)  
0b4c 32 9f fd			ld (debug_mark+2),a  
0b4f 18 03			jr .pastdmark  
0b51 ..			.dmark: db "AP1"  
0b54 f1			.pastdmark: pop af  
0b55			endm  
# End of macro DMARK
0b55					CALLMONITOR 
0b55 cd aa fd			call debug_vector  
0b58				endm  
# End of macro CALLMONITOR
0b58				endif 
0b58			 
0b58 7d				ld a, l 
0b59 32 a0 f9			ld (store_tmpid), a 
0b5c			 
0b5c				; get file header  
0b5c			 
0b5c 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0b5e 3a a0 f9			ld a, (store_tmpid) 
0b61 5f				ld e, a 
0b62			 
0b62 21 40 00				ld hl, STORE_BLOCK_PHY 
0b65 cd 83 07				call storage_findnextid 
0b68			 
0b68 cd d5 0f			call ishlzero 
0b6b 28 cc			jr z, .sa_notfound 
0b6d			 
0b6d 22 97 f9			ld (store_tmppageid), hl 
0b70			 
0b70				; TODO handle file id not found 
0b70			 
0b70				if DEBUG_STORESE 
0b70					DMARK "AP2" 
0b70 f5				push af  
0b71 3a 85 0b			ld a, (.dmark)  
0b74 32 9d fd			ld (debug_mark),a  
0b77 3a 86 0b			ld a, (.dmark+1)  
0b7a 32 9e fd			ld (debug_mark+1),a  
0b7d 3a 87 0b			ld a, (.dmark+2)  
0b80 32 9f fd			ld (debug_mark+2),a  
0b83 18 03			jr .pastdmark  
0b85 ..			.dmark: db "AP2"  
0b88 f1			.pastdmark: pop af  
0b89			endm  
# End of macro DMARK
0b89					CALLMONITOR 
0b89 cd aa fd			call debug_vector  
0b8c				endm  
# End of macro CALLMONITOR
0b8c				endif 
0b8c			 
0b8c				; update file extent count 
0b8c			 
0b8c 11 ac f9			ld de, store_page 
0b8f			 
0b8f cd 57 04			call storage_read_block 
0b92			 
0b92				if DEBUG_STORESE 
0b92					DMARK "AP3" 
0b92 f5				push af  
0b93 3a a7 0b			ld a, (.dmark)  
0b96 32 9d fd			ld (debug_mark),a  
0b99 3a a8 0b			ld a, (.dmark+1)  
0b9c 32 9e fd			ld (debug_mark+1),a  
0b9f 3a a9 0b			ld a, (.dmark+2)  
0ba2 32 9f fd			ld (debug_mark+2),a  
0ba5 18 03			jr .pastdmark  
0ba7 ..			.dmark: db "AP3"  
0baa f1			.pastdmark: pop af  
0bab			endm  
# End of macro DMARK
0bab					CALLMONITOR 
0bab cd aa fd			call debug_vector  
0bae				endm  
# End of macro CALLMONITOR
0bae				endif 
0bae			;	ld (store_tmppageid), hl 
0bae			 
0bae 3a ae f9			ld a, (store_page+2) 
0bb1 3c				inc a 
0bb2 32 ae f9			ld (store_page+2), a 
0bb5 32 9f f9			ld (store_tmpext), a 
0bb8				 
0bb8				if DEBUG_STORESE 
0bb8					DMARK "AP3" 
0bb8 f5				push af  
0bb9 3a cd 0b			ld a, (.dmark)  
0bbc 32 9d fd			ld (debug_mark),a  
0bbf 3a ce 0b			ld a, (.dmark+1)  
0bc2 32 9e fd			ld (debug_mark+1),a  
0bc5 3a cf 0b			ld a, (.dmark+2)  
0bc8 32 9f fd			ld (debug_mark+2),a  
0bcb 18 03			jr .pastdmark  
0bcd ..			.dmark: db "AP3"  
0bd0 f1			.pastdmark: pop af  
0bd1			endm  
# End of macro DMARK
0bd1					CALLMONITOR 
0bd1 cd aa fd			call debug_vector  
0bd4				endm  
# End of macro CALLMONITOR
0bd4				endif 
0bd4 2a 97 f9			ld hl, (store_tmppageid) 
0bd7 11 ac f9			ld de, store_page 
0bda cd bc 04			call storage_write_block 
0bdd			 
0bdd				; find free block 
0bdd			 
0bdd 11 00 00			ld de, 0			 ; file extent to locate 
0be0			 
0be0 21 40 00				ld hl, STORE_BLOCK_PHY 
0be3 cd 83 07				call storage_findnextid 
0be6 cd d5 0f			call ishlzero 
0be9 ca 39 0b			jp z, .sa_notfound 
0bec			 
0bec					; TODO handle no space left 
0bec					 
0bec 22 97 f9				ld (store_tmppageid), hl 
0bef			 
0bef				if DEBUG_STORESE 
0bef					DMARK "AP4" 
0bef f5				push af  
0bf0 3a 04 0c			ld a, (.dmark)  
0bf3 32 9d fd			ld (debug_mark),a  
0bf6 3a 05 0c			ld a, (.dmark+1)  
0bf9 32 9e fd			ld (debug_mark+1),a  
0bfc 3a 06 0c			ld a, (.dmark+2)  
0bff 32 9f fd			ld (debug_mark+2),a  
0c02 18 03			jr .pastdmark  
0c04 ..			.dmark: db "AP4"  
0c07 f1			.pastdmark: pop af  
0c08			endm  
# End of macro DMARK
0c08					CALLMONITOR 
0c08 cd aa fd			call debug_vector  
0c0b				endm  
# End of macro CALLMONITOR
0c0b				endif 
0c0b					; init the buffer with zeros so we can id if the buffer is full or not 
0c0b			 
0c0b e5					push hl 
0c0c c5					push bc 
0c0d			 
0c0d 21 ac f9				ld hl, store_page 
0c10 06 40				ld b, STORE_BLOCK_PHY 
0c12			;		ld a, 0 
0c12 36 00		.zeroblock:	ld (hl), 0 
0c14 23					inc hl 
0c15 10 fb				djnz .zeroblock 
0c17			 
0c17 c1					pop bc 
0c18 e1					pop hl 
0c19			 
0c19					; construct block 
0c19			 
0c19 3a a0 f9				ld a, (store_tmpid) 
0c1c 32 ac f9				ld (store_page), a   ; file id 
0c1f 3a 9f f9				ld a, (store_tmpext)   ; extent for this block 
0c22 32 ad f9				ld (store_page+1), a 
0c25			 
0c25 e1					pop hl    ; get string to write 
0c26 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0c28 11 ae f9				ld de, store_page+2 
0c2b			 
0c2b				if DEBUG_STORESE 
0c2b					DMARK "AP5" 
0c2b f5				push af  
0c2c 3a 40 0c			ld a, (.dmark)  
0c2f 32 9d fd			ld (debug_mark),a  
0c32 3a 41 0c			ld a, (.dmark+1)  
0c35 32 9e fd			ld (debug_mark+1),a  
0c38 3a 42 0c			ld a, (.dmark+2)  
0c3b 32 9f fd			ld (debug_mark+2),a  
0c3e 18 03			jr .pastdmark  
0c40 ..			.dmark: db "AP5"  
0c43 f1			.pastdmark: pop af  
0c44			endm  
# End of macro DMARK
0c44					CALLMONITOR 
0c44 cd aa fd			call debug_vector  
0c47				endm  
# End of macro CALLMONITOR
0c47				endif 
0c47			 
0c47			 
0c47			 
0c47					; fill buffer with data until end of string or full block 
0c47			 
0c47 7e			.appd:		ld a, (hl) 
0c48 12					ld (de), a 
0c49			;		cp 0 
0c49 b7					or a 
0c4a 28 04				jr z, .appdone 
0c4c 23					inc hl 
0c4d 13					inc de 
0c4e 10 f7				djnz .appd 
0c50			 
0c50 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
0c51 f5					push af   		; save last byte dumped 
0c52			 
0c52			 
0c52 2a 97 f9			ld hl, (store_tmppageid) 
0c55 11 ac f9			ld de, store_page 
0c58				if DEBUG_STORESE 
0c58					DMARK "AP6" 
0c58 f5				push af  
0c59 3a 6d 0c			ld a, (.dmark)  
0c5c 32 9d fd			ld (debug_mark),a  
0c5f 3a 6e 0c			ld a, (.dmark+1)  
0c62 32 9e fd			ld (debug_mark+1),a  
0c65 3a 6f 0c			ld a, (.dmark+2)  
0c68 32 9f fd			ld (debug_mark+2),a  
0c6b 18 03			jr .pastdmark  
0c6d ..			.dmark: db "AP6"  
0c70 f1			.pastdmark: pop af  
0c71			endm  
# End of macro DMARK
0c71					CALLMONITOR 
0c71 cd aa fd			call debug_vector  
0c74				endm  
# End of macro CALLMONITOR
0c74				endif 
0c74 cd bc 04				call storage_write_block 
0c77			 
0c77			 
0c77				; was that a full block of data written? 
0c77				; any more to write out? 
0c77			 
0c77				; if yes then set vars and jump to start of function again 
0c77			 
0c77 f1					pop af 
0c78 d1					pop de 
0c79			 
0c79					;cp 0		 ; no, string was fully written 
0c79 b7					or a 
0c7a c8					ret z 
0c7b			 
0c7b					; setup vars for next cycle 
0c7b			 
0c7b 3a a0 f9				ld a, (store_tmpid) 
0c7e 6f					ld l, a 
0c7f 26 00				ld h, 0 
0c81			 
0c81 c3 3b 0b			 	jp storage_append	 ; yes, need to write out some more 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			 
0c84			if DEBUG_STORECF 
0c84			storageput:	 
0c84					ret 
0c84			storageread: 
0c84					ld hl, store_page 
0c84					ld b, 200 
0c84			;		ld a,0 
0c84			.src:		ld (hl),0 
0c84					inc hl 
0c84					djnz .src 
0c84					 
0c84			 
0c84					ld de, 0 
0c84					ld bc, 1 
0c84					ld hl, store_page 
0c84					call cfRead 
0c84			 
0c84				call cfGetError 
0c84				ld hl,scratch 
0c84				call hexout 
0c84				ld hl, scratch+2 
0c84			;	ld a, 0 
0c84				ld (hl),0 
0c84				ld de, scratch 
0c84				ld a,display_row_1 
0c84				call str_at_display 
0c84				call update_display 
0c84			 
0c84					ld hl, store_page 
0c84					ld (os_cur_ptr),hl 
0c84			 
0c84					ret 
0c84			endif 
0c84			 
0c84			 
0c84			; Clear out the main buffer store (used to remove junk before writing a new block) 
0c84			 
0c84			storage_clear_page: 
0c84 e5				push hl 
0c85 d5				push de 
0c86 c5				push bc 
0c87 21 ac f9			ld hl, store_page 
0c8a			;	ld a, 0 
0c8a 36 00			ld (hl), 0 
0c8c			 
0c8c 11 ad f9			ld de, store_page+1 
0c8f 01 19 01			ld bc, STORE_BLOCK_LOG+1 
0c92			 
0c92 ed b0			ldir 
0c94				 
0c94 c1				pop bc 
0c95 d1				pop de 
0c96 e1				pop hl 
0c97 c9				ret 
0c98			 
0c98			; eof 
# End of file firmware_storage.asm
0c98			  
0c98			; support routines for above hardware abstraction layer  
0c98			  
0c98			include "firmware_general.asm"        ; general support functions  
0c98			 
0c98			; word look up 
0c98			 
0c98			; in 
0c98			; a is the index 
0c98			; hl is pointer start of array 
0c98			; 
0c98			; returns 
0c98			; hl to the word 
0c98			; 
0c98			 
0c98			table_lookup:  
0c98 d5					push de 
0c99 eb					ex de, hl 
0c9a			 
0c9a 6f					ld l, a 
0c9b 26 00				ld h, 0 
0c9d 29					add hl, hl 
0c9e 19					add hl, de 
0c9f 7e					ld a, (hl) 
0ca0 23					inc hl 
0ca1 66					ld h,(hl) 
0ca2 6f					ld l, a 
0ca3			 
0ca3 d1					pop de 
0ca4 c9					ret 
0ca5			 
0ca5			; Delay loops 
0ca5			 
0ca5			 
0ca5			 
0ca5			aDelayInMS: 
0ca5 c5				push bc 
0ca6 47				ld b,a 
0ca7			msdelay: 
0ca7 c5				push bc 
0ca8				 
0ca8			 
0ca8 01 41 00			ld bc,041h 
0cab cd c3 0c			call delayloop 
0cae c1				pop bc 
0caf 05				dec b 
0cb0 20 f5			jr nz,msdelay 
0cb2			 
0cb2			;if CPU_CLOCK_8MHZ 
0cb2			;msdelay8: 
0cb2			;	push bc 
0cb2			;	 
0cb2			; 
0cb2			;	ld bc,041h 
0cb2			;	call delayloop 
0cb2			;	pop bc 
0cb2			;	dec b 
0cb2			;	jr nz,msdelay8 
0cb2			;endif 
0cb2			 
0cb2			 
0cb2 c1				pop bc 
0cb3 c9				ret 
0cb4			 
0cb4			 
0cb4			delay250ms: 
0cb4				;push de 
0cb4 01 00 40			ld bc, 04000h 
0cb7 c3 c3 0c			jp delayloop 
0cba			delay500ms: 
0cba				;push de 
0cba 01 00 80			ld bc, 08000h 
0cbd c3 c3 0c			jp delayloop 
0cc0			delay1s: 
0cc0				;push bc 
0cc0			   ; Clobbers A, d and e 
0cc0 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0cc3			delayloop: 
0cc3 c5			    push bc 
0cc4			 
0cc4			if BASE_CPM 
0cc4				ld bc, CPM_DELAY_TUNE 
0cc4			.cpmloop: 
0cc4				push bc 
0cc4			 
0cc4			endif 
0cc4			 
0cc4			 
0cc4			 
0cc4			delayloopi: 
0cc4			;	push bc 
0cc4			;.dl: 
0cc4 cb 47		    bit     0,a    	; 8 
0cc6 cb 47		    bit     0,a    	; 8 
0cc8 cb 47		    bit     0,a    	; 8 
0cca e6 ff		    and     255  	; 7 
0ccc 0b			    dec     bc      	; 6 
0ccd 79			    ld      a,c     	; 4 
0cce b0			    or      b     	; 4 
0ccf c2 c4 0c		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0cd2			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0cd2				;pop de 
0cd2			;pop bc 
0cd2			 
0cd2			if BASE_CPM 
0cd2				pop bc 
0cd2				 
0cd2			    dec     bc      	; 6 
0cd2			    ld      a,c     	; 4 
0cd2			    or      b     	; 4 
0cd2			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0cd2				 
0cd2			 
0cd2			endif 
0cd2			;if CPU_CLOCK_8MHZ 
0cd2			;    pop bc 
0cd2			;    push bc 
0cd2			;.dl8: 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    and     255  	; 7 
0cd2			;    dec     bc      	; 6 
0cd2			;    ld      a,c     	; 4 
0cd2			;    or      b     	; 4 
0cd2			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cd2			;endif 
0cd2			 
0cd2			;if CPU_CLOCK_10MHZ 
0cd2			;    pop bc 
0cd2			;    push bc 
0cd2			;.dl8: 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    bit     0,a    	; 8 
0cd2			;    and     255  	; 7 
0cd2			;    dec     bc      	; 6 
0cd2			;    ld      a,c     	; 4 
0cd2			;    or      b     	; 4 
0cd2			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0cd2			;endif 
0cd2 c1			    pop bc 
0cd3			 
0cd3 c9				ret 
0cd4			 
0cd4			 
0cd4			 
0cd4			; eof 
# End of file firmware_general.asm
0cd4			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0cd4			; display routines that use the physical hardware abstraction layer 
0cd4			 
0cd4			 
0cd4			; Display an activity indicator 
0cd4			; Each call returns the new char pointed to in hl 
0cd4			 
0cd4			active: 
0cd4 3a f8 fa			ld a, (display_active) 
0cd7 fe 06			cp 6 
0cd9			 
0cd9 20 02			jr nz, .sne 
0cdb				; gone past the last one reset sequence 
0cdb 3e ff			ld a, 255 
0cdd			 
0cdd			.sne:   
0cdd				; get the next char in seq 
0cdd 3c				inc a 
0cde 32 f8 fa			ld (display_active), a 
0ce1			 
0ce1				; look up the string in the table 
0ce1 21 f8 0c			ld hl, actseq 
0ce4 cb 27			sla a 
0ce6 cd ac 0f			call addatohl 
0ce9 cd 68 23			call loadwordinhl 
0cec			 
0cec				; forth will write the to string when pushing so move from rom to ram 
0cec			 
0cec 11 f9 fa			ld de, display_active+1 
0cef 01 02 00			ld bc, 2 
0cf2 ed b0			ldir 
0cf4			 
0cf4 21 f9 fa			ld hl, display_active+1 
0cf7 c9				ret 
0cf8				 
0cf8				 
0cf8			 
0cf8			 
0cf8			;db "|/-\|-\" 
0cf8			 
0cf8			actseq: 
0cf8			 
0cf8 06 0d		dw spin0 
0cfa 08 0d		dw spin1 
0cfc 0a 0d		dw spin2 
0cfe 0c 0d		dw spin3 
0d00 0a 0d		dw spin2 
0d02 08 0d		dw spin1 
0d04 06 0d		dw spin0 
0d06			 
0d06 .. 00		spin0: db " ", 0 
0d08 .. 00		spin1: db "-", 0 
0d0a .. 00		spin2: db "+", 0 
0d0c .. 00		spin3: db "#", 0 
0d0e			 
0d0e			 
0d0e			; information window 
0d0e			 
0d0e			; pass hl with 1st string to display 
0d0e			; pass de with 2nd string to display 
0d0e			 
0d0e			info_panel: 
0d0e e5				push hl 
0d0f			 
0d0f 2a fe fa			ld hl, (display_fb_active) 
0d12 e5				push hl    ; future de destination 
0d13 21 e3 fc				ld hl, display_fb0 
0d16 22 fe fa				ld (display_fb_active), hl 
0d19			 
0d19			;	call clear_display 
0d19			 
0d19				if BASE_CPM 
0d19				ld a, '.' 
0d19				else 
0d19 3e a5			ld a, 165 
0d1b				endif 
0d1b cd 81 0d			call fill_display 
0d1e			 
0d1e			 
0d1e 3e 55			ld a, display_row_3 + 5 
0d20 cd 8e 0d			call str_at_display 
0d23			 
0d23 e1				pop hl 
0d24 d1				pop de 
0d25			 
0d25 e5				push hl 
0d26			 
0d26			 
0d26 3e 2d			ld a, display_row_2 + 5 
0d28 cd 8e 0d			call str_at_display 
0d2b			 
0d2b			 
0d2b cd 9e 0d			call update_display 
0d2e cd 77 1f			call next_page_prompt 
0d31 cd 7c 0d			call clear_display 
0d34			 
0d34				 
0d34 21 42 fc				ld hl, display_fb1 
0d37 22 fe fa				ld (display_fb_active), hl 
0d3a cd 9e 0d			call update_display 
0d3d			 
0d3d e1				pop hl 
0d3e			 
0d3e c9				ret 
0d3f			 
0d3f			 
0d3f			 
0d3f			 
0d3f			; TODO windowing? 
0d3f			 
0d3f			; TODO scroll line up 
0d3f			 
0d3f			scroll_up: 
0d3f			 
0d3f e5				push hl 
0d40 d5				push de 
0d41 c5				push bc 
0d42			 
0d42				; get frame buffer  
0d42			 
0d42 2a fe fa			ld hl, (display_fb_active) 
0d45 e5				push hl    ; future de destination 
0d46			 
0d46 11 28 00			ld  de, display_cols 
0d49 19				add hl, de 
0d4a			 
0d4a d1				pop de 
0d4b			 
0d4b				;ex de, hl 
0d4b 01 9f 00			ld bc, display_fb_len -1  
0d4e			;if DEBUG_FORTH_WORDS 
0d4e			;	DMARK "SCL" 
0d4e			;	CALLMONITOR 
0d4e			;endif	 
0d4e ed b0			ldir 
0d50			 
0d50				; wipe bottom row 
0d50			 
0d50			 
0d50 2a fe fa			ld hl, (display_fb_active) 
0d53 11 a0 00			ld de, display_cols*display_rows 
0d56 19				add hl, de 
0d57 06 28			ld b, display_cols 
0d59			;	ld a, ' ' 
0d59			.scwipe: 
0d59 36 20			ld (hl), ' ' 
0d5b 2b				dec hl 
0d5c 10 fb			djnz .scwipe 
0d5e			 
0d5e				;pop hl 
0d5e			 
0d5e c1				pop bc 
0d5f d1				pop de 
0d60 e1				pop hl 
0d61			 
0d61 c9				ret 
0d62			 
0d62			 
0d62			;scroll_upo: 
0d62			;	ld de, display_row_1 
0d62			 ;	ld hl, display_row_2 
0d62			;	ld bc, display_cols 
0d62			;	ldir 
0d62			;	ld de, display_row_2 
0d62			 ;	ld hl, display_row_3 
0d62			;	ld bc, display_cols 
0d62			;	ldir 
0d62			;	ld de, display_row_3 
0d62			 ;	ld hl, display_row_4 
0d62			;	ld bc, display_cols 
0d62			;	ldir 
0d62			 
0d62			; TODO clear row 4 
0d62			 
0d62			;	ret 
0d62			 
0d62				 
0d62			scroll_down: 
0d62			 
0d62 e5				push hl 
0d63 d5				push de 
0d64 c5				push bc 
0d65			 
0d65				; get frame buffer  
0d65			 
0d65 2a fe fa			ld hl, (display_fb_active) 
0d68			 
0d68 11 9f 00			ld de, display_fb_len - 1 
0d6b 19				add hl, de 
0d6c			 
0d6c e5			push hl    ; future de destination 
0d6d			 
0d6d 11 28 00			ld  de, display_cols 
0d70 ed 52			sbc hl, de 
0d72			 
0d72			 
0d72 d1				pop de 
0d73			 
0d73			;	ex de, hl 
0d73 01 9f 00			ld bc, display_fb_len -1  
0d76			 
0d76			 
0d76				 
0d76			 
0d76 ed b0			ldir 
0d78			 
0d78				; wipe bottom row 
0d78			 
0d78			 
0d78			;	ld hl, (display_fb_active) 
0d78			;;	ld de, display_cols*display_rows 
0d78			;;	add hl, de 
0d78			;	ld b, display_cols 
0d78			;	ld a, ' ' 
0d78			;.scwiped: 
0d78			;	ld (hl), a 
0d78			;	dec hl 
0d78			;	djnz .scwiped 
0d78			 
0d78				;pop hl 
0d78			 
0d78 c1				pop bc 
0d79 d1				pop de 
0d7a e1				pop hl 
0d7b			 
0d7b c9				ret 
0d7c			;scroll_down: 
0d7c			;	ld de, display_row_4 
0d7c			;	ld hl, display_row_3 
0d7c			;	ld bc, display_cols 
0d7c			;	ldir 
0d7c			;	ld de, display_row_3 
0d7c			; 	ld hl, display_row_2 
0d7c			;	ld bc, display_cols 
0d7c			;	ldir 
0d7c			;	ld de, display_row_2 
0d7c			;	ld hl, display_row_1 
0d7c			;	ld bc, display_cols 
0d7c			;	ldir 
0d7c			;;; TODO clear row 1 
0d7c			;	ret 
0d7c			 
0d7c			 
0d7c			 
0d7c			 
0d7c			 
0d7c			; clear active frame buffer 
0d7c			 
0d7c			clear_display: 
0d7c 3e 20			ld a, ' ' 
0d7e c3 81 0d			jp fill_display 
0d81			 
0d81			; fill active frame buffer with a char in A 
0d81			 
0d81			fill_display: 
0d81 06 a0			ld b,display_fb_len 
0d83 2a fe fa			ld hl, (display_fb_active) 
0d86 77			.fd1:	ld (hl),a 
0d87 23				inc hl 
0d88 10 fc			djnz .fd1 
0d8a 23				inc hl 
0d8b			;	ld a,0 
0d8b 36 00			ld (hl),0 
0d8d			 
0d8d			 
0d8d c9				ret 
0d8e			; Write string (DE) at pos (A) to active frame buffer 
0d8e			 
0d8e 2a fe fa		str_at_display:    ld hl,(display_fb_active) 
0d91 06 00					ld b,0 
0d93 4f					ld c,a 
0d94 09					add hl,bc 
0d95 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0d96 b7			            OR   A              ;Null terminator? 
0d97 c8			            RET  Z              ;Yes, so finished 
0d98 77					ld (hl),a 
0d99 23				inc hl 
0d9a 13			            INC  DE             ;Point to next character 
0d9b 18 f8		            JR   .sad1     ;Repeat 
0d9d c9					ret 
0d9e			 
0d9e			; using current frame buffer write to physical display 
0d9e			 
0d9e			update_display: 
0d9e e5				push hl 
0d9f 2a fe fa			ld hl, (display_fb_active) 
0da2 cd ce 77			call write_display 
0da5 e1				pop hl 
0da6 c9				ret 
0da7			 
0da7			; TODO scrolling 
0da7			 
0da7			 
0da7			; move cursor right one char 
0da7			cursor_right: 
0da7			 
0da7				; TODO shift right 
0da7				; TODO if beyond max col 
0da7				; TODO       cursor_next_line 
0da7			 
0da7 c9				ret 
0da8			 
0da8			 
0da8			cursor_next_line: 
0da8				; TODO first char 
0da8				; TODO line down 
0da8				; TODO if past last row 
0da8				; TODO    scroll up 
0da8			 
0da8 c9				ret 
0da9			 
0da9			cursor_left: 
0da9				; TODO shift left 
0da9				; TODO if beyond left  
0da9				; TODO     cursor prev line 
0da9				 
0da9 c9				ret 
0daa			 
0daa			cursor_prev_line: 
0daa				; TODO last char 
0daa				; TODO line up 
0daa				; TODO if past first row 
0daa				; TODO   scroll down 
0daa			 
0daa c9				ret 
0dab			 
0dab			 
0dab			cout: 
0dab				; A - char 
0dab c9				ret 
0dac			 
0dac			 
0dac			; Display a menu and allow item selection (optional toggle items) 
0dac			; 
0dac			; format: 
0dac			; hl pointer to word array with zero term for items 
0dac			; e.g.    db item1 
0dac			;         db .... 
0dac			;         db 0 
0dac			; 
0dac			; a = starting menu item  
0dac			; 
0dac			; de = pointer item toggle array   (todo) 
0dac			; 
0dac			; returns item selected in a 1-... 
0dac			; returns 0 if back button pressed 
0dac			; 
0dac			; NOTE: Uses system frame buffer to display 
0dac			; 
0dac			; LEFT, Q = go back 
0dac			; RIGHT, SPACE, CR = select 
0dac			; UP, A - Up 
0dac			; DOWN, Z - Down 
0dac			 
0dac			 
0dac			 
0dac			 
0dac			 
0dac			menu: 
0dac			 
0dac					; keep array pointer 
0dac			 
0dac 22 a5 f9				ld (store_tmp1), hl 
0daf 32 a3 f9				ld (store_tmp2), a 
0db2			 
0db2					; check for key bounce 
0db2			 
0db2			if BASE_KEV 
0db2			 
0db2 cd 17 7b		.mbounce:	call cin 
0db5			;		cp 0 
0db5 b7					or a 
0db6 20 fa				jr nz, .mbounce 
0db8			endif 
0db8					; for ease use ex 
0db8			 
0db8					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0db8 21 e3 fc				ld hl, display_fb0 
0dbb 22 fe fa				ld (display_fb_active), hl 
0dbe			 
0dbe cd 7c 0d		.mloop:		call clear_display 
0dc1 cd 9e 0d				call update_display 
0dc4			 
0dc4					; draw selection id '>' at 1 
0dc4			 
0dc4					; init start of list display 
0dc4			 
0dc4 3e 05				ld a, 5 
0dc6 32 a1 f9				ld (store_tmp3), a   ; display row count 
0dc9 3a a3 f9				ld a,( store_tmp2) 
0dcc 32 a4 f9				ld (store_tmp2+1), a   ; display item count 
0dcf			 
0dcf					 
0dcf			.mitem:	 
0dcf			 
0dcf			 
0dcf 3a a4 f9				ld a,(store_tmp2+1) 
0dd2 6f					ld l, a 
0dd3 26 00				ld h, 0 
0dd5 29					add hl, hl 
0dd6 ed 5b a5 f9			ld de, (store_tmp1) 
0dda 19					add hl, de 
0ddb 7e					ld a, (hl) 
0ddc 23					inc hl 
0ddd 66					ld h,(hl) 
0dde 6f					ld l, a 
0ddf			 
0ddf cd d5 0f				call ishlzero 
0de2 28 1a				jr z, .mdone 
0de4			 
0de4 eb					ex de, hl 
0de5 3a a1 f9				ld a, (store_tmp3) 
0de8 cd 8e 0d				call str_at_display 
0deb					 
0deb			 
0deb					; next item 
0deb 3a a4 f9				ld a, (store_tmp2+1) 
0dee 3c					inc a 
0def 32 a4 f9				ld (store_tmp2+1), a   ; display item count 
0df2			 
0df2			 		; next row 
0df2			 
0df2 3a a1 f9				ld a, (store_tmp3) 
0df5 c6 28				add display_cols 
0df7 32 a1 f9				ld (store_tmp3), a 
0dfa			 
0dfa					; at end of screen? 
0dfa			 
0dfa fe 10				cp display_rows*4 
0dfc 20 d1				jr nz, .mitem 
0dfe			 
0dfe			 
0dfe			.mdone: 
0dfe cd d5 0f				call ishlzero 
0e01 28 08				jr z, .nodn 
0e03			 
0e03 3e 78				ld a, display_row_4 
0e05 11 82 0e				ld de, .mdown 
0e08 cd 8e 0d				call str_at_display 
0e0b			 
0e0b					; draw options to fill the screens with active item on line 1 
0e0b					; if current option is 2 or more then display ^ in top 
0e0b			 
0e0b 3a a3 f9		.nodn:		ld a, (store_tmp2) 
0e0e			;		cp 0 
0e0e b7					or a 
0e0f 28 08				jr z, .noup 
0e11			 
0e11 3e 00				ld a, 0 
0e13 11 80 0e				ld de, .mup 
0e16 cd 8e 0d				call str_at_display 
0e19			 
0e19 3e 02		.noup:		ld a, 2 
0e1b 11 7e 0e				ld de, .msel 
0e1e cd 8e 0d				call str_at_display 
0e21			 
0e21					; if current option + 1 is not null then display V in bottom 
0e21					; get key 
0e21 cd 9e 0d				call update_display 
0e24			 
0e24			 
0e24					; handle key 
0e24			 
0e24 cd 08 7b				call cin_wait 
0e27			 
0e27 fe 05				cp KEY_UP 
0e29 28 2b				jr z, .mgoup 
0e2b fe 61				cp 'a' 
0e2d 28 27				jr z, .mgoup 
0e2f fe 0a				cp KEY_DOWN 
0e31 28 31				jr z, .mgod 
0e33 fe 7a				cp 'z' 
0e35 28 2d				jr z, .mgod 
0e37 fe 20				cp ' ' 
0e39 28 33				jr z, .goend 
0e3b fe 0c				cp KEY_RIGHT 
0e3d 28 2f				jr z, .goend 
0e3f fe 0d				cp KEY_CR 
0e41 28 2b				jr z, .goend 
0e43 fe 71				cp 'q' 
0e45 28 0b				jr z, .goback 
0e47			 
0e47 fe 0b				cp KEY_LEFT 
0e49 28 07				jr z, .goback 
0e4b fe 08				cp KEY_BS 
0e4d 28 03				jr z, .goback 
0e4f c3 be 0d				jp .mloop 
0e52			 
0e52			.goback: 
0e52 3e 00			ld a, 0 
0e54 18 1c			jr .goend2 
0e56			 
0e56				; move up one 
0e56			.mgoup: 
0e56 3a a3 f9				ld a, (store_tmp2) 
0e59			;		cp 0 
0e59 b7					or a 
0e5a ca be 0d				jp z, .mloop 
0e5d 3d					dec a 
0e5e 32 a3 f9				ld (store_tmp2), a 
0e61 c3 be 0d				jp .mloop 
0e64			 
0e64				; move down one 
0e64			.mgod: 
0e64 3a a3 f9				ld a, (store_tmp2) 
0e67 3c					inc a 
0e68 32 a3 f9				ld (store_tmp2), a 
0e6b c3 be 0d				jp .mloop 
0e6e			 
0e6e			 
0e6e			.goend: 
0e6e					; get selected item number 
0e6e			 
0e6e 3a a3 f9				ld a, (store_tmp2) 
0e71 3c					inc a 
0e72			 
0e72			.goend2: 
0e72 f5					push af 
0e73			 
0e73					; restore active fb 
0e73					; TODO BUG assumes fb1 
0e73			 
0e73 21 42 fc				ld hl, display_fb1 
0e76 22 fe fa				ld (display_fb_active), hl 
0e79			 
0e79					; restore main regs 
0e79			 
0e79			 
0e79 cd 9e 0d				call update_display 
0e7c			 
0e7c f1					pop af 
0e7d			 
0e7d c9				ret 
0e7e			 
0e7e .. 00		.msel:   db ">",0 
0e80 .. 00		.mup:   db "^",0 
0e82 .. 00		.mdown:   db "v",0 
0e84			 
0e84			 
0e84			; eof 
0e84			 
# End of file firmware_display.asm
0e84			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0e84			; random number generators 
0e84			 
0e84			 
0e84			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0e84			 
0e84			 
0e84			;-----> Generate a random number 
0e84			; output a=answer 0<=a<=255 
0e84			; all registers are preserved except: af 
0e84			random: 
0e84 e5			        push    hl 
0e85 d5			        push    de 
0e86 2a dd fa		        ld      hl,(randData) 
0e89 ed 5f		        ld      a,r 
0e8b 57			        ld      d,a 
0e8c 5e			        ld      e,(hl) 
0e8d 19			        add     hl,de 
0e8e 85			        add     a,l 
0e8f ac			        xor     h 
0e90 22 dd fa		        ld      (randData),hl 
0e93 d1			        pop     de 
0e94 e1			        pop     hl 
0e95 c9			        ret 
0e96			 
0e96			 
0e96			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0e96			 
0e96			 
0e96			 
0e96			;------LFSR------ 
0e96			;James Montelongo 
0e96			;optimized by Spencer Putt 
0e96			;out: 
0e96			; a = 8 bit random number 
0e96			RandLFSR: 
0e96 21 e3 fa		        ld hl,LFSRSeed+4 
0e99 5e			        ld e,(hl) 
0e9a 23			        inc hl 
0e9b 56			        ld d,(hl) 
0e9c 23			        inc hl 
0e9d 4e			        ld c,(hl) 
0e9e 23			        inc hl 
0e9f 7e			        ld a,(hl) 
0ea0 47			        ld b,a 
0ea1 cb 13		        rl e  
0ea3 cb 12			rl d 
0ea5 cb 11		        rl c  
0ea7 17				rla 
0ea8 cb 13		        rl e  
0eaa cb 12			rl d 
0eac cb 11		        rl c  
0eae 17				rla 
0eaf cb 13		        rl e  
0eb1 cb 12			rl d 
0eb3 cb 11		        rl c  
0eb5 17				rla 
0eb6 67			        ld h,a 
0eb7 cb 13		        rl e  
0eb9 cb 12			rl d 
0ebb cb 11		        rl c  
0ebd 17				rla 
0ebe a8			        xor b 
0ebf cb 13		        rl e  
0ec1 cb 12			rl d 
0ec3 ac			        xor h 
0ec4 a9			        xor c 
0ec5 aa			        xor d 
0ec6 21 e5 fa		        ld hl,LFSRSeed+6 
0ec9 11 e6 fa		        ld de,LFSRSeed+7 
0ecc 01 07 00		        ld bc,7 
0ecf ed b8		        lddr 
0ed1 12			        ld (de),a 
0ed2 c9			        ret 
0ed3			 
0ed3			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0ed3			 
0ed3			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0ed3			 
0ed3			 
0ed3			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0ed3			 
0ed3			prng16: 
0ed3			;Inputs: 
0ed3			;   (seed1) contains a 16-bit seed value 
0ed3			;   (seed2) contains a NON-ZERO 16-bit seed value 
0ed3			;Outputs: 
0ed3			;   HL is the result 
0ed3			;   BC is the result of the LCG, so not that great of quality 
0ed3			;   DE is preserved 
0ed3			;Destroys: 
0ed3			;   AF 
0ed3			;cycle: 4,294,901,760 (almost 4.3 billion) 
0ed3			;160cc 
0ed3			;26 bytes 
0ed3 2a d7 fa		    ld hl,(seed1) 
0ed6 44			    ld b,h 
0ed7 4d			    ld c,l 
0ed8 29			    add hl,hl 
0ed9 29			    add hl,hl 
0eda 2c			    inc l 
0edb 09			    add hl,bc 
0edc 22 d7 fa		    ld (seed1),hl 
0edf 2a d5 fa		    ld hl,(seed2) 
0ee2 29			    add hl,hl 
0ee3 9f			    sbc a,a 
0ee4 e6 2d		    and %00101101 
0ee6 ad			    xor l 
0ee7 6f			    ld l,a 
0ee8 22 d5 fa		    ld (seed2),hl 
0eeb 09			    add hl,bc 
0eec c9			    ret 
0eed			 
0eed			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0eed			 
0eed			rand32: 
0eed			;Inputs: 
0eed			;   (seed1_0) holds the lower 16 bits of the first seed 
0eed			;   (seed1_1) holds the upper 16 bits of the first seed 
0eed			;   (seed2_0) holds the lower 16 bits of the second seed 
0eed			;   (seed2_1) holds the upper 16 bits of the second seed 
0eed			;   **NOTE: seed2 must be non-zero 
0eed			;Outputs: 
0eed			;   HL is the result 
0eed			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0eed			;Destroys: 
0eed			;   AF 
0eed			;Tested and passes all CAcert tests 
0eed			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0eed			;it has a period of 18,446,744,069,414,584,320 
0eed			;roughly 18.4 quintillion. 
0eed			;LFSR taps: 0,2,6,7  = 11000101 
0eed			;291cc 
0eed			;seed1_0=$+1 
0eed			;    ld hl,12345 
0eed			;seed1_1=$+1 
0eed			;    ld de,6789 
0eed			;    ld b,h 
0eed			;    ld c,l 
0eed			;    add hl,hl \ rl e \ rl d 
0eed			;    add hl,hl \ rl e \ rl d 
0eed			;    inc l 
0eed			;    add hl,bc 
0eed			;    ld (seed1_0),hl 
0eed			;    ld hl,(seed1_1) 
0eed			;    adc hl,de 
0eed			;    ld (seed1_1),hl 
0eed			;    ex de,hl 
0eed			;seed2_0=$+1 
0eed			;    ld hl,9876 
0eed			;seed2_1=$+1 
0eed			;    ld bc,54321 
0eed			;    add hl,hl \ rl c \ rl b 
0eed			;    ld (seed2_1),bc 
0eed			;    sbc a,a 
0eed			;    and %11000101 
0eed			;    xor l 
0eed			;    ld l,a 
0eed			;    ld (seed2_0),hl 
0eed			;    ex de,hl 
0eed			;    add hl,bc 
0eed			;    ret 
0eed			; 
0eed			 
0eed			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0eed			; 20 bytes, 86 cycles (excluding ret) 
0eed			 
0eed			; returns   hl = pseudorandom number 
0eed			; corrupts   a 
0eed			 
0eed			; generates 16-bit pseudorandom numbers with a period of 65535 
0eed			; using the xorshift method: 
0eed			 
0eed			; hl ^= hl << 7 
0eed			; hl ^= hl >> 9 
0eed			; hl ^= hl << 8 
0eed			 
0eed			; some alternative shift triplets which also perform well are: 
0eed			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0eed			 
0eed			;  org 32768 
0eed			 
0eed			xrnd: 
0eed 2a db fa		  ld hl,(xrandc)       ; seed must not be 0 
0ef0 3e 00		  ld a,0 
0ef2 bd			  cp l 
0ef3 20 02		  jr nz, .xrnd1 
0ef5 2e 01		  ld l, 1 
0ef7			.xrnd1: 
0ef7			 
0ef7 7c			  ld a,h 
0ef8 1f			  rra 
0ef9 7d			  ld a,l 
0efa 1f			  rra 
0efb ac			  xor h 
0efc 67			  ld h,a 
0efd 7d			  ld a,l 
0efe 1f			  rra 
0eff 7c			  ld a,h 
0f00 1f			  rra 
0f01 ad			  xor l 
0f02 6f			  ld l,a 
0f03 ac			  xor h 
0f04 67			  ld h,a 
0f05			 
0f05 22 db fa		  ld (xrandc),hl 
0f08			 
0f08 c9			  ret 
0f09			;  
0f09			 
0f09			 
0f09			;;;; int maths 
0f09			 
0f09			; https://map.grauw.nl/articles/mult_div_shifts.php 
0f09			; Divide 16-bit values (with 16-bit result) 
0f09			; In: Divide BC by divider DE 
0f09			; Out: BC = result, HL = rest 
0f09			; 
0f09			Div16: 
0f09 21 00 00		    ld hl,0 
0f0c 78			    ld a,b 
0f0d 06 08		    ld b,8 
0f0f			Div16_Loop1: 
0f0f 17			    rla 
0f10 ed 6a		    adc hl,hl 
0f12 ed 52		    sbc hl,de 
0f14 30 01		    jr nc,Div16_NoAdd1 
0f16 19			    add hl,de 
0f17			Div16_NoAdd1: 
0f17 10 f6		    djnz Div16_Loop1 
0f19 17			    rla 
0f1a 2f			    cpl 
0f1b 47			    ld b,a 
0f1c 79			    ld a,c 
0f1d 48			    ld c,b 
0f1e 06 08		    ld b,8 
0f20			Div16_Loop2: 
0f20 17			    rla 
0f21 ed 6a		    adc hl,hl 
0f23 ed 52		    sbc hl,de 
0f25 30 01		    jr nc,Div16_NoAdd2 
0f27 19			    add hl,de 
0f28			Div16_NoAdd2: 
0f28 10 f6		    djnz Div16_Loop2 
0f2a 17			    rla 
0f2b 2f			    cpl 
0f2c 41			    ld b,c 
0f2d 4f			    ld c,a 
0f2e c9			ret 
0f2f			 
0f2f			 
0f2f			;http://z80-heaven.wikidot.com/math 
0f2f			; 
0f2f			;Inputs: 
0f2f			;     DE and A are factors 
0f2f			;Outputs: 
0f2f			;     A is not changed 
0f2f			;     B is 0 
0f2f			;     C is not changed 
0f2f			;     DE is not changed 
0f2f			;     HL is the product 
0f2f			;Time: 
0f2f			;     342+6x 
0f2f			; 
0f2f			Mult16: 
0f2f			 
0f2f 06 08		     ld b,8          ;7           7 
0f31 21 00 00		     ld hl,0         ;10         10 
0f34 29			       add hl,hl     ;11*8       88 
0f35 07			       rlca          ;4*8        32 
0f36 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0f38 19			         add hl,de   ;--         -- 
0f39 10 f9		       djnz $-5      ;13*7+8     99 
0f3b c9			ret 
0f3c			 
0f3c			; 
0f3c			; Square root of 16-bit value 
0f3c			; In:  HL = value 
0f3c			; Out:  D = result (rounded down) 
0f3c			; 
0f3c			;Sqr16: 
0f3c			;    ld de,#0040 
0f3c			;    ld a,l 
0f3c			;    ld l,h 
0f3c			;    ld h,d 
0f3c			;    or a 
0f3c			;    ld b,8 
0f3c			;Sqr16_Loop: 
0f3c			;    sbc hl,de 
0f3c			;    jr nc,Sqr16_Skip 
0f3c			;    add hl,de 
0f3c			;Sqr16_Skip: 
0f3c			;    ccf 
0f3c			;    rl d 
0f3c			;    add a,a 
0f3c			;    adc hl,hl 
0f3c			;    add a,a 
0f3c			;    adc hl,hl 
0f3c			;    djnz Sqr16_Loop 
0f3c			;    ret 
0f3c			; 
0f3c			; 
0f3c			; Divide 8-bit values 
0f3c			; In: Divide E by divider C 
0f3c			; Out: A = result, B = rest 
0f3c			; 
0f3c			Div8: 
0f3c af			    xor a 
0f3d 06 08		    ld b,8 
0f3f			Div8_Loop: 
0f3f cb 13		    rl e 
0f41 17			    rla 
0f42 91			    sub c 
0f43 30 01		    jr nc,Div8_NoAdd 
0f45 81			    add a,c 
0f46			Div8_NoAdd: 
0f46 10 f7		    djnz Div8_Loop 
0f48 47			    ld b,a 
0f49 7b			    ld a,e 
0f4a 17			    rla 
0f4b 2f			    cpl 
0f4c c9			    ret 
0f4d			 
0f4d			; 
0f4d			; Multiply 8-bit value with a 16-bit value (unrolled) 
0f4d			; In: Multiply A with DE 
0f4d			; Out: HL = result 
0f4d			; 
0f4d			Mult12U: 
0f4d 2e 00		    ld l,0 
0f4f 87			    add a,a 
0f50 30 01		    jr nc,Mult12U_NoAdd0 
0f52 19			    add hl,de 
0f53			Mult12U_NoAdd0: 
0f53 29			    add hl,hl 
0f54 87			    add a,a 
0f55 30 01		    jr nc,Mult12U_NoAdd1 
0f57 19			    add hl,de 
0f58			Mult12U_NoAdd1: 
0f58 29			    add hl,hl 
0f59 87			    add a,a 
0f5a 30 01		    jr nc,Mult12U_NoAdd2 
0f5c 19			    add hl,de 
0f5d			Mult12U_NoAdd2: 
0f5d 29			    add hl,hl 
0f5e 87			    add a,a 
0f5f 30 01		    jr nc,Mult12U_NoAdd3 
0f61 19			    add hl,de 
0f62			Mult12U_NoAdd3: 
0f62 29			    add hl,hl 
0f63 87			    add a,a 
0f64 30 01		    jr nc,Mult12U_NoAdd4 
0f66 19			    add hl,de 
0f67			Mult12U_NoAdd4: 
0f67 29			    add hl,hl 
0f68 87			    add a,a 
0f69 30 01		    jr nc,Mult12U_NoAdd5 
0f6b 19			    add hl,de 
0f6c			Mult12U_NoAdd5: 
0f6c 29			    add hl,hl 
0f6d 87			    add a,a 
0f6e 30 01		    jr nc,Mult12U_NoAdd6 
0f70 19			    add hl,de 
0f71			Mult12U_NoAdd6: 
0f71 29			    add hl,hl 
0f72 87			    add a,a 
0f73 d0			    ret nc 
0f74 19			    add hl,de 
0f75 c9			    ret 
0f76			 
0f76			; 
0f76			; Multiply 8-bit value with a 16-bit value (right rotating) 
0f76			; In: Multiply A with DE 
0f76			;      Put lowest value in A for most efficient calculation 
0f76			; Out: HL = result 
0f76			; 
0f76			Mult12R: 
0f76 21 00 00		    ld hl,0 
0f79			Mult12R_Loop: 
0f79 cb 3f		    srl a 
0f7b 30 01		    jr nc,Mult12R_NoAdd 
0f7d 19			    add hl,de 
0f7e			Mult12R_NoAdd: 
0f7e cb 23		    sla e 
0f80 cb 12		    rl d 
0f82 b7			    or a 
0f83 c2 79 0f		    jp nz,Mult12R_Loop 
0f86 c9			    ret 
0f87			 
0f87			; 
0f87			; Multiply 16-bit values (with 32-bit result) 
0f87			; In: Multiply BC with DE 
0f87			; Out: BCHL = result 
0f87			; 
0f87			Mult32: 
0f87 79			    ld a,c 
0f88 48			    ld c,b 
0f89 21 00 00		    ld hl,0 
0f8c 06 10		    ld b,16 
0f8e			Mult32_Loop: 
0f8e 29			    add hl,hl 
0f8f 17			    rla 
0f90 cb 11		    rl c 
0f92 30 07		    jr nc,Mult32_NoAdd 
0f94 19			    add hl,de 
0f95 ce 00		    adc a,0 
0f97 d2 9b 0f		    jp nc,Mult32_NoAdd 
0f9a 0c			    inc c 
0f9b			Mult32_NoAdd: 
0f9b 10 f1		    djnz Mult32_Loop 
0f9d 41			    ld b,c 
0f9e 4f			    ld c,a 
0f9f c9			    ret 
0fa0			 
0fa0			 
0fa0			 
0fa0			; 
0fa0			; Multiply 8-bit values 
0fa0			; In:  Multiply H with E 
0fa0			; Out: HL = result 
0fa0			; 
0fa0			Mult8: 
0fa0 16 00		    ld d,0 
0fa2 6a			    ld l,d 
0fa3 06 08		    ld b,8 
0fa5			Mult8_Loop: 
0fa5 29			    add hl,hl 
0fa6 30 01		    jr nc,Mult8_NoAdd 
0fa8 19			    add hl,de 
0fa9			Mult8_NoAdd: 
0fa9 10 fa		    djnz Mult8_Loop 
0fab c9			    ret 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			 
0fac			;;http://z80-heaven.wikidot.com/math 
0fac			;;This divides DE by BC, storing the result in DE, remainder in HL 
0fac			; 
0fac			;DE_Div_BC:          ;1281-2x, x is at most 16 
0fac			;     ld a,16        ;7 
0fac			;     ld hl,0        ;10 
0fac			;     jp $+5         ;10 
0fac			;.DivLoop: 
0fac			;       add hl,bc    ;-- 
0fac			;       dec a        ;64 
0fac			;       jr z,.DivLoopEnd        ;86 
0fac			; 
0fac			;       sla e        ;128 
0fac			;       rl d         ;128 
0fac			;       adc hl,hl    ;240 
0fac			;       sbc hl,bc    ;240 
0fac			;       jr nc,.DivLoop ;23|21 
0fac			;       inc e        ;-- 
0fac			;       jp .DivLoop+1 
0fac			; 
0fac			;.DivLoopEnd: 
0fac			 
0fac			;HL_Div_C: 
0fac			;Inputs: 
0fac			;     HL is the numerator 
0fac			;     C is the denominator 
0fac			;Outputs: 
0fac			;     A is the remainder 
0fac			;     B is 0 
0fac			;     C is not changed 
0fac			;     DE is not changed 
0fac			;     HL is the quotient 
0fac			; 
0fac			;       ld b,16 
0fac			;       xor a 
0fac			;         add hl,hl 
0fac			;         rla 
0fac			;         cp c 
0fac			;         jr c,$+4 
0fac			;           inc l 
0fac			;           sub c 
0fac			;         djnz $-7 
0fac			 
0fac			; https://plutiedev.com/z80-add-8bit-to-16bit 
0fac			 
0fac			addatohl: 
0fac 85			    add   a, l    ; A = A+L 
0fad 6f			    ld    l, a    ; L = A+L 
0fae 8c			    adc   a, h    ; A = A+L+H+carry 
0faf 95			    sub   l       ; A = H+carry 
0fb0 67			    ld    h, a    ; H = H+carry 
0fb1 c9			ret 
0fb2			 
0fb2			addatode: 
0fb2 83			    add   a, e    ; A = A+L 
0fb3 5f			    ld    e, a    ; L = A+L 
0fb4 8a			    adc   a, d    ; A = A+L+H+carry 
0fb5 93			    sub   e       ; A = H+carry 
0fb6 57			    ld    d, a    ; H = H+carry 
0fb7 c9			ret 
0fb8			 
0fb8			 
0fb8			addatobc: 
0fb8 81			    add   a, c    ; A = A+L 
0fb9 4f			    ld    c, a    ; L = A+L 
0fba 88			    adc   a, b    ; A = A+L+H+carry 
0fbb 91			    sub   c       ; A = H+carry 
0fbc 47			    ld    b, a    ; H = H+carry 
0fbd c9			ret 
0fbe			 
0fbe			subafromhl: 
0fbe			   ; If A=0 do nothing 
0fbe			    ; Otherwise flip A's sign. Since 
0fbe			    ; the upper byte becomes -1, also 
0fbe			    ; substract 1 from H. 
0fbe ed 44		    neg 
0fc0 ca c9 0f		    jp    z, Skip 
0fc3 25			    dec   h 
0fc4			     
0fc4			    ; Now add the low byte as usual 
0fc4			    ; Two's complement takes care of 
0fc4			    ; ensuring the result is correct 
0fc4 85			    add   a, l 
0fc5 6f			    ld    l, a 
0fc6 8c			    adc   a, h 
0fc7 95			    sub   l 
0fc8 67			    ld    h, a 
0fc9			Skip: 
0fc9 c9				ret 
0fca			 
0fca			 
0fca			; compare hl and de 
0fca			; returns:  
0fca			; if hl = de, z=1, s=0, c0=0 
0fca			; if hl > de, z=0, s=0, c=0 
0fca			; if hl < de, z=0, s=1, c=1 
0fca			cmp16:	 
0fca b7				or a 
0fcb ed 52			sbc hl,de 
0fcd e0				ret po 
0fce 7c				ld a,h 
0fcf 1f				rra 
0fd0 ee 40			xor 01000000B 
0fd2 37				scf 
0fd3 8f				adc a,a 
0fd4 c9				ret 
0fd5			 
0fd5			 
0fd5			; test if hl contains zero   - A is destroyed 
0fd5			 
0fd5			ishlzero:    
0fd5 b7				or a     ; reset flags 
0fd6 7c				ld a, h 
0fd7 b5				or l        	 
0fd8			 
0fd8 c9				ret 
0fd9			 
0fd9			 
0fd9			 
0fd9			 
0fd9			if FORTH_ENABLE_FLOATMATH 
0fd9			;include "float/bbcmath.z80" 
0fd9			include "float/lpfpcalc.asm" 
0fd9			endif 
0fd9			 
0fd9			 
0fd9			; eof 
0fd9			 
# End of file firmware_maths.asm
0fd9			include "firmware_strings.asm"   ; string handling  
0fd9			 
0fd9			 
0fd9			; TODO string len 
0fd9			; input text string, end on cr with zero term 
0fd9			; a offset into frame buffer to start prompt 
0fd9			; d is max length 
0fd9			; e is display size TODO 
0fd9			; c is current cursor position 
0fd9			; hl is ptr to where string will be stored and edited directly 
0fd9			 
0fd9			 
0fd9			; TODO check limit of buffer for new inserts 
0fd9			; TODO check insert does not push beyond buffer 
0fd9			; TODO scroll in a limited display area 
0fd9			; TODO scroll whole screen on page wrap 
0fd9			 
0fd9			 
0fd9			; TODO use LCD cursor? 
0fd9			 
0fd9			EDIT_V1: equ 0 
0fd9			EDIT_V2: equ 1 
0fd9			 
0fd9			 
0fd9			 
0fd9			if EDIT_V2 
0fd9			input_str: 
0fd9			 
0fd9 32 96 fd			    	ld (input_at_pos),a      ; save display position to start 
0fdc			;		ld (input_at_cursor),a	; save draw pos of cursor relative to start 
0fdc 22 99 fd				ld (input_start), hl     ; save ptr to buffer 
0fdf			;		ld a, c 
0fdf			;		call addatohl 
0fdf			;		ld (input_ptr), hl     ; save ptr to point under the cursor 
0fdf 7a					ld a,d 
0fe0 32 98 fd			        ld (input_size), a       ; save length of input area 
0fe3 79					ld a, c 
0fe4 32 87 fd				ld (input_cursor),a      ; init cursor start position relative to start of string 
0fe7 7b					ld a,e 
0fe8 32 97 fd			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0feb			 
0feb			 
0feb					; add a trailing space to make screen refresh nicer 
0feb			 
0feb					;ld hl, (input_start) 
0feb					;push hl 
0feb					;ld a, 0 
0feb					;call strlent 
0feb					;ld a, l 
0feb					;pop hl 
0feb					;call addatohl 
0feb					;dec hl 
0feb					;ld a, ' ' 
0feb					;ld (hl), a 
0feb					;inc hl 
0feb					;ld (hl), a 
0feb					;inc hl 
0feb					;ld a, 0 
0feb					;ld (hl), a 
0feb			 
0feb			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0feb					; init cursor shape if not set by the cin routines 
0feb 21 f3 fa				ld hl, cursor_shape 
0fee			if BASE_KEV 
0fee			;		ld a, 255 
0fee 36 ff				ld (hl), 255 
0ff0			else 
0ff0					;ld a, '#' 
0ff0					ld (hl), '#' 
0ff0			endif 
0ff0 23					inc hl 
0ff1			;		ld a, 0 
0ff1 36 00				ld (hl), 0 
0ff3			 
0ff3 3e 09				ld a, CUR_BLINK_RATE 
0ff5 32 92 fd				ld (input_cur_flash), a 
0ff8 3e 01				ld a, 1 
0ffa 32 91 fd				ld (input_cur_onoff),a 
0ffd			.inmain:	 
0ffd			 
0ffd cd 1e 11				call input_disp_ref 
1000			 
1000					; save current length of string 
1000			 
1000 2a 99 fd				ld hl, (input_start) 
1003 3e 00				ld a, 0 
1005 cd 0f 13				call strlent 
1008 7d					ld a,l 
1009 32 8c fd				ld (input_len), a 
100c			 
100c					;call input_disp_oncur 
100c			 
100c					; display current state of input buffer 
100c			 
100c					; clean any backspace chars 
100c			 
100c 3e 20				ld a, " " 
100e 32 f3 f0				ld (scratch),a 
1011 3e 00				ld a, 0 
1013 32 f4 f0				ld (scratch+1),a 
1016 3a 96 fd				ld a,(input_at_pos) 
1019 85					add l 
101a 11 f3 f0				ld de, scratch 
101d cd 8e 0d				call str_at_display 
1020			 
1020					; pause 1ms 
1020			 
1020 3e 01				ld a, 1 
1022 cd a5 0c				call aDelayInMS 
1025			 
1025			; display cursor if visible on this cycle 
1025			 
1025					; dec flash counter 
1025 3a 92 fd				ld a, (input_cur_flash) 
1028 3d					dec a 
1029 32 92 fd				ld (input_cur_flash), a 
102c			;		cp 0 
102c b7					or a 
102d 20 0d				jr nz, .inochgstate 
102f			 
102f			 
102f					; reset on change of state 
102f 3e 09				ld a, CUR_BLINK_RATE 
1031 32 92 fd				ld (input_cur_flash), a 
1034			 
1034					; change state 
1034 3a 91 fd				ld a,(input_cur_onoff) 
1037 ed 44				neg 
1039 32 91 fd				ld (input_cur_onoff),a 
103c			 
103c			 
103c			 
103c			 
103c					; TODO is cursor visible? 
103c					; TODO if so then over write the char at curspos pos with the cursor shape 
103c			 
103c								 
103c			 
103c			.inochgstate: 
103c 3a 91 fd				ld a,(input_cur_onoff) 
103f fe ff				cp 255 
1041 28 0e				jr z, .skipcursor 
1043 3a 96 fd				ld a, (input_at_pos) 
1046 47					ld b, a 
1047 3a 87 fd				ld a, (input_cursor) 
104a 80					add b 
104b 11 f3 fa				ld de, cursor_shape 
104e					 
104e cd 8e 0d				call str_at_display 
1051			 
1051			.skipcursor: 
1051				if DEBUG_INPUTV2 
1051			 
1051					ld a,(input_at_pos) 
1051					ld hl, LFSRSeed 
1051					call hexout 
1051					ld a, (input_cursor) 
1051					ld hl, LFSRSeed+2 
1051					call hexout 
1051					ld a,(input_size) 
1051					ld hl, LFSRSeed+4 
1051					call hexout 
1051			 
1051					ld a,(input_cur_onoff) 
1051					ld hl, LFSRSeed+6 
1051					call hexout 
1051			 
1051					ld a,(input_cur_flash) 
1051					ld hl, LFSRSeed+8 
1051					call hexout 
1051			 
1051					ld a,(input_len) 
1051					ld hl, LFSRSeed+10 
1051					call hexout 
1051					ld hl, LFSRSeed+12 
1051			;		ld a, 0 
1051					ld (hl),0 
1051					ld a, display_row_4 
1051					ld de, LFSRSeed 
1051					call str_at_display 
1051				endif 
1051 cd 9e 0d				call update_display 
1054			 
1054					; TODO keyboard processing 
1054			 
1054			if BASE_CPM 
1054					call cin_wait 
1054			else 
1054 cd 17 7b				call cin    ; _wait 
1057			endif 
1057			;		cp 0 
1057 b7					or a 
1058 ca fd 0f				jp z, .inmain 
105b			 
105b fe 0b				cp KEY_LEFT    ; cursor left 
105d ca 10 11				jp z, input_left 
1060				 
1060 fe 0c				cp KEY_RIGHT      ; cursor right 
1062 ca 17 11				jp z, input_right 
1065			 
1065 fe 0d				cp KEY_CR 
1067 c8					ret z 
1068			 
1068 fe 08				cp KEY_BS 
106a ca 82 11				jp z, input_delchar 
106d			 
106d fe 06				cp KEY_NEXTWORD 
106f ca 96 10				jp z, input_nxtword 
1072			 
1072 fe 07				cp KEY_PREVWORD 
1074 ca bb 10				jp z, input_prvword 
1077			 
1077 fe 0e				cp KEY_HOME    ; jump to start of line 
1079 20 08				jr nz, .ikh 
107b 3e 00				ld a, 0 
107d 32 87 fd				ld (input_cursor), a 
1080 ca fd 0f				jp z, .inmain 
1083			.ikh: 
1083			 
1083 fe 0f				cp KEY_END     ; jump to end of line 
1085 20 09				jr nz, .ike 
1087 3a 8c fd				ld a, (input_len) 
108a 32 87 fd				ld (input_cursor),a 
108d ca fd 0f				jp z, .inmain 
1090			.ike: 
1090 fe 05			        cp KEY_UP      ; recall last command 
1092 c8					ret z 
1093			;jr nz, .irec 
1093			; TODO next word 
1093			; TODO prev word 
1093			;  
1093			; 
1093			;	ld hl, scratch 
1093			;	ld de, os_last_cmd 
1093			;	call strcpy 
1093			;		jp  .inmain 
1093			.irec: 
1093			;		jr .instr1 
1093			 
1093			 
1093			 
1093					; if any keys not intercepted by above but are special keys like function keys then return them to the program 
1093			 
1093			; TODO return if any special keys are given 
1093			;		ld l, a 
1093			;		ld a, 28 ; KEY_F12   ; 27 
1093			;		sub l 
1093			;		ret m 
1093			;		ld a, l 
1093					; if no special key then insert as a char 
1093			 
1093 c3 57 11				jp input_inschr 
1096			 
1096				 
1096			input_nxtword: 
1096				; jump to start next word after the cursor 
1096			 
1096			.insknwn:	 
1096 cd 4d 11				call input_curptr	 
1099 7e					ld a,(hl)	 
109a			;		cp 0 
109a b7					or a 
109b ca fd 0f				jp z, .inmain    ; end of string 
109e			 
109e			; if we are on a word, then move off of it 
109e			 
109e fe 20				cp ' ' 
10a0 28 06				jr z, .inspace     ; we are on space so eat the space until we hit non-space 
10a2 21 87 fd				ld hl, input_cursor 
10a5 34					inc (hl) 
10a6 18 ee				jr .insknwn 
10a8			 
10a8			.inspace: 
10a8			 
10a8 cd 4d 11				call input_curptr	 
10ab 7e					ld a,(hl)	 
10ac			;		cp 0 
10ac b7					or a 
10ad ca fd 0f				jp z, .inmain    ; end of string 
10b0			 
10b0			; if we are on a word, then move off of it 
10b0			 
10b0 fe 20				cp ' ' 
10b2 c2 fd 0f				jp nz, .inmain     ; we are on non space so at next word 
10b5 21 87 fd				ld hl, input_cursor 
10b8 34					inc (hl) 
10b9 18 ed				jr .inspace 
10bb			 
10bb			 
10bb			 
10bb			 
10bb			input_prvword: 
10bb				; jump to the start of previous word before the cursor 
10bb			 
10bb			; where are we to start with currently? 
10bb			 
10bb cd 4d 11				call input_curptr	 
10be 7e					ld a, (hl) 
10bf fe 20				cp ' ' 
10c1 28 1c				jr z, .inspacep     ; we are on space so eat the space until we hit non-space 
10c3			 
10c3			 
10c3			 
10c3			.inskpwn:	 
10c3 3a 87 fd				ld a,(input_cursor) 
10c6			;		cp 0 
10c6 b7					or a 
10c7 ca fd 0f				jp z, .inmain    ; start of string 
10ca			 
10ca			;if we are on a word, then move off of it 
10ca			 
10ca cd 4d 11				call input_curptr	 
10cd 7e					ld a, (hl) 
10ce fe 20				cp ' ' 
10d0 28 06				jr z, .iwstart     ; we are on space so eat the space until we hit non-space 
10d2					;jp z, .inmain    ; start of string 
10d2 21 87 fd				ld hl, input_cursor 
10d5 35					dec (hl) 
10d6 18 eb				jr .inskpwn 
10d8			.iwstart: 
10d8 21 87 fd				ld hl, input_cursor 
10db 34					inc (hl) 
10dc c3 fd 0f				jp .inmain 
10df					 
10df			 
10df			.inspacep: 
10df			 
10df					;jp .inmain    ; start of string 
10df			 
10df			 
10df			 
10df 3a 87 fd				ld a,(input_cursor) 
10e2			;		cp 0 
10e2 b7					or a 
10e3 ca fd 0f				jp z, .inmain    ; start of string 
10e6			 
10e6			; if we are on a word, then move off of it 
10e6			 
10e6 cd 4d 11				call input_curptr	 
10e9 7e					ld a, (hl) 
10ea fe 20				cp ' ' 
10ec c2 f5 10				jp nz, .incharp     ; we are on non space so at end of prev word 
10ef 21 87 fd				ld hl, input_cursor 
10f2 35					dec (hl) 
10f3 18 ea				jr .inspacep 
10f5			 
10f5			 
10f5			.incharp:	 
10f5					; eat the word to get to the start 
10f5 3a 87 fd				ld a,(input_cursor) 
10f8			;		cp 0 
10f8 b7					or a 
10f9 ca fd 0f				jp z, .inmain    ; start of string 
10fc			 
10fc			; if we are on a word, then move off of it 
10fc			 
10fc cd 4d 11				call input_curptr	 
10ff 7e					ld a, (hl) 
1100 fe 20				cp ' ' 
1102 28 06				jr z, .ipwordst     ; we are on space so eat the space until we hit non-space 
1104 21 87 fd				ld hl, input_cursor 
1107 35					dec (hl) 
1108 18 eb				jr .incharp 
110a			.ipwordst: 
110a					; at space before the prev word so reposition over it 
110a 21 87 fd				ld hl, input_cursor 
110d 34					inc (hl) 
110e 18 b3				jr .inskpwn 
1110					 
1110			 
1110			 
1110			input_left: 
1110				; move cursor left 
1110 21 87 fd			ld hl, input_cursor 
1113 35				dec (hl) 
1114			;	cp 0 
1114			;	jp z, .inmain    ; ignore left as at the start of the string 
1114 c3 fd 0f			jp .inmain 
1117			 
1117			input_right: 
1117				; move cursor right 
1117				 
1117				;ld a, (input_size) 
1117				;ld b, a 
1117 21 87 fd			ld hl, input_cursor 
111a 34				inc (hl) 
111b				;dec b 
111b				;cp 0 
111b				;jp z, .inmain   ; ignore as at end of the string buffer 
111b				;ld a, b 
111b				;inc a 
111b				;ld (input_cursor), a 
111b c3 fd 0f			jp .inmain 
111e			 
111e			 
111e			 
111e			input_disp_ref: 
111e				; display the text from start of buffer (ie full refresh) 
111e 3a 96 fd			ld a, (input_at_pos) 
1121 2a 99 fd			ld hl,(input_start) 
1124 eb				ex de, hl 
1125 cd 8e 0d			call str_at_display  
1128 c9				ret 
1129			input_disp_oncur: 
1129				; display the text from cursor position to end of buffer 
1129				; TODO position start of string at cursor position on screen 
1129				; TODO draw from that point on 
1129 3a 87 fd			ld a, (input_cursor) 
112c 47				ld b, a 
112d 3a 96 fd			ld a, (input_at_pos) 
1130 80				add b 
1131 48				ld c, b     ; save a 
1132 78				ld a, b     ; inc string start for cursor 
1133 2a 99 fd			ld hl,(input_start) 
1136 cd ac 0f			call addatohl 
1139 eb				ex de, hl 
113a 79				ld a, c 
113b cd 8e 0d			call str_at_display  
113e c9				ret 
113f			 
113f			input_nxtw: 
113f				; Find next word 
113f c9				ret 
1140			 
1140			input_prvw: 
1140				; Find previous word 
1140 c9				ret 
1141			 
1141			input_lenrem:   
1141				; Calculate the length of string remaining from current cursor 
1141				; position to end of buffer (exc null term) 
1141				 
1141 3a 87 fd			ld a, (input_cursor) 
1144 4f				ld c, a 
1145 3a 98 fd			ld a, (input_size) 
1148 91				sub c 
1149 06 00			ld b, 0 
114b 0d				dec c 
114c c9				ret	 
114d			 
114d			input_curptr: 
114d				; calc address of the character under the cursor 
114d				 
114d 2a 99 fd			ld hl, (input_start) 
1150 3a 87 fd			ld a, (input_cursor) 
1153 cd ac 0f			call addatohl 
1156 c9				ret 
1157			 
1157			input_inschr: 
1157				; Insert char at cursor position 
1157 f5				push af   ; save char 
1158				;call input_lenrem    ; get bc length of remaining string 
1158			 
1158				 
1158 cd 4d 11			call input_curptr 
115b			;	ld hl, (input_start) 
115b			;	ld a, (input_cursor) 
115b			;	call addatohl 
115b				;push hl   ; save to come back to 
115b			 
115b				; shift everything up one to end of buffer 
115b			 
115b				;push hl 
115b				;dec de 
115b				;inc de 
115b			;	ldir 
115b				 
115b				;pop hl 
115b			 
115b				; are we adding to the end of line? 
115b			 
115b 3a 87 fd			ld a, (input_cursor) 
115e 47				ld b, a 
115f 3a 8c fd			ld a, (input_len) 
1162 b8				cp b 
1163 20 08			jr nz, .insmid   ; no, insert in middle of text 
1165			 
1165				; tack on the end of the line 
1165 f1				pop af 
1166 77				ld (hl), a   ; save new char 
1167 23				inc hl 
1168			;	ld a, 0 
1168 36 00			ld (hl), 0 
116a c3 17 11			jp input_right 
116d				 
116d			.insmid: 
116d				; hl has insertion point so move everything up one to allow for insertion 
116d				;call input_shiftright 
116d f1				pop af 
116e			 
116e			.shufinsmid: 
116e 47				ld b, a     ; b contains new char, c prev char at this position  
116f 7e				ld a, (hl) 
1170			 
1170			;	cp 0    ; at end of string need to then dump new char and add term 
1170 b7				or a 
1171 28 07			jr z, .endinsmid 
1173 4f				ld c, a 
1174 78				ld a, b 
1175 77				ld (hl), a 
1176 23				inc hl 
1177 79				ld a, c 
1178 18 f4			jr .shufinsmid 
117a				 
117a			 
117a			 
117a			 
117a			.endinsmid: 
117a 78				ld a, b 
117b 77				ld (hl), a 
117c 23				inc hl 
117d			;	ld a, 0 
117d 36 00			ld (hl), 0 
117f			 
117f			 
117f			;	ld (hl), a   ; save new char 
117f			 
117f c3 17 11			jp input_right 
1182			 
1182			;input_shiftright: 
1182			;	; shift text right at cursor, hl has shift start 
1182			;	push hl 
1182			;	push de 
1182			;	push bc 
1182			; 
1182			; 
1182			;	; move to end of string past zero term 
1182			;	ld hl,(input_start) 
1182			;	ld a, (input_len) 
1182			;	call addatohl 
1182			;	inc hl 
1182			;;	inc hl 
1182			;;	inc hl 
1182			;	ld a, 0 
1182			;	ld (hl), a 
1182			;;	dec hl 
1182			;	 
1182			;;	ld (hl), a 
1182			;;	dec hl 
1182			; 
1182			;	push hl 
1182			;	pop de 
1182			;	inc de 
1182			;	 
1182			; 
1182			;;	ld hl,(input_start) 
1182			;;	ld a, (input_cursor) 
1182			;;	call addatohl 
1182			; 
1182			; 
1182			;	; calc how many bytes from cursor pos to end of string we need to shift 
1182			;	call input_lenrem    ; get bc length of remaining string 
1182			;	;ld a, (input_cursor) 
1182			;	;ld c, a 
1182			;	ld a, (input_len) 
1182			;	cp 2 
1182			;	jr z, .iskipzero	 
1182			;	;sub c 
1182			;	;inc a 
1182			;	;ld c, a 
1182			;	;ld b, 0 
1182			;	inc c 
1182			;	inc c 
1182			;	; move data 
1182			;	lddr 
1182			;.iskipzero: 
1182			; 
1182			;	pop bc 
1182			;	pop de 
1182			;	pop hl 
1182			;	ret	 
1182			 
1182			input_delchar: 
1182				; Delete char at cursor position 
1182 cd 41 11			call input_lenrem    ; get bc length of remaining string 
1185 2a 99 fd			ld hl, (input_start) 
1188 3a 87 fd			ld a, (input_cursor) 
118b cd ac 0f			call addatohl 
118e			 
118e e5				push hl 
118f d1				pop de 
1190 1b				dec de 
1191			 
1191			.dl:	 
1191 ed a0			ldi  
1193 7e				ld a, (hl) 
1194			;	cp 0 
1194 b7				or a 
1195 28 02			jr z, .dldone 
1197 18 f8			jr .dl 
1199			.dldone: 
1199 ed a0			ldi 
119b			 
119b c3 10 11			jp input_left 
119e			 
119e			 
119e			endif 
119e			 
119e			 
119e			 
119e			if EDIT_V1 
119e			input_str: 
119e			 
119e				    	ld (input_at_pos),a      ; save display position to start 
119e					add c 
119e					ld (input_at_cursor),a	; save draw pos of cursor 
119e					ld (input_start), hl     ; save ptr to buffer 
119e					ld a, c 
119e					call addatohl 
119e					ld (input_ptr), hl     ; save ptr to point under the cursor 
119e					ld a,d 
119e				        ld (input_size), a       ; save length of input area 
119e					ld a, c 
119e					ld (input_cursor),a      ; init cursor start position  
119e					ld a,e 
119e				        ld (input_display_size), a       ; save length of input area that is displayed TODO 
119e					 
119e					 
119e			 
119e			;		ld a,(input_ptr) 
119e			;		ld (input_under_cursor),a 	; save what is under the cursor 
119e			 
119e			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
119e					; init cursor shape if not set by the cin routines 
119e					ld hl, cursor_shape 
119e			if BASE_KEV 
119e					ld a, 255 
119e			else 
119e					ld a, '#' 
119e			endif 
119e					ld (hl), a 
119e					inc hl 
119e					ld a, 0 
119e					ld (hl), a 
119e			 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e					ld a, 1 
119e					ld (input_cur_onoff),a 
119e			 
119e			;	if DEBUG_INPUT 
119e			;		push af 
119e			;		ld a, 'I' 
119e			;		ld (debug_mark),a 
119e			;		pop af 
119e			;		CALLMONITOR 
119e			;	endif 
119e			.is1:		; main entry loop 
119e			 
119e			 
119e			 
119e					; pause 1ms 
119e			 
119e					ld a, 1 
119e					call aDelayInMS 
119e			 
119e					; dec flash counter 
119e					ld a, (input_cur_flash) 
119e					dec a 
119e					ld (input_cur_flash), a 
119e			;		cp 0 
119e					or a 
119e					jr nz, .nochgstate 
119e			 
119e			 
119e					; change state 
119e					ld a,(input_cur_onoff) 
119e					neg 
119e					ld (input_cur_onoff),a 
119e			 
119e			 
119e					; reset on change of state 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e			.nochgstate: 
119e					 
119e					 
119e			 
119e					; display cursor  
119e			 
119e			;		ld hl, (input_start) 
119e			;		ld a, (input_cursor) 
119e			;		call addatohl 
119e			 
119e					; get char under cursor and replace with cursor 
119e			ld hl, (input_ptr) 
119e			;		ld a, (hl) 
119e			;		ld (input_under_cursor),a 
119e			;		ld a, '_' 
119e			;		ld (hl), a 
119e			 
119e					; display string 
119e			 
119e					ld de, (input_start) 
119e					ld a, (input_at_pos) 
119e					call str_at_display 
119e			;	        call update_display 
119e			 
119e					; find place to put the cursor 
119e			;		add h 
119e			;		ld l, display_row_1 
119e			;		sub l 
119e			; (input_at_pos) 
119e					;ld c, a 
119e			;		ld a, (input_cursor) 
119e			;		ld l, (input_at_pos) 
119e			;		;ld b, h 
119e			;		add l 
119e			;		ld (input_at_cursor),a 
119e					;ld l,h 
119e			 
119e			;		ld h, 0 
119e			;		ld l,(input_at_pos) 
119e			;		ld a, (input_cursor) 
119e			;		call addatohl 
119e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
119e			;		call subafromhl 
119e			;		ld a,l 
119e			;		ld (input_at_cursor), a 
119e			 
119e				if DEBUG_INPUT 
119e					ld a, (hardware_diag) 
119e			;		cp 0 
119e					or a 
119e					jr z, .skip_input_diag 
119e			 
119e					ld a,(input_at_pos) 
119e					ld hl, LFSRSeed 
119e					call hexout 
119e					ld a, (input_cursor) 
119e					ld hl, LFSRSeed+2 
119e					call hexout 
119e					ld a,(input_at_cursor) 
119e					ld hl, LFSRSeed+4 
119e					call hexout 
119e			 
119e					ld a,(input_cur_onoff) 
119e					ld hl, LFSRSeed+6 
119e					call hexout 
119e			 
119e					ld a,(input_cur_flash) 
119e					ld hl, LFSRSeed+8 
119e					call hexout 
119e			 
119e					ld a,(input_len) 
119e					ld hl, LFSRSeed+10 
119e					call hexout 
119e					ld hl, LFSRSeed+12 
119e					ld a, 0 
119e					ld (hl),a 
119e					ld a, display_row_4 
119e					ld de, LFSRSeed 
119e					call str_at_display 
119e					.skip_input_diag: 
119e				endif 
119e			 
119e					; decide on if we are showing the cursor this time round 
119e			 
119e					ld a, (input_cur_onoff) 
119e					cp 255 
119e					jr z, .skipcur 
119e			 
119e			 
119e					ld a,(input_at_cursor) 
119e					ld de, cursor_shape 
119e					call str_at_display 
119e			 
119e					; save length of current input string 
119e					ld hl, (input_start) 
119e					ld a, 0 
119e					call strlent 
119e					ld a,l 
119e					ld (input_len),a 
119e			 
119e			.skipcur: 
119e			 
119e				        call update_display 
119e					 
119e			 
119e			 
119e					; wait 
119e				 
119e					; TODO loop without wait to flash the cursor and char under cursor	 
119e					call cin    ; _wait 
119e			 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1 
119e			 
119e					; get ptr to char to input into 
119e			 
119e					ld c,a 
119e					ld hl, (input_start) 
119e					ld a, (input_cursor) 
119e					call addatohl 
119e					ld (input_ptr), hl 
119e					ld a,c 
119e			 
119e					; replace char under cursor 
119e			 
119e			;		ld hl, (input_ptr) 
119e			;		ld a, (input_under_cursor) 	; get what is under the cursor 
119e			;		ld (hl), a 
119e			 
119e			;	if DEBUG_INPUT 
119e			;		push af 
119e			;		ld a, 'i' 
119e			;		ld (debug_mark),a 
119e			;		pop af 
119e			;		CALLMONITOR 
119e			;	endif 
119e					cp KEY_HOME 
119e					jr nz, .iske 
119e			 
119e					ld a, (input_at_pos) 
119e					ld (input_at_cursor),a 
119e					ld a, 0 
119e					ld (input_cursor), a 
119e					jp .is1 
119e					 
119e			.iske:		cp KEY_END 
119e					jr nz, .isknw 
119e					jp .is1 
119e			 
119e			.isknw:		cp KEY_NEXTWORD 
119e					jr nz, .iskpw 
119e			 
119e			.isknwm:	ld hl, (input_ptr) 
119e					ld a,(hl)	 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1    ; end of string 
119e					cp ' ' 
119e					jp z, .is1    ; end of word 
119e					inc hl 
119e					ld (input_ptr), hl 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e					jr .isknwm 
119e			 
119e			.iskpw:		cp KEY_PREVWORD 
119e					jr nz, .iskl 
119e			.iskpwm:	 
119e					ld hl, (input_ptr) 
119e					ld a,(hl)	 
119e			;		cp 0  
119e					or a 
119e					jp z, .is1    ; end of string 
119e					cp ' ' 
119e					jp z, .is1    ; end of word 
119e					dec hl 
119e					ld (input_ptr), hl 
119e					ld a, (input_at_cursor) 
119e					dec a 
119e					ld (input_at_cursor), a 
119e					jr .iskpwm 
119e			 
119e			 
119e			.iskl:		cp KEY_LEFT 
119e					jr nz, .isk1 
119e			 
119e					ld a, (input_cursor) 
119e			 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1 		; at start of line to ignore  
119e			 
119e					dec  a 		; TODO check underflow 
119e					ld (input_cursor), a 
119e			 
119e					ld hl, (input_ptr) 
119e					dec hl 
119e					ld (input_ptr), hl 
119e					 
119e					ld a, (input_at_cursor) 
119e					dec a 
119e					ld (input_at_cursor), a 
119e			 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e					jp .is1 
119e			 
119e			.isk1:		cp KEY_RIGHT 
119e					jr nz, .isk2 
119e			 
119e					ld a,(input_len)		; TODO BUG why cant i load e direct? 
119e					ld e,a 
119e					ld a, (input_cursor) 
119e					cp e 
119e					jp z, .is1		; at the end of string so dont go right 
119e			 
119e					inc  a 		; TODO check overflow 
119e					ld (input_cursor), a 
119e			 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e			 
119e					ld hl, (input_ptr) 
119e					inc hl 
119e					ld (input_ptr), hl 
119e			 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e					jp .is1 
119e			 
119e			.isk2:		cp KEY_UP 
119e			 
119e					jr nz, .isk3 
119e			 
119e					; swap last command with the current on 
119e			 
119e					; move cursor to start of string 
119e					ld hl, (input_start) 
119e					ld (input_ptr), hl 
119e			 
119e					ld a, (input_at_pos) 
119e					ld (input_at_cursor), a 
119e			 
119e					ld a, 0 
119e					ld (input_cursor), a 
119e					 
119e					; swap input and last command buffers 
119e			 
119e					ld hl, os_cli_cmd 
119e					ld de, os_last_cmd 
119e					ld b, 255 
119e			.swap1:		ld a, (hl) 
119e					ld c,a 
119e					ld a, (de) 
119e					ld (hl), a 
119e					ld a,c 
119e					ld (de),a 
119e					inc hl 
119e					inc de 
119e					djnz .swap1 
119e			 
119e			 
119e			 
119e			 
119e			 
119e					jp .is1 
119e			 
119e			.isk3:		cp KEY_BS 
119e					jr nz, .isk4 
119e			 
119e					ld a, (input_cursor) 
119e			 
119e			;		cp 0 
119e					or a 
119e					jp z, .is1 		; at start of line to ignore  
119e			 
119e					dec  a 		; TODO check underflow 
119e					ld (input_cursor), a 
119e			 
119e					; hl is source 
119e					; de needs to be source - 1 
119e			 
119e			;		ld a, 0 
119e			;		dec hl 
119e			;		ld (hl), a 
119e			 
119e					ld hl, (input_ptr) 
119e					dec hl 
119e					ld (input_ptr), hl 
119e			 
119e					; shift all data 
119e			 
119e					push hl 
119e					inc hl 
119e					pop de 
119e					ld a, (input_len)		; TODO BUG WAS ld c, (input... 
119e					ld c,a 
119e					ld b,0 
119e					ldir  
119e			 
119e			 
119e			 
119e			 
119e					ld a, (input_at_cursor) 
119e					dec a 
119e					ld (input_at_cursor), a 
119e			 
119e			 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e			 
119e					; remove char 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld de,.iblank 
119e					call str_at_display 
119e			 
119e					jp .is1 
119e			 
119e			.isk4:		cp KEY_CR 
119e					jr z, .endinput 
119e			 
119e					; else add the key press to the end 
119e			 
119e					ld c, a			; save key pressed 
119e			 
119e					ld a,(hl)		; get what is currently under char 
119e			 
119e			;		cp 0			; we are at the end of the string 
119e					or a 
119e					jr nz, .onchar 
119e					 
119e					; add a char to the end of the string 
119e				 
119e					ld (hl),c 
119e					inc hl 
119e			;		ld a,' ' 
119e			;		ld (hl),a 
119e			;		inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e					dec hl 
119e			 
119e					ld a, (input_cursor) 
119e					inc a				; TODO check max string length and scroll  
119e					ld (input_cursor), a		; inc cursor pos 
119e							 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e			 
119e					ld hl, (input_ptr) 
119e					inc hl 
119e					ld (input_ptr), hl 
119e			 
119e					ld hl, (input_ptr) 
119e					inc hl 
119e					ld (input_ptr), hl 
119e			;	if DEBUG_INPUT 
119e			;		push af 
119e			;		ld a, '+' 
119e			;		ld (debug_mark),a 
119e			;		pop af 
119e			;		CALLMONITOR 
119e			;	endif 
119e					ld a, 1		; show cursor moving 
119e					ld (input_cur_onoff),a 
119e					ld a, CUR_BLINK_RATE 
119e					ld (input_cur_flash), a 
119e					jp .is1 
119e					 
119e			 
119e			 
119e					; if on a char then insert 
119e			.onchar: 
119e			 
119e					; TODO over flow check: make sure insert does not blow out buffer 
119e			 
119e					; need to do some maths to use lddr 
119e			 
119e					push hl   ; save char pos 
119e					push bc 
119e			 
119e					ld hl, (input_start) 
119e					ld a, (input_len) 
119e					call addatohl  		; end of string 
119e					inc hl 
119e					inc hl		; past zero term 
119e					push hl 
119e					inc hl 
119e					push hl  
119e			 
119e								; start and end of lddr set, now how much to move? 
119e			 
119e							 
119e					ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
119e					ld b,a 
119e					ld a,(input_len) 
119e					ld e,a 
119e					sub b 
119e					inc a		;?? 
119e					inc a		;?? 
119e					inc a		;?? 
119e			 
119e					ld b,0 
119e					ld c,a 
119e			 
119e				if DEBUG_INPUT 
119e					push af 
119e					ld a, 'i' 
119e					ld (debug_mark),a 
119e					pop af 
119e			;		CALLMONITOR 
119e				endif 
119e					pop de 
119e					pop hl 
119e				if DEBUG_INPUT 
119e					push af 
119e					ld a, 'I' 
119e					ld (debug_mark),a 
119e					pop af 
119e			;		CALLMONITOR 
119e				endif 
119e					lddr 
119e				 
119e			 
119e			 
119e					; TODO have a key for insert/overwrite mode???? 
119e					pop bc 
119e					pop hl 
119e					ld (hl), c		; otherwise overwrite current char 
119e					 
119e			 
119e			 
119e			 
119e					ld a, (input_cursor) 
119e					inc  a 		; TODO check overflow 
119e					ld (input_cursor), a 
119e			 
119e					ld a, (input_at_cursor) 
119e					inc a 
119e					ld (input_at_cursor), a 
119e			 
119e					jp .is1 
119e			 
119e			.endinput:	; TODO look for end of string 
119e			 
119e					; add trailing space for end of token 
119e			 
119e					ld hl, (input_start) 
119e					ld a,(input_len) 
119e					call addatohl 
119e					ld a, ' ' 
119e					ld (hl),a 
119e					; TODO eof of parse marker 
119e			 
119e					inc hl 
119e					ld a, 0 
119e					ld (hl),a 
119e			 
119e			 
119e					ret 
119e			 
119e			.iblank: db " ",0 
119e			 
119e			 
119e			input_str_prev:	ld (input_at_pos), a 
119e					ld (input_start), hl 
119e					ld a,1			; add cursor 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e					ld (input_ptr), hl 
119e					ld a,d 
119e					ld (input_size), a 
119e					ld a,0 
119e					ld (input_cursor),a 
119e			.instr1:	 
119e			 
119e					; TODO do block cursor 
119e					; TODO switch cursor depending on the modifer key 
119e			 
119e					; update cursor shape change on key hold 
119e			 
119e					ld hl, (input_ptr) 
119e					dec hl 
119e					ld a,(cursor_shape) 
119e					ld (hl), a 
119e			 
119e					; display entered text 
119e					ld a,(input_at_pos) 
119e			            	CALL fLCD_Pos       ;Position cursor to location in A 
119e			            	LD   de, (input_start) 
119e			            	CALL fLCD_Str       ;Display string pointed to by DE 
119e			 
119e					call cin 
119e			;		cp 0 
119e					or a 
119e					jr z, .instr1 
119e			 
119e					; proecess keyboard controls first 
119e			 
119e					ld hl,(input_ptr) 
119e			 
119e					cp KEY_CR	 ; pressing enter ends input 
119e					jr z, .instrcr 
119e			 
119e					cp KEY_BS 	; back space 
119e					jr nz, .instr2 
119e					; process back space 
119e			 
119e					; TODO stop back space if at start of string 
119e					dec hl 
119e					dec hl ; to over write cursor 
119e					ld a,(cursor_shape) 
119e					;ld a,0 
119e					ld (hl),a 
119e					inc hl 
119e					ld a," " 
119e					ld (hl),a 
119e					ld (input_ptr),hl 
119e					 
119e			 
119e					jr .instr1 
119e			 
119e			.instr2:	cp KEY_LEFT    ; cursor left 
119e					jr nz, .instr3 
119e					dec hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e				 
119e			.instr3:	cp KEY_RIGHT      ; cursor right 
119e					jr nz, .instr4 
119e					inc hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e			 
119e			.instr4:	cp KEY_HOME    ; jump to start of line 
119e					jr nz, .instr5 
119e					dec hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e			 
119e			.instr5:	cp KEY_END     ; jump to end of line 
119e					jr nz, .instr6 
119e					dec hl 
119e					ld (input_ptr),hl 
119e					jr .instr1 
119e			.instr6:        cp KEY_UP      ; recall last command 
119e					jr nz, .instrnew 
119e			 
119e				ld hl, scratch 
119e				ld de, os_last_cmd 
119e				call strcpy 
119e					jr .instr1 
119e			 
119e			 
119e			.instrnew:	; no special key pressed to see if we have room to store it 
119e			 
119e					; TODO do string size test 
119e			 
119e					dec hl ; to over write cursor 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,(cursor_shape) 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e			 
119e					ld (input_ptr),hl 
119e					 
119e					jr .instr1 
119e			.instrcr:	dec hl		; remove cursor 
119e					ld a,' '	; TODO add a trailing space for safety 
119e					ld (hl),a 
119e					inc hl 
119e					ld a,0 
119e					ld (hl),a 
119e			 
119e			 
119e					; if at end of line scroll up    
119e					; TODO detecting only end of line 4 for scroll up  
119e			 
119e					;ld   
119e			 
119e					ret 
119e			 
119e			 
119e			endif 
119e			; strcpy hl = dest, de source 
119e			 
119e 1a			strcpy:   LD   A, (DE)        ;Get character from string 
119f b7			            OR   A              ;Null terminator? 
11a0 c8			            RET  Z              ;Yes, so finished 
11a1 1a					ld a,(de) 
11a2 77					ld (hl),a 
11a3 13			            INC  DE             ;Point to next character 
11a4 23					inc hl 
11a5 18 f7		            JR   strcpy       ;Repeat 
11a7 c9					ret 
11a8			 
11a8			 
11a8			; TODO string_at  
11a8			; pass string which starts with lcd offset address and then null term string 
11a8			 
11a8			; TODO string to dec 
11a8			; TODO string to hex 
11a8			; TODO byte to string hex 
11a8			; TODO byte to string dec 
11a8			 
11a8			 
11a8			 
11a8			; from z80uartmonitor 
11a8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11a8			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
11a8			; pass hl for where to put the text 
11a8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11a8 c5			hexout:	PUSH BC 
11a9 f5					PUSH AF 
11aa 47					LD B, A 
11ab					; Upper nybble 
11ab cb 3f				SRL A 
11ad cb 3f				SRL A 
11af cb 3f				SRL A 
11b1 cb 3f				SRL A 
11b3 cd c3 11				CALL tohex 
11b6 77					ld (hl),a 
11b7 23					inc hl	 
11b8					 
11b8					; Lower nybble 
11b8 78					LD A, B 
11b9 e6 0f				AND 0FH 
11bb cd c3 11				CALL tohex 
11be 77					ld (hl),a 
11bf 23					inc hl	 
11c0					 
11c0 f1					POP AF 
11c1 c1					POP BC 
11c2 c9					RET 
11c3					 
11c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11c3			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
11c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
11c3			tohex: 
11c3 e5					PUSH HL 
11c4 d5					PUSH DE 
11c5 16 00				LD D, 0 
11c7 5f					LD E, A 
11c8 21 d0 11				LD HL, .DATA 
11cb 19					ADD HL, DE 
11cc 7e					LD A, (HL) 
11cd d1					POP DE 
11ce e1					POP HL 
11cf c9					RET 
11d0			 
11d0			.DATA: 
11d0 30					DEFB	30h	; 0 
11d1 31					DEFB	31h	; 1 
11d2 32					DEFB	32h	; 2 
11d3 33					DEFB	33h	; 3 
11d4 34					DEFB	34h	; 4 
11d5 35					DEFB	35h	; 5 
11d6 36					DEFB	36h	; 6 
11d7 37					DEFB	37h	; 7 
11d8 38					DEFB	38h	; 8 
11d9 39					DEFB	39h	; 9 
11da 41					DEFB	41h	; A 
11db 42					DEFB	42h	; B 
11dc 43					DEFB	43h	; C 
11dd 44					DEFB	44h	; D 
11de 45					DEFB	45h	; E 
11df 46					DEFB	46h	; F 
11e0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
11e0			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
11e0			;;    subtract $30, if result > 9 then subtract $7 more 
11e0			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
11e0			atohex: 
11e0 d6 30				SUB $30 
11e2 fe 0a				CP 10 
11e4 f8					RET M		; If result negative it was 0-9 so we're done 
11e5 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
11e7 c9					RET		 
11e8			 
11e8			 
11e8			 
11e8			 
11e8			; Get 2 ASCII characters as hex byte from pointer in hl 
11e8			 
11e8			BYTERD: 
11e8 16 00			LD	D,00h		;Set up 
11ea cd f2 11			CALL	HEXCON		;Get byte and convert to hex 
11ed 87				ADD	A,A		;First nibble so 
11ee 87				ADD	A,A		;multiply by 16 
11ef 87				ADD	A,A		; 
11f0 87				ADD	A,A		; 
11f1 57				LD	D,A		;Save hi nibble in D 
11f2			HEXCON: 
11f2 7e				ld a, (hl)		;Get next chr 
11f3 23				inc hl 
11f4 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
11f6 fe 0a			CP	00Ah		;Is it 0-9 ? 
11f8 38 02			JR	C,NALPHA	;If so miss next bit 
11fa d6 07			SUB	007h		;Else convert alpha 
11fc			NALPHA: 
11fc b2				OR	D		;Add hi nibble back 
11fd c9				RET			; 
11fe			 
11fe			 
11fe			; 
11fe			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
11fe			; Since the routines get_byte and therefore get_nibble are called, only valid 
11fe			; characters (0-9a-f) are accepted. 
11fe			; 
11fe			;get_word        push    af 
11fe			;                call    get_byte        ; Get the upper byte 
11fe			;                ld      h, a 
11fe			;                call    get_byte        ; Get the lower byte 
11fe			;                ld      l, a 
11fe			;                pop     af 
11fe			;                ret 
11fe			; 
11fe			; Get a byte in hexadecimal notation. The result is returned in A. Since 
11fe			; the routine get_nibble is used only valid characters are accepted - the  
11fe			; input routine only accepts characters 0-9a-f. 
11fe			; 
11fe c5			get_byte:        push    bc              ; Save contents of B (and C) 
11ff 7e					ld a,(hl) 
1200 23					inc hl 
1201 cd 26 12		                call    nibble2val      ; Get upper nibble 
1204 cb 07		                rlc     a 
1206 cb 07		                rlc     a 
1208 cb 07		                rlc     a 
120a cb 07		                rlc     a 
120c 47			                ld      b, a            ; Save upper four bits 
120d 7e					ld a,(hl) 
120e cd 26 12		                call    nibble2val      ; Get lower nibble 
1211 b0			                or      b               ; Combine both nibbles 
1212 c1			                pop     bc              ; Restore B (and C) 
1213 c9			                ret 
1214			; 
1214			; Get a hexadecimal digit from the serial line. This routine blocks until 
1214			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
1214			; to the serial line interface. The lower 4 bits of A contain the value of  
1214			; that particular digit. 
1214			; 
1214			;get_nibble      ld a,(hl)           ; Read a character 
1214			;                call    to_upper        ; Convert to upper case 
1214			;                call    is_hex          ; Was it a hex digit? 
1214			;                jr      nc, get_nibble  ; No, get another character 
1214			 ;               call    nibble2val      ; Convert nibble to value 
1214			 ;               call    print_nibble 
1214			 ;               ret 
1214			; 
1214			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
1214			; A valid hexadecimal digit is denoted by a set C flag. 
1214			; 
1214			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
1214			;                ret     nc              ; Yes 
1214			;                cp      '0'             ; Less than '0'? 
1214			;                jr      nc, is_hex_1    ; No, continue 
1214			;                ccf                     ; Complement carry (i.e. clear it) 
1214			;                ret 
1214			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
1214			;                ret     c               ; Yes 
1214			;                cp      'A'             ; Less than 'A'? 
1214			;                jr      nc, is_hex_2    ; No, continue 
1214			;                ccf                     ; Yes - clear carry and return 
1214			;                ret 
1214			;is_hex_2        scf                     ; Set carry 
1214			;                ret 
1214			; 
1214			; Convert a single character contained in A to upper case: 
1214			; 
1214 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
1216 d8			                ret     c 
1217 fe 7b		                cp      'z' + 1         ; > 'z'? 
1219 d0			                ret     nc              ; Nothing to do, either 
121a e6 5f		                and     $5f             ; Convert to upper case 
121c c9			                ret 
121d			 
121d			 
121d			to_lower: 
121d			 
121d			   ; if char is in [A-Z] make it lower case 
121d			 
121d			   ; enter : a = char 
121d			   ; exit  : a = lower case char 
121d			   ; uses  : af 
121d			 
121d fe 41		   cp 'A' 
121f d8			   ret c 
1220			    
1220 fe 5b		   cp 'Z'+1 
1222 d0			   ret nc 
1223			    
1223 f6 20		   or $20 
1225 c9			   ret 
1226			 
1226			; 
1226			; Expects a hexadecimal digit (upper case!) in A and returns the 
1226			; corresponding value in A. 
1226			; 
1226 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1228 38 02		                jr      c, nibble2val_1 ; Yes 
122a d6 07		                sub     7               ; Adjust for A-F 
122c d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
122e e6 0f		                and     $f              ; Only return lower 4 bits 
1230 c9			                ret 
1231			; 
1231			; Print_nibble prints a single hex nibble which is contained in the lower  
1231			; four bits of A: 
1231			; 
1231			;print_nibble    push    af              ; We won't destroy the contents of A 
1231			;                and     $f              ; Just in case... 
1231			;                add     a, '0'             ; If we have a digit we are done here. 
1231			;                cp      '9' + 1         ; Is the result > 9? 
1231			;                jr      c, print_nibble_1 
1231			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1231			;print_nibble_1  call    putc            ; Print the nibble and 
1231			;                pop     af              ; restore the original value of A 
1231			;                ret 
1231			;; 
1231			;; Send a CR/LF pair: 
1231			; 
1231			;crlf            push    af 
1231			;                ld      a, cr 
1231			;                call    putc 
1231			;                ld      a, lf 
1231			;                call    putc 
1231			;                pop     af 
1231			;                ret 
1231			; 
1231			; Print_word prints the four hex digits of a word to the serial line. The  
1231			; word is expected to be in HL. 
1231			; 
1231			;print_word      push    hl 
1231			;                push    af 
1231			;                ld      a, h 
1231			;                call    print_byte 
1231			;                ld      a, l 
1231			;                call    print_byte 
1231			;                pop     af 
1231			;                pop     hl 
1231			;                ret 
1231			; 
1231			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1231			; The byte to be printed is expected to be in A. 
1231			; 
1231			;print_byte      push    af              ; Save the contents of the registers 
1231			;                push    bc 
1231			;                ld      b, a 
1231			;                rrca 
1231			;                rrca 
1231			;                rrca 
1231			;                rrca 
1231			;                call    print_nibble    ; Print high nibble 
1231			;                ld      a, b 
1231			;                call    print_nibble    ; Print low nibble 
1231			;                pop     bc              ; Restore original register contents 
1231			;                pop     af 
1231			;                ret 
1231			 
1231			 
1231			 
1231			 
1231			 
1231			fourehexhl:  
1231 7e				ld a,(hl) 
1232 cd e0 11			call atohex 
1235 cb 3f				SRL A 
1237 cb 3f				SRL A 
1239 cb 3f				SRL A 
123b cb 3f				SRL A 
123d 47				ld b, a 
123e 23				inc hl 
123f 7e				ld a,(hl) 
1240 23				inc hl 
1241 cd e0 11			call atohex 
1244 80				add b 
1245 57				ld d,a 
1246 7e				ld a,(hl) 
1247 cd e0 11			call atohex 
124a cb 3f				SRL A 
124c cb 3f				SRL A 
124e cb 3f				SRL A 
1250 cb 3f				SRL A 
1252 47				ld b, a 
1253 23				inc hl 
1254 7e				ld a,(hl) 
1255 23				inc hl 
1256 cd e0 11			call atohex 
1259 80				add b 
125a 5f				ld e, a 
125b d5				push de 
125c e1				pop hl 
125d c9				ret 
125e			 
125e			; pass hl. returns z set if the byte at hl is a digit 
125e			;isdigithl:  
125e			;	push bc 
125e			;	ld a,(hl) 
125e			;	cp ':' 
125e			;	jr nc, .isdf 		; > 
125e			;	cp '0' 
125e			;	jr c, .isdf		; < 
125e			; 
125e			;	; TODO find a better way to set z 
125e			; 
125e			;	ld b,a 
125e			;	cp b 
125e			;	pop bc 
125e			;	ret 
125e			; 
125e			;.isdf:	; not digit so clear z 
125e			; 
125e			;	; TODO find a better way to unset z 
125e			; 
125e			;	ld b,a 
125e			;	inc b 
125e			;	cp b 
125e			; 
125e			;	pop bc 
125e			;	ret 
125e				 
125e				 
125e			 
125e			 
125e			; pass hl as the four byte address to load 
125e			 
125e			get_word_hl:  
125e e5				push hl 
125f cd fe 11			call get_byte 
1262				 
1262 47				ld b, a 
1263			 
1263 e1				pop hl 
1264 23				inc hl 
1265 23				inc hl 
1266			 
1266			; TODO not able to handle a-f  
1266 7e				ld a,(hl) 
1267			;	;cp ':' 
1267			;	cp 'g' 
1267			;	jr nc, .single_byte_hl 		; > 
1267			;	cp 'G' 
1267			;	jr nc, .single_byte_hl 		; > 
1267			;	cp '0' 
1267			;	jr c, .single_byte_hl		; < 
1267			 
1267				;call isdigithl 
1267			;	cp 0 
1267 b7				or a 
1268 28 06			jr z, .single_byte_hl 
126a			 
126a			.getwhln:   ; hex word so get next byte 
126a			 
126a cd fe 11			call get_byte 
126d 6f				ld l, a 
126e 60				ld h,b 
126f c9				ret 
1270 68			.single_byte_hl:   ld l,b 
1271 26 00				ld h,0 
1273 c9					ret 
1274			 
1274			 
1274			 
1274			 
1274 21 de 1c			ld hl,asc+1 
1277			;	ld a, (hl) 
1277			;	call nibble2val 
1277 cd fe 11			call get_byte 
127a			 
127a			;	call fourehexhl 
127a 32 27 f1			ld (scratch+52),a 
127d				 
127d 21 25 f1			ld hl,scratch+50 
1280 22 16 f4			ld (os_cur_ptr),hl 
1283			 
1283 c9				ret 
1284			 
1284			 
1284			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1284			 
1284			; Decimal Unsigned Version 
1284			 
1284			;Number in a to decimal ASCII 
1284			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1284			;Example: display a=56 as "056" 
1284			;input: a = number 
1284			;Output: a=0,value of a in the screen 
1284			;destroys af,bc (don't know about hl and de) 
1284			DispAToASCII: 
1284 0e 9c			ld	c,-100 
1286 cd 90 12			call	.Na1 
1289 0e f6			ld	c,-10 
128b cd 90 12			call	.Na1 
128e 0e ff			ld	c,-1 
1290 06 2f		.Na1:	ld	b,'0'-1 
1292 04			.Na2:	inc	b 
1293 81				add	a,c 
1294 38 fc			jr	c,.Na2 
1296 91				sub	c		;works as add 100/10/1 
1297 f5				push af		;safer than ld c,a 
1298 78				ld	a,b		;char is in b 
1299			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1299 f1				pop af		;safer than ld a,c 
129a c9				ret 
129b			 
129b			; Decimal Signed Version 
129b			 
129b			; DispA 
129b			; -------------------------------------------------------------- 
129b			; Converts a signed integer value to a zero-terminated ASCII 
129b			; string representative of that value (using radix 10). 
129b			; -------------------------------------------------------------- 
129b			; INPUTS: 
129b			;     HL     Value to convert (two's complement integer). 
129b			;     DE     Base address of string destination. (pointer). 
129b			; -------------------------------------------------------------- 
129b			; OUTPUTS: 
129b			;     None 
129b			; -------------------------------------------------------------- 
129b			; REGISTERS/MEMORY DESTROYED 
129b			; AF HL 
129b			; -------------------------------------------------------------- 
129b			 
129b			;DispHLToASCII: 
129b			;   push    de 
129b			;   push    bc 
129b			; 
129b			;; Detect sign of HL. 
129b			;    bit    7, h 
129b			;    jr     z, ._DoConvert 
129b			; 
129b			;; HL is negative. Output '-' to string and negate HL. 
129b			;    ld     a, '-' 
129b			;    ld     (de), a 
129b			;    inc    de 
129b			; 
129b			;; Negate HL (using two's complement) 
129b			;    xor    a 
129b			;    sub    l 
129b			;    ld     l, a 
129b			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
129b			;    sbc    a, h 
129b			;    ld     h, a 
129b			; 
129b			;; Convert HL to digit characters 
129b			;._DoConvert: 
129b			;    ld     b, 0     ; B will count character length of number 
129b			;-   ld     a, 10 
129b			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
129b			;    push   af 
129b			;    inc    b 
129b			;    ld     a, h 
129b			;    or     l 
129b			;    jr     nz, - 
129b			; 
129b			;; Retrieve digits from stack 
129b			;-   pop    af 
129b			;    or     $30 
129b			;    ld     (de), a 
129b			;    inc    de 
129b			;    djnz   - 
129b			; 
129b			;; Terminate string with NULL 
129b			;    xor    a 
129b			;    ld     (de), a 
129b			; 
129b			;    pop    bc 
129b			;    pop    de 
129b			;    ret 
129b			 
129b			;Comments 
129b			; 
129b			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
129b			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
129b			;    Note that the output string will not be fixed-width. 
129b			; 
129b			;Example Usage 
129b			; 
129b			;    ld    hl, -1004 
129b			;    ld    de, OP1 
129b			;    call  DispA 
129b			;    ld    hl, OP1 
129b			;    syscall  PutS 
129b			 
129b			 
129b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
129b			 
129b			 
129b			;Converts an ASCII string to an unsigned 16-bit integer 
129b			;Quits when it reaches a non-decimal digit 
129b			 
129b			string_to_uint16: 
129b			atoui_16: 
129b			;Input: 
129b			;     DE points to the string 
129b			;Outputs: 
129b			;     HL is the result 
129b			;     A is the 8-bit value of the number 
129b			;     DE points to the byte after the number 
129b			;Destroys: 
129b			;     BC 
129b			;       if the string is non-empty, BC is HL/10 
129b			;Size:  24 bytes 
129b			;Speed: 42+d(104+{0,9}) 
129b			;       d is the number of digits in the number 
129b			;       max is 640 cycles for a 5 digit number 
129b			;Assuming no leading zeros: 
129b			;1 digit:  146cc 
129b			;2 digit:  250cc 
129b			;3 digit:  354cc or 363cc (avg: 354.126cc) 
129b			;4 digit:  458cc or 467cc (avg: 458.27cc) 
129b			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
129b			;avg: 544.81158447265625cc (544+13297/16384) 
129b			;=============================================================== 
129b 21 00 00		  ld hl,0 
129e			.u16a: 
129e 1a			  ld a,(de) 
129f d6 30		  sub 30h 
12a1 fe 0a		  cp 10 
12a3 d0			  ret nc 
12a4 13			  inc de 
12a5 44			  ld b,h 
12a6 4d			  ld c,l 
12a7 29			  add hl,hl 
12a8 29			  add hl,hl 
12a9 09			  add hl,bc 
12aa 29			  add hl,hl 
12ab 85			  add a,l 
12ac 6f			  ld l,a 
12ad 30 ef		  jr nc,.u16a 
12af 24			  inc h 
12b0 c3 9e 12		  jp .u16a 
12b3			 
12b3			 
12b3			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
12b3			 
12b3			;written by Zeda 
12b3			;Converts a 16-bit unsigned integer to an ASCII string. 
12b3			 
12b3			uitoa_16: 
12b3			;Input: 
12b3			;   DE is the number to convert 
12b3			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
12b3			;Output: 
12b3			;   HL points to the null-terminated ASCII string 
12b3			;      NOTE: This isn't necessarily the same as the input HL. 
12b3 d5			  push de 
12b4 c5			  push bc 
12b5 f5			  push af 
12b6 eb			  ex de,hl 
12b7			 
12b7 01 f0 d8		  ld bc,-10000 
12ba 3e 2f		  ld a,'0'-1 
12bc 3c			  inc a 
12bd 09			  add hl,bc  
12be 38 fc		   jr c,$-2 
12c0 12			  ld (de),a 
12c1 13			  inc de 
12c2			 
12c2 01 e8 03		  ld bc,1000 
12c5 3e 3a		  ld a,'9'+1 
12c7 3d			  dec a  
12c8 09			  add hl,bc  
12c9 30 fc		   jr nc,$-2 
12cb 12			  ld (de),a 
12cc 13			  inc de 
12cd			 
12cd 01 9c ff		  ld bc,-100 
12d0 3e 2f		  ld a,'0'-1 
12d2 3c			  inc a  
12d3 09			  add hl,bc  
12d4 38 fc		   jr c,$-2 
12d6 12			  ld (de),a 
12d7 13			  inc de 
12d8			 
12d8 7d			  ld a,l 
12d9 26 3a		  ld h,'9'+1 
12db 25			  dec h  
12dc c6 0a		  add a,10  
12de 30 fb		   jr nc,$-3 
12e0 c6 30		  add a,'0' 
12e2 eb			  ex de,hl 
12e3 72			  ld (hl),d 
12e4 23			  inc hl 
12e5 77			  ld (hl),a 
12e6 23			  inc hl 
12e7 36 00		  ld (hl),0 
12e9			 
12e9			;Now strip the leading zeros 
12e9 0e fa		  ld c,-6 
12eb 09			  add hl,bc 
12ec 3e 30		  ld a,'0' 
12ee 23			  inc hl  
12ef be			  cp (hl)  
12f0 28 fc		  jr z,$-2 
12f2			 
12f2			;Make sure that the string is non-empty! 
12f2 7e			  ld a,(hl) 
12f3 b7			  or a 
12f4 20 01		  jr nz,.atoub 
12f6 2b			  dec hl 
12f7			.atoub: 
12f7			 
12f7 f1			  pop af 
12f8 c1			  pop bc 
12f9 d1			  pop de 
12fa c9			  ret 
12fb			 
12fb			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
12fb			 
12fb			toUpper: 
12fb			;A is the char. 
12fb			;If A is a lowercase letter, this sets it to the matching uppercase 
12fb			;18cc or 30cc or 41cc 
12fb			;avg: 26.75cc 
12fb fe 61		  cp 'a' 
12fd d8			  ret c 
12fe fe 7b		  cp 'z'+1 
1300 d0			  ret nc 
1301 d6 20		  sub 'a'-'A' 
1303 c9			  ret 
1304			 
1304			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1304			 
1304			; String Length 
1304			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1304			 
1304			; Get the length of the null-terminated string starting at $8000 hl 
1304			;    LD     HL, $8000 
1304			 
1304			strlenz: 
1304			 
1304 af			    XOR    A               ; Zero is the value we are looking for. 
1305 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1306 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1307			                           ; 65, 536 bytes (the entire addressable memory space). 
1307 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1309			 
1309			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1309 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
130a 6f			    LD     L, A             ; number of bytes 
130b ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
130d 2b			    DEC    HL              ; Compensate for null. 
130e c9				ret 
130f			 
130f			; Get the length of the A terminated string starting at $8000 hl 
130f			;    LD     HL, $8000 
130f			 
130f			strlent: 
130f			 
130f			                  ; A is the value we are looking for. 
130f 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
1311 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
1313			                           ; 65, 536 bytes (the entire addressable memory space). 
1313 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1315			 
1315			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1315 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1317 2e 00		    LD     L, 0             ; number of bytes 
1319 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
131b 2b			    DEC    HL              ; Compensate for null. 
131c c9				ret 
131d			 
131d			 
131d			;Comparing Strings 
131d			 
131d			;IN    HL     Address of string1. 
131d			;      DE     Address of string2. 
131d			 
131d			; doc given but wrong??? 
131d			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
131d			;      carry  Set if string1 > string2, reset if string1 <= string2. 
131d			; tested 
131d			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
131d			 
131d			strcmp_old: 
131d e5			    PUSH   HL 
131e d5			    PUSH   DE 
131f			 
131f 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1320 be			    CP     (HL)            ; (want to minimize work). 
1321 38 01		    JR     C, Str1IsBigger 
1323 7e			    LD     A, (HL) 
1324			 
1324			Str1IsBigger: 
1324 4f			    LD     C, A             ; Put length in BC 
1325 06 00		    LD     B, 0 
1327 13			    INC    DE              ; Increment pointers to meat of string. 
1328 23			    INC    HL 
1329			 
1329			CmpLoop: 
1329 1a			    LD     A, (DE)          ; Compare bytes. 
132a ed a1		    CPI 
132c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
132e 13			    INC    DE              ; Update pointer. 
132f ea 29 13		    JP     PE, CmpLoop 
1332			 
1332 d1			    POP    DE 
1333 e1			    POP    HL 
1334 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1335 be			    CP     (HL) 
1336 c9			    RET 
1337			 
1337			NoMatch: 
1337 2b			    DEC    HL 
1338 be			    CP     (HL)            ; Compare again to affect carry. 
1339 d1			    POP    DE 
133a e1			    POP    HL 
133b c9			    RET 
133c			 
133c			;; test strmp 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str2 
133c			;call strcmp 
133c			;jr z, .z1 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "NZ1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.z1: 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "ZZ1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str1 
133c			;call strcmp 
133c			;jr z, .z2 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "NZ2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.z2: 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "ZZ2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str2 
133c			;call strcmp 
133c			;jr c, .c1 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "Nc1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.c1: 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "cc1" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			; 
133c			;ld de, .str1 
133c			;ld hl, .str1 
133c			;call strcmp 
133c			;jr c, .c2 
133c			;;this 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "Nc2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;.c2: 
133c			; 
133c			;	if DEBUG_FORTH_WORDS 
133c			;		DMARK "cc2" 
133c			;		CALLMONITOR 
133c			;	endif 
133c			;	NEXTW 
133c			;.str1:   db "string1",0 
133c			;.str2:   db "string2",0 
133c			 
133c			; only care about direct match or not 
133c			; hl and de strings 
133c			; zero set if the same 
133c			 
133c			strcmp: 
133c 1a				ld a, (de) 
133d be				cp (hl) 
133e 28 02			jr z, .ssame 
1340 b7				or a 
1341 c9				ret 
1342			 
1342			.ssame:  
1342			;	cp 0 
1342 b7				or a 
1343 c8				ret z 
1344			 
1344 23				inc hl 
1345 13				inc de 
1346 18 f4			jr strcmp 
1348				 
1348				 
1348			 
1348			;Copyright (c) 2014, Luke Maurits 
1348			;All rights reserved. 
1348			; 
1348			;Redistribution and use in source and binary forms, with or without 
1348			;modification, are permitted provided that the following conditions are met: 
1348			; 
1348			;* Redistributions of source code must retain the above copyright notice, this 
1348			;  list of conditions and the following disclaimer. 
1348			; 
1348			;* Redistributions in binary form must reproduce the above copyright notice, 
1348			;  this list of conditions and the following disclaimer in the documentation 
1348			;  and/or other materials provided with the distribution. 
1348			; 
1348			;THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
1348			;AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
1348			;IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
1348			;DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
1348			;FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
1348			;DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
1348			;SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
1348			;CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
1348			;OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
1348			;OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
1348			 
1348			; https://github.com/lmaurits/lm512/blob/master/string.z80 
1348			 
1348			StrictStrCmp: 
1348				; Load next chars of each string 
1348 1a				ld a, (de) 
1349 47				ld b, a 
134a 7e				ld a, (hl) 
134b				; Compare 
134b b8				cp b 
134c				; Return non-zero if chars don't match 
134c c0				ret nz 
134d				; Check for end of both strings 
134d fe 00			cp "\0" 
134f				; Return if strings have ended 
134f c8				ret z 
1350				; Otherwise, advance to next chars 
1350 23				inc hl 
1351 13				inc de 
1352 18 f4			jr StrictStrCmp 
1354			 
1354			;end 
1354			; eof 
1354			 
1354			 
1354			 
1354			 
1354			 
1354			 
# End of file firmware_strings.asm
1354			include "firmware_memory.asm"   ; malloc and free  
1354			 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354			.mallocsize: db "Wants malloc >256",0 
1354			.mallocasize: db "MALLOC gives >256",0 
1354			.malloczero: db "MALLOC gives zero",0 
1354			 
1354			malloc_guard_zerolen: 
1354				push hl 
1354				push de 
1354				push af 
1354			 
1354				ld de, 0 
1354			        call cmp16 
1354				jr nz, .lowalloz 
1354			 
1354				push hl 
1354				push de 
1354					ld hl, display_fb0 
1354					ld (display_fb_active), hl 
1354				call clear_display 
1354				ld a, 0 
1354				ld de, .malloczero 
1354				call str_at_display 
1354				call update_display 
1354				call delay1s 
1354				call delay1s 
1354				call bp_on 
1354			;	ld a, 0 
1354			;	ld (os_view_disable), a 
1354			 
1354				pop de 
1354				pop hl 
1354			 
1354				 
1354			 
1354				CALLMONITOR 
1354			.lowalloz: 
1354			 
1354			 
1354				pop af 
1354				pop de 
1354				pop hl 
1354			ret 
1354			 
1354			malloc_guard_entry: 
1354				push hl 
1354				push de 
1354				push af 
1354			 
1354			 	or a      ;clear carry flag 
1354				push hl 
1354				ld de, 255 
1354				sbc hl, de 
1354				jr c, .lowalloc 
1354			 
1354				push de 
1354					ld hl, display_fb0 
1354					ld (display_fb_active), hl 
1354				call clear_display 
1354				ld a, 0 
1354				ld de, .mallocsize 
1354				call str_at_display 
1354				call update_display 
1354				call delay1s 
1354				call delay1s 
1354			;	ld a, 0 
1354			;	ld (os_view_disable), a 
1354				call bp_on 
1354			 
1354				pop de 
1354				pop hl 
1354			 
1354				 
1354			 
1354				CALLMONITOR 
1354				jr .lowdone 
1354			.lowalloc: 
1354			 
1354			 
1354				pop hl 
1354			.lowdone:	pop af 
1354				pop de 
1354				pop hl 
1354			ret 
1354			 
1354			malloc_guard_exit: 
1354				push hl 
1354				push de 
1354				push af 
1354			 
1354			 	or a      ;clear carry flag 
1354				push hl 
1354				ld de, 255 
1354				sbc hl, de 
1354				jr c, .lowallocx 
1354			 
1354				push de 
1354					ld hl, display_fb0 
1354					ld (display_fb_active), hl 
1354				call clear_display 
1354				ld a, 0 
1354				ld de, .mallocasize 
1354				call str_at_display 
1354				call update_display 
1354				call delay1s 
1354				call delay1s 
1354			;	ld a, 0 
1354			;	ld (os_view_disable), a 
1354				call bp_on 
1354				pop de 
1354				pop hl 
1354			 
1354				CALLMONITOR 
1354				jr .lowdonex 
1354			.lowallocx: 
1354			 
1354				pop hl 
1354			.lowdonex:	pop af 
1354				pop de 
1354				pop hl 
1354			ret 
1354			endif 
1354			 
1354			if MALLOC_2 
1354			; Z80 Malloc and Free Functions 
1354			 
1354			; Malloc Function: 
1354			; Input: 
1354			;   HL: Size of block to allocate 
1354			; Output: 
1354			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1354			 
1354			malloc: 
1354				 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354			call malloc_guard_entry 
1354			endif 
1354			 
1354			 
1354			 
1354			 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "mal" 
1354						CALLMONITOR 
1354					endif 
1354			    push af            ; Save AF register 
1354			    ld a, l            ; Load low byte of size into A 
1354			    or h               ; Check if size is zero 
1354			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1354			 
1354			    ; Allocate memory 
1354			    ld hl, (heap_start) ; Load start of heap into HL 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "ma1" 
1354						CALLMONITOR 
1354					endif 
1354			    call malloc_internal ; Call internal malloc function 
1354			    pop af             ; Restore AF register 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret                ; Return 
1354			 
1354			; Free Function: 
1354			; Input: 
1354			;   HL: Pointer to memory block to free 
1354			; Output: 
1354			;   None 
1354			 
1354			free: 
1354			    push af            ; Save AF register 
1354			    ld a, l            ; Load low byte of pointer into A 
1354			    or h               ; Check if pointer is NULL 
1354			    jp z, free_exit    ; If pointer is NULL, exit 
1354			 
1354			    ; Free memory 
1354			    ld hl, (heap_start) ; Load start of heap into HL 
1354			    call free_internal  ; Call internal free function 
1354			    pop af             ; Restore AF register 
1354			    ret                ; Return 
1354			 
1354			; Internal Malloc Function: 
1354			; Input: 
1354			;   HL: Size of block to allocate 
1354			; Output: 
1354			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1354			 
1354			malloc_internal: 
1354			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1354			    add hl, bc         ; Add management overhead to requested size 
1354			    ex de, hl          ; Save total size in DE, and keep it in HL 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "ma2" 
1354						CALLMONITOR 
1354					endif 
1354			 
1354			    ; Search for free memory block 
1354			    ld de, (heap_end)  ; Load end of heap into DE 
1354			    ld bc, 0           ; Initialize counter 
1354			 
1354					if DEBUG_FORTH_MALLOC 
1354						DMARK "ma2" 
1354						CALLMONITOR 
1354					endif 
1354			malloc_search_loop: 
1354			    ; Check if current block is free 
1354			    ld a, (hl)         ; Load current block's status (free or used) 
1354			;    cp 0               ; Compare with zero (free) 
1354				or a 
1354			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1354			 
1354			    ; Check if current block is large enough 
1354			    ld a, (hl+1)       ; Load high byte of block size 
1354			    cp l               ; Compare with low byte of requested size 
1354			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1354			 
1354			    ld a, (hl+2)       ; Load low byte of block size 
1354			    cp h               ; Compare with high byte of requested size 
1354			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1354			 
1354			    ; Mark block as used 
1354			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1354			 
1354			    ; Calculate remaining space in block 
1354			    ld bc, 0           ; Clear BC 
1354			    add hl, bc         ; Increment HL to point to start of data block 
1354			    add hl, de         ; HL = HL + DE (total size) 
1354			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1354			    add hl, bc         ; Add management overhead to start of data block 
1354			 
1354			    ; Save pointer to allocated block in HL 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354						DMARK "ma5" 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret 
1354			 
1354			malloc_skip_block_check: 
1354			    ; Move to the next block 
1354			    ld bc, 3           ; Size of management overhead 
1354			    add hl, bc         ; Move to the next block 
1354			    inc de             ; Increment counter 
1354			 
1354			    ; Check if we have reached the end of heap 
1354			    ld a, e            ; Load low byte of heap end address 
1354			    cp (hl)            ; Compare with low byte of current address 
1354			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1354			    ld a, d            ; Load high byte of heap end address 
1354			;    cp 0               ; Check if it's zero (end of memory) 
1354				or a 
1354			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1354			 
1354			    ; If we reached here, allocation failed 
1354			    xor a              ; Set result to NULL 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354						DMARK "ma6" 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret 
1354			malloc_exit: 
1354			if DEBUG_FORTH_MALLOC_HIGH 
1354						DMARK "ma7" 
1354			call malloc_guard_exit 
1354			call malloc_guard_zerolen 
1354			endif 
1354			    ret 
1354			 
1354			; Internal Free Function: 
1354			; Input: 
1354			;   HL: Pointer to memory block to free 
1354			; Output: 
1354			;   None 
1354			 
1354			free_internal: 
1354			    ld de, (heap_start) ; Load start of heap into DE 
1354			    ld bc, 0            ; Initialize counter 
1354			 
1354			free_search_loop: 
1354			    ; Check if current block contains the pointer 
1354			    ld a, l             ; Load low byte of pointer 
1354			    cp (hl+1)           ; Compare with high byte of current block's address 
1354			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1354			    ld a, h             ; Load high byte of pointer 
1354			    cp (hl+2)           ; Compare with low byte of current block's address 
1354			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1354			 
1354			    ; Mark block as free 
1354			    ld (hl), 0          ; Set status byte to indicate free block 
1354			    ret                 ; Return 
1354			 
1354			free_skip_block_check: 
1354			    ; Move to the next block 
1354			    ld bc, 3            ; Size of management overhead 
1354			    add hl, bc          ; Move to the next block 
1354			    inc de              ; Increment counter 
1354			 
1354			    ; Check if we have reached the end of heap 
1354			    ld a, e             ; Load low byte of heap end address 
1354			    cp (hl)             ; Compare with low byte of current address 
1354			    jr nz, free_search_loop  ; If not equal, continue searching 
1354			    ld a, d             ; Load high byte of heap end address 
1354			;    cp 0                ; Check if it's zero (end of memory) 
1354				or a 
1354			    jr nz, free_search_loop  ; If not zero, continue searching 
1354			 
1354			    ; If we reached here, pointer is not found in heap 
1354			    ret 
1354			 
1354			free_exit: 
1354			    ret                 ; Return 
1354			 
1354			; Define heap start and end addresses 
1354			;heap_start:    .dw 0xC000   ; Start of heap 
1354			;heap_end:      .dw 0xE000   ; End of heap 
1354			 
1354			endif 
1354			 
1354			 
1354			if MALLOC_1 
1354			 
1354			 
1354			 
1354			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1354			 
1354			;moved to firmware.asm 
1354			;heap_start        .equ  0x9000      ; Starting address of heap 
1354			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1354			 
1354			;      .org 0 
1354			;      jp    main 
1354			 
1354			 
1354			;      .org  0x100 
1354			;main: 
1354			;      ld    HL, 0x8100 
1354			;      ld    SP, HL 
1354			; 
1354			;      call  heap_init 
1354			; 
1354			;      ; Make some allocations 
1354			;      ld    HL, 12 
1354			;      call  malloc            ; Allocates 0x9004 
1354			; 
1354			;      ld    HL, 12 
1354			;      call  malloc            ; Allocates 0x9014 
1354			; 
1354			;      ld    HL, 12 
1354			;      call  malloc            ; Allocates 0x9024 
1354			; 
1354			;      ; Free some allocations 
1354			;      ld    HL, 0x9014 
1354			;      call  free 
1354			; 
1354			;      ld    HL, 0x9004 
1354			;      call  free 
1354			; 
1354			;      ld    HL, 0x9024 
1354			;      call  free 
1354			; 
1354			; 
1354			;      halt 
1354			 
1354			 
1354			;------------------------------------------------------------------------------ 
1354			;     heap_init                                                               : 
1354			;                                                                             : 
1354			; Description                                                                 : 
1354			;     Initialise the heap and make it ready for malloc and free operations.   : 
1354			;                                                                             : 
1354			;     The heap is maintained as a linked list, starting with an initial       : 
1354			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1354			;     the first free block in the heap. Each block then points to the next    : 
1354			;     free block within the heap, and the free list ends at the first block   : 
1354			;     with a null pointer to the next free block.                             : 
1354			;                                                                             : 
1354			; Parameters                                                                  : 
1354			;     Inputs are compile-time only. Two defines which specify the starting    : 
1354			;     address of the heap and its size are required, along with a memory      : 
1354			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1354			;     principally stores a pointer to the first free block in the heap.       : 
1354			;                                                                             : 
1354			; Returns                                                                     : 
1354			;     Nothing                                                                 : 
1354			;------------------------------------------------------------------------------ 
1354			heap_init: 
1354 e5			      push  HL 
1355			 
1355			      ; Initialise free list struct 
1355 21 0e 80		      ld    HL, heap_start 
1358 22 0a 80		      ld    (free_list), HL 
135b 21 00 00		      ld    HL, 0 
135e 22 0c 80		      ld    (free_list+2), HL 
1361			 
1361			      ; Insert first free block at bottom of heap, consumes entire heap 
1361 21 ca f0		      ld    HL, heap_start+heap_size-4 
1364 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
1367 21 bc 70		      ld    HL, heap_size-4 
136a 22 10 80		      ld    (heap_start+2), HL      ; Block size 
136d			 
136d			      ; Insert end of free list block at top of heap - two null words will 
136d			      ; terminate the free list 
136d 21 00 00		      ld    HL, 0 
1370 22 cc f0		      ld    (heap_start+heap_size-2), HL 
1373 22 ca f0		      ld    (heap_start+heap_size-4), HL 
1376			 
1376 e1			      pop   HL 
1377			 
1377 c9			      ret 
1378			 
1378			 
1378			;------------------------------------------------------------------------------ 
1378			;     malloc                                                                  : 
1378			;                                                                             : 
1378			; Description                                                                 : 
1378			;     Allocates the wanted space from the heap and returns the address of the : 
1378			;     first useable byte of the allocation.                                   : 
1378			;                                                                             : 
1378			;     Allocations can happen in one of two ways:                              : 
1378			;                                                                             : 
1378			;     1. A free block may be found which is the exact size wanted. In this    : 
1378			;        case the block is removed from the free list and retuedn to the      : 
1378			;        caller.                                                              : 
1378			;     2. A free block may be found which is larger than the size wanted. In   : 
1378			;        this case, the larger block is split into two. The first portion of  : 
1378			;        this block will become the requested space by the malloc call and    : 
1378			;        is returned to the caller. The second portion becomes a new free     : 
1378			;        block, and the free list is adjusted to maintain continuity via this : 
1378			;        newly created block.                                                 : 
1378			;                                                                             : 
1378			;     malloc does not set any initial value in the allocated space, the       : 
1378			;     caller is required to do this as required.                              : 
1378			;                                                                             : 
1378			;     This implementation of malloc uses the stack exclusively, and is        : 
1378			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1378			;     advisable to disable interrupts before calling malloc, and recommended  : 
1378			;     to avoid the use of malloc inside ISRs in general.                      : 
1378			;                                                                             : 
1378			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1378			;                                                                             : 
1378			; Parameters                                                                  : 
1378			;     HL  Number of bytes wanted                                              : 
1378			;                                                                             : 
1378			; Returns                                                                     : 
1378			;     HL  Address of the first useable byte of the allocation                 : 
1378			;                                                                             : 
1378			; Flags                                                                       : 
1378			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1378			;                                                                             : 
1378			; Stack frame                                                                 : 
1378			;       |             |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     BC      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     DE      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |     IX      |                                                       : 
1378			;       +-------------+                                                       : 
1378			;       |  prev_free  |                                                       : 
1378			;   +4  +-------------+                                                       : 
1378			;       |  this_free  |                                                       : 
1378			;   +2  +-------------+                                                       : 
1378			;       |  next_free  |                                                       : 
1378			;   +0  +-------------+                                                       : 
1378			;       |             |                                                       : 
1378			;                                                                             : 
1378			;------------------------------------------------------------------------------ 
1378			 
1378			 
1378			;malloc: 
1378			; 
1378			;	SAVESP ON 1 
1378			; 
1378			;	call malloc_code 
1378			; 
1378			;	CHECKSP ON 1 
1378			;	ret 
1378			 
1378			 
1378			malloc: 
1378 c5			      push  BC 
1379 d5			      push  DE 
137a dd e5		      push  IX 
137c			if DEBUG_FORTH_MALLOC_HIGH 
137c			call malloc_guard_entry 
137c			endif 
137c			 
137c					if DEBUG_FORTH_MALLOC 
137c						DMARK "mal" 
137c						CALLMONITOR 
137c					endif 
137c 7c			      ld    A, H                    ; Exit if no space requested 
137d b5			      or    L 
137e ca 3d 14		      jp    Z, malloc_early_exit 
1381			 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			; 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			;inc hl 
1381			 
1381			 
1381			 
1381			 
1381					if DEBUG_FORTH_MALLOC 
1381						DMARK "maA" 
1381						CALLMONITOR 
1381					endif 
1381			      ; Set up stack frame 
1381 eb			      ex    DE, HL 
1382 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1385 39			      add   HL, SP 
1386 f9			      ld    SP, HL 
1387 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
138b dd 39		      add   IX, SP 
138d			 
138d			      ; Setup initial state 
138d 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1390 19			      add   HL, DE 
1391			 
1391 44			      ld    B, H                    ; Move want to BC 
1392 4d			      ld    C, L 
1393			 
1393 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
1396 dd 75 04		      ld    (IX+4), L 
1399 dd 74 05		      ld    (IX+5), H 
139c			 
139c 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
139d 23			      inc   HL 
139e 56			      ld    D, (HL) 
139f dd 73 02		      ld    (IX+2), E 
13a2 dd 72 03		      ld    (IX+3), D 
13a5 eb			      ex    DE, HL                  ; this_free ptr into HL 
13a6			 
13a6					if DEBUG_FORTH_MALLOC 
13a6						DMARK "maB" 
13a6						CALLMONITOR 
13a6					endif 
13a6			      ; Loop through free block list to find some space 
13a6			malloc_find_space: 
13a6 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
13a7 23			      inc   HL 
13a8 56			      ld    D, (HL) 
13a9			 
13a9 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
13aa b3			      or    E 
13ab ca 37 14		      jp    Z, malloc_no_space 
13ae			 
13ae dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
13b1 dd 72 01		      ld    (IX+1), D 
13b4			 
13b4			      ; Does this block have enough space to make the allocation? 
13b4 23			      inc   HL                      ; Load free block size into DE 
13b5 5e			      ld    E, (HL) 
13b6 23			      inc   HL 
13b7 56			      ld    D, (HL) 
13b8			 
13b8 eb			      ex    DE, HL                  ; Check size of block against want 
13b9 b7			      or    A                       ; Ensure carry flag clear 
13ba ed 42		      sbc   HL, BC 
13bc e5			      push  HL                      ; Store the result for later (new block size) 
13bd			 
13bd ca 0c 14		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
13c0 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
13c2			 
13c2			      ; this_free block is not big enough, setup ptrs to test next free block 
13c2 e1			      pop   HL                      ; Discard previous result 
13c3			 
13c3 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
13c6 dd 66 03		      ld    H, (IX+3) 
13c9 dd 75 04		      ld    (IX+4), L 
13cc dd 74 05		      ld    (IX+5), H 
13cf			 
13cf dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
13d2 dd 66 01		      ld    H, (IX+1) 
13d5 dd 75 02		      ld    (IX+2), L 
13d8 dd 74 03		      ld    (IX+3), H 
13db			 
13db					if DEBUG_FORTH_MALLOC 
13db						DMARK "MA>" 
13db						CALLMONITOR 
13db					endif 
13db 18 c9		      jr    malloc_find_space 
13dd			 
13dd			      ; split a bigger block into two - requested size and remaining size 
13dd			malloc_alloc_split: 
13dd					if DEBUG_FORTH_MALLOC 
13dd						DMARK "MAs" 
13dd						CALLMONITOR 
13dd					endif 
13dd eb			      ex    DE, HL                  ; Calculate address of new free block 
13de 2b			      dec   HL 
13df 2b			      dec   HL 
13e0 2b			      dec   HL 
13e1 09			      add   HL, BC 
13e2			 
13e2			      ; Create a new block and point it at next_free 
13e2 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
13e5 dd 56 01		      ld    D, (IX+1) 
13e8			 
13e8 73			      ld    (HL), E                 ; Store next_free ptr into new block 
13e9 23			      inc   HL 
13ea 72			      ld    (HL), D 
13eb			 
13eb d1			      pop   DE                      ; Store size of new block into new block 
13ec 23			      inc   HL 
13ed 73			      ld    (HL), E 
13ee 23			      inc   HL 
13ef 72			      ld    (HL), D 
13f0			 
13f0			      ; Update this_free ptr to point to new block 
13f0 2b			      dec   HL 
13f1 2b			      dec   HL 
13f2 2b			      dec   HL 
13f3			 
13f3 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
13f6 dd 56 03		      ld    D, (IX+3) 
13f9			 
13f9 dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
13fc dd 74 03		      ld    (IX+3), H 
13ff			 
13ff			      ; Modify this_free block to be allocation 
13ff eb			      ex    DE, HL 
1400 af			      xor   A                       ; Null the next block ptr of allocated block 
1401 77			      ld    (HL), A 
1402 23			      inc   HL 
1403 77			      ld    (HL), A 
1404			 
1404 23			      inc   HL                      ; Store want size into allocated block 
1405 71			      ld    (HL), C 
1406 23			      inc   HL 
1407 70			      ld    (HL), B 
1408 23			      inc   HL 
1409 e5			      push  HL                      ; Address of allocation to return 
140a			 
140a 18 19		      jr    malloc_update_links 
140c			 
140c			malloc_alloc_fit: 
140c e1			      pop   HL                      ; Dont need new block size, want is exact fit 
140d			 
140d					if DEBUG_FORTH_MALLOC 
140d						DMARK "MAf" 
140d						CALLMONITOR 
140d					endif 
140d			      ; Modify this_free block to be allocation 
140d eb			      ex    DE, HL 
140e 2b			      dec   HL 
140f 2b			      dec   HL 
1410 2b			      dec   HL 
1411			 
1411 af			      xor   A                       ; Null the next block ptr of allocated block 
1412 77			      ld    (HL), A 
1413 23			      inc   HL 
1414 77			      ld    (HL), A 
1415			 
1415 23			      inc   HL                      ; Store address of allocation to return 
1416 23			      inc   HL 
1417 23			      inc   HL 
1418 e5			      push  HL 
1419			 
1419			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1419 dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
141c dd 66 01		      ld    H, (IX+1) 
141f			 
141f dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1422 dd 74 03		      ld    (IX+3), H 
1425			 
1425			 
1425			malloc_update_links: 
1425			      ; Update prev_free ptr to point to this_free 
1425 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1428 dd 66 05		      ld    H, (IX+5) 
142b			 
142b dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
142e dd 56 03		      ld    D, (IX+3) 
1431			 
1431 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1432 23			      inc   HL 
1433 72			      ld    (HL), D 
1434			 
1434					if DEBUG_FORTH_MALLOC 
1434						DMARK "Mul" 
1434						CALLMONITOR 
1434					endif 
1434			      ; Clear the Z flag to indicate successful allocation 
1434 7a			      ld    A, D 
1435 b3			      or    E 
1436			 
1436 d1			      pop   DE                      ; Address of allocation 
1437					if DEBUG_FORTH_MALLOC 
1437						DMARK "MAu" 
1437						CALLMONITOR 
1437					endif 
1437			 
1437			malloc_no_space: 
1437 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
143a 39			      add   HL, SP 
143b f9			      ld    SP, HL 
143c			 
143c eb			      ex    DE, HL                  ; Alloc addr into HL for return 
143d					if DEBUG_FORTH_MALLOC 
143d						DMARK "MAN" 
143d						CALLMONITOR 
143d					endif 
143d			 
143d			malloc_early_exit: 
143d					if DEBUG_FORTH_MALLOC 
143d						DMARK "MAx" 
143d						CALLMONITOR 
143d					endif 
143d dd e1		      pop   IX 
143f d1			      pop   DE 
1440 c1			      pop   BC 
1441			 
1441			if DEBUG_FORTH_MALLOC_HIGH 
1441			call malloc_guard_exit 
1441			call malloc_guard_zerolen 
1441			endif 
1441 c9			      ret 
1442			 
1442			 
1442			;------------------------------------------------------------------------------ 
1442			;     free                                                                    : 
1442			;                                                                             : 
1442			; Description                                                                 : 
1442			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1442			;     returned by malloc, otherwise the behaviour is undefined.               : 
1442			;                                                                             : 
1442			;     Where possible, directly adjacent free blocks will be merged together   : 
1442			;     into larger blocks to help ensure that the heap does not become         : 
1442			;     excessively fragmented.                                                 : 
1442			;                                                                             : 
1442			;     free does not clear or set any other value into the freed space, and    : 
1442			;     therefore its contents may be visible through subsequent malloc's. The  : 
1442			;     caller should clear the freed space as required.                        : 
1442			;                                                                             : 
1442			;     This implementation of free uses the stack exclusively, and is          : 
1442			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1442			;     advisable to disable interrupts before calling free, and recommended    : 
1442			;     to avoid the use of free inside ISRs in general.                        : 
1442			;                                                                             : 
1442			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1442			;                                                                             : 
1442			; Parameters                                                                  : 
1442			;     HL  Pointer to address of first byte of allocation to be freed          : 
1442			;                                                                             : 
1442			; Returns                                                                     : 
1442			;     Nothing                                                                 : 
1442			;                                                                             : 
1442			; Stack frame                                                                 : 
1442			;       |             |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |     BC      |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |     DE      |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |     IX      |                                                       : 
1442			;       +-------------+                                                       : 
1442			;       |  prev_free  |                                                       : 
1442			;   +2  +-------------+                                                       : 
1442			;       |  next_free  |                                                       : 
1442			;   +0  +-------------+                                                       : 
1442			;       |             |                                                       : 
1442			;                                                                             : 
1442			;------------------------------------------------------------------------------ 
1442			free: 
1442 c5			      push  BC 
1443 d5			      push  DE 
1444 dd e5		      push  IX 
1446			 
1446 7c			      ld    A, H                    ; Exit if ptr is null 
1447 b5			      or    L 
1448 ca 0c 15		      jp    Z, free_early_exit 
144b			 
144b			      ; Set up stack frame 
144b eb			      ex    DE, HL 
144c 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
144f 39			      add   HL, SP 
1450 f9			      ld    SP, HL 
1451 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1455 dd 39		      add   IX, SP 
1457			 
1457			      ; The address in HL points to the start of the useable allocated space, 
1457			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1457			      ; address of the block itself. 
1457 eb			      ex    DE, HL 
1458 11 fc ff		      ld    DE, -4 
145b 19			      add   HL, DE 
145c			 
145c			      ; An allocated block must have a null next block pointer in it 
145c 7e			      ld    A, (HL) 
145d 23			      inc   HL 
145e b6			      or    (HL) 
145f c2 07 15		      jp    NZ, free_done 
1462			 
1462 2b			      dec   HL 
1463			 
1463 44			      ld    B, H                    ; Copy HL to BC 
1464 4d			      ld    C, L 
1465			 
1465			      ; Loop through the free list to find the first block with an address 
1465			      ; higher than the block being freed 
1465 21 0a 80		      ld    HL, free_list 
1468			 
1468			free_find_higher_block: 
1468 5e			      ld    E, (HL)                 ; Load next ptr from free block 
1469 23			      inc   HL 
146a 56			      ld    D, (HL) 
146b 2b			      dec   HL 
146c			 
146c dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
146f dd 72 01		      ld    (IX+1), D 
1472 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
1475 dd 74 03		      ld    (IX+3), H 
1478			 
1478 78			      ld    A, B                    ; Check if DE is greater than BC 
1479 ba			      cp    D                       ; Compare MSB first 
147a 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
147c 30 04		      jr    NC, free_find_higher_block_skip 
147e 79			      ld    A, C 
147f bb			      cp    E                       ; Then compare LSB 
1480 38 08		      jr    C, free_found_higher_block 
1482			 
1482			free_find_higher_block_skip: 
1482 7a			      ld    A, D                    ; Reached the end of the free list? 
1483 b3			      or    E 
1484 ca 07 15		      jp    Z, free_done 
1487			 
1487 eb			      ex    DE, HL 
1488			 
1488 18 de		      jr    free_find_higher_block 
148a			 
148a			free_found_higher_block: 
148a			      ; Insert freed block between prev and next free blocks 
148a 71			      ld    (HL), C                 ; Point prev free block to freed block 
148b 23			      inc   HL 
148c 70			      ld    (HL), B 
148d			 
148d 60			      ld    H, B                    ; Point freed block at next free block 
148e 69			      ld    L, C 
148f 73			      ld    (HL), E 
1490 23			      inc   HL 
1491 72			      ld    (HL), D 
1492			 
1492			      ; Check if the freed block is adjacent to the next free block 
1492 23			      inc   HL                      ; Load size of freed block into HL 
1493 5e			      ld    E, (HL) 
1494 23			      inc   HL 
1495 56			      ld    D, (HL) 
1496 eb			      ex    DE, HL 
1497			 
1497 09			      add   HL, BC                  ; Add addr of freed block and its size 
1498			 
1498 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
149b dd 56 01		      ld    D, (IX+1) 
149e			 
149e b7			      or    A                       ; Clear the carry flag 
149f ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
14a1 20 22		      jr    NZ, free_check_adjacent_to_prev 
14a3			 
14a3			      ; Freed block is adjacent to next, merge into one bigger block 
14a3 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
14a4 5e			      ld    E, (HL) 
14a5 23			      inc   HL 
14a6 56			      ld    D, (HL) 
14a7 e5			      push  HL                      ; Save ptr to next block for later 
14a8			 
14a8 60			      ld    H, B                    ; Store ptr from next block into freed block 
14a9 69			      ld    L, C 
14aa 73			      ld    (HL), E 
14ab 23			      inc   HL 
14ac 72			      ld    (HL), D 
14ad			 
14ad e1			      pop   HL                      ; Restore ptr to next block 
14ae 23			      inc   HL                      ; Load size of next block into DE 
14af 5e			      ld    E, (HL) 
14b0 23			      inc   HL 
14b1 56			      ld    D, (HL) 
14b2 d5			      push  DE                      ; Save next block size for later 
14b3			 
14b3 60			      ld    H, B                    ; Load size of freed block into HL 
14b4 69			      ld    L, C 
14b5 23			      inc   HL 
14b6 23			      inc   HL 
14b7 5e			      ld    E, (HL) 
14b8 23			      inc   HL 
14b9 56			      ld    D, (HL) 
14ba eb			      ex    DE, HL 
14bb			 
14bb d1			      pop   DE                      ; Restore size of next block 
14bc 19			      add   HL, DE                  ; Add sizes of both blocks 
14bd eb			      ex    DE, HL 
14be			 
14be 60			      ld    H, B                    ; Store new bigger size into freed block 
14bf 69			      ld    L, C 
14c0 23			      inc   HL 
14c1 23			      inc   HL 
14c2 73			      ld    (HL), E 
14c3 23			      inc   HL 
14c4 72			      ld    (HL), D 
14c5			 
14c5			free_check_adjacent_to_prev: 
14c5			      ; Check if the freed block is adjacent to the prev free block 
14c5 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
14c8 dd 66 03		      ld    H, (IX+3) 
14cb			 
14cb 23			      inc   HL                      ; Size of prev free block into DE 
14cc 23			      inc   HL 
14cd 5e			      ld    E, (HL) 
14ce 23			      inc   HL 
14cf 56			      ld    D, (HL) 
14d0 2b			      dec   HL 
14d1 2b			      dec   HL 
14d2 2b			      dec   HL 
14d3			 
14d3 19			      add   HL, DE                  ; Add prev block addr and size 
14d4			 
14d4 b7			      or    A                       ; Clear the carry flag 
14d5 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
14d7 20 2e		      jr    NZ, free_done 
14d9			 
14d9			      ; Freed block is adjacent to prev, merge into one bigger block 
14d9 60			      ld    H, B                    ; Load next ptr from freed block into DE 
14da 69			      ld    L, C 
14db 5e			      ld    E, (HL) 
14dc 23			      inc   HL 
14dd 56			      ld    D, (HL) 
14de e5			      push  HL                      ; Save freed block ptr for later 
14df			 
14df dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
14e2 dd 66 03		      ld    H, (IX+3) 
14e5 73			      ld    (HL), E 
14e6 23			      inc   HL 
14e7 72			      ld    (HL), D 
14e8			 
14e8 e1			      pop   HL                      ; Restore freed block ptr 
14e9 23			      inc   HL                      ; Load size of freed block into DE 
14ea 5e			      ld    E, (HL) 
14eb 23			      inc   HL 
14ec 56			      ld    D, (HL) 
14ed d5			      push  DE                      ; Save freed block size for later 
14ee			 
14ee dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
14f1 dd 66 03		      ld    H, (IX+3) 
14f4 23			      inc   HL 
14f5 23			      inc   HL 
14f6 5e			      ld    E, (HL) 
14f7 23			      inc   HL 
14f8 56			      ld    D, (HL) 
14f9			 
14f9 e1			      pop   HL                      ; Add sizes of both blocks 
14fa 19			      add   HL, DE 
14fb eb			      ex    DE, HL 
14fc			 
14fc dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
14ff dd 66 03		      ld    H, (IX+3) 
1502 23			      inc   HL 
1503 23			      inc   HL 
1504 73			      ld    (HL), E 
1505 23			      inc   HL 
1506 72			      ld    (HL), D 
1507			 
1507			free_done: 
1507 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
150a 39			      add   HL, SP 
150b f9			      ld    SP, HL 
150c			 
150c			free_early_exit: 
150c dd e1		      pop   IX 
150e d1			      pop   DE 
150f c1			      pop   BC 
1510			 
1510 c9			      ret 
1511			 
1511			; moved to firmware.asm 
1511			; 
1511			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1511			;                  .dw   0 
1511			 
1511			 
1511			endif 
1511			 
1511			 
1511			if MALLOC_3 
1511			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1511			;heap_start        .equ  0x9000      ; Starting address of heap 
1511			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1511			; 
1511			 ;     .org 0 
1511			  ;    jp    main 
1511			; 
1511			; 
1511			 ;     .org  0x100 
1511			;main: 
1511			 ;     ld    HL, 0x8100 
1511			  ;    ld    SP, HL 
1511			; 
1511			;      call  heap_init 
1511			 
1511			      ; Make some allocations 
1511			;      ld    HL, 12 
1511			;      call  malloc            ; Allocates 0x9004 
1511			; 
1511			 ;     ld    HL, 12 
1511			;      call  malloc            ; Allocates 0x9014 
1511			 
1511			;      ld    HL, 12 
1511			;      call  malloc            ; Allocates 0x9024 
1511			 
1511			      ; Free some allocations 
1511			;      ld    HL, 0x9014 
1511			;      call  free 
1511			 
1511			;      ld    HL, 0x9004 
1511			;      call  free 
1511			; 
1511			;      ld    HL, 0x9024 
1511			;      call  free 
1511			 
1511			 
1511			 ;     halt 
1511			 
1511			 
1511			;------------------------------------------------------------------------------ 
1511			;     heap_init                                                               : 
1511			;                                                                             : 
1511			; Description                                                                 : 
1511			;     Initialise the heap and make it ready for malloc and free operations.   : 
1511			;                                                                             : 
1511			;     The heap is maintained as a linked list, starting with an initial       : 
1511			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1511			;     the first free block in the heap. Each block then points to the next    : 
1511			;     free block within the heap, and the free list ends at the first block   : 
1511			;     with a null pointer to the next free block.                             : 
1511			;                                                                             : 
1511			; Parameters                                                                  : 
1511			;     Inputs are compile-time only. Two defines which specify the starting    : 
1511			;     address of the heap and its size are required, along with a memory      : 
1511			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1511			;     principally stores a pointer to the first free block in the heap.       : 
1511			;                                                                             : 
1511			; Returns                                                                     : 
1511			;     Nothing                                                                 : 
1511			;------------------------------------------------------------------------------ 
1511			heap_init: 
1511			      push  HL 
1511			 
1511			      ; Initialise free list struct 
1511			      ld    HL, heap_start 
1511			      ld    (free_list), HL 
1511			      ld    HL, 0 
1511			      ld    (free_list+2), HL 
1511			 
1511			      ; Insert first free block at bottom of heap, consumes entire heap 
1511			      ld    HL, heap_start+heap_size-4 
1511			      ld    (heap_start), HL        ; Next block (end of free list) 
1511			      ld    HL, heap_size-4 
1511			      ld    (heap_start+2), HL      ; Block size 
1511			 
1511			      ; Insert end of free list block at top of heap - two null words will 
1511			      ; terminate the free list 
1511			      ld    HL, 0 
1511			      ld    (heap_start+heap_size-2), HL 
1511			      ld    (heap_start+heap_size-4), HL 
1511			 
1511			      pop   HL 
1511			 
1511			      ret 
1511			 
1511			 
1511			;------------------------------------------------------------------------------ 
1511			;     malloc                                                                  : 
1511			;                                                                             : 
1511			; Description                                                                 : 
1511			;     Allocates the wanted space from the heap and returns the address of the : 
1511			;     first useable byte of the allocation.                                   : 
1511			;                                                                             : 
1511			;     Allocations can happen in one of two ways:                              : 
1511			;                                                                             : 
1511			;     1. A free block may be found which is the exact size wanted. In this    : 
1511			;        case the block is removed from the free list and retuedn to the      : 
1511			;        caller.                                                              : 
1511			;     2. A free block may be found which is larger than the size wanted. In   : 
1511			;        this case, the larger block is split into two. The first portion of  : 
1511			;        this block will become the requested space by the malloc call and    : 
1511			;        is returned to the caller. The second portion becomes a new free     : 
1511			;        block, and the free list is adjusted to maintain continuity via this : 
1511			;        newly created block.                                                 : 
1511			;                                                                             : 
1511			;     malloc does not set any initial value in the allocated space, the       : 
1511			;     caller is required to do this as required.                              : 
1511			;                                                                             : 
1511			;     This implementation of malloc uses the stack exclusively, and is        : 
1511			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1511			;     advisable to disable interrupts before calling malloc, and recommended  : 
1511			;     to avoid the use of malloc inside ISRs in general.                      : 
1511			;                                                                             : 
1511			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1511			;                                                                             : 
1511			; Parameters                                                                  : 
1511			;     HL  Number of bytes wanted                                              : 
1511			;                                                                             : 
1511			; Returns                                                                     : 
1511			;     HL  Address of the first useable byte of the allocation                 : 
1511			;                                                                             : 
1511			; Flags                                                                       : 
1511			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1511			;                                                                             : 
1511			; Stack frame                                                                 : 
1511			;       |             |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     BC      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     DE      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     IX      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |  prev_free  |                                                       : 
1511			;   +4  +-------------+                                                       : 
1511			;       |  this_free  |                                                       : 
1511			;   +2  +-------------+                                                       : 
1511			;       |  next_free  |                                                       : 
1511			;   +0  +-------------+                                                       : 
1511			;       |             |                                                       : 
1511			;                                                                             : 
1511			;------------------------------------------------------------------------------ 
1511			malloc: 
1511			      push  BC 
1511			      push  DE 
1511			      push  IX 
1511			 
1511			      ld    A, H                    ; Exit if no space requested 
1511			      or    L 
1511			      jp    Z, malloc_early_exit 
1511			 
1511			      ; Set up stack frame 
1511			      ex    DE, HL 
1511			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			      ld    IX, 0                   ; Use IX as a frame pointer 
1511			      add   IX, SP 
1511			 
1511			      ; Setup initial state 
1511			      ld    HL, 4                   ; want must also include space used by block struct 
1511			      add   HL, DE 
1511			 
1511			      ld    B, H                    ; Move want to BC 
1511			      ld    C, L 
1511			 
1511			      ld    HL, free_list           ; Store prev_free ptr to stack 
1511			      ld    (IX+4), L 
1511			      ld    (IX+5), H 
1511			 
1511			      ld    E, (HL)                 ; Store this_free ptr to stack 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      ld    (IX+2), E 
1511			      ld    (IX+3), D 
1511			      ex    DE, HL                  ; this_free ptr into HL 
1511			 
1511			      ; Loop through free block list to find some space 
1511			malloc_find_space: 
1511			      ld    E, (HL)                 ; Load next_free ptr into DE 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			 
1511			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1511			      or    E 
1511			      jp    Z, malloc_no_space 
1511			 
1511			      ld    (IX+0), E               ; Store next_free ptr to stack 
1511			      ld    (IX+1), D 
1511			 
1511			      ; Does this block have enough space to make the allocation? 
1511			      inc   HL                      ; Load free block size into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			 
1511			      ex    DE, HL                  ; Check size of block against want 
1511			      or    A                       ; Ensure carry flag clear 
1511			      sbc   HL, BC 
1511			      push  HL                      ; Store the result for later (new block size) 
1511			 
1511			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1511			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1511			 
1511			      ; this_free block is not big enough, setup ptrs to test next free block 
1511			      pop   HL                      ; Discard previous result 
1511			 
1511			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1511			      ld    H, (IX+3) 
1511			      ld    (IX+4), L 
1511			      ld    (IX+5), H 
1511			 
1511			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1511			      ld    H, (IX+1) 
1511			      ld    (IX+2), L 
1511			      ld    (IX+3), H 
1511			 
1511			      jr    malloc_find_space 
1511			 
1511			      ; split a bigger block into two - requested size and remaining size 
1511			malloc_alloc_split: 
1511			      ex    DE, HL                  ; Calculate address of new free block 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			      add   HL, BC 
1511			 
1511			      ; Create a new block and point it at next_free 
1511			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1511			      ld    D, (IX+1) 
1511			 
1511			      ld    (HL), E                 ; Store next_free ptr into new block 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      pop   DE                      ; Store size of new block into new block 
1511			      inc   HL 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      ; Update this_free ptr to point to new block 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			 
1511			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1511			      ld    D, (IX+3) 
1511			 
1511			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1511			      ld    (IX+3), H 
1511			 
1511			      ; Modify this_free block to be allocation 
1511			      ex    DE, HL 
1511			      xor   A                       ; Null the next block ptr of allocated block 
1511			      ld    (HL), A 
1511			      inc   HL 
1511			      ld    (HL), A 
1511			 
1511			      inc   HL                      ; Store want size into allocated block 
1511			      ld    (HL), C 
1511			      inc   HL 
1511			      ld    (HL), B 
1511			      inc   HL 
1511			      push  HL                      ; Address of allocation to return 
1511			 
1511			      jr    malloc_update_links 
1511			 
1511			malloc_alloc_fit: 
1511			      pop   HL                      ; Dont need new block size, want is exact fit 
1511			 
1511			      ; Modify this_free block to be allocation 
1511			      ex    DE, HL 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			 
1511			      xor   A                       ; Null the next block ptr of allocated block 
1511			      ld    (HL), A 
1511			      inc   HL 
1511			      ld    (HL), A 
1511			 
1511			      inc   HL                      ; Store address of allocation to return 
1511			      inc   HL 
1511			      inc   HL 
1511			      push  HL 
1511			 
1511			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1511			      ld    L, (IX+0)               ; next_free to HL 
1511			      ld    H, (IX+1) 
1511			 
1511			      ld    (IX+2), L               ; HL to this_free 
1511			      ld    (IX+3), H 
1511			 
1511			 
1511			malloc_update_links: 
1511			      ; Update prev_free ptr to point to this_free 
1511			      ld    L, (IX+4)               ; prev_free ptr to HL 
1511			      ld    H, (IX+5) 
1511			 
1511			      ld    E, (IX+2)               ; this_free ptr to DE 
1511			      ld    D, (IX+3) 
1511			 
1511			      ld    (HL), E                 ; this_free ptr into prev_free 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      ; Clear the Z flag to indicate successful allocation 
1511			      ld    A, D 
1511			      or    E 
1511			 
1511			      pop   DE                      ; Address of allocation 
1511			 
1511			malloc_no_space: 
1511			      ld    HL, 6                   ; Clean up stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			 
1511			      ex    DE, HL                  ; Alloc addr into HL for return 
1511			 
1511			malloc_early_exit: 
1511			      pop   IX 
1511			      pop   DE 
1511			      pop   BC 
1511			 
1511			      ret 
1511			 
1511			 
1511			;------------------------------------------------------------------------------ 
1511			;     free                                                                    : 
1511			;                                                                             : 
1511			; Description                                                                 : 
1511			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1511			;     returned by malloc, otherwise the behaviour is undefined.               : 
1511			;                                                                             : 
1511			;     Where possible, directly adjacent free blocks will be merged together   : 
1511			;     into larger blocks to help ensure that the heap does not become         : 
1511			;     excessively fragmented.                                                 : 
1511			;                                                                             : 
1511			;     free does not clear or set any other value into the freed space, and    : 
1511			;     therefore its contents may be visible through subsequent malloc's. The  : 
1511			;     caller should clear the freed space as required.                        : 
1511			;                                                                             : 
1511			;     This implementation of free uses the stack exclusively, and is          : 
1511			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1511			;     advisable to disable interrupts before calling free, and recommended    : 
1511			;     to avoid the use of free inside ISRs in general.                        : 
1511			;                                                                             : 
1511			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1511			;                                                                             : 
1511			; Parameters                                                                  : 
1511			;     HL  Pointer to address of first byte of allocation to be freed          : 
1511			;                                                                             : 
1511			; Returns                                                                     : 
1511			;     Nothing                                                                 : 
1511			;                                                                             : 
1511			; Stack frame                                                                 : 
1511			;       |             |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     BC      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     DE      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |     IX      |                                                       : 
1511			;       +-------------+                                                       : 
1511			;       |  prev_free  |                                                       : 
1511			;   +2  +-------------+                                                       : 
1511			;       |  next_free  |                                                       : 
1511			;   +0  +-------------+                                                       : 
1511			;       |             |                                                       : 
1511			;                                                                             : 
1511			;------------------------------------------------------------------------------ 
1511			free: 
1511			      push  BC 
1511			      push  DE 
1511			      push  IX 
1511			 
1511			      ld    A, H                    ; Exit if ptr is null 
1511			      or    L 
1511			      jp    Z, free_early_exit 
1511			 
1511			      ; Set up stack frame 
1511			      ex    DE, HL 
1511			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			      ld    IX, 0                   ; Use IX as a frame pointer 
1511			      add   IX, SP 
1511			 
1511			      ; The address in HL points to the start of the useable allocated space, 
1511			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1511			      ; address of the block itself. 
1511			      ex    DE, HL 
1511			      ld    DE, -4 
1511			      add   HL, DE 
1511			 
1511			      ; An allocated block must have a null next block pointer in it 
1511			      ld    A, (HL) 
1511			      inc   HL 
1511			      or    (HL) 
1511			      jp    NZ, free_done 
1511			 
1511			      dec   HL 
1511			 
1511			      ld    B, H                    ; Copy HL to BC 
1511			      ld    C, L 
1511			 
1511			      ; Loop through the free list to find the first block with an address 
1511			      ; higher than the block being freed 
1511			      ld    HL, free_list 
1511			 
1511			free_find_higher_block: 
1511			      ld    E, (HL)                 ; Load next ptr from free block 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      dec   HL 
1511			 
1511			      ld    (IX+0), E               ; Save ptr to next free block 
1511			      ld    (IX+1), D 
1511			      ld    (IX+2), L               ; Save ptr to prev free block 
1511			      ld    (IX+3), H 
1511			 
1511			      ld    A, B                    ; Check if DE is greater than BC 
1511			      cp    D                       ; Compare MSB first 
1511			      jr    Z, $+4                  ; MSB the same, compare LSB 
1511			      jr    NC, free_find_higher_block_skip 
1511			      ld    A, C 
1511			      cp    E                       ; Then compare LSB 
1511			      jr    C, free_found_higher_block 
1511			 
1511			free_find_higher_block_skip: 
1511			      ld    A, D                    ; Reached the end of the free list? 
1511			      or    E 
1511			      jp    Z, free_done 
1511			 
1511			      ex    DE, HL 
1511			 
1511			      jr    free_find_higher_block 
1511			 
1511			free_found_higher_block: 
1511			      ; Insert freed block between prev and next free blocks 
1511			      ld    (HL), C                 ; Point prev free block to freed block 
1511			      inc   HL 
1511			      ld    (HL), B 
1511			 
1511			      ld    H, B                    ; Point freed block at next free block 
1511			      ld    L, C 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      ; Check if the freed block is adjacent to the next free block 
1511			      inc   HL                      ; Load size of freed block into HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      ex    DE, HL 
1511			 
1511			      add   HL, BC                  ; Add addr of freed block and its size 
1511			 
1511			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1511			      ld    D, (IX+1) 
1511			 
1511			      or    A                       ; Clear the carry flag 
1511			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1511			      jr    NZ, free_check_adjacent_to_prev 
1511			 
1511			      ; Freed block is adjacent to next, merge into one bigger block 
1511			      ex    DE, HL                  ; Load next ptr from next block into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  HL                      ; Save ptr to next block for later 
1511			 
1511			      ld    H, B                    ; Store ptr from next block into freed block 
1511			      ld    L, C 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      pop   HL                      ; Restore ptr to next block 
1511			      inc   HL                      ; Load size of next block into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  DE                      ; Save next block size for later 
1511			 
1511			      ld    H, B                    ; Load size of freed block into HL 
1511			      ld    L, C 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      ex    DE, HL 
1511			 
1511			      pop   DE                      ; Restore size of next block 
1511			      add   HL, DE                  ; Add sizes of both blocks 
1511			      ex    DE, HL 
1511			 
1511			      ld    H, B                    ; Store new bigger size into freed block 
1511			      ld    L, C 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			free_check_adjacent_to_prev: 
1511			      ; Check if the freed block is adjacent to the prev free block 
1511			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1511			      ld    H, (IX+3) 
1511			 
1511			      inc   HL                      ; Size of prev free block into DE 
1511			      inc   HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      dec   HL 
1511			      dec   HL 
1511			      dec   HL 
1511			 
1511			      add   HL, DE                  ; Add prev block addr and size 
1511			 
1511			      or    A                       ; Clear the carry flag 
1511			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1511			      jr    NZ, free_done 
1511			 
1511			      ; Freed block is adjacent to prev, merge into one bigger block 
1511			      ld    H, B                    ; Load next ptr from freed block into DE 
1511			      ld    L, C 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  HL                      ; Save freed block ptr for later 
1511			 
1511			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1511			      ld    H, (IX+3) 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			      pop   HL                      ; Restore freed block ptr 
1511			      inc   HL                      ; Load size of freed block into DE 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			      push  DE                      ; Save freed block size for later 
1511			 
1511			      ld    L, (IX+2)               ; Load size of prev block into DE 
1511			      ld    H, (IX+3) 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    E, (HL) 
1511			      inc   HL 
1511			      ld    D, (HL) 
1511			 
1511			      pop   HL                      ; Add sizes of both blocks 
1511			      add   HL, DE 
1511			      ex    DE, HL 
1511			 
1511			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1511			      ld    H, (IX+3) 
1511			      inc   HL 
1511			      inc   HL 
1511			      ld    (HL), E 
1511			      inc   HL 
1511			      ld    (HL), D 
1511			 
1511			free_done: 
1511			      ld    HL, 4                   ; Clean up stack frame 
1511			      add   HL, SP 
1511			      ld    SP, HL 
1511			 
1511			free_early_exit: 
1511			      pop   IX 
1511			      pop   DE 
1511			      pop   BC 
1511			 
1511			      ret 
1511			 
1511			 
1511			;      .org 0x8000 
1511			; 
1511			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1511			 ;                 .dw   0 
1511			 
1511			endif 
1511			 
1511			 
1511			if MALLOC_4 
1511			 
1511			; My memory allocation code. Very very simple.... 
1511			; allocate space under 250 chars 
1511			 
1511			heap_init: 
1511				; init start of heap as zero 
1511				;  
1511			 
1511				ld hl, heap_start 
1511			;	ld a, 0 
1511				ld (hl), 0      ; empty block 
1511				inc hl 
1511			;	ld a, 0 
1511				ld (hl), 0      ; length of block 
1511				; write end of list 
1511				inc hl 
1511				ld a,(hl) 
1511				inc hl 
1511				ld a,(hl) 
1511				 
1511			 
1511				; init some malloc vars 
1511			 
1511				ld hl, 0 
1511				ld (free_list), hl       ; store last malloc location 
1511			 
1511				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1511			;	ld a, 0 
1511				ld (hl), 0 
1511			 
1511			 
1511				ld hl, heap_start 
1511				;  
1511				  
1511				ret 
1511			 
1511			 
1511			;    free block marker 
1511			;    requested size  
1511			;    pointer to next block 
1511			;    .... 
1511			;    next block marker 
1511			 
1511			 
1511			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1511			; 
1511			 
1511			 
1511			malloc:  
1511				push de 
1511				push bc 
1511				push af 
1511			 
1511				; hl space required 
1511				 
1511				ld c, l    ; hold space   (TODO only a max of 255) 
1511			 
1511			;	inc c     ; TODO BUG need to fix memory leak on push str 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			;	inc c 
1511			 
1511			 
1511			 
1511				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1511			 
1511				ld a, (free_list+3) 
1511			;	cp 0 
1511				or a 
1511				jr z, .contheap 
1511			 
1511				ld hl, (free_list)     ; get last alloc 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mrs" 
1511						CALLMONITOR 
1511					endif 
1511				jr .startalloc 
1511			 
1511			.contheap: 
1511				ld hl, heap_start 
1511			 
1511			.startalloc: 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mym" 
1511						CALLMONITOR 
1511					endif 
1511			.findblock: 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mmf" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511				ld a,(hl)  
1511				; if byte is zero then clear to use 
1511			 
1511			;	cp 0 
1511				or a 
1511				jr z, .foundemptyblock 
1511			 
1511				; if byte is not clear 
1511				;     then byte is offset to next block 
1511			 
1511				inc hl 
1511				ld a, (hl) ; get size 
1511			.nextblock:	inc hl 
1511					ld e, (hl) 
1511					inc hl 
1511					ld d, (hl) 
1511					ex de, hl 
1511			;	inc hl  ; move past the store space 
1511			;	inc hl  ; move past zero index  
1511			 
1511				; TODO detect no more space 
1511			 
1511				push hl 
1511				ld de, heap_end 
1511				call cmp16 
1511				pop hl 
1511				jr nc, .nospace 
1511			 
1511				jr .findblock 
1511			 
1511			.nospace: ld hl, 0 
1511				jp .exit 
1511			 
1511			 
1511			.foundemptyblock:	 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mme" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			; TODO has block enough space if reusing??? 
1511			 
1511				;  
1511			 
1511			; see if this block has been previously used 
1511				inc hl 
1511				ld a, (hl) 
1511				dec hl 
1511			;	cp 0 
1511				or a 
1511				jr z, .newblock 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "meR" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			; no reusing previously allocated block 
1511			 
1511			; is it smaller than previously used? 
1511				 
1511				inc hl    ; move to size 
1511				ld a, c 
1511				sub (hl)        ; we want c < (hl) 
1511				dec hl    ; move back to marker 
1511			        jr z, .findblock 
1511			 
1511				; update with the new size which should be lower 
1511			 
1511			        ;inc  hl   ; negate next move. move back to size  
1511			 
1511			.newblock: 
1511				; need to be at marker here 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "meN" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			 
1511				ld a, c 
1511			 
1511				ld (free_list+3), a	 ; flag resume from last malloc  
1511				ld (free_list), hl    ; save out last location 
1511			 
1511			 
1511				;inc a     ; space for length byte 
1511				ld (hl), a     ; save block in use marker 
1511			 
1511				inc hl   ; move to space marker 
1511				ld (hl), a    ; save new space 
1511			 
1511				inc hl   ; move to start of allocated area 
1511				 
1511			;	push hl     ; save where we are - 1  
1511			 
1511			;	inc hl  ; move past zero index  
1511				; skip space to set down new marker 
1511			 
1511				; provide some extra space for now 
1511			 
1511				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1511				inc a 
1511				inc a 
1511			 
1511				push hl   ; save where we are in the node block 
1511			 
1511				call addatohl 
1511			 
1511				; write linked list point 
1511			 
1511				pop de     ; get our node position 
1511				ex de, hl 
1511			 
1511				ld (hl), e 
1511				inc hl 
1511				ld (hl), d 
1511			 
1511				inc hl 
1511			 
1511				; now at start of allocated data so save pointer 
1511			 
1511				push hl 
1511			 
1511				; jump to position of next node and setup empty header in DE 
1511			 
1511				ex de, hl 
1511			 
1511			;	inc hl ; move past end of block 
1511			 
1511			;	ld a, 0 
1511				ld (hl), 0   ; empty marker 
1511				inc hl 
1511				ld (hl), 0   ; size 
1511				inc hl  
1511				ld (hl), 0   ; ptr 
1511				inc hl 
1511				ld (hl), 0   ; ptr 
1511			 
1511			 
1511				pop hl 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "mmr" 
1511						CALLMONITOR 
1511					endif 
1511			 
1511			.exit: 
1511				pop af 
1511				pop bc 
1511				pop de  
1511				ret 
1511			 
1511			 
1511			 
1511			 
1511			free:  
1511				push hl 
1511				push af 
1511				; get address in hl 
1511			 
1511					if DEBUG_FORTH_MALLOC_INT 
1511						DMARK "fre" 
1511						CALLMONITOR 
1511					endif 
1511				; data is at hl - move to block count 
1511				dec hl 
1511				dec hl    ; get past pointer 
1511				dec hl 
1511			 
1511				ld a, (hl)    ; need this for a validation check 
1511			 
1511				dec hl    ; move to block marker 
1511			 
1511				; now check that the block count and block marker are the same  
1511			        ; this checks that we are on a malloc node and not random memory 
1511			        ; OK a faint chance this could be a problem but rare - famous last words! 
1511			 
1511				ld c, a 
1511				ld a, (hl)    
1511			 
1511				cp c 
1511				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1511			 
1511				; yes good chance we are on a malloc node 
1511			 
1511			;	ld a, 0      
1511				ld (hl), 0   ; mark as free 
1511			 
1511				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1511			 
1511			.freeignore:  
1511			 
1511				pop af 
1511				pop hl 
1511			 
1511				ret 
1511			 
1511			 
1511			 
1511			endif 
1511			 
1511			; eof 
# End of file firmware_memory.asm
1511			  
1511			; device C  
1511			; Now handled by SPI  
1511			;if SOUND_ENABLE  
1511			;	include "firmware_sound.asm"  
1511			;endif  
1511			  
1511			include "firmware_diags.asm"  
1511			; Hardware diags menu 
1511			 
1511			 
1511			config: 
1511			 
1511 3e 00			ld a, 0 
1513 21 36 15			ld hl, .configmn 
1516 cd ac 0d			call menu 
1519			 
1519 fe 00			cp 0 
151b c8				ret z 
151c			 
151c			;	cp 1 
151c			;	call z, .savetostore 
151c			 
151c 3d				dec a 
151d			if STARTUP_V1 
151d				call z, .selautoload 
151d			endif 
151d			 
151d			if STARTUP_V2 
151d cc 44 15			call z, .enautoload 
1520			endif 
1520				;cp 2 
1520 3d				dec a 
1521 cc 5b 15			call z, .disautoload 
1524			if STARTUP_V2 
1524 3d				dec a 
1525 cc 72 15			call z, .selbank 
1528			endif 
1528			;	cp 3 
1528			;	call z, .selbank 
1528			;	cp 3 
1528 3d				dec a 
1529 cc 12 18			call z, .debug_tog 
152c			;	cp 4 
152c 3d				dec a 
152d cc e0 18			call z, .bpsgo 
1530			;	cp 5 
1530			;	call z, hardware_diags 
1530			if STARTUP_V2 
1530			;	cp 5 
1530 3d				dec a 
1531 cc d3 15			call z, create_startup 
1534			endif 
1534 18 db			jr config 
1536			 
1536			.configmn: 
1536			;	dw prom_c3 
1536 ce 1a			dw prom_c2 
1538 e4 1a			dw prom_c2a 
153a			if STARTUP_V2 
153a 93 1b			dw prom_bsel  
153c			endif 
153c			;	dw prom_c2b 
153c			;	dw prom_c4 
153c 5b 1b			dw prom_m4 
153e 76 1b			dw prom_m4b 
1540			;	dw prom_c1 
1540			if STARTUP_V2 
1540 7e 1b			dw prom_c9 
1542			endif 
1542 00 00			dw 0 
1544				 
1544			 
1544			if STARTUP_V2 
1544			.enautoload: 
1544				if STORAGE_SE 
1544 3e fe			ld a, $fe      ; bit 0 clear 
1546 32 92 f9			ld (spi_device), a 
1549			 
1549 cd 05 05			call storage_get_block_0 
154c			 
154c 3e 01			ld a, 1 
154e 32 cd f9			ld (store_page+STORE_0_AUTOFILE), a 
1551			 
1551 21 00 00				ld hl, 0 
1554 11 ac f9				ld de, store_page 
1557 cd bc 04			call storage_write_block	 ; save update 
155a				else 
155a			 
155a				ld hl, prom_notav 
155a				ld de, prom_empty 
155a				call info_panel 
155a				endif 
155a			 
155a			 
155a c9				ret 
155b			endif 
155b			 
155b			.disautoload: 
155b				if STORAGE_SE 
155b 3e fe			ld a, $fe      ; bit 0 clear 
155d 32 92 f9			ld (spi_device), a 
1560			 
1560 cd 05 05			call storage_get_block_0 
1563			 
1563 3e 00			ld a, 0 
1565 32 cd f9			ld (store_page+STORE_0_AUTOFILE), a 
1568			 
1568 21 00 00				ld hl, 0 
156b 11 ac f9				ld de, store_page 
156e cd bc 04			call storage_write_block	 ; save update 
1571				else 
1571			 
1571				ld hl, prom_notav 
1571				ld de, prom_empty 
1571				call info_panel 
1571				endif 
1571			 
1571			 
1571 c9				ret 
1572			 
1572			if STARTUP_V1 
1572			 
1572			; Select auto start 
1572			 
1572			.selautoload: 
1572			 
1572				 
1572				if STORAGE_SE 
1572			 
1572					call config_dir 
1572				        ld hl, scratch 
1572					ld a, 0 
1572					call menu 
1572			 
1572					cp 0 
1572					ret z 
1572			 
1572					dec a 
1572			 
1572			 
1572					; locate menu option 
1572			 
1572					ld hl, scratch 
1572					call table_lookup 
1572			 
1572					if DEBUG_FORTH_WORDS 
1572						DMARK "ALl" 
1572						CALLMONITOR 
1572					endif 
1572					; with the pointer to the menu it, the byte following the zero term is the file id 
1572			 
1572					ld a, 0 
1572					ld bc, 50   ; max of bytes to look at 
1572					cpir  
1572			 
1572					if DEBUG_FORTH_WORDS 
1572						DMARK "ALb" 
1572						CALLMONITOR 
1572					endif 
1572					;inc hl 
1572			 
1572					ld a, (hl)   ; file id 
1572					 
1572				        ; save bank and file ids 
1572			 
1572					push af 
1572			 
1572			; TODO need to save to block 0 on bank 1	 
1572			 
1572					call storage_get_block_0 
1572			 
1572					if DEBUG_FORTH_WORDS 
1572						DMARK "AL0" 
1572						CALLMONITOR 
1572					endif 
1572					pop af 
1572			 
1572					ld (store_page+STORE_0_FILERUN),a 
1572					 
1572					; save bank id 
1572			 
1572					ld a,(spi_device) 
1572					ld (store_page+STORE_0_BANKRUN),a 
1572			 
1572					; enable auto run of store file 
1572			 
1572					ld a, 1 
1572					ld (store_page+STORE_0_AUTOFILE),a 
1572			 
1572					; save buffer 
1572			 
1572					ld hl, 0 
1572					ld de, store_page 
1572					if DEBUG_FORTH_WORDS 
1572						DMARK "ALw" 
1572						CALLMONITOR 
1572					endif 
1572				call storage_write_block	 ; save update 
1572			  
1572			 
1572			 
1572			 
1572					ld hl, scratch 
1572					call config_fdir 
1572			 
1572				else 
1572			 
1572				ld hl, prom_notav 
1572				ld de, prom_empty 
1572				call info_panel 
1572			 
1572				endif 
1572				ret 
1572			endif 
1572			 
1572			 
1572			; Select storage bank 
1572			 
1572			.selbank: 
1572			 
1572			if STARTUP_V2 
1572			;	if STORAGE_SE 
1572			;	else 
1572			 
1572 21 c9 1b			ld hl, prom_banks 
1575 cd ac 0d			call menu 
1578 fe 00			cp 0 
157a c8				ret z 
157b				 
157b				; set the bank number from the result 
157b			 
157b				 
157b 0e ff				ld c, SPI_CE_HIGH 
157d 06 30				ld b, '0'    ; human readable bank number 
157f			 
157f			 
157f					; active low 
157f			 
157f			;		cp 0 
157f b7					or a 
1580 28 28				jr z, .bset 
1582 fe 01				cp 1 
1584 20 04				jr nz, .b2 
1586 cb 81				res 0, c 
1588 06 31				ld b, '1'    ; human readable bank number 
158a fe 02		.b2:		cp 2 
158c 20 04				jr nz, .b3 
158e cb 89				res 1, c 
1590 06 32				ld b, '2'    ; human readable bank number 
1592 fe 03		.b3:		cp 3 
1594 20 04				jr nz, .b4 
1596 cb 91				res 2, c 
1598 06 33				ld b, '3'    ; human readable bank number 
159a fe 04		.b4:		cp 4 
159c 20 04				jr nz, .b5 
159e cb 99				res 3, c 
15a0 06 34				ld b, '4'    ; human readable bank number 
15a2 fe 05		.b5:		cp 5 
15a4 20 04				jr nz, .bset 
15a6 cb a1				res 4, c 
15a8 06 35				ld b, '5'    ; human readable bank number 
15aa			 
15aa			.bset: 
15aa			 
15aa 79					ld a, c 
15ab			;		ld (spi_device),a 
15ab 78					ld a, b 
15ac			;		ld (spi_device_id),a 
15ac c5					push bc 
15ad			 
15ad					; select bank 1 and load block 0  
15ad			 
15ad 3e fe			ld a, $fe      ; bit 0 clear 
15af 32 92 f9			ld (spi_device), a 
15b2			 
15b2 cd 05 05			call storage_get_block_0 
15b5			 
15b5 c1				pop bc 
15b6 79				ld a,c 
15b7 32 cf f9			ld (store_page+STORE_0_BANKRUN), a 
15ba 78				ld a,b 
15bb 32 d1 f9			ld (store_page+STORE_0_BANKRUNN), a 
15be 21 00 00				ld hl, 0 
15c1 11 ac f9				ld de, store_page 
15c4 cd bc 04			call storage_write_block 
15c7			 
15c7			else 
15c7				ld hl, prom_notav 
15c7				ld de, prom_empty 
15c7				call info_panel 
15c7			;	endif 
15c7				 
15c7			endif 
15c7 c9				ret 
15c8			 
15c8			if STORAGE_SE 
15c8			 
15c8			.config_ldir:   
15c8				; Load storage bank labels into menu array 
15c8			 
15c8				 
15c8			 
15c8			 
15c8 c9				ret 
15c9			 
15c9			 
15c9			endif 
15c9			 
15c9			 
15c9			; Save user words to storage 
15c9			 
15c9			.savetostore: 
15c9			 
15c9			;	if STORAGE_SE 
15c9			; 
15c9			;		call config_dir 
15c9			;	        ld hl, scratch 
15c9			;		ld a, 0 
15c9			;		call menu 
15c9			;		 
15c9			;		ld hl, scratch 
15c9			;		call config_fdir 
15c9			; 
15c9			;	else 
15c9			 
15c9 21 d5 1b			ld hl, prom_notav 
15cc 11 eb 1b			ld de, prom_empty 
15cf cd 0e 0d			call info_panel 
15d2			 
15d2			;	endif 
15d2			 
15d2 c9				ret 
15d3			 
15d3			if STARTUP_V2 
15d3			 
15d3			create_startup: 
15d3			 
15d3 3e 00			ld a, 0 
15d5 21 37 17			ld hl, .crstart 
15d8 cd ac 0d			call menu 
15db			 
15db fe 00			cp 0 
15dd c8				ret z 
15de			 
15de fe 01			cp 1 
15e0 cc 1c 16			call z, .genlsword 
15e3 fe 02			cp 2 
15e5 cc 26 16			call z, .genedword 
15e8			 
15e8 fe 03			cp 3 
15ea cc 30 16			call z, .gendemword 
15ed			 
15ed fe 04			cp 4 
15ef cc 3a 16			call z, .genutlword 
15f2 fe 05			cp 5 
15f4 cc 44 16			call z, .genspiword 
15f7 fe 06			cp 6 
15f9 cc 4e 16			call z, .genkeyword 
15fc fe 07			cp 7 
15fe cc 12 16			call z, .gensoundword 
1601 fe 08			cp 8 
1603 cc 08 16			call z, .genhwword 
1606 18 cb			jr create_startup 
1608			 
1608			.genhwword: 
1608 21 45 1b			ld hl, crs_hw 
160b 11 9b 16			ld de, .hwworddef 
160e cd 58 16			call .genfile 
1611 c9				ret 
1612			.gensoundword: 
1612 21 39 1b			ld hl, crs_sound 
1615 11 a9 16			ld de, .soundworddef 
1618 cd 58 16			call .genfile 
161b c9				ret 
161c			.genlsword: 
161c 21 fb 1a			ld hl, crs_s1 
161f 11 cf 16			ld de, .lsworddef 
1622 cd 58 16			call .genfile 
1625 c9				ret 
1626			 
1626			.genedword: 
1626 11 d3 16			ld de, .edworddef 
1629 21 04 1b			ld hl, crs_s2 
162c cd 58 16			call .genfile 
162f c9				ret 
1630			 
1630			.gendemword: 
1630 11 db 16			ld de, .demoworddef 
1633 21 0d 1b			ld hl, crs_s3 
1636 cd 58 16			call .genfile 
1639 c9				ret 
163a			 
163a			.genutlword: 
163a 21 19 1b			ld hl, crs_s4 
163d 11 bd 16			ld de, .utilwordef 
1640 cd 58 16			call .genfile 
1643 c9				ret 
1644			.genspiword: 
1644 21 20 1b			ld hl, crs_s5 
1647 11 fd 16			ld de, .spiworddef 
164a cd 58 16			call .genfile 
164d c9				ret 
164e			.genkeyword: 
164e 21 2a 1b			ld hl, crs_s6 
1651 11 0b 17			ld de, .keyworddef 
1654 cd 58 16			call .genfile 
1657 c9				ret 
1658			 
1658			; hl - points to file name 
1658			; de - points to strings to add to file 
1658			 
1658			.genfile: 
1658 e5				push hl 
1659 d5				push de 
165a			 
165a cd 7c 0d			call clear_display 
165d 3e 00			ld a, display_row_1 
165f 11 8a 16			ld de, .genfiletxt 
1662 cd 8e 0d			call str_at_display 
1665 cd 9e 0d			call update_display 
1668			 
1668 d1				pop de 
1669 e1				pop hl 
166a			 
166a			 
166a d5				push de 
166b cd 51 08			call storage_create 
166e				; id in hl 
166e d1				pop de   ; table of strings to add 
166f			 
166f			.genloop: 
166f			 
166f e5				push hl ; save id for next time around 
1670 d5				push de ; save de for next time around 
1671			 
1671 eb				ex de, hl 
1672 cd 68 23			call loadwordinhl 
1675 eb				ex de, hl 
1676			 
1676				; need hl to be the id 
1676				; need de to be the string ptr 
1676				 
1676 cd 3b 0b			call storage_append 
1679			 
1679 d1				pop de 
167a e1				pop hl 
167b			 
167b 13				inc de 
167c 13				inc de 
167d			 
167d 1a				ld a,(de) 
167e fe 00			cp 0 
1680 20 ed			jr nz, .genloop 
1682 13				inc de 
1683 1a				ld a, (de) 
1684 1b				dec de 
1685 fe 00			cp 0 
1687 20 e6			jr nz, .genloop	 
1689			 
1689 c9				ret 
168a			 
168a .. 00		.genfiletxt:  db "Creating file...",0 
169b			 
169b			.hwworddef: 
169b 54 6d			dw test5 
169d 8c 6d			dw test6 
169f c4 6d			dw test7 
16a1 d8 6d			dw test8 
16a3 04 6e			dw test9 
16a5 1a 6e			dw test10 
16a7 00 00			dw 0 
16a9			 
16a9			.soundworddef: 
16a9 3f 6e			dw sound1 
16ab 63 6e			dw sound2 
16ad 93 6e			dw sound3 
16af b8 6e			dw sound4 
16b1 c5 6e			dw sound5 
16b3 d2 6e			dw sound6 
16b5 df 6e			dw sound7 
16b7 ec 6e			dw sound8 
16b9 04 6f			dw sound9 
16bb 00 00			dw 0 
16bd			 
16bd			.utilwordef: 
16bd 7a 6b			dw strncpy 
16bf 55 6b			dw type 
16c1 d7 6c			dw tuck 
16c3 21 6b			dw clrstack 
16c5 da 6a			dw longread 
16c7 db 6b			dw start1 
16c9 eb 6b			dw start2 
16cb			; duplicated 
16cb			;	dw start3b 
16cb			;	dw start3c 
16cb ea 6c			dw list 
16cd 00 00			dw 0 
16cf			 
16cf			.lsworddef: 
16cf fc 6b			dw start3b 
16d1 00 00			dw 0 
16d3			 
16d3			.edworddef: 
16d3 39 67			dw edit1 
16d5 5a 67			dw edit2 
16d7 8f 67			dw edit3 
16d9 00 00			dw 0 
16db			 
16db			.demoworddef: 
16db 1b 6f			dw game1 
16dd 2c 6f			dw game1a 
16df 8e 6f			dw game1b 
16e1 c3 6f			dw game1c 
16e3 f9 6f			dw game1d 
16e5 2a 70			dw game1s 
16e7 3e 70			dw game1t 
16e9 53 70			dw game1f 
16eb 87 70			dw game1z 
16ed cb 70			dw game1zz 
16ef 34 71			dw ssv2 
16f1 6a 71			dw ssv3 
16f3 86 71			dw ssv4 
16f5 a2 71			dw ssv5 
16f7 bb 71			dw ssv1 
16f9 03 72			dw ssv1cpm	 
16fb			;	dw game2b 
16fb			;	dw game2bf 
16fb			;	dw game2mba 
16fb			;	dw game2mbas	 
16fb			;	dw game2mbht 
16fb			;	dw game2mbms 
16fb			;	dw game2mb 
16fb			;	dw game3w 
16fb			;	dw game3p 
16fb			;	dw game3sc 
16fb			;	dw game3vsi 
16fb			;	dw game3vs 
16fb 00 00			dw 0 
16fd			 
16fd			 
16fd			.spiworddef: 
16fd			 
16fd c7 67		    dw spi1 
16ff 20 68		    dw spi2 
1701 54 68		    dw spi2b 
1703 d8 68		    dw spi3 
1705 82 68		    dw spi4 
1707 ab 68		    dw spi5 
1709			;    dw spi6 
1709			;    dw spi7 
1709			 
1709			;    dw spi8 
1709			;    dw spi9 
1709			;    dw spi10 
1709 00 00		    dw 0 
170b			 
170b			.keyworddef: 
170b			 
170b 5a 72			dw keyup 
170d 68 72			dw keydown 
170f 78 72			dw keyleft 
1711 88 72			dw keyright 
1713 99 72			dw 	keyf1 
1715 a7 72			dw keyf2 
1717 b5 72			dw keyf3 
1719 c3 72			dw keyf4 
171b d1 72			dw keyf5 
171d df 72			dw keyf6 
171f ed 72			dw keyf7 
1721 fb 72			dw keyf8 
1723 09 73			dw keyf9 
1725 17 73			dw keyf10 
1727 26 73			dw keyf11 
1729 35 73			dw keyf12 
172b 44 73			dw keytab 
172d 53 73			dw keycr 
172f 61 73			dw keyhome 
1731 71 73			dw keyend 
1733 80 73			dw keybs 
1735 00 00			dw 0 
1737			 
1737			.crstart: 
1737 fb 1a			dw crs_s1 
1739 04 1b			dw crs_s2 
173b 0d 1b			dw crs_s3 
173d 19 1b			dw crs_s4 
173f 20 1b			dw crs_s5 
1741 2a 1b			dw crs_s6 
1743 39 1b			dw crs_sound 
1745 45 1b			dw crs_hw 
1747 00 00			dw 0 
1749			 
1749			endif 
1749			 
1749			 
1749			if STORAGE_SE 
1749			 
1749			config_fdir: 
1749				; using the scratch dir go through and release the memory allocated for each string 
1749				 
1749 21 f3 f0			ld hl, scratch 
174c 5e			.cfdir:	ld e,(hl) 
174d 23				inc hl 
174e 56				ld d,(hl) 
174f 23				inc hl 
1750			 
1750 eb				ex de, hl 
1751 cd d5 0f			call ishlzero 
1754 c8				ret z     ; return on null pointer 
1755 cd 42 14			call free 
1758 eb				ex de, hl 
1759 18 f1			jr .cfdir 
175b			 
175b			 
175b c9				ret 
175c			 
175c			 
175c			config_dir: 
175c			 
175c				; for the config menus that need to build a directory of storage call this routine 
175c				; it will construct a menu in scratch to pass to menu 
175c			 
175c				; open storage device 
175c			 
175c				; execute DIR to build a list of files and their ids into scratch in menu format 
175c				; once the menu has finished then will need to call config_fdir to release the strings 
175c				 
175c				; c = number items 
175c			 
175c				 
175c cd 05 05			call storage_get_block_0 
175f			 
175f 21 ac f9			ld hl, store_page     ; get current id count 
1762 46				ld b, (hl) 
1763 0e 00			ld c, 0    ; count of files   
1765			 
1765			 
1765 21 f3 f0			ld hl, scratch 
1768 22 a3 f9			ld (store_tmp2), hl    ; location to poke strings 
176b			 
176b				; check for empty drive 
176b			 
176b 3e 00			ld a, 0 
176d b8				cp b 
176e ca 08 18			jp z, .dirdone 
1771			 
1771				 
1771					if DEBUG_FORTH_WORDS 
1771						DMARK "Cdc" 
1771 f5				push af  
1772 3a 86 17			ld a, (.dmark)  
1775 32 9d fd			ld (debug_mark),a  
1778 3a 87 17			ld a, (.dmark+1)  
177b 32 9e fd			ld (debug_mark+1),a  
177e 3a 88 17			ld a, (.dmark+2)  
1781 32 9f fd			ld (debug_mark+2),a  
1784 18 03			jr .pastdmark  
1786 ..			.dmark: db "Cdc"  
1789 f1			.pastdmark: pop af  
178a			endm  
# End of macro DMARK
178a						CALLMONITOR 
178a cd aa fd			call debug_vector  
178d				endm  
# End of macro CALLMONITOR
178d					endif 
178d			 
178d			 
178d			.diritem:	 
178d c5				push bc 
178e				; for each of the current ids do a search for them and if found push to stack 
178e			 
178e 21 40 00				ld hl, STORE_BLOCK_PHY 
1791 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
1793 58					ld e,b 
1794			 
1794 cd 83 07				call storage_findnextid 
1797			 
1797			 
1797					; if found hl will be non zero 
1797			 
1797 cd d5 0f				call ishlzero 
179a 28 69				jr z, .dirnotfound 
179c			 
179c					; increase count 
179c			 
179c c1					pop bc	 
179d 0c					inc c 
179e c5					push bc 
179f					 
179f			 
179f					; get file header and push the file name 
179f			 
179f 11 ac f9				ld de, store_page 
17a2 cd 57 04				call storage_read_block 
17a5			 
17a5					; push file id to stack 
17a5				 
17a5 3a ac f9				ld a, (store_page) 
17a8 26 00				ld h, 0 
17aa 6f					ld l, a 
17ab			 
17ab					;call forth_push_numhl 
17ab					; TODO store id 
17ab			 
17ab e5					push hl 
17ac			 
17ac					; push extent count to stack  
17ac				 
17ac 21 af f9				ld hl, store_page+3 
17af			 
17af					; get file name length 
17af			 
17af cd 04 13				call strlenz   
17b2			 
17b2 23					inc hl   ; cover zero term 
17b3 23					inc hl  ; stick the id at the end of the area 
17b4			 
17b4 e5					push hl 
17b5 c1					pop bc    ; move length to bc 
17b6			 
17b6 cd 78 13				call malloc 
17b9			 
17b9					; TODO save malloc area to scratch 
17b9			 
17b9 eb					ex de, hl 
17ba 2a a3 f9				ld hl, (store_tmp2) 
17bd 73					ld (hl), e 
17be 23					inc hl 
17bf 72					ld (hl), d 
17c0 23					inc hl 
17c1 22 a3 f9				ld (store_tmp2), hl 
17c4			 
17c4					 
17c4			 
17c4					;pop hl   ; get source 
17c4			;		ex de, hl    ; swap aronund	 
17c4			 
17c4 21 af f9				ld hl, store_page+3 
17c7					if DEBUG_FORTH_WORDS 
17c7						DMARK "CFd" 
17c7 f5				push af  
17c8 3a dc 17			ld a, (.dmark)  
17cb 32 9d fd			ld (debug_mark),a  
17ce 3a dd 17			ld a, (.dmark+1)  
17d1 32 9e fd			ld (debug_mark+1),a  
17d4 3a de 17			ld a, (.dmark+2)  
17d7 32 9f fd			ld (debug_mark+2),a  
17da 18 03			jr .pastdmark  
17dc ..			.dmark: db "CFd"  
17df f1			.pastdmark: pop af  
17e0			endm  
# End of macro DMARK
17e0						CALLMONITOR 
17e0 cd aa fd			call debug_vector  
17e3				endm  
# End of macro CALLMONITOR
17e3					endif 
17e3 ed b0				ldir 
17e5			 
17e5					; de is past string, move back one and store id 
17e5					 
17e5 1b					dec de 
17e6			 
17e6					; store file id 
17e6			 
17e6 e1					pop hl 
17e7 eb					ex de,hl 
17e8 73					ld (hl), e 
17e9			 
17e9					if DEBUG_FORTH_WORDS 
17e9						DMARK "Cdi" 
17e9 f5				push af  
17ea 3a fe 17			ld a, (.dmark)  
17ed 32 9d fd			ld (debug_mark),a  
17f0 3a ff 17			ld a, (.dmark+1)  
17f3 32 9e fd			ld (debug_mark+1),a  
17f6 3a 00 18			ld a, (.dmark+2)  
17f9 32 9f fd			ld (debug_mark+2),a  
17fc 18 03			jr .pastdmark  
17fe ..			.dmark: db "Cdi"  
1801 f1			.pastdmark: pop af  
1802			endm  
# End of macro DMARK
1802						CALLMONITOR 
1802 cd aa fd			call debug_vector  
1805				endm  
# End of macro CALLMONITOR
1805					endif 
1805					 
1805			.dirnotfound: 
1805 c1					pop bc     
1806 10 85				djnz .diritem 
1808				 
1808			.dirdone:	 
1808			 
1808			;		ld a, 0 
1808 2a a3 f9				ld hl, (store_tmp2) 
180b 36 00				ld (hl), 0 
180d 23					inc hl 
180e 36 00				ld (hl), 0 
1810 23					inc hl 
1811					; push a count of the dir items found 
1811			 
1811			;		ld h, 0 
1811			;		ld l, c 
1811			 
1811 c9				ret 
1812			 
1812			endif 
1812			 
1812			 
1812			; Settings 
1812			; Run  
1812			 
1812			 
1812			 
1812			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
1812			;;hd_menu2:   db "        2: Editor",0   
1812			;hd_menu2:   db "        2: Editor       6: Menu",0   
1812			;hd_menu3:   db "        3: Storage",0 
1812			;hd_menu4:   db "0=quit  4: Debug",0 
1812			;hd_don:     db "ON",0 
1812			;hd_doff:     db "OFF",0 
1812			; 
1812			; 
1812			; 
1812			;hardware_diags_old:       
1812			; 
1812			;.diagmenu: 
1812			;	call clear_display 
1812			;	ld a, display_row_1 
1812			;	ld de, hd_menu1 
1812			;	call str_at_display 
1812			; 
1812			;	ld a, display_row_2 
1812			;	ld de, hd_menu2 
1812			;	call str_at_display 
1812			; 
1812			;	ld a, display_row_3 
1812			;	ld de, hd_menu3 
1812			;	call str_at_display 
1812			; 
1812			;	ld a,  display_row_4 
1812			;	ld de, hd_menu4 
1812			;	call str_at_display 
1812			; 
1812			;	; display debug state 
1812			; 
1812			;	ld de, hd_don 
1812			;	ld a, (os_view_disable) 
1812			;	cp 0 
1812			;	jr z, .distog 
1812			;	ld de, hd_doff 
1812			;.distog: ld a, display_row_4+17 
1812			;	call str_at_display 
1812			; 
1812			;	call update_display 
1812			; 
1812			;	call cin_wait 
1812			; 
1812			; 
1812			; 
1812			;	cp '4' 
1812			;	jr nz, .diagn1 
1812			; 
1812			;	; debug toggle 
1812			; 
1812			;	ld a, (os_view_disable) 
1812			;	ld b, '*' 
1812			;	cp 0 
1812			;	jr z, .debtog 
1812			;	ld b, 0 
1812			;.debtog:	 
1812			;	ld a,b 
1812			;	ld (os_view_disable),a 
1812			; 
1812			;.diagn1: cp '0' 
1812			;	 ret z 
1812			; 
1812			;;	cp '1' 
1812			;;       jp z, matrix	 
1812			;;   TODO keyboard matrix test 
1812			; 
1812			;	cp '2' 
1812			;	jp z, .diagedit 
1812			; 
1812			;;	cp '6' 
1812			;;	jp z, .menutest 
1812			;;if ENABLE_BASIC 
1812			;;	cp '6' 
1812			;;	jp z, basic 
1812			;;endif 
1812			 ; 
1812			;	jp .diagmenu 
1812			; 
1812			; 
1812			;	ret 
1812			 
1812			 
1812			.debug_tog: 
1812 21 3b 18			ld hl, .menudebug 
1815				 
1815			;	ld a, (os_view_disable) 
1815			;	cp '*' 
1815 3a aa fd			ld a,(debug_vector) 
1818 fe c9			cp $C9   ; RET 
181a 20 04			jr nz,.tdon  
181c 3e 01			ld a, 1 
181e 18 02			jr .tog1 
1820 3e 00		.tdon: ld a, 0 
1822			 
1822			.tog1: 
1822 cd ac 0d			call menu 
1825 fe 00			cp 0 
1827 c8				ret z 
1828 fe 01			cp 1    ; disable debug 
182a 28 04			jr z, .dtog0 
182c 3e 2a			ld a, '*' 
182e 18 05			jr .dtogset 
1830			.dtog0:  
1830				;ld a, 0 
1830 cd ce 18			call bp_on 
1833 18 dd			jr .debug_tog 
1835			.dtogset:  
1835				; ld (os_view_disable), a 
1835 cd da 18			call bp_off 
1838 c3 12 18			jp .debug_tog 
183b			 
183b			 
183b			.menudebug: 
183b 41 18				dw .m6 
183d 4a 18				dw .m7 
183f 00 00				dw 0 
1841 .. 00		.m6:   db "Debug ON",0 
184a .. 00		.m7:   db "Debug OFF",0 
1854			;hardware_diags:       
1854			 
1854			ENABLE_HDIAGS: equ 0 
1854			 
1854			if ENABLE_HDIAGS 
1854			.diagm: 
1854				ld hl, .menuitems 
1854				ld a, 0 
1854				call menu 
1854			 
1854			         cp 0 
1854				 ret z 
1854			 
1854				cp 2 
1854				jp z, .diagedit 
1854			 
1854			;	cp '6' 
1854			;	jp z, .menutest 
1854			;if ENABLE_BASIC 
1854			;	cp '6' 
1854			;	jp z, basic 
1854			;endif 
1854			  
1854				jp .diagm 
1854			 
1854				 
1854			.menuitems:   	dw .m1 
1854					dw .m2 
1854					dw .m3 
1854					dw .m5 
1854					dw .m5a 
1854					dw .m5b 
1854					dw 0 
1854			 
1854			 
1854			.m1:   db "Key Matrix",0 
1854			.m2:   db "Editor",0 
1854			.m3:   db "Storage",0 
1854			.m5:   db "Sound",0 
1854			.m5a:  db "RAM Test",0 
1854			.m5b:  db "LCD Test",0 
1854			 
1854			 
1854			; debug editor 
1854			 
1854			.diagedit: 
1854			 
1854				ld hl, scratch 
1854			;	ld bc, 250 
1854			;	ldir 
1854				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1854			;	ld a, 0 
1854				ld (hl), 0 
1854				inc hl 
1854				ld (hl), 0 
1854				inc hl 
1854				ld (hl), 0 
1854			 
1854			        call clear_display 
1854				call update_display 
1854				;ld a, 1 
1854				;ld (hardware_diag), a 
1854			.diloop: 
1854				ld a, display_row_1 
1854				ld c, 0 
1854				ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1854				ld e, 40 
1854			 
1854				ld hl, scratch	 
1854				call input_str 
1854			 
1854				ld a, display_row_2 
1854				ld de, scratch 
1854				call str_at_display 
1854				call update_display 
1854			 
1854				jp .diloop 
1854			endif 
1854			 
1854			; pass word in hl 
1854			; a has display location 
1854			display_word_at: 
1854 f5				push af 
1855 e5				push hl 
1856 7c				ld a,h 
1857 21 f8 f3			ld hl, os_word_scratch 
185a cd a8 11			call hexout 
185d e1				pop hl 
185e 7d				ld a,l 
185f 21 fa f3			ld hl, os_word_scratch+2 
1862 cd a8 11			call hexout 
1865 21 fc f3			ld hl, os_word_scratch+4 
1868			;	ld a,0 
1868 36 00			ld (hl),0 
186a 11 f8 f3			ld de,os_word_scratch 
186d f1				pop af 
186e cd 8e 0d				call str_at_display 
1871 c9				ret 
1872			 
1872			display_ptr_state: 
1872			 
1872				; to restore afterwards 
1872			 
1872 d5				push de 
1873 c5				push bc 
1874 e5				push hl 
1875 f5				push af 
1876			 
1876				; for use in here 
1876			 
1876			;	push bc 
1876			;	push de 
1876			;	push hl 
1876			;	push af 
1876			 
1876 cd 7c 0d			call clear_display 
1879			 
1879 11 51 1a			ld de, .ptrstate 
187c 3e 00			ld a, display_row_1 
187e cd 8e 0d			call str_at_display 
1881			 
1881				; display debug step 
1881			 
1881			 
1881 11 9d fd			ld de, debug_mark 
1884 3e 26			ld a, display_row_1+display_cols-2 
1886 cd 8e 0d			call str_at_display 
1889			 
1889				; display a 
1889 11 5b 1a			ld de, .ptrcliptr 
188c 3e 28			ld a, display_row_2 
188e cd 8e 0d			call str_at_display 
1891			 
1891 f1				pop af 
1892 2a 72 f9			ld hl,(cli_ptr) 
1895 3e 30			ld a, display_row_2+8 
1897 cd 54 18			call display_word_at 
189a			 
189a			 
189a				; display hl 
189a			 
189a			 
189a 11 63 1a			ld de, .ptrclioptr 
189d 3e 32			ld a, display_row_2+10 
189f cd 8e 0d			call str_at_display 
18a2			; 
18a2			;	pop hl 
18a2 3e 35			ld a, display_row_2+13 
18a4 2a 70 f9			ld hl,(cli_origptr) 
18a7 cd 54 18			call display_word_at 
18aa			; 
18aa			;	 
18aa			;	; display de 
18aa			 
18aa			;	ld de, .regstatede 
18aa			;	ld a, display_row_3 
18aa			;	call str_at_display 
18aa			 
18aa			;	pop de 
18aa			;	ld h,d 
18aa			;	ld l, e 
18aa			;	ld a, display_row_3+3 
18aa			;	call display_word_at 
18aa			 
18aa			 
18aa				; display bc 
18aa			 
18aa			;	ld de, .regstatebc 
18aa			;	ld a, display_row_3+10 
18aa			;	call str_at_display 
18aa			 
18aa			;	pop bc 
18aa			;	ld h,b 
18aa			;	ld l, c 
18aa			;	ld a, display_row_3+13 
18aa			;	call display_word_at 
18aa			 
18aa			 
18aa				; display dsp 
18aa			 
18aa			;	ld de, .regstatedsp 
18aa			;	ld a, display_row_4 
18aa			;	call str_at_display 
18aa			 
18aa				 
18aa			;	ld hl,(cli_data_sp) 
18aa			;	ld a, display_row_4+4 
18aa			;	call display_word_at 
18aa			 
18aa				; display rsp 
18aa			 
18aa 11 92 1a			ld de, .regstatersp 
18ad 3e 82			ld a, display_row_4+10 
18af cd 8e 0d			call str_at_display 
18b2			 
18b2				 
18b2 2a 24 f9			ld hl,(cli_ret_sp) 
18b5 3e 86			ld a, display_row_4+14 
18b7 cd 54 18			call display_word_at 
18ba			 
18ba cd 9e 0d			call update_display 
18bd			 
18bd cd c0 0c			call delay1s 
18c0 cd c0 0c			call delay1s 
18c3 cd c0 0c			call delay1s 
18c6			 
18c6			 
18c6 cd 77 1f			call next_page_prompt 
18c9			 
18c9				; restore  
18c9			 
18c9 f1				pop af 
18ca e1				pop hl 
18cb c1				pop bc 
18cc d1				pop de 
18cd c9				ret 
18ce			 
18ce			; Update the break point vector so that the user can hook a new routine 
18ce			 
18ce			bp_on: 
18ce 3e c3			ld a, $c3    ; JP 
18d0 32 aa fd			ld (debug_vector), a 
18d3 21 e0 18			ld hl, break_point_state 
18d6 22 ab fd			ld (debug_vector+1), hl 
18d9 c9				ret 
18da			 
18da			bp_off: 
18da 3e c9			ld a, $c9    ; RET 
18dc 32 aa fd			ld (debug_vector), a 
18df c9				ret 
18e0			 
18e0			 
18e0			break_point_state: 
18e0			;	push af 
18e0			; 
18e0			;	; see if disabled 
18e0			; 
18e0			;	ld a, (os_view_disable) 
18e0			;	cp '*' 
18e0			;	jr nz, .bpsgo 
18e0			;	pop af 
18e0			;	ret 
18e0			 
18e0			.bpsgo: 
18e0			;	pop af 
18e0 f5				push af 
18e1 22 d5 f0			ld (os_view_hl), hl 
18e4 ed 53 d3 f0		ld (os_view_de), de 
18e8 ed 43 d1 f0		ld (os_view_bc), bc 
18ec e5				push hl 
18ed 6f				ld l, a 
18ee 26 00			ld h, 0 
18f0 22 d7 f0			ld (os_view_af),hl 
18f3			 
18f3 21 e3 fc				ld hl, display_fb0 
18f6 22 fe fa				ld (display_fb_active), hl 
18f9 e1				pop hl	 
18fa			 
18fa 3e 31			ld a, '1' 
18fc fe 2a		.bps1:  cp '*' 
18fe cc da 18			call z, bp_off 
1901			;	jr nz, .bps1b 
1901			;	ld (os_view_disable),a 
1901 fe 31		.bps1b:  cp '1' 
1903 20 14			jr nz, .bps2 
1905			 
1905				; display reg 
1905			 
1905				 
1905			 
1905 3a d7 f0			ld a, (os_view_af) 
1908 2a d5 f0			ld hl, (os_view_hl) 
190b ed 5b d3 f0		ld de, (os_view_de) 
190f ed 4b d1 f0		ld bc, (os_view_bc) 
1913 cd ad 19			call display_reg_state 
1916 c3 99 19			jp .bpschk 
1919			 
1919 fe 32		.bps2:  cp '2' 
191b 20 08			jr nz, .bps3 
191d				 
191d				; display hl 
191d 2a d5 f0			ld hl, (os_view_hl) 
1920 cd 97 1a			call display_dump_at_hl 
1923			 
1923 18 74			jr .bpschk 
1925			 
1925 fe 33		.bps3:  cp '3' 
1927 20 08			jr nz, .bps4 
1929			 
1929			        ; display de 
1929 2a d3 f0			ld hl, (os_view_de) 
192c cd 97 1a			call display_dump_at_hl 
192f			 
192f 18 68			jr .bpschk 
1931 fe 34		.bps4:  cp '4' 
1933 20 08			jr nz, .bps5 
1935			 
1935			        ; display bc 
1935 2a d1 f0			ld hl, (os_view_bc) 
1938 cd 97 1a			call display_dump_at_hl 
193b			 
193b 18 5c			jr .bpschk 
193d fe 35		.bps5:  cp '5' 
193f 20 08		        jr nz, .bps7 
1941			 
1941				; display cur ptr 
1941 2a 72 f9			ld hl, (cli_ptr) 
1944 cd 97 1a			call display_dump_at_hl 
1947			 
1947 18 50			jr .bpschk 
1949 fe 36		.bps7:  cp '6' 
194b 20 08			jr nz, .bps8b 
194d				 
194d				; display cur orig ptr 
194d 2a 70 f9			ld hl, (cli_origptr) 
1950 cd 97 1a			call display_dump_at_hl 
1953 18 44			jr .bpschk 
1955 fe 37		.bps8b:  cp '7' 
1957 20 08			jr nz, .bps9 
1959				 
1959				; display dsp 
1959 2a 20 f9			ld hl, (cli_data_sp) 
195c cd 97 1a			call display_dump_at_hl 
195f			 
195f 18 38			jr .bpschk 
1961 fe 39		.bps9:  cp '9' 
1963 20 05			jr nz, .bps8c 
1965				 
1965				; display SP 
1965			;	ld hl, sp 
1965 cd 97 1a			call display_dump_at_hl 
1968			 
1968 18 2f			jr .bpschk 
196a fe 38		.bps8c:  cp '8' 
196c 20 08			jr nz, .bps8d 
196e				 
196e				; display rsp 
196e 2a 24 f9			ld hl, (cli_ret_sp) 
1971 cd 97 1a			call display_dump_at_hl 
1974			 
1974 18 23			jr .bpschk 
1976 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
1978 20 05			jr nz, .bps8 
197a cd 35 1d			call monitor 
197d			 
197d 18 1a			jr .bpschk 
197f fe 30		.bps8:  cp '0' 
1981 20 16			jr nz, .bpschk 
1983			 
1983 21 42 fc				ld hl, display_fb1 
1986 22 fe fa				ld (display_fb_active), hl 
1989 cd 9e 0d				call update_display 
198c			 
198c				;ld a, (os_view_af) 
198c 2a d5 f0			ld hl, (os_view_hl) 
198f ed 5b d3 f0		ld de, (os_view_de) 
1993 ed 4b d1 f0		ld bc, (os_view_bc) 
1997 f1				pop af 
1998 c9				ret 
1999			 
1999			.bpschk:   
1999 cd c0 0c			call delay1s 
199c 3e 9f		ld a,display_row_4 + display_cols - 1 
199e 11 75 1f		        ld de, endprg 
19a1 cd 8e 0d			call str_at_display 
19a4 cd 9e 0d			call update_display 
19a7 cd 08 7b			call cin_wait 
19aa			 
19aa c3 fc 18			jp .bps1 
19ad			 
19ad			 
19ad			display_reg_state: 
19ad			 
19ad				; to restore afterwards 
19ad			 
19ad d5				push de 
19ae c5				push bc 
19af e5				push hl 
19b0 f5				push af 
19b1			 
19b1				; for use in here 
19b1			 
19b1 c5				push bc 
19b2 d5				push de 
19b3 e5				push hl 
19b4 f5				push af 
19b5			 
19b5 cd 7c 0d			call clear_display 
19b8			 
19b8 11 6d 1a			ld de, .regstate 
19bb 3e 00			ld a, display_row_1 
19bd cd 8e 0d			call str_at_display 
19c0			 
19c0				; display debug step 
19c0			 
19c0			 
19c0 11 9d fd			ld de, debug_mark 
19c3 3e 25			ld a, display_row_1+display_cols-3 
19c5 cd 8e 0d			call str_at_display 
19c8			 
19c8				; display a 
19c8 11 89 1a			ld de, .regstatea 
19cb 3e 28			ld a, display_row_2 
19cd cd 8e 0d			call str_at_display 
19d0			 
19d0 e1				pop hl 
19d1			;	ld h,0 
19d1			;	ld l, a 
19d1 3e 2b			ld a, display_row_2+3 
19d3 cd 54 18			call display_word_at 
19d6			 
19d6			 
19d6				; display hl 
19d6			 
19d6			 
19d6 11 7d 1a			ld de, .regstatehl 
19d9 3e 32			ld a, display_row_2+10 
19db cd 8e 0d			call str_at_display 
19de			 
19de e1				pop hl 
19df 3e 35			ld a, display_row_2+13 
19e1 cd 54 18			call display_word_at 
19e4			 
19e4				 
19e4				; display de 
19e4			 
19e4 11 81 1a			ld de, .regstatede 
19e7 3e 50			ld a, display_row_3 
19e9 cd 8e 0d			call str_at_display 
19ec			 
19ec e1				pop hl 
19ed			;	ld h,d 
19ed			;	ld l, e 
19ed 3e 53			ld a, display_row_3+3 
19ef cd 54 18			call display_word_at 
19f2			 
19f2			 
19f2				; display bc 
19f2			 
19f2 11 85 1a			ld de, .regstatebc 
19f5 3e 5a			ld a, display_row_3+10 
19f7 cd 8e 0d			call str_at_display 
19fa			 
19fa e1				pop hl 
19fb			;	ld h,b 
19fb			;	ld l, c 
19fb 3e 5d			ld a, display_row_3+13 
19fd cd 54 18			call display_word_at 
1a00			 
1a00			 
1a00				; display dsp 
1a00			 
1a00 11 8d 1a			ld de, .regstatedsp 
1a03 3e 78			ld a, display_row_4 
1a05 cd 8e 0d			call str_at_display 
1a08			 
1a08				 
1a08 2a 20 f9			ld hl,(cli_data_sp) 
1a0b 3e 7c			ld a, display_row_4+4 
1a0d cd 54 18			call display_word_at 
1a10			 
1a10				; display rsp 
1a10			 
1a10 11 92 1a			ld de, .regstatersp 
1a13 3e 82			ld a, display_row_4+10 
1a15 cd 8e 0d			call str_at_display 
1a18			 
1a18				 
1a18 2a 24 f9			ld hl,(cli_ret_sp) 
1a1b 3e 86			ld a, display_row_4+14 
1a1d cd 54 18			call display_word_at 
1a20			 
1a20 cd 9e 0d			call update_display 
1a23			 
1a23			;	call delay1s 
1a23			;	call delay1s 
1a23			;	call delay1s 
1a23			 
1a23			 
1a23			;	call next_page_prompt 
1a23			 
1a23				; restore  
1a23			 
1a23 f1				pop af 
1a24 e1				pop hl 
1a25 c1				pop bc 
1a26 d1				pop de 
1a27 c9				ret 
1a28			 
1a28 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1a3c .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1a51 .. 00		.ptrstate:	db "Ptr State",0 
1a5b .. 00		.ptrcliptr:     db "cli_ptr",0 
1a63 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1a6d .. 00		.regstate:	db "Reg State (1/0)",0 
1a7d .. 00		.regstatehl:	db "HL:",0 
1a81 .. 00		.regstatede:	db "DE:",0 
1a85 .. 00		.regstatebc:	db "BC:",0 
1a89 .. 00		.regstatea:	db "A :",0 
1a8d .. 00		.regstatedsp:	db "DSP:",0 
1a92 .. 00		.regstatersp:	db "RSP:",0 
1a97			 
1a97			display_dump_at_hl: 
1a97 e5				push hl 
1a98 d5				push de 
1a99 c5				push bc 
1a9a f5				push af 
1a9b			 
1a9b 22 16 f4			ld (os_cur_ptr),hl	 
1a9e cd 7c 0d			call clear_display 
1aa1 cd 83 1e			call dumpcont 
1aa4			;	call delay1s 
1aa4			;	call next_page_prompt 
1aa4			 
1aa4			 
1aa4 f1				pop af 
1aa5 c1				pop bc 
1aa6 d1				pop de 
1aa7 e1				pop hl 
1aa8 c9				ret 
1aa9			 
1aa9			;if ENABLE_BASIC 
1aa9			;	include "nascombasic.asm" 
1aa9			;	basic: 
1aa9			;	include "forth/FORTH.ASM" 
1aa9			;endif 
1aa9			 
1aa9			; eof 
1aa9			 
1aa9			 
# End of file firmware_diags.asm
1aa9			  
1aa9			include "firmware_prompts.asm"  
1aa9			; Prompts  
1aa9			 
1aa9			; boot messages 
1aa9			 
1aa9 .. 00		prom_bootmsg:	db "z80-homebrew OS v1.7",0 
1abe .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1ace			 
1ace			 
1ace			; config menus 
1ace			 
1ace			;prom_c3: db "Add Dictionary To File",0 
1ace			 
1ace			if STARTUP_V1 
1ace			prom_c2: db "Select Autoload File",0 
1ace			prom_c2a: db "Disable Autoload File", 0 
1ace			endif 
1ace			 
1ace			if STARTUP_V2 
1ace .. 00		prom_c2: db "Enable Autoload Files",0 
1ae4 .. 00		prom_c2a: db "Disable Autoload Files", 0 
1afb			 
1afb .. 00		crs_s1: db "*ls-word", 0 
1b04 .. 00		crs_s2: db "*ed-word", 0 
1b0d .. 00		crs_s3: db "*Demo-Games", 0 
1b19 .. 00		crs_s4: db "*Utils", 0 
1b20 .. 00		crs_s5: db "*SPI-Util", 0 
1b2a .. 00		crs_s6: db "*Key-Constants", 0 
1b39 .. 00		crs_sound: db "*Sound-Util", 0 
1b45 .. 00		crs_hw: db "*Hello-World",0 
1b52			 
1b52			 
1b52			 
1b52			endif 
1b52			;prom_c2b: db "Select Storage Bank",0 
1b52 .. 00		prom_c4: db "Settings",0 
1b5b .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
1b76 .. 00		prom_m4b:   db "Monitor",0 
1b7e			;prom_c1: db "Hardware Diags",0 
1b7e			 
1b7e			 
1b7e			if STARTUP_V2 
1b7e .. 00		prom_c9: db "Create Startup Files",0 
1b93 .. 00		prom_bsel: db "Start From Bank...",0 
1ba6 .. 00		prom_bsel1: db "Bank 1",0 
1bad .. 00		prom_bsel2: db "Bank 2",0 
1bb4 .. 00		prom_bsel3: db "Bank 3",0 
1bbb .. 00		prom_bsel4: db "Bank 4",0 
1bc2 .. 00		prom_bsel5: db "Bank 5",0 
1bc9			 
1bc9			prom_banks: 
1bc9 a6 1b			dw prom_bsel1 
1bcb ad 1b			dw prom_bsel2 
1bcd b4 1b			dw prom_bsel3 
1bcf bb 1b			dw prom_bsel4 
1bd1 c2 1b			dw prom_bsel5 
1bd3 00 00			dw 0 
1bd5			endif 
1bd5			 
1bd5 .. 00		prom_notav:    db "Feature not available",0 
1beb .. 00		prom_empty:    db "",0 
1bec			 
1bec			; eof 
1bec			 
# End of file firmware_prompts.asm
1bec			  
1bec			; eof  
1bec			  
# End of file firmware.asm
1bec			 
1bec			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
1bec			;if BASE_KEV  
1bec			;baseram: equ 08000h 
1bec			;endif 
1bec			 
1bec			;if BASE_SC114 
1bec			;baseram:     equ    endofcode 
1bec			;endif 
1bec			 
1bec			 
1bec			; Add NMI support. A rst 066h when r15z goes neg on clock side of resist. needs to do retn when exiting 
1bec			 
1bec			; start system 
1bec			 
1bec			coldstart: 
1bec				; set sp 
1bec				; di/ei 
1bec			 
1bec f3				di 
1bed 31 fd ff			ld sp, tos 
1bf0 cd 8f 77			call init_nmi 
1bf3			;	ei 
1bf3			 
1bf3				; init spinner 
1bf3 3e 00			ld a,0 
1bf5 32 f8 fa			ld (display_active), a 
1bf8			 
1bf8				; disable breakpoint by default 
1bf8			 
1bf8				;ld a,'*' 
1bf8			;	ld a,' ' 
1bf8			;	ld (os_view_disable),a 
1bf8			 
1bf8				; set break point vector as new break point on or off 
1bf8 cd da 18			call bp_off 
1bfb			 
1bfb			 
1bfb				; default the parse vector to just a RET 
1bfb 3e c9			ld a, $c9 
1bfd 32 a7 fd			ld (parse_vector), a 
1c00			 
1c00				; init hardware 
1c00			 
1c00				; init keyboard and screen hardware 
1c00			 
1c00 cd 6c 00			call hardware_init 
1c03			 
1c03			 
1c03 cd c0 0c			call delay1s 
1c06 3e 58			ld a, display_row_3+8 
1c08 11 03 00			ld de, buildtime 
1c0b cd 8e 0d			call str_at_display 
1c0e cd 9e 0d			call update_display 
1c11			 
1c11 cd c0 0c			call delay1s 
1c14 cd c0 0c			call delay1s 
1c17 cd c0 0c			call delay1s 
1c1a			 
1c1a				; detect if any keys are held down to enable breakpoints at start up 
1c1a			 
1c1a cd 17 7b			call cin  
1c1d fe 00			cp 0 
1c1f 28 03			jr z, .nokeys 
1c21			 
1c21				;call hardware_diags 
1c21 cd 11 15			call config 
1c24			 
1c24			;	ld de, .bpen 
1c24			;	ld a, display_row_4 
1c24			;	call str_at_display 
1c24			;	call update_display 
1c24			; 
1c24			;	ld a,0 
1c24			;	ld (os_view_disable),a 
1c24			; 
1c24			;.bpwait: 
1c24			;	call cin 
1c24			;	cp 0 
1c24			;	jr z, .bpwait 
1c24			;	jr .nokeys 
1c24			; 
1c24			; 
1c24			;.bpen:  db "Break points enabled!",0 
1c24			 
1c24			 
1c24			 
1c24			 
1c24			 
1c24			 
1c24			.nokeys: 
1c24			 
1c24			 
1c24				 
1c24			 
1c24			;jp  testkey 
1c24			 
1c24			;call storage_get_block_0 
1c24			; 
1c24			;ld hl, 0 
1c24			;ld de, store_page 
1c24			;call storage_read_block 
1c24			 
1c24				 
1c24			;ld hl, 10 
1c24			;ld de, store_page 
1c24			;call storage_read_block 
1c24			 
1c24			 
1c24			 
1c24			 
1c24			 
1c24			;stop:	nop 
1c24			;	jp stop 
1c24			 
1c24			 
1c24			 
1c24			main: 
1c24 cd 7c 0d			call clear_display 
1c27 cd 9e 0d			call update_display 
1c2a			 
1c2a			 
1c2a			 
1c2a			;	call testlcd 
1c2a			 
1c2a			 
1c2a			 
1c2a cd b2 23			call forth_init 
1c2d			 
1c2d			 
1c2d			warmstart: 
1c2d cd 88 23			call forth_warmstart 
1c30			 
1c30				; run startup word load 
1c30			        ; TODO prevent this running at warmstart after crash  
1c30			 
1c30				if STARTUP_ENABLE 
1c30			 
1c30					if STARTUP_V1 
1c30			 
1c30						if STORAGE_SE 
1c30							call forth_autoload 
1c30						endif 
1c30						call forth_startup 
1c30					endif 
1c30			 
1c30					if STARTUP_V2 
1c30			 
1c30						if STORAGE_SE 
1c30 cd b9 75						call forth_autoload 
1c33						else 
1c33							call forth_startup 
1c33						endif 
1c33			 
1c33			 
1c33					endif 
1c33			 
1c33				endif 
1c33			 
1c33			warmstart_afterauto: 
1c33			 
1c33				; show free memory after boot 
1c33 11 d0 1c			ld de, freeram 
1c36 3e 00			ld a, display_row_1 
1c38 cd 8e 0d			call str_at_display 
1c3b			 
1c3b				; get current heap start after loading any uwords 
1c3b			 
1c3b				;ld de, (os_last_new_uword) 
1c3b				;ex de, hl 
1c3b			 
1c3b			; Or use heap_size word???? 
1c3b				;ld hl, heap_end 
1c3b				;ld hl, heap_size 
1c3b				;ld de, topusermem 
1c3b				;ld de, heap_start 
1c3b ed 5b 0a 80			ld de, (free_list )      
1c3f 21 ce f0				ld hl, heap_end 
1c42 ed 52			sbc hl, de 
1c44				;push hl 
1c44				;ld a,h	         	 
1c44				;ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1c44				;call hexout 
1c44			   	;pop hl 
1c44			; 
1c44			;	ld a,l 
1c44			;	ld hl, os_word_scratch+2 
1c44			;	call hexout 
1c44			;	ld hl, os_word_scratch+4 
1c44			;	ld a, 0 
1c44			;	ld (hl),a 
1c44 eb				ex de, hl 
1c45 21 f8 f3			ld hl, os_word_scratch 
1c48 cd b3 12			call uitoa_16 
1c4b			 
1c4b			 
1c4b 11 f8 f3			ld de, os_word_scratch 
1c4e 3e 0d			ld a, display_row_1 + 13 
1c50 cd 8e 0d			call str_at_display 
1c53 cd 9e 0d			call update_display 
1c56			 
1c56			 
1c56				;call demo 
1c56			 
1c56			 
1c56				; init scratch input area for cli commands 
1c56			 
1c56 21 1a f4			ld hl, os_cli_cmd 
1c59			;	ld a,0 
1c59 36 00			ld (hl),0 
1c5b 23				inc hl 
1c5c 36 00			ld (hl),0 
1c5e			 
1c5e 3e 00			ld a,0 
1c60 32 19 f5			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1c63			 
1c63 32 16 f4			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1c66 32 17 f4			ld (os_cur_ptr+1),a	 
1c69			 
1c69 32 f8 f3			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1c6c 32 f9 f3			ld (os_word_scratch+1),a	 
1c6f				 
1c6f			 
1c6f				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c6f 21 1a f4			ld hl, os_cli_cmd 
1c72			 
1c72			;	ld a, 0		 ; init cli input 
1c72 36 00			ld (hl), 0 
1c74 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1c76			cli: 
1c76				; show cli prompt 
1c76				;push af 
1c76				;ld a, 0 
1c76				;ld de, prompt 
1c76				;call str_at_display 
1c76			 
1c76				;call update_display 
1c76				;pop af 
1c76				;inc a 
1c76				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1c76			 
1c76			.lastrecall: 
1c76			 
1c76 0e 00			ld c, 0 
1c78 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1c7a 1e 28			ld e, 40 
1c7c			 
1c7c 21 1a f4			ld hl, os_cli_cmd 
1c7f			 
1c7f				STACKFRAME OFF $fefe $9f9f 
1c7f				if DEBUG_STACK_IMB 
1c7f					if OFF 
1c7f						exx 
1c7f						ld de, $fefe 
1c7f						ld a, d 
1c7f						ld hl, curframe 
1c7f						call hexout 
1c7f						ld a, e 
1c7f						ld hl, curframe+2 
1c7f						call hexout 
1c7f						ld hl, $fefe 
1c7f						push hl 
1c7f						ld hl, $9f9f 
1c7f						push hl 
1c7f						exx 
1c7f					endif 
1c7f				endif 
1c7f			endm 
# End of macro STACKFRAME
1c7f			 
1c7f cd d9 0f			call input_str 
1c82			 
1c82				STACKFRAMECHK OFF $fefe $9f9f 
1c82				if DEBUG_STACK_IMB 
1c82					if OFF 
1c82						exx 
1c82						ld hl, $9f9f 
1c82						pop de   ; $9f9f 
1c82						call cmp16 
1c82						jr nz, .spnosame 
1c82						ld hl, $fefe 
1c82						pop de   ; $fefe 
1c82						call cmp16 
1c82						jr z, .spfrsame 
1c82						.spnosame: call showsperror 
1c82						.spfrsame: nop 
1c82						exx 
1c82					endif 
1c82				endif 
1c82			endm 
# End of macro STACKFRAMECHK
1c82			 
1c82			 
1c82				; check to see if last line recall has been requested 
1c82			 
1c82			if EDIT_V2 
1c82 fe 05			cp KEY_UP 
1c84 20 0f			jr nz, .noexecline 
1c86			 
1c86 11 1a f4			ld de, os_cli_cmd 
1c89 21 19 f5			ld hl, os_last_cmd 
1c8c 01 ff 00			ld bc, 255 
1c8f ed b0			ldir 
1c91 3e 00			ld a, 0 
1c93 18 e1			jr .lastrecall 
1c95			endif 
1c95			 
1c95			.noexecline: 
1c95				; no so exec the line		 
1c95			 
1c95				; copy input to last command 
1c95			 
1c95 21 1a f4			ld hl, os_cli_cmd 
1c98 11 19 f5			ld de, os_last_cmd 
1c9b 01 ff 00			ld bc, 255 
1c9e ed b0			ldir 
1ca0			 
1ca0				; wipe current buffer 
1ca0			 
1ca0			;	ld a, 0 
1ca0			;	ld hl, os_cli_cmd 
1ca0			;	ld de, os_cli_cmd+1 
1ca0			;	ld bc, 254 
1ca0			;	ldir 
1ca0				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1ca0			;	call strcpy 
1ca0			;	ld a, 0 
1ca0			;	ld (hl), a 
1ca0			;	inc hl 
1ca0			;	ld (hl), a 
1ca0			;	inc hl 
1ca0			;	ld (hl), a 
1ca0			 
1ca0				; switch frame buffer to program  
1ca0			 
1ca0 21 42 fc				ld hl, display_fb1 
1ca3 22 fe fa				ld (display_fb_active), hl 
1ca6			 
1ca6			;	nop 
1ca6				STACKFRAME ON $fbfe $8f9f 
1ca6				if DEBUG_STACK_IMB 
1ca6					if ON 
1ca6						exx 
1ca6						ld de, $fbfe 
1ca6						ld a, d 
1ca6						ld hl, curframe 
1ca6						call hexout 
1ca6						ld a, e 
1ca6						ld hl, curframe+2 
1ca6						call hexout 
1ca6						ld hl, $fbfe 
1ca6						push hl 
1ca6						ld hl, $8f9f 
1ca6						push hl 
1ca6						exx 
1ca6					endif 
1ca6				endif 
1ca6			endm 
# End of macro STACKFRAME
1ca6				; first time into the parser so pass over the current scratch pad 
1ca6 21 1a f4			ld hl,os_cli_cmd 
1ca9				; tokenise the entered statement(s) in HL 
1ca9 cd 28 24			call forthparse 
1cac			        ; exec forth statements in top of return stack 
1cac cd 60 24			call forthexec 
1caf				;call forthexec_cleanup 
1caf			;	call parsenext 
1caf			 
1caf				STACKFRAMECHK ON $fbfe $8f9f 
1caf				if DEBUG_STACK_IMB 
1caf					if ON 
1caf						exx 
1caf						ld hl, $8f9f 
1caf						pop de   ; $8f9f 
1caf						call cmp16 
1caf						jr nz, .spnosame 
1caf						ld hl, $fbfe 
1caf						pop de   ; $fbfe 
1caf						call cmp16 
1caf						jr z, .spfrsame 
1caf						.spnosame: call showsperror 
1caf						.spfrsame: nop 
1caf						exx 
1caf					endif 
1caf				endif 
1caf			endm 
# End of macro STACKFRAMECHK
1caf				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1caf			 
1caf 3e 78			ld a, display_row_4 
1cb1 11 e1 1c			ld de, endprog 
1cb4			 
1cb4 cd 9e 0d			call update_display		 
1cb7			 
1cb7 cd 77 1f			call next_page_prompt 
1cba			 
1cba				; switch frame buffer to cli 
1cba			 
1cba 21 e3 fc				ld hl, display_fb0 
1cbd 22 fe fa				ld (display_fb_active), hl 
1cc0			 
1cc0			 
1cc0 cd 7c 0d		        call clear_display 
1cc3 cd 9e 0d			call update_display		 
1cc6			 
1cc6 21 1a f4			ld hl, os_cli_cmd 
1cc9			 
1cc9			;	ld a, 0		 ; init cli input 
1cc9 36 00			ld (hl), 0 
1ccb			 
1ccb				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
1ccb			 
1ccb				; now on last line 
1ccb			 
1ccb				; TODO scroll screen up 
1ccb			 
1ccb				; TODO instead just clear screen and place at top of screen 
1ccb			 
1ccb			;	ld a, 0 
1ccb			;	ld (f_cursor_ptr),a 
1ccb			 
1ccb				;call clear_display 
1ccb				;call update_display 
1ccb			 
1ccb				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ccb 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1ccd c3 76 1c			jp cli 
1cd0			 
1cd0 .. 00		freeram: db "Free bytes: ",0 
1cdd ..			asc: db "1A2F" 
1ce1 .. 00		endprog: db "End prog...",0 
1ced			 
1ced			testenter2:   
1ced 21 25 f1			ld hl,scratch+50 
1cf0 22 16 f4			ld (os_cur_ptr),hl 
1cf3 c3 76 1c			jp cli 
1cf6			 
1cf6			testenter:  
1cf6			 
1cf6 21 dd 1c			ld hl,asc 
1cf9			;	ld a,(hl) 
1cf9			;	call nibble2val 
1cf9 cd fe 11			call get_byte 
1cfc			 
1cfc			 
1cfc			;	ld a,(hl) 
1cfc			;	call atohex 
1cfc			 
1cfc			;	call fourehexhl 
1cfc 32 25 f1			ld (scratch+50),a 
1cff			 
1cff			 
1cff			 
1cff 21 df 1c			ld hl,asc+2 
1d02			;	ld a, (hl) 
1d02			;	call nibble2val 
1d02 cd fe 11			call get_byte 
1d05			 
1d05			;	call fourehexhl 
1d05 32 27 f1			ld (scratch+52),a 
1d08				 
1d08 21 25 f1			ld hl,scratch+50 
1d0b 22 16 f4			ld (os_cur_ptr),hl 
1d0e c3 76 1c			jp cli 
1d11			 
1d11			enter:	 
1d11 3a f7 f0			ld a,(scratch+4) 
1d14 fe 00			cp 0 
1d16 28 0c			jr z, .entercont 
1d18				; no, not a null term line so has an address to work out.... 
1d18			 
1d18 21 f5 f0			ld hl,scratch+2 
1d1b cd 5e 12			call get_word_hl 
1d1e			 
1d1e 22 16 f4			ld (os_cur_ptr),hl	 
1d21 c3 76 1c			jp cli 
1d24			 
1d24			 
1d24			.entercont:  
1d24			 
1d24 21 f5 f0			ld hl, scratch+2 
1d27 cd fe 11			call get_byte 
1d2a			 
1d2a 2a 16 f4		   	ld hl,(os_cur_ptr) 
1d2d 77					ld (hl),a 
1d2e 23					inc hl 
1d2f 22 16 f4				ld (os_cur_ptr),hl 
1d32				 
1d32			; get byte  
1d32			 
1d32			 
1d32 c3 76 1c			jp cli 
1d35			 
1d35			 
1d35			; basic monitor support 
1d35			 
1d35			monitor: 
1d35				;  
1d35 cd 7c 0d			call clear_display 
1d38 3e 00			ld a, 0 
1d3a 11 8e 1d			ld de, .monprompt 
1d3d cd 8e 0d			call str_at_display 
1d40 cd 9e 0d			call update_display 
1d43			 
1d43				; get a monitor command 
1d43			 
1d43 0e 00			ld c, 0     ; entry at top left 
1d45 16 64			ld d, 100   ; max buffer size 
1d47 1e 0f			ld e, 15    ; input scroll area 
1d49			;	ld a, 0     ; init string 
1d49 21 f1 f2			ld hl, os_input 
1d4c 36 00			ld (hl), 0 
1d4e 23				inc hl 
1d4f 36 00			ld (hl), 0 
1d51 21 f1 f2			ld hl, os_input 
1d54 3e 01			ld a, 1     ; init string 
1d56 cd d9 0f			call input_str 
1d59			 
1d59 cd 7c 0d		        call clear_display 
1d5c cd 9e 0d			call update_display		 
1d5f			 
1d5f 3a f1 f2			ld a, (os_input) 
1d62 cd fb 12			call toUpper 
1d65 fe 48		        cp 'H' 
1d67 ca 02 1e		        jp z, .monhelp 
1d6a fe 44			cp 'D'		; dump 
1d6c ca 35 1e			jp z, .mondump	 
1d6f fe 43			cp 'C'		; dump 
1d71 ca 4f 1e			jp z, .moncdump	 
1d74 fe 4d			cp 'M'		; dump 
1d76 ca 90 1d			jp z, .moneditstart 
1d79 fe 55			cp 'U'		; dump 
1d7b ca 9c 1d			jp z, .monedit	 
1d7e fe 47			cp 'G'		; dump 
1d80 ca 2b 1e			jp z, .monjump 
1d83 fe 42			cp 'B'		; forth breakpoint 
1d85 cc e0 18			call z, break_point_state 
1d88 fe 51			cp 'Q'		; dump 
1d8a c8				ret z	 
1d8b			 
1d8b			 
1d8b				; TODO "S" to access symbol by name and not need the address 
1d8b				; TODO "F" to find a string in memory 
1d8b			 
1d8b c3 35 1d			jp monitor 
1d8e			 
1d8e .. 00		.monprompt: db ">", 0 
1d90			 
1d90			.moneditstart: 
1d90				; get starting address 
1d90			 
1d90 21 f3 f2			ld hl,os_input+2 
1d93 cd 5e 12			call get_word_hl 
1d96			 
1d96 22 16 f4			ld (os_cur_ptr),hl	 
1d99			 
1d99 c3 35 1d			jp monitor 
1d9c			 
1d9c			.monedit: 
1d9c				; get byte to load 
1d9c			 
1d9c 21 f3 f2			ld hl,os_input+2 
1d9f cd fe 11			call get_byte 
1da2			 
1da2				; get address to update 
1da2 2a 16 f4			ld hl, (os_cur_ptr) 
1da5			 
1da5				; update byte 
1da5			 
1da5 77				ld (hl), a 
1da6			 
1da6				; move to next address and save it 
1da6			 
1da6 23				inc hl 
1da7 22 16 f4			ld (os_cur_ptr),hl	 
1daa			 
1daa c3 35 1d			jp monitor 
1dad			 
1dad			 
1dad .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1dc1 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
1ddd .. 00		.monhelptext3:  db "G-Call address, B-Breakpoints",0 
1dfb .. 00		.monhelptext4:  db "Q-Quit",0 
1e02			        
1e02			.monhelp: 
1e02 3e 00			ld a, display_row_1 
1e04 11 ad 1d		        ld de, .monhelptext1 
1e07			 
1e07 cd 8e 0d			call str_at_display 
1e0a 3e 28			ld a, display_row_2 
1e0c 11 c1 1d		        ld de, .monhelptext2 
1e0f					 
1e0f cd 8e 0d			call str_at_display 
1e12 3e 50			ld a, display_row_3 
1e14 11 dd 1d		        ld de, .monhelptext3 
1e17					 
1e17 cd 8e 0d			call str_at_display 
1e1a 3e 78			ld a, display_row_4 
1e1c 11 fb 1d		        ld de, .monhelptext4 
1e1f cd 8e 0d			call str_at_display 
1e22			 
1e22 cd 9e 0d			call update_display		 
1e25			 
1e25 cd 77 1f			call next_page_prompt 
1e28 c3 35 1d			jp monitor 
1e2b			 
1e2b			.monjump:    
1e2b 21 f3 f2			ld hl,os_input+2 
1e2e cd 5e 12			call get_word_hl 
1e31			 
1e31 e9				jp (hl) 
1e32 c3 35 1d			jp monitor 
1e35			 
1e35			.mondump:    
1e35 21 f3 f2			ld hl,os_input+2 
1e38 cd 5e 12			call get_word_hl 
1e3b			 
1e3b 22 16 f4			ld (os_cur_ptr),hl	 
1e3e cd 83 1e			call dumpcont 
1e41 3e 78			ld a, display_row_4 
1e43 11 e1 1c			ld de, endprog 
1e46			 
1e46 cd 9e 0d			call update_display		 
1e49			 
1e49 cd 77 1f			call next_page_prompt 
1e4c c3 35 1d			jp monitor 
1e4f			.moncdump: 
1e4f cd 83 1e			call dumpcont 
1e52 3e 78			ld a, display_row_4 
1e54 11 e1 1c			ld de, endprog 
1e57			 
1e57 cd 9e 0d			call update_display		 
1e5a			 
1e5a cd 77 1f			call next_page_prompt 
1e5d c3 35 1d			jp monitor 
1e60			 
1e60			 
1e60			; TODO symbol access  
1e60			 
1e60			.symbols:     ;; A list of symbols that can be called up  
1e60 e3 fc			dw display_fb0 
1e62 .. 00			db "fb0",0  
1e66 ac f9		     	dw store_page 
1e68 .. 00			db "store_page",0 
1e73			 
1e73			 
1e73			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1e73			 
1e73 3a f4 f0			ld a,(scratch+1) 
1e76 fe 00			cp 0 
1e78 28 09			jr z, dumpcont 
1e7a			 
1e7a				; no, not a null term line so has an address to work out.... 
1e7a			 
1e7a 21 f5 f0			ld hl,scratch+2 
1e7d cd 5e 12			call get_word_hl 
1e80			 
1e80 22 16 f4			ld (os_cur_ptr),hl	 
1e83			 
1e83			 
1e83			 
1e83			dumpcont: 
1e83			 
1e83				; dump bytes at ptr 
1e83			 
1e83			 
1e83 3e 00			ld a, display_row_1 
1e85 2a fe fa			ld hl, (display_fb_active) 
1e88 cd ac 0f			call addatohl 
1e8b cd b3 1e			call .dumpbyterow 
1e8e			 
1e8e 3e 28			ld a, display_row_2 
1e90 2a fe fa			ld hl, (display_fb_active) 
1e93 cd ac 0f			call addatohl 
1e96 cd b3 1e			call .dumpbyterow 
1e99			 
1e99			 
1e99 3e 50			ld a, display_row_3 
1e9b 2a fe fa			ld hl, (display_fb_active) 
1e9e cd ac 0f			call addatohl 
1ea1 cd b3 1e			call .dumpbyterow 
1ea4			 
1ea4 3e 78			ld a, display_row_4 
1ea6 2a fe fa			ld hl, (display_fb_active) 
1ea9 cd ac 0f			call addatohl 
1eac cd b3 1e			call .dumpbyterow 
1eaf			 
1eaf cd 9e 0d			call update_display 
1eb2			;		jp cli 
1eb2 c9				ret 
1eb3			 
1eb3			.dumpbyterow: 
1eb3			 
1eb3				;push af 
1eb3			 
1eb3 e5				push hl 
1eb4			 
1eb4				; calc where to poke the ascii 
1eb4			if display_cols == 20 
1eb4				ld a, 16 
1eb4			else 
1eb4 3e 1f			ld a, 31 
1eb6			endif 
1eb6			 
1eb6 cd ac 0f			call addatohl 
1eb9 22 f8 f3			ld (os_word_scratch),hl  		; save pos for later 
1ebc			 
1ebc			 
1ebc			; display decoding address 
1ebc 2a 16 f4		   	ld hl,(os_cur_ptr) 
1ebf			 
1ebf 7c				ld a,h 
1ec0 e1				pop hl 
1ec1 e5				push hl 
1ec2			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1ec2 cd a8 11			call hexout 
1ec5 2a 16 f4		   	ld hl,(os_cur_ptr) 
1ec8			 
1ec8 7d				ld a,l 
1ec9 e1				pop hl 
1eca 23				inc hl 
1ecb 23				inc hl 
1ecc e5				push hl 
1ecd			;	ld hl, os_word_scratch+2 
1ecd cd a8 11			call hexout 
1ed0 e1				pop hl 
1ed1 23				inc hl 
1ed2 23				inc hl 
1ed3				;ld hl, os_word_scratch+4 
1ed3			;	ld a, ':' 
1ed3 36 3a			ld (hl),':' 
1ed5 23				inc hl 
1ed6				;ld a, 0 
1ed6				;ld (hl),a 
1ed6				;ld de, os_word_scratch 
1ed6				;pop af 
1ed6				;push af 
1ed6			;		ld a, display_row_2 
1ed6			;		call str_at_display 
1ed6			;		call update_display 
1ed6			 
1ed6			 
1ed6			;pop af 
1ed6			;	add 5 
1ed6			 
1ed6			if display_cols == 20 
1ed6				ld b, 4 
1ed6			else 
1ed6 06 08			ld b, 8 
1ed8			endif	 
1ed8			 
1ed8			.dumpbyte: 
1ed8 c5				push bc 
1ed9 e5				push hl 
1eda			 
1eda			 
1eda 2a 16 f4		   	ld hl,(os_cur_ptr) 
1edd 7e					ld a,(hl) 
1ede			 
1ede					; poke the ascii to display 
1ede 2a f8 f3				ld hl,(os_word_scratch) 
1ee1 77					ld (hl),a 
1ee2 23					inc hl 
1ee3 22 f8 f3				ld (os_word_scratch),hl 
1ee6			 
1ee6					 
1ee6			 
1ee6			 
1ee6 e1					pop hl 
1ee7 e5					push hl 
1ee8			 
1ee8 cd a8 11				call hexout 
1eeb			 
1eeb					 
1eeb 2a 16 f4		   	ld hl,(os_cur_ptr) 
1eee 23				inc hl 
1eef 22 16 f4		   	ld (os_cur_ptr),hl 
1ef2			 
1ef2 e1					pop hl 
1ef3 23					inc hl 
1ef4 23					inc hl 
1ef5 23					inc hl 
1ef6			 
1ef6			 
1ef6			 
1ef6					;ld a,0 
1ef6					;ld (os_word_scratch+2),a 
1ef6					;pop af 
1ef6					;push af 
1ef6			 
1ef6					;ld de, os_word_scratch 
1ef6					;call str_at_display 
1ef6			;		call update_display 
1ef6			;		pop af 
1ef6 c1					pop bc 
1ef7 c6 03				add 3 
1ef9 10 dd			djnz .dumpbyte 
1efb			 
1efb				 
1efb			 
1efb c9				ret 
1efc			 
1efc			jump:	 
1efc			 
1efc 21 f5 f0			ld hl,scratch+2 
1eff cd 5e 12			call get_word_hl 
1f02				;ld hl,(scratch+2) 
1f02				;call fourehexhl 
1f02			 
1f02 22 16 f4			ld (os_cur_ptr),hl	 
1f05			 
1f05 e9				jp (hl) 
1f06			 
1f06			 
1f06			 
1f06			; TODO implement a basic monitor mode to start with 
1f06			 
1f06			 
1f06			 
1f06			 
1f06			 
1f06			 
1f06			 
1f06			 
1f06			 
1f06			; testing and demo code during development 
1f06			 
1f06			 
1f06 .. 00		str1: db "Enter some text...",0 
1f19 .. 00		clear: db "                    ",0 
1f2e			 
1f2e			demo: 
1f2e			 
1f2e			 
1f2e			 
1f2e			;	call update_display 
1f2e			 
1f2e				; init scratch input area for testing 
1f2e 21 f3 f0			ld hl, scratch	 
1f31			;	ld a,0 
1f31 36 00			ld (hl),0 
1f33			 
1f33			 
1f33 3e 28		            LD   A, display_row_2 
1f35			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f35 11 06 1f		            LD   DE, str1 
1f38 cd 8e 0d			call str_at_display 
1f3b			 
1f3b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f3b			cloop:	 
1f3b 3e 50		            LD   A, display_row_3 
1f3d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f3d 11 19 1f		            LD   DE, clear 
1f40			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1f40 cd 8e 0d				call str_at_display 
1f43 3e 78			ld a, display_row_4 
1f45 11 73 1f			ld de, prompt 
1f48			 
1f48 cd 8e 0d				call str_at_display 
1f4b cd 9e 0d			call update_display 
1f4e			 
1f4e 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1f50 16 0a			ld d, 10 
1f52 21 f3 f0			ld hl, scratch	 
1f55 cd d9 0f			call input_str 
1f58			 
1f58			;	call clear_display 
1f58			;'	call update_display 
1f58			 
1f58 3e 00		            LD   A, display_row_1 
1f5a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f5a 11 19 1f		            LD   DE, clear 
1f5d cd 8e 0d				call str_at_display 
1f60			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f60 3e 00		            LD   A, display_row_1 
1f62			;            CALL fLCD_Pos       ;Position cursor to location in A 
1f62 11 f3 f0		            LD   DE, scratch 
1f65			;            CALL fLCD_Str       ;Display string pointed to by DE 
1f65 cd 8e 0d				call str_at_display 
1f68 cd 9e 0d			call update_display 
1f6b			 
1f6b			;		ld a,0 
1f6b 21 f3 f0			ld hl, scratch 
1f6e 36 00			ld (hl),0 
1f70			 
1f70			;	nop 
1f70 c3 3b 1f			jp cloop 
1f73			 
1f73			 
1f73			 
1f73			; OS Prompt 
1f73			 
1f73 .. 00		prompt: db ">",0 
1f75 .. 00		endprg: db "?",0 
1f77			 
1f77			 
1f77			; handy next page prompt 
1f77			next_page_prompt: 
1f77 e5				push hl 
1f78 d5				push de 
1f79 f5				push af 
1f7a c5				push bc 
1f7b			 
1f7b 3e 9f			ld a,display_row_4 + display_cols - 1 
1f7d 11 75 1f		        ld de, endprg 
1f80 cd 8e 0d			call str_at_display 
1f83 cd 9e 0d			call update_display 
1f86 cd 08 7b			call cin_wait 
1f89 c1				pop bc 
1f8a f1				pop af 
1f8b d1				pop de 
1f8c e1				pop hl 
1f8d			 
1f8d			 
1f8d c9				ret 
1f8e			 
1f8e			 
1f8e			; forth parser 
1f8e			 
1f8e			; My forth kernel 
1f8e			include "forth_kernel.asm" 
1f8e			; 
1f8e			; kernel to the forth OS 
1f8e			 
1f8e			DS_TYPE_STR: equ 1     ; string type 
1f8e			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1f8e			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1f8e			DS_TYPE_CONST: equ 4     ; string type that won't be freed on a POP 
1f8e			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1f8e			 
1f8e			FORTH_PARSEV1: equ 0 
1f8e			FORTH_PARSEV2: equ 0 
1f8e			FORTH_PARSEV3: equ 0 
1f8e			FORTH_PARSEV4: equ 0 
1f8e			FORTH_PARSEV5: equ 0 
1f8e			FORTH_PARSEV6: equ 1 
1f8e			 
1f8e			;if FORTH_PARSEV5 
1f8e			;	FORTH_END_BUFFER: equ 0 
1f8e			;else 
1f8e			FORTH_END_BUFFER: equ 127 
1f8e			;endif 
1f8e			 
1f8e			FORTH_TRUE: equ 1 
1f8e			FORTH_FALSE: equ 0 
1f8e			 
1f8e			if FORTH_PARSEV4 
1f8e			include "forth_stackops.asm" 
1f8e			endif 
1f8e			 
1f8e			if FORTH_PARSEV5 
1f8e			include "forth_stackopsv5.asm" 
1f8e			endif 
1f8e			 
1f8e			if FORTH_PARSEV6 
1f8e			include "forth_stackopsv5.asm" 
1f8e			 
1f8e			; Stack operations for v5 parser on wards 
1f8e			; * DATA stack 
1f8e			; * LOOP stack 
1f8e			; * RETURN stack 
1f8e			 
1f8e			 
1f8e			 
1f8e			FORTH_CHK_DSP_UNDER: macro 
1f8e				push hl 
1f8e				push de 
1f8e				ld hl,(cli_data_sp) 
1f8e				ld de, cli_data_stack 
1f8e				call cmp16 
1f8e				jp c, fault_dsp_under 
1f8e				pop de 
1f8e				pop hl 
1f8e				endm 
1f8e			 
1f8e			 
1f8e			FORTH_CHK_RSP_UNDER: macro 
1f8e				push hl 
1f8e				push de 
1f8e				ld hl,(cli_ret_sp) 
1f8e				ld de, cli_ret_stack 
1f8e				call cmp16 
1f8e				jp c, fault_rsp_under 
1f8e				pop de 
1f8e				pop hl 
1f8e				endm 
1f8e			 
1f8e			FORTH_CHK_LOOP_UNDER: macro 
1f8e				push hl 
1f8e				push de 
1f8e				ld hl,(cli_loop_sp) 
1f8e				ld de, cli_loop_stack 
1f8e				call cmp16 
1f8e				jp c, fault_loop_under 
1f8e				pop de 
1f8e				pop hl 
1f8e				endm 
1f8e			 
1f8e			FORTH_ERR_TOS_NOTSTR: macro 
1f8e				; TOSO might need more for checks when used 
1f8e				push af 
1f8e				ld a,(hl) 
1f8e				cp DS_TYPE_STR 
1f8e				jp nz, type_faultn   
1f8e				pop af 
1f8e				endm 
1f8e			 
1f8e			FORTH_ERR_TOS_NOTNUM: macro 
1f8e				push af 
1f8e				ld a,(hl) 
1f8e				cp DS_TYPE_INUM 
1f8e				jp nz, type_faultn   
1f8e				pop af 
1f8e				endm 
1f8e			 
1f8e			 
1f8e			; increase data stack pointer and save hl to it 
1f8e				 
1f8e			FORTH_DSP_NEXT: macro 
1f8e				call macro_forth_dsp_next 
1f8e				endm 
1f8e			 
1f8e			 
1f8e			macro_forth_dsp_next: 
1f8e				if DEBUG_FORTH_STACK_GUARD 
1f8e cd a8 73				call check_stacks 
1f91				endif 
1f91 e5				push hl 
1f92 d5				push de 
1f93 eb				ex de,hl 
1f94 2a 20 f9			ld hl,(cli_data_sp) 
1f97 23				inc hl 
1f98 23				inc hl 
1f99			 
1f99			; PARSEV5 
1f99 23				inc hl 
1f9a 22 20 f9			ld (cli_data_sp),hl 
1f9d 73				ld (hl), e 
1f9e 23				inc hl 
1f9f 72				ld (hl), d 
1fa0 d1				pop de 
1fa1 e1				pop hl 
1fa2				if DEBUG_FORTH_STACK_GUARD 
1fa2 cd a8 73				call check_stacks 
1fa5				endif 
1fa5 c9				ret 
1fa6			 
1fa6			 
1fa6			; increase ret stack pointer and save hl to it 
1fa6				 
1fa6			FORTH_RSP_NEXT: macro 
1fa6				call macro_forth_rsp_next 
1fa6				endm 
1fa6			 
1fa6			macro_forth_rsp_next: 
1fa6				if DEBUG_FORTH_STACK_GUARD 
1fa6 cd a8 73				call check_stacks 
1fa9				endif 
1fa9 e5				push hl 
1faa d5				push de 
1fab eb				ex de,hl 
1fac 2a 24 f9			ld hl,(cli_ret_sp) 
1faf 23				inc hl 
1fb0 23				inc hl 
1fb1 22 24 f9			ld (cli_ret_sp),hl 
1fb4 73				ld (hl), e 
1fb5 23				inc hl 
1fb6 72				ld (hl), d 
1fb7 d1				pop de 
1fb8 e1				pop hl 
1fb9				if DEBUG_FORTH_STACK_GUARD 
1fb9 cd a8 73				call check_stacks 
1fbc				endif 
1fbc c9				ret 
1fbd			 
1fbd			; get current ret stack pointer and save to hl  
1fbd				 
1fbd			FORTH_RSP_TOS: macro 
1fbd				call macro_forth_rsp_tos 
1fbd				endm 
1fbd			 
1fbd			macro_forth_rsp_tos: 
1fbd				;push de 
1fbd 2a 24 f9			ld hl,(cli_ret_sp) 
1fc0 cd f8 1f			call loadhlptrtohl 
1fc3				;ld e, (hl) 
1fc3				;inc hl 
1fc3				;ld d, (hl) 
1fc3				;ex de, hl 
1fc3					if DEBUG_FORTH_WORDS 
1fc3			;			DMARK "RST" 
1fc3						CALLMONITOR 
1fc3 cd aa fd			call debug_vector  
1fc6				endm  
# End of macro CALLMONITOR
1fc6					endif 
1fc6				;pop de 
1fc6 c9				ret 
1fc7			 
1fc7			; pop ret stack pointer 
1fc7				 
1fc7			FORTH_RSP_POP: macro 
1fc7				call macro_forth_rsp_pop 
1fc7				endm 
1fc7			 
1fc7			 
1fc7			macro_forth_rsp_pop: 
1fc7				if DEBUG_FORTH_STACK_GUARD 
1fc7			;		DMARK "RPP" 
1fc7 cd a8 73				call check_stacks 
1fca					FORTH_CHK_RSP_UNDER 
1fca e5				push hl 
1fcb d5				push de 
1fcc 2a 24 f9			ld hl,(cli_ret_sp) 
1fcf 11 de f8			ld de, cli_ret_stack 
1fd2 cd ca 0f			call cmp16 
1fd5 da bf 74			jp c, fault_rsp_under 
1fd8 d1				pop de 
1fd9 e1				pop hl 
1fda				endm 
# End of macro FORTH_CHK_RSP_UNDER
1fda				endif 
1fda e5				push hl 
1fdb 2a 24 f9			ld hl,(cli_ret_sp) 
1fde			 
1fde			 
1fde				if FORTH_ENABLE_FREE 
1fde			 
1fde					; get pointer 
1fde			 
1fde					push de 
1fde					push hl 
1fde			 
1fde					ld e, (hl) 
1fde					inc hl 
1fde					ld d, (hl) 
1fde			 
1fde					ex de, hl 
1fde					call free 
1fde			 
1fde					pop hl 
1fde					pop de 
1fde			 
1fde			 
1fde				endif 
1fde			 
1fde			 
1fde 2b				dec hl 
1fdf 2b				dec hl 
1fe0 22 24 f9			ld (cli_ret_sp), hl 
1fe3				; do stack underflow checks 
1fe3 e1				pop hl 
1fe4				if DEBUG_FORTH_STACK_GUARD 
1fe4 cd a8 73				call check_stacks 
1fe7					FORTH_CHK_RSP_UNDER 
1fe7 e5				push hl 
1fe8 d5				push de 
1fe9 2a 24 f9			ld hl,(cli_ret_sp) 
1fec 11 de f8			ld de, cli_ret_stack 
1fef cd ca 0f			call cmp16 
1ff2 da bf 74			jp c, fault_rsp_under 
1ff5 d1				pop de 
1ff6 e1				pop hl 
1ff7				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ff7				endif 
1ff7 c9				ret 
1ff8			 
1ff8			 
1ff8			 
1ff8			; routine to load word pointed to by hl into hl 
1ff8			 
1ff8			loadhlptrtohl: 
1ff8			 
1ff8 d5				push de 
1ff9 5e				ld e, (hl) 
1ffa 23				inc hl 
1ffb 56				ld d, (hl) 
1ffc eb				ex de, hl 
1ffd d1				pop de 
1ffe			 
1ffe c9				ret 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			 
1fff			; push a number held in HL onto the data stack 
1fff			; entry point for pushing a value when already in hl used in function above 
1fff			 
1fff			forth_push_numhl: 
1fff			 
1fff e5				push hl    ; save value to push 
2000			 
2000			if DEBUG_FORTH_PUSH 
2000				; see if disabled 
2000			 
2000			 
2000 f5				push af 
2001 3a aa fd			ld a,(debug_vector) 
2004 fe c9			cp $c9   ; ret 
2006			;	ld a, (os_view_disable) 
2006			;	cp '*' 
2006 28 33			jr z, .pskip2 
2008 e5				push hl 
2009 e5			push hl 
200a cd 7c 0d			call clear_display 
200d e1			pop hl 
200e 7c				ld a,h 
200f 21 f8 f3			ld hl, os_word_scratch 
2012 cd a8 11			call hexout 
2015 e1				pop hl 
2016 7d				ld a,l 
2017 21 fa f3			ld hl, os_word_scratch+2 
201a cd a8 11			call hexout 
201d			 
201d 21 fc f3			ld hl, os_word_scratch+4 
2020			;	ld a,0 
2020 36 00			ld (hl),0 
2022 11 f8 f3			ld de,os_word_scratch 
2025 3e 28				ld a, display_row_2 
2027 cd 8e 0d				call str_at_display 
202a 11 a5 65			ld de, .push_num 
202d 3e 00			ld a, display_row_1 
202f			 
202f cd 8e 0d				call str_at_display 
2032			 
2032			 
2032 cd 9e 0d			call update_display 
2035 cd c0 0c			call delay1s 
2038 cd c0 0c			call delay1s 
203b			.pskip2:  
203b			 
203b f1				pop af 
203c			endif	 
203c			 
203c			 
203c				FORTH_DSP_NEXT 
203c cd 8e 1f			call macro_forth_dsp_next 
203f				endm 
# End of macro FORTH_DSP_NEXT
203f			 
203f 2a 20 f9			ld hl, (cli_data_sp) 
2042			 
2042				; save item type 
2042			;	ld a,  DS_TYPE_INUM 
2042 36 02			ld (hl), DS_TYPE_INUM 
2044 23				inc hl 
2045			 
2045				; get word off stack 
2045 d1				pop de 
2046				;ld a,e 
2046 73				ld (hl), e 
2047 23				inc hl 
2048			;	ld a,d 
2048 72				ld (hl), d 
2049			 
2049			if DEBUG_FORTH_PUSH 
2049 2b				dec hl 
204a 2b				dec hl 
204b 2b				dec hl 
204c						DMARK "PH5" 
204c f5				push af  
204d 3a 61 20			ld a, (.dmark)  
2050 32 9d fd			ld (debug_mark),a  
2053 3a 62 20			ld a, (.dmark+1)  
2056 32 9e fd			ld (debug_mark+1),a  
2059 3a 63 20			ld a, (.dmark+2)  
205c 32 9f fd			ld (debug_mark+2),a  
205f 18 03			jr .pastdmark  
2061 ..			.dmark: db "PH5"  
2064 f1			.pastdmark: pop af  
2065			endm  
# End of macro DMARK
2065				CALLMONITOR 
2065 cd aa fd			call debug_vector  
2068				endm  
# End of macro CALLMONITOR
2068			endif	 
2068			 
2068 c9				ret 
2069			 
2069			 
2069			; Push a string to stack pointed to by hl 
2069			 
2069			forth_push_str: 
2069			 
2069			if DEBUG_FORTH_PUSH 
2069						DMARK "PSQ" 
2069 f5				push af  
206a 3a 7e 20			ld a, (.dmark)  
206d 32 9d fd			ld (debug_mark),a  
2070 3a 7f 20			ld a, (.dmark+1)  
2073 32 9e fd			ld (debug_mark+1),a  
2076 3a 80 20			ld a, (.dmark+2)  
2079 32 9f fd			ld (debug_mark+2),a  
207c 18 03			jr .pastdmark  
207e ..			.dmark: db "PSQ"  
2081 f1			.pastdmark: pop af  
2082			endm  
# End of macro DMARK
2082				CALLMONITOR 
2082 cd aa fd			call debug_vector  
2085				endm  
# End of macro CALLMONITOR
2085			endif	 
2085			 
2085			 
2085			    
2085 e5				push hl 
2086 e5				push hl 
2087			 
2087			;	ld a, 0   ; find end of string 
2087 cd 04 13			call strlenz 
208a			if DEBUG_FORTH_PUSH 
208a						DMARK "PQ2" 
208a f5				push af  
208b 3a 9f 20			ld a, (.dmark)  
208e 32 9d fd			ld (debug_mark),a  
2091 3a a0 20			ld a, (.dmark+1)  
2094 32 9e fd			ld (debug_mark+1),a  
2097 3a a1 20			ld a, (.dmark+2)  
209a 32 9f fd			ld (debug_mark+2),a  
209d 18 03			jr .pastdmark  
209f ..			.dmark: db "PQ2"  
20a2 f1			.pastdmark: pop af  
20a3			endm  
# End of macro DMARK
20a3				CALLMONITOR 
20a3 cd aa fd			call debug_vector  
20a6				endm  
# End of macro CALLMONITOR
20a6			endif	 
20a6 eb				ex de, hl 
20a7 e1				pop hl   ; get ptr to start of string 
20a8			if DEBUG_FORTH_PUSH 
20a8						DMARK "PQ3" 
20a8 f5				push af  
20a9 3a bd 20			ld a, (.dmark)  
20ac 32 9d fd			ld (debug_mark),a  
20af 3a be 20			ld a, (.dmark+1)  
20b2 32 9e fd			ld (debug_mark+1),a  
20b5 3a bf 20			ld a, (.dmark+2)  
20b8 32 9f fd			ld (debug_mark+2),a  
20bb 18 03			jr .pastdmark  
20bd ..			.dmark: db "PQ3"  
20c0 f1			.pastdmark: pop af  
20c1			endm  
# End of macro DMARK
20c1				CALLMONITOR 
20c1 cd aa fd			call debug_vector  
20c4				endm  
# End of macro CALLMONITOR
20c4			endif	 
20c4 19				add hl,de 
20c5			if DEBUG_FORTH_PUSH 
20c5						DMARK "PQE" 
20c5 f5				push af  
20c6 3a da 20			ld a, (.dmark)  
20c9 32 9d fd			ld (debug_mark),a  
20cc 3a db 20			ld a, (.dmark+1)  
20cf 32 9e fd			ld (debug_mark+1),a  
20d2 3a dc 20			ld a, (.dmark+2)  
20d5 32 9f fd			ld (debug_mark+2),a  
20d8 18 03			jr .pastdmark  
20da ..			.dmark: db "PQE"  
20dd f1			.pastdmark: pop af  
20de			endm  
# End of macro DMARK
20de				CALLMONITOR 
20de cd aa fd			call debug_vector  
20e1				endm  
# End of macro CALLMONITOR
20e1			endif	 
20e1			 
20e1 2b				dec hl    ; see if there is an optional trailing double quote 
20e2 7e				ld a,(hl) 
20e3 fe 22			cp '"' 
20e5 20 02			jr nz, .strnoq 
20e7			;	ld a, 0      ; get rid of double quote 
20e7 36 00			ld (hl), 0 
20e9 23			.strnoq: inc hl 
20ea			 
20ea			;	ld a, 0 
20ea 36 00			ld (hl), 0     ; add null term and get rid of trailing double quote 
20ec			 
20ec 13				inc de ; add one for the type string 
20ed 13				inc de ; add one for null term??? 
20ee			 
20ee				; tos is get string pointer again 
20ee				; de contains space to allocate 
20ee				 
20ee d5				push de 
20ef			 
20ef eb				ex de, hl 
20f0			 
20f0				;push af 
20f0			 
20f0			if DEBUG_FORTH_PUSH 
20f0						DMARK "PHm" 
20f0 f5				push af  
20f1 3a 05 21			ld a, (.dmark)  
20f4 32 9d fd			ld (debug_mark),a  
20f7 3a 06 21			ld a, (.dmark+1)  
20fa 32 9e fd			ld (debug_mark+1),a  
20fd 3a 07 21			ld a, (.dmark+2)  
2100 32 9f fd			ld (debug_mark+2),a  
2103 18 03			jr .pastdmark  
2105 ..			.dmark: db "PHm"  
2108 f1			.pastdmark: pop af  
2109			endm  
# End of macro DMARK
2109				CALLMONITOR 
2109 cd aa fd			call debug_vector  
210c				endm  
# End of macro CALLMONITOR
210c			endif	 
210c cd 78 13			call malloc	; on ret hl now contains allocated memory 
210f				if DEBUG_FORTH_MALLOC_GUARD 
210f cc fd 65				call z,malloc_error 
2112				endif 
2112			 
2112				 
2112 c1				pop bc    ; get length 
2113 d1				pop de   ;  get string start    
2114			 
2114				; hl has destination from malloc 
2114			 
2114 eb				ex de, hl    ; prep for ldir 
2115			 
2115 d5				push de   ; save malloc area for DSP later 
2116				;push hl   ; save malloc area for DSP later 
2116			 
2116			if DEBUG_FORTH_PUSH 
2116						DMARK "PHc" 
2116 f5				push af  
2117 3a 2b 21			ld a, (.dmark)  
211a 32 9d fd			ld (debug_mark),a  
211d 3a 2c 21			ld a, (.dmark+1)  
2120 32 9e fd			ld (debug_mark+1),a  
2123 3a 2d 21			ld a, (.dmark+2)  
2126 32 9f fd			ld (debug_mark+2),a  
2129 18 03			jr .pastdmark  
212b ..			.dmark: db "PHc"  
212e f1			.pastdmark: pop af  
212f			endm  
# End of macro DMARK
212f				CALLMONITOR 
212f cd aa fd			call debug_vector  
2132				endm  
# End of macro CALLMONITOR
2132			endif	 
2132			 
2132			 
2132 ed b0			ldir 
2134			 
2134			 
2134				; push malloc to data stack     macro?????  
2134			 
2134				FORTH_DSP_NEXT 
2134 cd 8e 1f			call macro_forth_dsp_next 
2137				endm 
# End of macro FORTH_DSP_NEXT
2137			 
2137				; save value and type 
2137			 
2137 2a 20 f9			ld hl, (cli_data_sp) 
213a			 
213a				; save item type 
213a			;	ld a,  DS_TYPE_STR 
213a 36 01			ld (hl), DS_TYPE_STR 
213c 23				inc hl 
213d			 
213d				; get malloc word off stack 
213d d1				pop de 
213e 73				ld (hl), e 
213f 23				inc hl 
2140 72				ld (hl), d 
2141			 
2141			 
2141			 
2141			if DEBUG_FORTH_PUSH 
2141 2a 20 f9			ld hl, (cli_data_sp) 
2144						DMARK "PHS" 
2144 f5				push af  
2145 3a 59 21			ld a, (.dmark)  
2148 32 9d fd			ld (debug_mark),a  
214b 3a 5a 21			ld a, (.dmark+1)  
214e 32 9e fd			ld (debug_mark+1),a  
2151 3a 5b 21			ld a, (.dmark+2)  
2154 32 9f fd			ld (debug_mark+2),a  
2157 18 03			jr .pastdmark  
2159 ..			.dmark: db "PHS"  
215c f1			.pastdmark: pop af  
215d			endm  
# End of macro DMARK
215d				CALLMONITOR 
215d cd aa fd			call debug_vector  
2160				endm  
# End of macro CALLMONITOR
2160			;	ex de,hl 
2160			endif	 
2160				; in case of spaces, skip the ptr past the copied string 
2160				;pop af 
2160				;ld (cli_origptr),hl 
2160			 
2160 c9				ret 
2161			 
2161			 
2161			 
2161			; TODO ascii push input onto stack given hl to start of input 
2161			 
2161			; identify type 
2161			; if starts with a " then a string 
2161			; otherwise it is a number 
2161			;  
2161			; if a string 
2161			;     scan for ending " to get length of string to malloc for + 1 
2161			;     malloc 
2161			;     put pointer to string on stack first byte flags as string 
2161			; 
2161			; else a number 
2161			;    look for number format identifier 
2161			;    $xx hex 
2161			;    %xxxxx bin 
2161			;    xxxxx decimal 
2161			;    convert number to 16bit word.  
2161			;    malloc word + 1 with flag to identiy as num 
2161			;    put pointer to number on stack 
2161			;   
2161			;  
2161			  
2161			forth_apush: 
2161				; kernel push 
2161			 
2161			if DEBUG_FORTH_PUSH 
2161						DMARK "PSH" 
2161 f5				push af  
2162 3a 76 21			ld a, (.dmark)  
2165 32 9d fd			ld (debug_mark),a  
2168 3a 77 21			ld a, (.dmark+1)  
216b 32 9e fd			ld (debug_mark+1),a  
216e 3a 78 21			ld a, (.dmark+2)  
2171 32 9f fd			ld (debug_mark+2),a  
2174 18 03			jr .pastdmark  
2176 ..			.dmark: db "PSH"  
2179 f1			.pastdmark: pop af  
217a			endm  
# End of macro DMARK
217a				CALLMONITOR 
217a cd aa fd			call debug_vector  
217d				endm  
# End of macro CALLMONITOR
217d			endif	 
217d				; identify input type 
217d			 
217d 7e				ld a,(hl) 
217e			 
217e fe 23			cp '#' 
2180 ca b8 21			jp z, .fapdec 
2183			 
2183			 
2183 fe 22			cp '"' 
2185 28 0a			jr z, .fapstr 
2187 fe 24			cp '$' 
2189 ca b0 21			jp z, .faphex 
218c fe 25			cp '%' 
218e ca 99 21			jp z, .fapbin 
2191			;	cp 'b' 
2191			;	jp z, .fabin 
2191				; else decimal 
2191			 
2191				; TODO do decimal conversion 
2191				; decimal is stored as a 16bit word 
2191			 
2191				; by default everything is a string if type is not detected 
2191			.fapstr: ; 
2191 fe 22			cp '"' 
2193 20 01			jr nz, .strnoqu 
2195 23				inc hl 
2196			.strnoqu: 
2196 c3 69 20			jp forth_push_str 
2199			 
2199			 
2199			 
2199			.fapbin:    ; push a binary string.  
2199 11 00 00			ld de, 0   ; hold a 16bit value 
219c			 
219c 23			.fapbinshift:	inc hl  
219d 7e				ld a,(hl) 
219e			;	cp 0     ; done scanning  
219e b7				or a 
219f 28 0b			jr z, .fapbdone  	; got it in HL so push  
21a1			 
21a1				; left shift de 
21a1 eb				ex de, hl	 
21a2 29				add hl, hl 
21a3			 
21a3				; is 1 
21a3 fe 31			cp '1' 
21a5 20 02			jr nz, .binzero 
21a7 cb 4d			bit 1, l 
21a9			.binzero: 
21a9 eb				ex de, hl	 ; save current de 
21aa 18 f0			jr .fapbinshift 
21ac			 
21ac			.fapbdone: 
21ac eb				ex de, hl 
21ad c3 ff 1f			jp forth_push_numhl 
21b0			 
21b0			 
21b0			.faphex:   ; hex is always stored as a 16bit word 
21b0				; skip number prefix 
21b0 23				inc hl 
21b1				; turn ascii into number 
21b1 cd 5e 12			call get_word_hl	; ret 16bit word in hl 
21b4			 
21b4 c3 ff 1f			jp forth_push_numhl 
21b7			 
21b7			;	 nop 
21b7			 
21b7			.fabin:   ; TODO bin conversion 
21b7			 
21b7			 
21b7 c9				ret 
21b8			.fapdec:	 
21b8				; string to dec conversion 
21b8 23				inc hl 
21b9 eb				ex de, hl 
21ba cd 9b 12			call string_to_uint16 
21bd c3 ff 1f			jp forth_push_numhl 
21c0 c9				ret 
21c1				 
21c1			;atoui_16: 
21c1			 
21c1			; get either a string ptr or a 16bit word from the data stack 
21c1			 
21c1			FORTH_DSP: macro 
21c1				call macro_forth_dsp 
21c1				endm 
21c1			 
21c1			macro_forth_dsp: 
21c1				; data stack pointer points to current word on tos 
21c1			 
21c1 2a 20 f9			ld hl,(cli_data_sp) 
21c4			 
21c4				if DEBUG_FORTH_PUSH 
21c4						DMARK "DSP" 
21c4 f5				push af  
21c5 3a d9 21			ld a, (.dmark)  
21c8 32 9d fd			ld (debug_mark),a  
21cb 3a da 21			ld a, (.dmark+1)  
21ce 32 9e fd			ld (debug_mark+1),a  
21d1 3a db 21			ld a, (.dmark+2)  
21d4 32 9f fd			ld (debug_mark+2),a  
21d7 18 03			jr .pastdmark  
21d9 ..			.dmark: db "DSP"  
21dc f1			.pastdmark: pop af  
21dd			endm  
# End of macro DMARK
21dd			 
21dd cd 30 66				call display_data_sp 
21e0				;call break_point_state 
21e0				;rst 030h 
21e0				CALLMONITOR 
21e0 cd aa fd			call debug_vector  
21e3				endm  
# End of macro CALLMONITOR
21e3				endif 
21e3			 
21e3 c9				ret 
21e4			 
21e4			; return hl to start of value on stack 
21e4			 
21e4			FORTH_DSP_VALUE: macro 
21e4				call macro_forth_dsp_value 
21e4				endm 
21e4			 
21e4			macro_forth_dsp_value: 
21e4			 
21e4				FORTH_DSP 
21e4 cd c1 21			call macro_forth_dsp 
21e7				endm 
# End of macro FORTH_DSP
21e7			 
21e7 d5				push de 
21e8			 
21e8 23				inc hl ; skip type 
21e9			 
21e9 5e				ld e, (hl) 
21ea 23				inc hl 
21eb 56				ld d, (hl) 
21ec eb				ex de,hl  
21ed			 
21ed d1				pop de 
21ee			 
21ee c9				ret 
21ef			 
21ef			; return hl to start of value to second item on stack 
21ef			 
21ef			FORTH_DSP_VALUEM1: macro 
21ef				call macro_forth_dsp_value_m1 
21ef				endm 
21ef			 
21ef			macro_forth_dsp_value_m1: 
21ef			 
21ef				FORTH_DSP 
21ef cd c1 21			call macro_forth_dsp 
21f2				endm 
# End of macro FORTH_DSP
21f2			 
21f2 2b				dec hl 
21f3 2b				dec hl 
21f4			;	dec hl 
21f4			 
21f4 d5				push de 
21f5			 
21f5 5e				ld e, (hl) 
21f6 23				inc hl 
21f7 56				ld d, (hl) 
21f8 eb				ex de,hl  
21f9			 
21f9 d1				pop de 
21fa			 
21fa c9				ret 
21fb			 
21fb				 
21fb			 
21fb			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
21fb			 
21fb			FORTH_DSP_POP: macro 
21fb				call macro_forth_dsp_pop 
21fb				endm 
21fb			 
21fb			 
21fb			; get the tos data type 
21fb			 
21fb			FORTH_DSP_TYPE:   macro 
21fb			 
21fb				;FORTH_DSP_VALUE 
21fb				FORTH_DSP 
21fb				 
21fb				; hl points to value 
21fb				; check type 
21fb			 
21fb				ld a,(hl) 
21fb			 
21fb				endm 
21fb			 
21fb			; load the tos value into hl 
21fb			 
21fb			 
21fb			FORTH_DSP_VALUEHL:  macro 
21fb				call macro_dsp_valuehl 
21fb				endm 
21fb			 
21fb			 
21fb			 
21fb			macro_dsp_valuehl: 
21fb				FORTH_DSP_VALUE 
21fb cd e4 21			call macro_forth_dsp_value 
21fe				endm 
# End of macro FORTH_DSP_VALUE
21fe			 
21fe				;FORTH_ERR_TOS_NOTNUM 
21fe			 
21fe				;inc hl   ; skip type id 
21fe			 
21fe			;	push de 
21fe			; 
21fe			;	ld e, (hl) 
21fe			;	inc hl 
21fe			;	ld d, (hl) 
21fe			;	ex de,hl  
21fe			 
21fe			;	pop de 
21fe			 
21fe				if DEBUG_FORTH_PUSH 
21fe						DMARK "DVL" 
21fe f5				push af  
21ff 3a 13 22			ld a, (.dmark)  
2202 32 9d fd			ld (debug_mark),a  
2205 3a 14 22			ld a, (.dmark+1)  
2208 32 9e fd			ld (debug_mark+1),a  
220b 3a 15 22			ld a, (.dmark+2)  
220e 32 9f fd			ld (debug_mark+2),a  
2211 18 03			jr .pastdmark  
2213 ..			.dmark: db "DVL"  
2216 f1			.pastdmark: pop af  
2217			endm  
# End of macro DMARK
2217				CALLMONITOR 
2217 cd aa fd			call debug_vector  
221a				endm  
# End of macro CALLMONITOR
221a				endif 
221a c9				ret 
221b			 
221b			forth_apushstrhl:      
221b				; push of string requires use of cli_origptr 
221b				; bodge use 
221b			 
221b				; get current cli_origptr, save, update with temp pointer  
221b ed 5b 70 f9		ld de, (cli_origptr) 
221f 22 70 f9			ld (cli_origptr), hl 
2222 d5				push de 
2223 cd 61 21			call forth_apush 
2226 d1				pop de 
2227 ed 53 70 f9		ld (cli_origptr), de 
222b c9			        ret	 
222c			 
222c			 
222c			; increase loop stack pointer and save hl to it 
222c				 
222c			FORTH_LOOP_NEXT: macro 
222c				call macro_forth_loop_next 
222c				;nop 
222c				endm 
222c			 
222c			macro_forth_loop_next: 
222c				if DEBUG_FORTH_STACK_GUARD 
222c cd a8 73				call check_stacks 
222f				endif 
222f e5				push hl 
2230 d5				push de 
2231 eb				ex de,hl 
2232 2a 22 f9			ld hl,(cli_loop_sp) 
2235 23				inc hl 
2236 23				inc hl 
2237					if DEBUG_FORTH_WORDS 
2237						DMARK "LNX" 
2237 f5				push af  
2238 3a 4c 22			ld a, (.dmark)  
223b 32 9d fd			ld (debug_mark),a  
223e 3a 4d 22			ld a, (.dmark+1)  
2241 32 9e fd			ld (debug_mark+1),a  
2244 3a 4e 22			ld a, (.dmark+2)  
2247 32 9f fd			ld (debug_mark+2),a  
224a 18 03			jr .pastdmark  
224c ..			.dmark: db "LNX"  
224f f1			.pastdmark: pop af  
2250			endm  
# End of macro DMARK
2250						CALLMONITOR 
2250 cd aa fd			call debug_vector  
2253				endm  
# End of macro CALLMONITOR
2253					endif 
2253 22 22 f9			ld (cli_loop_sp),hl 
2256 73				ld (hl), e 
2257 23				inc hl 
2258 72				ld (hl), d 
2259 d1				pop de    ; been reversed so save a swap on restore 
225a e1				pop hl 
225b				if DEBUG_FORTH_STACK_GUARD 
225b cd a8 73				call check_stacks 
225e				endif 
225e c9				ret 
225f			 
225f			; get current ret stack pointer and save to hl  
225f				 
225f			FORTH_LOOP_TOS: macro 
225f				call macro_forth_loop_tos 
225f				endm 
225f			 
225f			macro_forth_loop_tos: 
225f d5				push de 
2260 2a 22 f9			ld hl,(cli_loop_sp) 
2263 5e				ld e, (hl) 
2264 23				inc hl 
2265 56				ld d, (hl) 
2266 eb				ex de, hl 
2267 d1				pop de 
2268 c9				ret 
2269			 
2269			; pop loop stack pointer 
2269				 
2269			FORTH_LOOP_POP: macro 
2269				call macro_forth_loop_pop 
2269				endm 
2269			 
2269			 
2269			macro_forth_loop_pop: 
2269				if DEBUG_FORTH_STACK_GUARD 
2269					DMARK "LPP" 
2269 f5				push af  
226a 3a 7e 22			ld a, (.dmark)  
226d 32 9d fd			ld (debug_mark),a  
2270 3a 7f 22			ld a, (.dmark+1)  
2273 32 9e fd			ld (debug_mark+1),a  
2276 3a 80 22			ld a, (.dmark+2)  
2279 32 9f fd			ld (debug_mark+2),a  
227c 18 03			jr .pastdmark  
227e ..			.dmark: db "LPP"  
2281 f1			.pastdmark: pop af  
2282			endm  
# End of macro DMARK
2282 cd a8 73				call check_stacks 
2285					FORTH_CHK_LOOP_UNDER 
2285 e5				push hl 
2286 d5				push de 
2287 2a 22 f9			ld hl,(cli_loop_sp) 
228a 11 5c f8			ld de, cli_loop_stack 
228d cd ca 0f			call cmp16 
2290 da c5 74			jp c, fault_loop_under 
2293 d1				pop de 
2294 e1				pop hl 
2295				endm 
# End of macro FORTH_CHK_LOOP_UNDER
2295				endif 
2295 e5				push hl 
2296 2a 22 f9			ld hl,(cli_loop_sp) 
2299 2b				dec hl 
229a 2b				dec hl 
229b 22 22 f9			ld (cli_loop_sp), hl 
229e				; TODO do stack underflow checks 
229e e1				pop hl 
229f				if DEBUG_FORTH_STACK_GUARD 
229f cd a8 73				call check_stacks 
22a2					FORTH_CHK_LOOP_UNDER 
22a2 e5				push hl 
22a3 d5				push de 
22a4 2a 22 f9			ld hl,(cli_loop_sp) 
22a7 11 5c f8			ld de, cli_loop_stack 
22aa cd ca 0f			call cmp16 
22ad da c5 74			jp c, fault_loop_under 
22b0 d1				pop de 
22b1 e1				pop hl 
22b2				endm 
# End of macro FORTH_CHK_LOOP_UNDER
22b2				endif 
22b2 c9				ret 
22b3			 
22b3			macro_forth_dsp_pop: 
22b3			 
22b3 e5				push hl 
22b4			 
22b4				; release malloc data 
22b4			 
22b4				if DEBUG_FORTH_STACK_GUARD 
22b4 cd a8 73				call check_stacks 
22b7					FORTH_CHK_DSP_UNDER 
22b7 e5				push hl 
22b8 d5				push de 
22b9 2a 20 f9			ld hl,(cli_data_sp) 
22bc 11 5a f6			ld de, cli_data_stack 
22bf cd ca 0f			call cmp16 
22c2 da b9 74			jp c, fault_dsp_under 
22c5 d1				pop de 
22c6 e1				pop hl 
22c7				endm 
# End of macro FORTH_CHK_DSP_UNDER
22c7				endif 
22c7				;ld hl,(cli_data_sp) 
22c7			if DEBUG_FORTH_DOT 
22c7				DMARK "DPP" 
22c7 f5				push af  
22c8 3a dc 22			ld a, (.dmark)  
22cb 32 9d fd			ld (debug_mark),a  
22ce 3a dd 22			ld a, (.dmark+1)  
22d1 32 9e fd			ld (debug_mark+1),a  
22d4 3a de 22			ld a, (.dmark+2)  
22d7 32 9f fd			ld (debug_mark+2),a  
22da 18 03			jr .pastdmark  
22dc ..			.dmark: db "DPP"  
22df f1			.pastdmark: pop af  
22e0			endm  
# End of macro DMARK
22e0				CALLMONITOR 
22e0 cd aa fd			call debug_vector  
22e3				endm  
# End of macro CALLMONITOR
22e3			endif	 
22e3			 
22e3			 
22e3			if FORTH_ENABLE_DSPPOPFREE 
22e3			 
22e3				FORTH_DSP 
22e3 cd c1 21			call macro_forth_dsp 
22e6				endm 
# End of macro FORTH_DSP
22e6			 
22e6 7e				ld a, (hl) 
22e7 fe 01			cp DS_TYPE_STR             ; implies that DS_TYPE_CONST *WONT* be freed 
22e9 20 22			jr nz, .skippopfree 
22eb			 
22eb				FORTH_DSP_VALUEHL 
22eb cd fb 21			call macro_dsp_valuehl 
22ee				endm 
# End of macro FORTH_DSP_VALUEHL
22ee			;	nop 
22ee			if DEBUG_FORTH_DOT 
22ee				DMARK "DPf" 
22ee f5				push af  
22ef 3a 03 23			ld a, (.dmark)  
22f2 32 9d fd			ld (debug_mark),a  
22f5 3a 04 23			ld a, (.dmark+1)  
22f8 32 9e fd			ld (debug_mark+1),a  
22fb 3a 05 23			ld a, (.dmark+2)  
22fe 32 9f fd			ld (debug_mark+2),a  
2301 18 03			jr .pastdmark  
2303 ..			.dmark: db "DPf"  
2306 f1			.pastdmark: pop af  
2307			endm  
# End of macro DMARK
2307				CALLMONITOR 
2307 cd aa fd			call debug_vector  
230a				endm  
# End of macro CALLMONITOR
230a			endif	 
230a cd 42 14			call free 
230d			.skippopfree: 
230d				 
230d			 
230d			endif 
230d			 
230d			if DEBUG_FORTH_DOT_KEY 
230d				DMARK "DP2" 
230d				CALLMONITOR 
230d			endif	 
230d			 
230d				; move pointer down 
230d			 
230d 2a 20 f9			ld hl,(cli_data_sp) 
2310 2b				dec hl 
2311 2b				dec hl 
2312			; PARSEV5 
2312 2b				dec hl 
2313 22 20 f9			ld (cli_data_sp), hl 
2316			 
2316				if DEBUG_FORTH_STACK_GUARD 
2316 cd a8 73				call check_stacks 
2319					FORTH_CHK_DSP_UNDER 
2319 e5				push hl 
231a d5				push de 
231b 2a 20 f9			ld hl,(cli_data_sp) 
231e 11 5a f6			ld de, cli_data_stack 
2321 cd ca 0f			call cmp16 
2324 da b9 74			jp c, fault_dsp_under 
2327 d1				pop de 
2328 e1				pop hl 
2329				endm 
# End of macro FORTH_CHK_DSP_UNDER
2329				endif 
2329			 
2329 e1				pop hl 
232a			 
232a c9				ret 
232b			 
232b			getwordathl: 
232b				; hl points to an address 
232b				; load hl with the word at that address 
232b			 
232b d5				push de 
232c			 
232c 5e				ld e, (hl) 
232d 23				inc hl 
232e 56				ld d, (hl) 
232f eb				ex de, hl 
2330			 
2330 d1				pop de 
2331 c9				ret 
2332			 
2332			 
2332			; functions to manuplite stack pointers 
2332			 
2332			; generate fragment to set hl to be pointer to a stack item 
2332			 
2332			FORTH_DSP_PTR: macro  x 
2332				ld hl,(cli_data_sp) 
2332				ld de, x * 3 
2332				sbc hl, de 
2332				endm 
2332			 
2332			 
2332			 
2332			; copy point in hl to stack tmp storage slots 1-4 
2332			hltostack1: 
2332 11 f0 f0			ld de, os_stack_1  
2335 c3 60 23			jp hltostackmv 
2338			 
2338			hltostack2:  
2338 11 ed f0			ld de, os_stack_2 
233b c3 60 23			jp hltostackmv 
233e			 
233e			hltostack3:  
233e 11 ea f0			ld de, os_stack_3 
2341 c3 60 23			jp hltostackmv 
2344			 
2344			hltostack4:  
2344 11 e7 f0			ld de, os_stack_4  
2347 c3 60 23			jp hltostackmv 
234a			 
234a			; copy to point in hl from stack tmp storage slots 1-4 
234a			hlfromstack1: 
234a 11 f0 f0			ld de, os_stack_1 
234d c3 5f 23			jp hlfromsttackmv 
2350			 
2350			hlfromstack2:  
2350 11 ed f0			ld de, os_stack_2 
2353 c3 5f 23			jp hlfromsttackmv 
2356			 
2356			hlfromstack3:  
2356 11 ea f0			ld de, os_stack_3 
2359 c3 5f 23			jp hlfromsttackmv 
235c			 
235c			hlfromstack4:  
235c 11 e7 f0			ld de, os_stack_4 
235f			 
235f			hlfromsttackmv: 
235f eb				ex de, hl 
2360			 
2360			hltostackmv: 
2360			 
2360				; do stack move 
2360 c5				push bc 
2361 01 03 00			ld bc, 3 
2364 ed b0			ldir  
2366 c1				pop bc	 
2367 c9				ret 
2368			 
2368			; eof 
2368			 
# End of file forth_stackopsv5.asm
2368			endif 
2368			loadwordinhl:	 
2368			 
2368 d5				push de 
2369			 
2369 5e				ld e, (hl) 
236a 23				inc hl 
236b 56				ld d, (hl) 
236c eb				ex de,hl  
236d			 
236d d1				pop de 
236e			 
236e c9				ret 
236f			 
236f			user_word_eol:  
236f				; hl contains the pointer to where to create a linked list item from the end 
236f				; of the user dict to continue on at the system word dict 
236f				 
236f				; poke the stub of the word list linked list to repoint to rom words 
236f			 
236f				; stub format 
236f				; db   word id 
236f				; dw    link to next word 
236f			        ; db char length of token 
236f				; db string + 0 term 
236f				; db exec code....  
236f			 
236f			;	ld a, WORD_SYS_ROOT     ; root word 
236f 36 00			ld (hl), WORD_SYS_ROOT		; word id 
2371 23				inc hl 
2372			 
2372 11 1b 25			ld de, sysdict 
2375 73				ld (hl), e		; next word link ie system dict 
2376 23				inc hl 
2377 72				ld (hl), d		; next word link ie system dict 
2378 23				inc hl	 
2379			 
2379			;	ld (hl), sysdict		; next word link ie system dict 
2379			;	inc hl 
2379			;	inc hl 
2379			 
2379			;	inc hl 
2379			;	inc hl 
2379			 
2379			;	ld a, 2			; word length is 0 
2379 36 02			ld (hl), 2 
237b 23				inc hl 
237c			 
237c			;	ld a, '~'			; word length is 0 
237c 36 7e			ld (hl), '~' 
237e 23				inc hl 
237f			;	ld a, 0			; save empty word 
237f 36 00			ld (hl), 0 
2381			 
2381 c9				ret 
2382			 
2382				 
2382			 
2382			forthexec_cleanup: 
2382				FORTH_RSP_POP 
2382 cd c7 1f			call macro_forth_rsp_pop 
2385				endm 
# End of macro FORTH_RSP_POP
2385 c9				ret 
2386			 
2386			forth_call_hl: 
2386				; taking hl 
2386 e5				push hl 
2387 c9				ret 
2388			 
2388			; this is called to reset Forth system but keep existing uwords etc 
2388			 
2388			forth_warmstart: 
2388				; setup stack over/under flow checks 
2388				if DEBUG_FORTH_STACK_GUARD 
2388 cd 8e 73				call chk_stk_init 
238b				endif 
238b			 
238b				; init stack pointers  - * these stacks go upwards *  
238b 21 de f8			ld hl, cli_ret_stack 
238e 22 24 f9			ld (cli_ret_sp), hl	 
2391				; set bottom of stack 
2391			;	ld a,0 
2391 36 00			ld (hl),0 
2393 23				inc hl 
2394 36 00			ld (hl),0 
2396			 
2396 21 5a f6			ld hl, cli_data_stack 
2399 22 20 f9			ld (cli_data_sp), hl	 
239c				; set bottom of stack 
239c			;	ld a,0 
239c 36 00			ld (hl),0 
239e 23				inc hl 
239f 36 00			ld (hl),0 
23a1			 
23a1 21 5c f8			ld hl, cli_loop_stack 
23a4 22 22 f9			ld (cli_loop_sp), hl	 
23a7				; set bottom of stack 
23a7			;	ld a,0 
23a7 36 00			ld (hl),0 
23a9 23				inc hl 
23aa 36 00			ld (hl),0 
23ac			 
23ac				; init extent of current open file 
23ac			 
23ac 3e 00			ld a, 0 
23ae 32 9c f9			ld (store_openext), a 
23b1			 
23b1 c9				ret 
23b2			 
23b2			 
23b2			 
23b2			; Cold Start - this is called to setup the whole Forth system 
23b2			 
23b2			forth_init: 
23b2			 
23b2				; setup stack over/under flow checks 
23b2			 
23b2			;	if DEBUG_FORTH_STACK_GUARD 
23b2			;		call chk_stk_init 
23b2			;	endif 
23b2			 
23b2				; enable auto display updates (slow.....) 
23b2			 
23b2 3e 01			ld a, 1 
23b4 32 6e f9			ld (cli_autodisplay), a 
23b7			 
23b7				; if storage is in use disable long reads for now 
23b7 3e 00			ld a, 0 
23b9 32 a7 f9			ld (store_longread), a 
23bc			 
23bc			 
23bc				; show start up screen 
23bc			 
23bc cd 7c 0d			call clear_display 
23bf			 
23bf 3e 00			ld a,0 
23c1 32 90 f9			ld (f_cursor_ptr), a 
23c4			 
23c4				; set start of word list in start of ram - for use when creating user words 
23c4			 
23c4 21 00 80			ld hl, baseram 
23c7 22 f0 f3			ld (os_last_new_uword), hl 
23ca cd 6f 23			call user_word_eol 
23cd				 
23cd			;		call display_data_sp 
23cd			;		call next_page_prompt 
23cd			 
23cd			 
23cd			 
23cd			 
23cd c9				ret 
23ce			 
23ce .. 00		.bootforth: db " Forth Kernel Init ",0 
23e2			 
23e2			; TODO push to stack 
23e2			 
23e2			;  
23e2			 
23e2			if FORTH_PARSEV2 
23e2			 
23e2			 
23e2				include "forth_parserv2.asm" 
23e2			 
23e2			endif 
23e2			 
23e2			 
23e2			; parse cli version 1 
23e2			 
23e2			if FORTH_PARSEV1 
23e2			 
23e2			 
23e2			 
23e2			      include "forth_parserv1.asm" 
23e2			endif 
23e2				 
23e2			if FORTH_PARSEV3 
23e2			      include "forth_parserv3.asm" 
23e2				include "forth_wordsv3.asm" 
23e2			endif 
23e2			 
23e2			if FORTH_PARSEV4 
23e2			      include "forth_parserv4.asm" 
23e2				include "forth_wordsv4.asm" 
23e2			endif 
23e2			 
23e2			if FORTH_PARSEV5 
23e2			      include "forth_parserv5.asm" 
23e2				include "forth_wordsv4.asm" 
23e2			endif 
23e2			 
23e2			if FORTH_PARSEV6 
23e2			      include "forth_parserv6.asm" 
23e2			 
23e2			 
23e2			; A better parser without using malloc and string copies all over the place.  
23e2			; Exec in situ should be faster 
23e2			 
23e2			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
23e2			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
23e2			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
23e2			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
23e2			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
23e2			WORD_SYS_END: equ 0   ; Opcode for all user words 
23e2			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
23e2			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
23e2			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
23e2			 
23e2			; Core word preamble macro 
23e2			 
23e2			CWHEAD:   macro nxtword opcode lit len opflags 
23e2				db WORD_SYS_CORE+opcode             
23e2				; internal op code number 
23e2				dw nxtword            
23e2				; link to next dict word block 
23e2				db len + 1 
23e2				; literal length of dict word inc zero term 
23e2				db lit,0              
23e2				; literal dict word 
23e2			        ; TODO db opflags        
23e2				endm 
23e2			 
23e2			 
23e2			NEXTW: macro  
23e2				call parse_vector 
23e2				jp macro_next 
23e2				endm 
23e2			 
23e2			macro_next: 
23e2			if DEBUG_FORTH_PARSE_EXEC 
23e2				DMARK "NXT" 
23e2				CALLMONITOR 
23e2			endif	 
23e2			;	inc hl  ; skip token null term  
23e2 ed 4b 72 f9		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
23e6 ed 5b 70 f9		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
23ea 2a f4 f3			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
23ed			if DEBUG_FORTH_PARSE_EXEC 
23ed				DMARK "}AA" 
23ed				CALLMONITOR 
23ed			endif	 
23ed c3 d2 24			jp execnext 
23f0				;jp exec1 
23f0			       
23f0			 
23f0			 
23f0			; Another go at the parser to compile  
23f0			 
23f0			 
23f0			; TODO rework parser to change all of the string words to byte tokens 
23f0			; TODO do a search for  
23f0			 
23f0			; TODO first run normal parser to zero term sections 
23f0			; TODO for each word do a token look up to get the op code 
23f0			; TODO need some means to flag to the exec that this is a byte code form    
23f0			 
23f0			 
23f0			forthcompile: 
23f0			 
23f0			; 
23f0			; line parse: 
23f0			;       parse raw input buffer 
23f0			;       tokenise the words 
23f0			;       malloc new copy (for looping etc) 
23f0			;       copy to malloc + current pc in line to start of string and add line term 
23f0			;       save on new rsp 
23f0			; 
23f0			 
23f0			; hl to point to the line to tokenise 
23f0			 
23f0			;	push hl 
23f0 22 f4 f3			ld (os_tok_ptr), hl  ; save ptr to string 
23f3			 
23f3			;	ld a,0		; string term on input 
23f3			;	call strlent 
23f3			 
23f3			;	ld (os_tok_len), hl	 ; save string length 
23f3			 
23f3			;if DEBUG_FORTH_TOK 
23f3			;	ex de,hl		 
23f3			;endif 
23f3			 
23f3			;	pop hl 		; get back string pointer 
23f3			 
23f3			if DEBUG_FORTH_TOK 
23f3						DMARK "TOc" 
23f3				CALLMONITOR 
23f3			endif 
23f3 7e			.cptoken2:    ld a,(hl) 
23f4 23				inc hl 
23f5 fe 7f			cp FORTH_END_BUFFER 
23f7 28 26			jr z, .cptokendone2 
23f9			;	cp 0 
23f9 b7				or a 
23fa 28 23			jr z, .cptokendone2 
23fc fe 22			cp '"' 
23fe 28 0a			jr z, .cptokenstr2     ; will want to skip until end of string delim 
2400 fe 20			cp ' ' 
2402 20 ef			jr nz,  .cptoken2 
2404			 
2404			; TODO consume comments held between ( and ) 
2404			 
2404				; we have a space so change to zero term for dict match later 
2404 2b				dec hl 
2405			;	ld a,0 
2405 36 00			ld (hl), 0 
2407 23				inc hl 
2408 18 e9			jr .cptoken2 
240a				 
240a			 
240a			.cptokenstr2: 
240a				; skip all white space until either eol (because forgot to term) or end double quote 
240a			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
240a				;inc hl ; skip current double quote 
240a 7e				ld a,(hl) 
240b 23				inc hl 
240c fe 22			cp '"' 
240e 28 e3			jr z, .cptoken2 
2410 fe 7f			cp FORTH_END_BUFFER 
2412 28 0b			jr z, .cptokendone2 
2414			;	cp 0 
2414 b7				or a 
2415 28 08			jr z, .cptokendone2 
2417 fe 20			cp ' ' 
2419 28 02			jr z, .cptmp2 
241b 18 ed			jr .cptokenstr2 
241d			 
241d			.cptmp2:	; we have a space so change to zero term for dict match later 
241d				;dec hl 
241d				;ld a,"-"	; TODO remove this when working 
241d				;ld (hl), a 
241d				;inc hl 
241d 18 eb			jr .cptokenstr2 
241f			 
241f			.cptokendone2: 
241f				;inc hl 
241f			;	ld a, FORTH_END_BUFFER 
241f 36 7f			ld (hl),FORTH_END_BUFFER 
2421			;	inc hl 
2421			;	ld a, '!' 
2421			;	ld (hl),a 
2421			 
2421 2a f4 f3			ld hl,(os_tok_ptr) 
2424			         
2424			if DEBUG_FORTH_TOK 
2424						DMARK "Tc1" 
2424				CALLMONITOR 
2424			endif 
2424			 
2424				; push exec string to top of return stack 
2424				FORTH_RSP_NEXT 
2424 cd a6 1f			call macro_forth_rsp_next 
2427				endm 
# End of macro FORTH_RSP_NEXT
2427 c9				ret 
2428			 
2428			; Another go at the parser need to simplify the process 
2428			 
2428			forthparse: 
2428			 
2428			; 
2428			; line parse: 
2428			;       parse raw input buffer 
2428			;       tokenise the words 
2428			;       malloc new copy (for looping etc) 
2428			;       copy to malloc + current pc in line to start of string and add line term 
2428			;       save on new rsp 
2428			; 
2428			 
2428			; hl to point to the line to tokenise 
2428			 
2428			;	push hl 
2428 22 f4 f3			ld (os_tok_ptr), hl  ; save ptr to string 
242b			 
242b			;	ld a,0		; string term on input 
242b			;	call strlent 
242b			 
242b			;	ld (os_tok_len), hl	 ; save string length 
242b			 
242b			;if DEBUG_FORTH_TOK 
242b			;	ex de,hl		 
242b			;endif 
242b			 
242b			;	pop hl 		; get back string pointer 
242b			 
242b			if DEBUG_FORTH_TOK 
242b						DMARK "TOK" 
242b				CALLMONITOR 
242b			endif 
242b 7e			.ptoken2:    ld a,(hl) 
242c 23				inc hl 
242d fe 7f			cp FORTH_END_BUFFER 
242f 28 26			jr z, .ptokendone2 
2431			;	cp 0 
2431 b7				or a 
2432 28 23			jr z, .ptokendone2 
2434 fe 22			cp '"' 
2436 28 0a			jr z, .ptokenstr2     ; will want to skip until end of string delim 
2438 fe 20			cp ' ' 
243a 20 ef			jr nz,  .ptoken2 
243c			 
243c			; TODO consume comments held between ( and ) 
243c			 
243c				; we have a space so change to zero term for dict match later 
243c 2b				dec hl 
243d			;	ld a,0 
243d 36 00			ld (hl), 0 
243f 23				inc hl 
2440 18 e9			jr .ptoken2 
2442				 
2442			 
2442			.ptokenstr2: 
2442				; skip all white space until either eol (because forgot to term) or end double quote 
2442			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
2442				;inc hl ; skip current double quote 
2442 7e				ld a,(hl) 
2443 23				inc hl 
2444 fe 22			cp '"' 
2446 28 e3			jr z, .ptoken2 
2448 fe 7f			cp FORTH_END_BUFFER 
244a 28 0b			jr z, .ptokendone2 
244c			;	cp 0 
244c b7				or a 
244d 28 08			jr z, .ptokendone2 
244f fe 20			cp ' ' 
2451 28 02			jr z, .ptmp2 
2453 18 ed			jr .ptokenstr2 
2455			 
2455			.ptmp2:	; we have a space so change to zero term for dict match later 
2455				;dec hl 
2455				;ld a,"-"	; TODO remove this when working 
2455				;ld (hl), a 
2455				;inc hl 
2455 18 eb			jr .ptokenstr2 
2457			 
2457			.ptokendone2: 
2457				;inc hl 
2457			;	ld a, FORTH_END_BUFFER 
2457 36 7f			ld (hl),FORTH_END_BUFFER 
2459			;	inc hl 
2459			;	ld a, '!' 
2459			;	ld (hl),a 
2459			 
2459 2a f4 f3			ld hl,(os_tok_ptr) 
245c			         
245c			if DEBUG_FORTH_TOK 
245c						DMARK "TK1" 
245c				CALLMONITOR 
245c			endif 
245c			 
245c				; push exec string to top of return stack 
245c				FORTH_RSP_NEXT 
245c cd a6 1f			call macro_forth_rsp_next 
245f				endm 
# End of macro FORTH_RSP_NEXT
245f c9				ret 
2460			 
2460			; 
2460			;	; malloc size + buffer pointer + if is loop flag 
2460			;	ld hl,(os_tok_len) 		 ; get string length 
2460			; 
2460			;	ld a,l 
2460			; 
2460			;	cp 0			; we dont want to use a null string 
2460			;	ret z 
2460			; 
2460			;;	add 3    ; prefix malloc with buffer for current word ptr 
2460			; 
2460			;	add 5     ; TODO when certain not over writing memory remove 
2460			; 
2460			;		 
2460			; 
2460			;if DEBUG_FORTH_TOK 
2460			;			DMARK "TKE" 
2460			;	CALLMONITOR 
2460			;endif 
2460			; 
2460			;	ld l,a 
2460			;	ld h,0 
2460			;;	push hl   ; save required space for the copy later 
2460			;	call malloc 
2460			;if DEBUG_FORTH_TOK 
2460			;			DMARK "TKM" 
2460			;	CALLMONITOR 
2460			;endif 
2460			;	if DEBUG_FORTH_MALLOC_GUARD 
2460			;		push af 
2460			;		call ishlzero 
2460			;;		ld a, l 
2460			;;		add h 
2460			;;		cp 0 
2460			;		pop af 
2460			;		 
2460			;		call z,malloc_error 
2460			;	endif 
2460			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
2460			; 
2460			; 
2460			;if DEBUG_FORTH_TOK 
2460			;			DMARK "TKR" 
2460			;	CALLMONITOR 
2460			;endif 
2460			; 
2460			;	FORTH_RSP_NEXT 
2460			; 
2460			;	;inc hl	 ; go past current buffer pointer 
2460			;	;inc hl 
2460			;	;inc hl   ; and past if loop flag 
2460			;		; TODO Need to set flag  
2460			; 
2460			;	 
2460			;	 
2460			;	ex de,hl	; malloc is dest 
2460			;	ld hl, (os_tok_len) 
2460			;;	pop bc 
2460			;	ld c, l                
2460			;	ld b,0 
2460			;	ld hl, (os_tok_ptr) 
2460			; 
2460			;if DEBUG_FORTH_TOK 
2460			;			DMARK "TKT" 
2460			;	CALLMONITOR 
2460			;endif 
2460			; 
2460			;	; do str cpy 
2460			; 
2460			;	ldir      ; copy byte in hl to de 
2460			; 
2460			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
2460			; 
2460			;if DEBUG_FORTH_TOK 
2460			; 
2460			;			DMARK "TKY" 
2460			;	CALLMONITOR 
2460			;endif 
2460			;	;ld a,0 
2460			;	;ld a,FORTH_END_BUFFER 
2460			;	ex de, hl 
2460			;	;dec hl			 ; go back over the space delim at the end of word 
2460			;	;ld (hl),a 
2460			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
2460			;	ld a,FORTH_END_BUFFER 
2460			;	ld (hl),a 
2460			;	inc hl 
2460			;	ld a,FORTH_END_BUFFER 
2460			;	ld (hl),a 
2460			; 
2460			;	; init the malloc area data 
2460			;	; set pc for in current area 
2460			;	;ld hl, (os_tok_malloc) 
2460			;	;inc hl 
2460			;	;inc hl 
2460			;	;inc hl 
2460			;	;ex de,hl 
2460			;	;ld hl, (os_tok_malloc) 
2460			;	;ld (hl),e 
2460			;	;inc hl 
2460			;	;ld (hl),d 
2460			; 
2460			; 
2460			;	ld hl,(os_tok_malloc) 
2460			;if DEBUG_FORTH_PARSE_KEY 
2460			;			DMARK "TKU" 
2460			;	CALLMONITOR 
2460			;endif 
2460			; 
2460			;	ret 
2460			 
2460			forthexec: 
2460			 
2460			; line exec: 
2460			; forth parser 
2460			 
2460			; 
2460			;       get current exec line on rsp 
2460			 
2460				FORTH_RSP_TOS 
2460 cd bd 1f			call macro_forth_rsp_tos 
2463				endm 
# End of macro FORTH_RSP_TOS
2463			 
2463			;       restore current pc - hl points to malloc of data 
2463			 
2463				;ld e, (hl) 
2463				;inc hl 
2463				;ld d, (hl) 
2463				;ex de,hl 
2463			 
2463			 
2463			exec1: 
2463 22 f4 f3			ld (os_tok_ptr), hl                 ; here move out of repeated saving in this tight loop 
2466			 
2466				; copy our PC to working vars  
2466 22 72 f9			ld (cli_ptr), hl                    ; here 
2469 22 70 f9			ld (cli_origptr), hl                ; here 
246c			 
246c 7e				ld a,(hl)                           ; here make hl be the ram ptr 
246d fe 7f			cp FORTH_END_BUFFER 
246f c8				ret z 
2470			 
2470				; skip any nulls 
2470			 
2470			;	cp 0 
2470 b7				or a 
2471 20 03			jr nz, .execword 
2473 23				inc hl 
2474 18 ed			jr exec1 
2476			 
2476			 
2476			.execword: 
2476			 
2476			 
2476			 
2476			if DEBUG_FORTH_PARSE_EXEC 
2476						DMARK "KYQ" 
2476				CALLMONITOR 
2476			endif 
2476			;       while at start of word: 
2476			; get start of dict (in user area first) 
2476			 
2476 21 00 80		ld hl, baseram 
2479			;ld hl, sysdict 
2479 22 74 f9		ld (cli_nextword),hl                            ; here do we need to do this? 
247c			;           match word at pc 
247c			;           exec word 
247c			;           or push to dsp 
247c			;           forward to next token 
247c			;           if line term pop rsp and exit 
247c			;        
247c			 
247c			if DEBUG_FORTH_PARSE_EXEC 
247c						DMARK "KYq" 
247c				CALLMONITOR 
247c			endif 
247c			 
247c			; 
247c			; word comp 
247c			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
247c			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
247c			;    move to start of word  
247c			;    compare word to cli_token 
247c			 
247c			.execpnword:	; HL at start of a word in the dictionary to check 
247c			 
247c 2a 74 f9			ld hl,(cli_nextword)                  ; here remove the need to store???? 
247f			 
247f cd 14 25			call forth_tok_next 
2482			; tok next end here 
2482 22 74 f9			ld (cli_nextword), hl     ; save for next check if no match on this word 
2485 eb				ex de, hl 
2486			 
2486			 
2486				; save the pointer of the current token - 1 to check against 
2486				 
2486 22 78 f9			ld (cli_token), hl   
2489				; TODO maybe remove below save if no debug 
2489				; save token string ptr for any debug later 
2489 23				inc hl  
248a 22 7a f9			ld (cli_origtoken), hl 
248d 2b				dec hl 
248e				; save pointer to the start of the next dictionay word 
248e 7e				ld a,(hl)   ; get string length 
248f 47				ld b,a 
2490			.execpnwordinc:  
2490 23				inc hl 
2491 10 fd			djnz .execpnwordinc 
2493 22 76 f9			ld (cli_execword), hl      ; save start of this words code 
2496			 
2496				; now check the word token against the string being parsed 
2496			 
2496 2a 78 f9			ld hl,(cli_token) 
2499 23				inc hl     ; skip string length (use zero term instead to end) 
249a				;ld (cli_token), hl 
249a			 
249a			.execpnchar:    ; compare char between token and string to parse 
249a			 
249a			 
249a				;ld hl, (cli_token)     ; the dict word  
249a ed 5b 72 f9		ld de, (cli_ptr)     ; cli to parse 
249e			 
249e			 
249e			.execpncharl:    ; compare char between token and string to parse (loop) 
249e			 
249e 1a				ld a,(de) 
249f cd fb 12			call toUpper 		; make sure the input string matches case 
24a2 be				cp (hl) 
24a3			 
24a3 c2 bb 24			jp nz, .execpnskipword	 ; no match so move to next word 
24a6				 
24a6			;    if same 
24a6			;       scan for string terms 0 for token and 32 for input 
24a6 46				ld b,(hl) 
24a7 80				add b			 
24a8 23				inc hl 
24a9 13				inc de 
24aa b7				or a 
24ab			;	cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
24ab							; TODO need to make sure last word in zero term string is accounted for 
24ab 20 f1			jr nz, .execpncharl 		 ; not at end of strings yet 
24ad			 
24ad			 
24ad				; at end of both strings so both are exact match 
24ad			 
24ad			;       skip ptr for next word 
24ad			 
24ad 2a 72 f9			ld hl,(cli_ptr) 	; at input string term 
24b0 23				inc hl			 ; at next char 
24b1 22 72 f9			ld (cli_ptr), hl     ; save for next round of the parser 
24b4 22 70 f9			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
24b7				 
24b7				 
24b7			 
24b7			 
24b7			 
24b7			;       exec code block 
24b7			if DEBUG_FORTH_JP 
24b7				call clear_display 
24b7				call update_display 
24b7				call delay1s 
24b7				ld hl, (cli_execword)     ; save for next check if no match on this word 
24b7				ld a,h 
24b7				ld hl, os_word_scratch 
24b7				call hexout 
24b7				ld hl, (cli_execword)     ; save for next check if no match on this word 
24b7				ld a,l 
24b7				ld hl, os_word_scratch+2 
24b7				call hexout 
24b7				ld hl, os_word_scratch+4 
24b7			;	ld a,0 
24b7				ld (hl),0 
24b7				ld de,os_word_scratch 
24b7				call str_at_display 
24b7					ld a, display_row_2 
24b7					call str_at_display 
24b7				ld de, (cli_origtoken) 
24b7				ld a, display_row_1+10 
24b7					call str_at_display 
24b7			 
24b7				ld a,display_row_1 
24b7				ld de, .foundword 
24b7				ld a, display_row_3 
24b7				call str_at_display 
24b7				call update_display 
24b7				call delay1s 
24b7				call delay1s 
24b7				call delay1s 
24b7			endif 
24b7			 
24b7			if DEBUG_FORTH_PARSE_EXEC 
24b7						DMARK "KYj" 
24b7			endif 
24b7				; TODO save the word pointer in this exec 
24b7			 
24b7 2a 76 f9			ld hl,(cli_execword) 
24ba e9				jp (hl) 
24bb			 
24bb			 
24bb			;    if not same 
24bb			;	scan for zero term 
24bb			;	get ptr for next word 
24bb			;	goto word comp 
24bb			 
24bb			.execpnskipword:	; get pointer to next word 
24bb 2a 74 f9			ld hl,(cli_nextword) 
24be			 
24be 7e				ld a,(hl) 
24bf fe 00			cp WORD_SYS_END 
24c1			;	cp 0 
24c1 28 09			jr z, .execendofdict			 ; at end of words 
24c3			 
24c3			if DEBUG_FORTH_PARSE_EXEC 
24c3						DMARK "KY4" 
24c3			endif 
24c3			if DEBUG_FORTH_PARSE_EXEC 
24c3			 
24c3				; see if disabled 
24c3			 
24c3			;	ld a, (os_view_disable) 
24c3			;	cp '*' 
24c3				ld a,(debug_vector) 
24c3				cp $c9   ; RET 
24c3				jr z, .noskip 
24c3			 
24c3			 
24c3				ld de, .nowordfound 
24c3				ld a, display_row_3 
24c3				call str_at_display 
24c3				call update_display 
24c3				ld a, 100 
24c3				call aDelayInMS 
24c3				 
24c3				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24c3					call delay250ms 
24c3				endif 
24c3			.noskip:  
24c3			 
24c3			endif	 
24c3			 
24c3 2a 70 f9			ld hl,(cli_origptr) 
24c6 22 72 f9			ld (cli_ptr),hl 
24c9			 
24c9			if DEBUG_FORTH_PARSE_EXEC 
24c9						DMARK "KY5" 
24c9			endif 
24c9 c3 7c 24			jp .execpnword			; else go to next word 
24cc			 
24cc			.execendofdict:  
24cc			 
24cc			if DEBUG_FORTH_PARSE_EXEC 
24cc						DMARK "KYe" 
24cc			endif 
24cc			if DEBUG_FORTH_PARSE_EXEC 
24cc				; see if disabled 
24cc			 
24cc			;	ld a, (os_view_disable) 
24cc			;	cp '*' 
24cc				ld a,(debug_vector) 
24cc				cp $c9   ; ret 
24cc				jr z, .ispskip 
24cc			 
24cc				call clear_display 
24cc				call update_display 
24cc				call delay1s 
24cc				ld de, (cli_origptr) 
24cc				ld a, display_row_1 
24cc				call str_at_display 
24cc				 
24cc				ld de, .enddict 
24cc				ld a, display_row_3 
24cc				call str_at_display 
24cc				call update_display 
24cc				ld a, 100 
24cc				call aDelayInMS 
24cc				if DEBUG_FORTH_PARSE_EXEC_SLOW 
24cc				call delay1s 
24cc				call delay1s 
24cc				call delay1s 
24cc				endif 
24cc			.ispskip:  
24cc				 
24cc			endif	 
24cc			 
24cc			 
24cc			 
24cc				; if the word is not a keyword then must be a literal so push it to stack 
24cc			 
24cc			; push token to stack to end of word 
24cc			 
24cc				STACKFRAME ON $1efe $2f9f 
24cc				if DEBUG_STACK_IMB 
24cc					if ON 
24cc						exx 
24cc						ld de, $1efe 
24cc						ld a, d 
24cc						ld hl, curframe 
24cc						call hexout 
24cc						ld a, e 
24cc						ld hl, curframe+2 
24cc						call hexout 
24cc						ld hl, $1efe 
24cc						push hl 
24cc						ld hl, $2f9f 
24cc						push hl 
24cc						exx 
24cc					endif 
24cc				endif 
24cc			endm 
# End of macro STACKFRAME
24cc			 
24cc 2a f4 f3		ld hl,(os_tok_ptr) 
24cf cd 61 21		call forth_apush 
24d2			 
24d2				STACKFRAMECHK ON $1efe $2f9f 
24d2				if DEBUG_STACK_IMB 
24d2					if ON 
24d2						exx 
24d2						ld hl, $2f9f 
24d2						pop de   ; $2f9f 
24d2						call cmp16 
24d2						jr nz, .spnosame 
24d2						ld hl, $1efe 
24d2						pop de   ; $1efe 
24d2						call cmp16 
24d2						jr z, .spfrsame 
24d2						.spnosame: call showsperror 
24d2						.spfrsame: nop 
24d2						exx 
24d2					endif 
24d2				endif 
24d2			endm 
# End of macro STACKFRAMECHK
24d2			 
24d2			execnext: 
24d2			 
24d2			if DEBUG_FORTH_PARSE_EXEC 
24d2						DMARK "KY>" 
24d2			endif 
24d2			; move past token to next word 
24d2			 
24d2 2a f4 f3		ld hl, (os_tok_ptr) 
24d5 3e 00		ld a, 0 
24d7 01 ff 00		ld bc, 255     ; input buffer size 
24da ed b1		cpir 
24dc			 
24dc			if DEBUG_FORTH_PARSE_EXEC 
24dc						DMARK "KY!" 
24dc				CALLMONITOR 
24dc			endif	 
24dc			; TODO this might place hl on the null, so will need to forward on??? 
24dc			;inc hl   ; see if this gets onto the next item 
24dc			 
24dc			 
24dc			; TODO pass a pointer to the buffer to push 
24dc			; TODO call function to push 
24dc			 
24dc			; look for end of input 
24dc			 
24dc			;inc hl 
24dc			;ld a,(hl) 
24dc			;cp FORTH_END_BUFFER 
24dc			;ret z 
24dc			 
24dc			 
24dc c3 63 24		jp exec1 
24df			 
24df			 
24df			 
24df			 
24df			 
24df			 
24df			 
24df			 
24df			 
24df			findnexttok: 
24df			 
24df				; hl is pointer to move 
24df				; de is the token to locate 
24df			 
24df					if DEBUG_FORTH 
24df						DMARK "NTK" 
24df						CALLMONITOR 
24df					endif 
24df d5				push de 
24e0			 
24e0			.fnt1:	 
24e0				; find first char of token to locate 
24e0			 
24e0 1a				ld a, (de) 
24e1 4f				ld c,a 
24e2 7e				ld a,(hl) 
24e3 cd fb 12			call toUpper 
24e6					if DEBUG_FORTH 
24e6						DMARK "NT1" 
24e6						CALLMONITOR 
24e6					endif 
24e6 b9				cp c 
24e7			 
24e7 28 03			jr z, .fnt2cmpmorefirst	 
24e9			 
24e9				; first char not found move to next char 
24e9			 
24e9 23				inc hl 
24ea 18 f4			jr .fnt1 
24ec			 
24ec			.fnt2cmpmorefirst:	 
24ec				; first char of token found.  
24ec			 
24ec e5				push hl     ; save start of token just in case it is the right one 
24ed d9				exx 
24ee e1				pop hl        ; save it to hl' 
24ef d9				exx 
24f0			 
24f0			 
24f0			.fnt2cmpmore:	 
24f0				; compare the rest 
24f0				 
24f0 23				inc hl 
24f1 13				inc de 
24f2				 
24f2 1a				ld a, (de) 
24f3 4f				ld c,a 
24f4 7e				ld a,(hl) 
24f5 cd fb 12			call toUpper 
24f8			 
24f8					if DEBUG_FORTH 
24f8						DMARK "NT2" 
24f8						CALLMONITOR 
24f8					endif 
24f8				; c has the token to find char 
24f8				; a has the mem to scan char 
24f8			 
24f8 b9				cp c 
24f9 28 04			jr z,.fntmatch1 
24fb			 
24fb				; they are not the same 
24fb			 
24fb					if DEBUG_FORTH 
24fb						DMARK "NT3" 
24fb						CALLMONITOR 
24fb					endif 
24fb d1				pop de	; reset de token to look for 
24fc d5				push de 
24fd 18 e1			jr .fnt1 
24ff				 
24ff			.fntmatch1: 
24ff			 
24ff				; is the same char a null which means we might have a full hit? 
24ff					if DEBUG_FORTH 
24ff						DMARK "NT4" 
24ff						CALLMONITOR 
24ff					endif 
24ff			 
24ff			;	cp 0 
24ff b7				or a 
2500 28 0b			jr z, .fntmatchyes 
2502			 
2502				; are we at the end of the token to find? 
2502			 
2502					if DEBUG_FORTH 
2502						DMARK "NT5" 
2502						CALLMONITOR 
2502					endif 
2502 3e 00			ld a, 0 
2504 b9				cp c 
2505			 
2505 c2 f0 24			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
2508			 
2508					if DEBUG_FORTH 
2508						DMARK "NT6" 
2508						CALLMONITOR 
2508					endif 
2508				; token to find is exhusted but no match to stream 
2508			 
2508				; restore tok pointer and continue on 
2508 d1				pop de 
2509 d5				push de 
250a c3 e0 24			jp .fnt1 
250d			 
250d			 
250d			.fntmatchyes: 
250d			 
250d				; hl now contains the end of the found token 
250d			 
250d				; get rid of saved token pointer to find 
250d			 
250d d1				pop de 
250e			 
250e					if DEBUG_FORTH 
250e						DMARK "NT9" 
250e						CALLMONITOR 
250e					endif 
250e			 
250e				; hl will be on the null term so forward on 
250e			 
250e				; get back the saved start of the token 
250e			 
250e d9				exx 
250f e5				push hl     ; save start of token just in case it is the right one 
2510 d9				exx 
2511 e1				pop hl        ; save it to hl 
2512			 
2512 c9				ret 
2513			 
2513			 
2513			; LIST needs to find a specific token   
2513			; FORGET needs to find a spefici token 
2513			 
2513			; SAVE needs to find all tokens by flag 
2513			; WORDS just needs to scan through all  by flag 
2513			; UWORDS needs to scan through all by flag 
2513			 
2513			 
2513			; given hl as pointer to start of dict look up string 
2513			; return hl as pointer to start of word block 
2513			; or 0 if not found 
2513			 
2513			forth_find_tok: 
2513 c9				ret 
2514			 
2514			; given hl as pointer to dict structure 
2514			; move to the next dict block structure 
2514			 
2514			forth_tok_next: 
2514				; hl now points to the address of the next word pointer  
2514				; TODO skip compiled symbol for now 
2514			;	push de 
2514 23				inc hl 
2515 5e				ld e, (hl) 
2516 23				inc hl 
2517 56				ld d, (hl) 
2518 23				inc hl 
2519			 
2519 eb				ex de,hl 
251a			if DEBUG_FORTH_PARSE_NEXTWORD 
251a				push bc 
251a				ld bc, (cli_nextword) 
251a						DMARK "NXW" 
251a				CALLMONITOR 
251a				pop bc 
251a			endif 
251a			;	pop de	 
251a c9				ret 
251b			 
251b			 
251b			 
251b			; eof 
# End of file forth_parserv6.asm
251b				include "forth_wordsv4.asm" 
251b			 
251b			; the core word dictionary v4 
251b			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
251b			 
251b			; this is a linked list for each of the system words used 
251b			; user defined words will follow the same format but will be in ram 
251b			 
251b			 
251b			; 
251b			; 
251b			; define linked list: 
251b			; 
251b			; 1. compiled byte op code 
251b			; 2. len of text word 
251b			; 3. text word 
251b			; 4. ptr to next dictionary word 
251b			; 5. asm, calls etc for the word 
251b			; 
251b			;  if 1 == 0 then last word in dict  
251b			;   
251b			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
251b			;  
251b			;  
251b			; create basic standard set of words 
251b			; 
251b			;  
251b			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
251b			; 2DUP 2DROP 2SWAP  
251b			; @ C@ - get byte  
251b			; ! C! - store byte 
251b			; 0< true if less than zero 
251b			; 0= true if zero 
251b			; < >  
251b			; = true if same 
251b			; variables 
251b			 
251b			 
251b			; Hardware specific words I may need 
251b			; 
251b			; IN OUT  
251b			; calls to key util functions 
251b			; calls to hardward abstraction stuff 
251b			; easy control of frame buffers and lcd i/o 
251b			; keyboard  
251b			 
251b			 
251b			;DICT: macro 
251b			; op_code, len, word, next 
251b			;    word: 
251b			;    db op_code 
251b			;    ds word zero term 
251b			;    dw next 
251b			;    endm 
251b			 
251b			 
251b			 
251b			 
251b			; op code 1 is a flag for user define words which are to be handled differently 
251b			 
251b			 
251b			; 
251b			; 
251b			;    TODO on entry to a word this should be the expected environment 
251b			;    hl - tos value if number then held, if string this is the ptr 
251b			;    de -  
251b			 
251b			 
251b			; opcode ranges 
251b			; 0 - end of word dict 
251b			; 255 - user define words 
251b			 
251b			sysdict: 
251b			include "forth_opcodes.asm" 
251b			; op codes for forth keywords 
251b			 
251b			; Changing use of opcodes to flag is the word exists in compiled form or not.  
251b			; This provides a means to compile uwords if required for higher performance 
251b			; by avoiding the use of the keyword parser and just jumping directly to the code 
251b			; Actually there is already a flag for if the code exists as binary thinking about it... 
251b			 
251b			 
251b			 
251b			 
251b			 
251b			; free to use code 0  
251b				OPCODE_HEAP: equ  1 
251b				OPCODE_EXEC: equ 2 
251b				OPCODE_DUP: equ 3 
251b				OPCODE_SWAP: equ 4 
251b				OPCODE_COLN: equ 5 
251b				OPCODE_SCOLN: equ 6 
251b				OPCODE_DROP: equ 7 
251b				OPCODE_DUP2: equ 8 
251b				OPCODE_DROP2: equ 9 
251b				OPCODE_SWAP2: equ 10 
251b				OPCODE_AT: equ 11 
251b				OPCODE_CAT: equ 12 
251b				OPCODE_BANG: equ 13 
251b				OPCODE_CBANG: equ 14 
251b				OPCODE_SCALL: equ 15 
251b				OPCODE_DEPTH: equ 16 
251b				OPCODE_OVER: equ 17 
251b				OPCODE_PAUSE: equ 18 
251b				OPCODE_PAUSES: equ 19 
251b				OPCODE_ROT: equ 20 
251b			;free to reuse	OPCODE_WORDS: equ 21 
251b			        OPCODE_NOT: equ 21 
251b				OPCODE_UWORDS: equ 22 
251b				OPCODE_BP: equ 23 
251b				OPCODE_MONITOR: equ 24  
251b				OPCODE_MALLOC: equ 25 
251b				OPCODE_FREE: equ 26 
251b				OPCODE_LIST: equ 27 
251b				OPCODE_FORGET: equ 28 
251b				OPCODE_NOP: equ 29 
251b				OPCODE_COMO: equ 30 
251b				OPCODE_COMC: equ 31 
251b			;free to reuse	OPCODE_ENDCORE: equ 32 
251b				OPCODE_AFTERSOUND: equ 33 
251b				OPCODE_GP2: equ 34 
251b				OPCODE_GP3: equ 35 
251b				OPCODE_GP4: equ 36 
251b				OPCODE_SIN: equ 37 
251b				OPCODE_SOUT: equ 38 
251b				OPCODE_SPIO: equ 39 
251b				OPCODE_SPICEH: equ 40 
251b				OPCODE_SPIOb: equ 41 
251b				OPCODE_SPII: equ 42 
251b				OPCODE_SESEL: equ 43 
251b				OPCODE_CARTDEV: equ 44 
251b			; free to reuse	OPCODE_ENDDEVICE: equ 45 
251b				OPCODE_FB: equ 46 
251b				OPCODE_EMIT: equ 47 
251b				OPCODE_DOTH: equ 48 
251b				OPCODE_DOTF: equ 49 
251b				OPCODE_DOT: equ 50 
251b				OPCODE_CLS: equ 51 
251b				OPCODE_DRAW: equ 52 
251b				OPCODE_DUMP: equ 53 
251b				OPCODE_CDUMP: equ 54 
251b				OPCODE_DAT: equ 55 
251b				OPCODE_HOME: equ 56 
251b				OPCODE_SPACE: equ 57 
251b				OPCODE_SPACES: equ 58 
251b				OPCODE_SCROLL: equ 59 
251b				OPCODE_ATQ: equ 60 
251b				OPCODE_AUTODSP: equ 61 
251b				OPCODE_MENU: equ 62 
251b			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
251b				OPCODE_THEN: equ 64 
251b				OPCODE_ELSE: equ 65 
251b				OPCODE_DO: equ 66 
251b				OPCODE_LOOP: equ 67 
251b				OPCODE_I: equ 68 
251b				OPCODE_DLOOP: equ 69  
251b				OPCODE_REPEAT: equ 70  
251b				OPCODE_UNTIL: equ 71 
251b				OPCODE_ENDFLOW: equ 72 
251b				OPCODE_WAITK: equ 73 
251b				OPCODE_ACCEPT: equ 74 
251b				OPCODE_EDIT: equ 75 
251b			;free to reuse	OPCODE_ENDKEY: equ 76 
251b				OPCODE_LZERO: equ 77 
251b				OPCODE_TZERO: equ 78 
251b				OPCODE_LESS: equ 79 
251b				OPCODE_GT: equ 80 
251b				OPCODE_EQUAL: equ 81  
251b			;free to reuse	OPCODE_ENDLOGIC: equ 82 
251b				OPCODE_NEG: equ 83 
251b				OPCODE_DIV: equ 84 
251b				OPCODE_MUL: equ 85 
251b				OPCODE_MIN: equ 86 
251b				OPCODE_MAX: equ 87 
251b				OPCODE_RND16: equ 88 
251b				OPCODE_RND8: equ 89 
251b				OPCODE_RND: equ 90 
251b			;free to reuse	OPCODE_ENDMATHS: equ 91  
251b				OPCODE_BYNAME: equ 92 
251b				OPCODE_DIR: equ 93 
251b				OPCODE_SAVE: equ 94 
251b				OPCODE_LOAD: equ 95 
251b				OPCODE_BSAVE: equ 96 
251b				OPCODE_BLOAD: equ 97 
251b				OPCODE_SEO: equ 98  
251b				OPCODE_SEI: equ 99 
251b				OPCODE_SFREE: equ 100 
251b				OPCODE_SIZE: equ 101 
251b				OPCODE_CREATE: equ 102 
251b				OPCODE_APPEND: equ 103 
251b				OPCODE_SDEL: equ 104 
251b				OPCODE_OPEN: equ 105 
251b				OPCODE_READ: equ 106 
251b				OPCODE_EOF: equ 106 
251b				OPCODE_FORMAT: equ 107 
251b				OPCODE_LABEL: equ 108 
251b				OPCODE_LABELS: equ 109 
251b			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
251b				OPCODE_UPPER: equ 111 
251b				OPCODE_LOWER: equ 112 
251b				OPCODE_SUBSTR: equ 113 
251b				OPCODE_LEFT: equ 114 
251b				OPCODE_RIGHT: equ 115 
251b				OPCODE_STR2NUM: equ 116 
251b				OPCODE_NUM2STR: equ 117 
251b				OPCODE_CONCAT: equ 118 
251b				OPCODE_FIND: equ 119 
251b				OPCODE_LEN: equ 120 
251b				OPCODE_CHAR: equ 121 
251b			; free to reuse	OPCODE_STRLEN: equ 122 
251b			; free to reuse	OPCODE_ENDSTR: equ 123 
251b				OPCODE_V0S: equ 124 
251b				OPCODE_V0Q: equ 125 
251b				OPCODE_V1S: equ 126 
251b				OPCODE_V1Q: equ 127 
251b				OPCODE_V2S: equ 128 
251b				OPCODE_V2Q: equ 129 
251b				OPCODE_V3S: equ 130 
251b				OPCODE_V3Q: equ 131 
251b			;free to reuse	OPCODE_END: equ 132 
251b				OPCODE_ZDUP: equ 133 
251b			 
251b			; eof 
# End of file forth_opcodes.asm
251b			 
251b			include "forth_words_core.asm" 
251b			 
251b			; | ## Core Words 
251b			 
251b			;if MALLOC_4 
251b			 
251b			.HEAP: 
251b			CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
251b 15				db WORD_SYS_CORE+OPCODE_HEAP             
251c 5d 25			dw .EXEC            
251e 05				db 4 + 1 
251f .. 00			db "HEAP",0              
2524				endm 
# End of macro CWHEAD
2524			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
2524			; | | u1 - Current number of bytes in the heap 
2524			; | | u2 - Remaining bytes left on the heap 
2524			; | |  
2524			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
2524			 
2524			 
2524				if DEBUG_FORTH_WORDS_KEY 
2524					DMARK "HEP" 
2524 f5				push af  
2525 3a 39 25			ld a, (.dmark)  
2528 32 9d fd			ld (debug_mark),a  
252b 3a 3a 25			ld a, (.dmark+1)  
252e 32 9e fd			ld (debug_mark+1),a  
2531 3a 3b 25			ld a, (.dmark+2)  
2534 32 9f fd			ld (debug_mark+2),a  
2537 18 03			jr .pastdmark  
2539 ..			.dmark: db "HEP"  
253c f1			.pastdmark: pop af  
253d			endm  
# End of macro DMARK
253d					CALLMONITOR 
253d cd aa fd			call debug_vector  
2540				endm  
# End of macro CALLMONITOR
2540				endif 
2540 2a 0a 80			ld hl, (free_list )      
2543 11 0e 80			ld de, heap_start 
2546			 
2546 ed 52			sbc hl, de  
2548			 
2548 cd ff 1f			call forth_push_numhl 
254b			 
254b			 
254b ed 5b 0a 80		ld de, (free_list )      
254f 21 ce f0			ld hl, heap_end 
2552			 
2552 ed 52			sbc hl, de 
2554			 
2554 cd ff 1f			call forth_push_numhl 
2557				 
2557			 
2557				 
2557			 
2557			 
2557			 
2557				NEXTW 
2557 cd a7 fd			call parse_vector 
255a c3 e2 23			jp macro_next 
255d				endm 
# End of macro NEXTW
255d			;endif 
255d			 
255d			.EXEC: 
255d			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
255d			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
255d			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
255d			;; > > 
255d			;; > >   
255d			;	STACKFRAME OFF $5efe $5f9f 
255d			; 
255d			;		if DEBUG_FORTH_WORDS_KEY 
255d			;			DMARK "EXE" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			; 
255d			;	FORTH_DSP_VALUEHL 
255d			; 
255d			;	FORTH_DSP_POP 
255d			; 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EX1" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;;	ld e,(hl) 
255d			;;	inc hl 
255d			;;	ld d,(hl) 
255d			;;	ex de,hl 
255d			; 
255d			;;		if DEBUG_FORTH_WORDS 
255d			;;			DMARK "EX2" 
255d			;;			CALLMONITOR 
255d			;;		endif 
255d			;	push hl 
255d			; 
255d			;	;ld a, 0 
255d			;	;ld a, FORTH_END_BUFFER 
255d			;	call strlenz 
255d			;	inc hl   ; include zero term to copy 
255d			;	inc hl   ; include term 
255d			;	inc hl   ; include term 
255d			;	ld b,0 
255d			;	ld c,l 
255d			;	pop hl 
255d			;	ld de, execscratch 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EX3" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;	ldir 
255d			; 
255d			; 
255d			;	ld hl, execscratch 
255d			; 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EXe" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			; 
255d			;	call forthparse 
255d			;	call forthexec 
255d			;;	call forthexec_cleanup 
255d			;;	call forthparse 
255d			;;	call forthexec 
255d			; 
255d			;	STACKFRAMECHK OFF $5efe $5f9f 
255d			; 
255d			;	; an immediate word so no need to process any more words 
255d			;	ret 
255d			;	NEXTW 
255d			 
255d			; dead code - old version  
255d			;	FORTH_RSP_NEXT 
255d			 
255d			;  
255d			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
255d			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
255d			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
255d			;	push hl 
255d			;	push de 
255d			;	push bc 
255d			; 
255d			; 
255d			;		if DEBUG_FORTH_WORDS_KEY 
255d			;			DMARK "EXR" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			; 
255d			; 
255d			; 
255d			;	;v5 FORTH_DSP_VALUE 
255d			;	FORTH_DSP_VALUEHL 
255d			; 
255d			;	; TODO do string type checks 
255d			; 
255d			;;v5	inc hl   ; skip type 
255d			; 
255d			;	push hl  ; source code  
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EX1" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;	ld a, 0 
255d			;	call strlent 
255d			; 
255d			;	inc hl 
255d			;	inc hl 
255d			;	inc hl 
255d			;	inc hl 
255d			; 
255d			;	push hl    ; size 
255d			; 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EX2" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;	call malloc 
255d			; 
255d			;	ex de, hl    ; de now contains malloc area 
255d			;	pop bc   	; get byte count 
255d			;	pop hl      ; get string to copy 
255d			; 
255d			;	push de     ; save malloc for free later 
255d			; 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EX3" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;	ldir       ; duplicate string 
255d			; 
255d			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
255d			;	 
255d			;	; TODO fix the parse would be better than this...  
255d			;	ex de, hl 
255d			;	dec hl 
255d			;	ld a, 0 
255d			;	ld (hl), a 
255d			;	dec hl 
255d			;	ld a, ' ' 
255d			;	ld (hl), a 
255d			;	dec hl 
255d			;	ld (hl), a 
255d			; 
255d			;	dec hl 
255d			;	ld (hl), a 
255d			; 
255d			; 
255d			;	FORTH_DSP_POP  
255d			; 
255d			;	pop hl     
255d			;	push hl    ; save malloc area 
255d			; 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EX4" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			; 
255d			;	call forthparse 
255d			;	call forthexec 
255d			;	 
255d			;	pop hl 
255d			;	if DEBUG_FORTH_WORDS 
255d			;		DMARK "EX5" 
255d			;		CALLMONITOR 
255d			;	endif 
255d			; 
255d			;	if FORTH_ENABLE_FREE 
255d			;	call free 
255d			;	endif 
255d			; 
255d			;	if DEBUG_FORTH_WORDS 
255d			;		DMARK "EX6" 
255d			;		CALLMONITOR 
255d			;	endif 
255d			; 
255d			;	pop bc 
255d			;	pop de 
255d			;	pop hl 
255d			;;	FORTH_RSP_POP	  
255d			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
255d			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
255d			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
255d			; 
255d			;	if DEBUG_FORTH_WORDS 
255d			;		DMARK "EX7" 
255d			;		CALLMONITOR 
255d			;	endif 
255d			;	NEXTW 
255d			 
255d			;.STKEXEC: 
255d			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
255d			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
255d			; 
255d			; 
255d			;		if DEBUG_FORTH_WORDS_KEY 
255d			;			DMARK "STX" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			; 
255d			;	FORTH_DSP_VALUEHL 
255d			; 
255d			;	ld (store_tmp1), hl    ; count 
255d			; 
255d			;	FORTH_DSP_POP 
255d			;.stkexec1: 
255d			;	ld hl, (store_tmp1)   ; count 
255d			;	ld a, 0 
255d			;	cp l 
255d			;	ret z 
255d			; 
255d			;	dec hl 
255d			;	ld (store_tmp1), hl    ; count 
255d			;	 
255d			;	FORTH_DSP_VALUEHL 
255d			;	push hl 
255d			;	 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EXp" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;	FORTH_DSP_POP 
255d			; 
255d			;	call strlenz 
255d			;	inc hl   ; include zero term to copy 
255d			;	inc hl   ; include zero term to copy 
255d			;	inc hl   ; include zero term to copy 
255d			;	ld b,0 
255d			;	ld c,l 
255d			;	pop hl 
255d			;	ld de, execscratch 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EX3" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;	ldir 
255d			; 
255d			; 
255d			;	ld hl, execscratch 
255d			; 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EXP" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			; 
255d			;	call forthparse 
255d			;	ld hl, execscratch 
255d			;		if DEBUG_FORTH_WORDS 
255d			;			DMARK "EXx" 
255d			;			CALLMONITOR 
255d			;		endif 
255d			;	call forthexec 
255d			; 
255d			;	jp .stkexec1 
255d			; 
255d			;	ret 
255d			 
255d			 
255d			.DUP: 
255d			CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
255d 17				db WORD_SYS_CORE+OPCODE_DUP             
255e d9 25			dw .ZDUP            
2560 04				db 3 + 1 
2561 .. 00			db "DUP",0              
2565				endm 
# End of macro CWHEAD
2565			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
2565			; | | >[!NOTE] 
2565			; | | > If the duplicated item is a string it is safely duplicated 
2565			 
2565				if DEBUG_FORTH_WORDS_KEY 
2565					DMARK "DUP" 
2565 f5				push af  
2566 3a 7a 25			ld a, (.dmark)  
2569 32 9d fd			ld (debug_mark),a  
256c 3a 7b 25			ld a, (.dmark+1)  
256f 32 9e fd			ld (debug_mark+1),a  
2572 3a 7c 25			ld a, (.dmark+2)  
2575 32 9f fd			ld (debug_mark+2),a  
2578 18 03			jr .pastdmark  
257a ..			.dmark: db "DUP"  
257d f1			.pastdmark: pop af  
257e			endm  
# End of macro DMARK
257e					CALLMONITOR 
257e cd aa fd			call debug_vector  
2581				endm  
# End of macro CALLMONITOR
2581				endif 
2581			 
2581				FORTH_DSP 
2581 cd c1 21			call macro_forth_dsp 
2584				endm 
# End of macro FORTH_DSP
2584			 
2584 7e				ld a, (HL) 
2585 fe 01			cp DS_TYPE_STR 
2587 20 28			jr nz, .dupinum 
2589			 
2589				; push another string 
2589			 
2589				FORTH_DSP_VALUEHL     		 
2589 cd fb 21			call macro_dsp_valuehl 
258c				endm 
# End of macro FORTH_DSP_VALUEHL
258c			 
258c			if DEBUG_FORTH_WORDS 
258c				DMARK "DUs" 
258c f5				push af  
258d 3a a1 25			ld a, (.dmark)  
2590 32 9d fd			ld (debug_mark),a  
2593 3a a2 25			ld a, (.dmark+1)  
2596 32 9e fd			ld (debug_mark+1),a  
2599 3a a3 25			ld a, (.dmark+2)  
259c 32 9f fd			ld (debug_mark+2),a  
259f 18 03			jr .pastdmark  
25a1 ..			.dmark: db "DUs"  
25a4 f1			.pastdmark: pop af  
25a5			endm  
# End of macro DMARK
25a5				CALLMONITOR 
25a5 cd aa fd			call debug_vector  
25a8				endm  
# End of macro CALLMONITOR
25a8			endif 
25a8 cd 69 20			call forth_push_str 
25ab			 
25ab				NEXTW 
25ab cd a7 fd			call parse_vector 
25ae c3 e2 23			jp macro_next 
25b1				endm 
# End of macro NEXTW
25b1			 
25b1			 
25b1			.dupinum: 
25b1				 
25b1			 
25b1			 
25b1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25b1 cd fb 21			call macro_dsp_valuehl 
25b4				endm 
# End of macro FORTH_DSP_VALUEHL
25b4			 
25b4			; TODO add floating point number detection 
25b4			 
25b4			if DEBUG_FORTH_WORDS 
25b4				DMARK "DUi" 
25b4 f5				push af  
25b5 3a c9 25			ld a, (.dmark)  
25b8 32 9d fd			ld (debug_mark),a  
25bb 3a ca 25			ld a, (.dmark+1)  
25be 32 9e fd			ld (debug_mark+1),a  
25c1 3a cb 25			ld a, (.dmark+2)  
25c4 32 9f fd			ld (debug_mark+2),a  
25c7 18 03			jr .pastdmark  
25c9 ..			.dmark: db "DUi"  
25cc f1			.pastdmark: pop af  
25cd			endm  
# End of macro DMARK
25cd				CALLMONITOR 
25cd cd aa fd			call debug_vector  
25d0				endm  
# End of macro CALLMONITOR
25d0			endif 
25d0			 
25d0 cd ff 1f			call forth_push_numhl 
25d3				NEXTW 
25d3 cd a7 fd			call parse_vector 
25d6 c3 e2 23			jp macro_next 
25d9				endm 
# End of macro NEXTW
25d9			.ZDUP: 
25d9			CWHEAD .DMRK OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
25d9 99				db WORD_SYS_CORE+OPCODE_ZDUP             
25da 13 26			dw .DMRK            
25dc 05				db 4 + 1 
25dd .. 00			db "?DUP",0              
25e2				endm 
# End of macro CWHEAD
25e2			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero (Only works for numerics) | DONE 
25e2			; | | >[!NOTE] 
25e2			; | | > If the duplicated item is a string it is not safely duplicated and remain as pointer to the origin 
25e2			 
25e2				if DEBUG_FORTH_WORDS_KEY 
25e2					DMARK "qDU" 
25e2 f5				push af  
25e3 3a f7 25			ld a, (.dmark)  
25e6 32 9d fd			ld (debug_mark),a  
25e9 3a f8 25			ld a, (.dmark+1)  
25ec 32 9e fd			ld (debug_mark+1),a  
25ef 3a f9 25			ld a, (.dmark+2)  
25f2 32 9f fd			ld (debug_mark+2),a  
25f5 18 03			jr .pastdmark  
25f7 ..			.dmark: db "qDU"  
25fa f1			.pastdmark: pop af  
25fb			endm  
# End of macro DMARK
25fb					CALLMONITOR 
25fb cd aa fd			call debug_vector  
25fe				endm  
# End of macro CALLMONITOR
25fe				endif 
25fe				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fe cd fb 21			call macro_dsp_valuehl 
2601				endm 
# End of macro FORTH_DSP_VALUEHL
2601			 
2601 e5				push hl 
2602			 
2602				; is it a zero? 
2602			 
2602 3e 00			ld a, 0 
2604 84				add h 
2605 85				add l 
2606			 
2606 e1				pop hl 
2607			 
2607			;	cp 0 
2607 b7				or a 
2608 28 03			jr z, .dup2orig 
260a			 
260a			 
260a cd ff 1f			call forth_push_numhl 
260d			 
260d			 
260d			; TODO add floating point number detection 
260d			 
260d			.dup2orig: 
260d			 
260d				NEXTW 
260d cd a7 fd			call parse_vector 
2610 c3 e2 23			jp macro_next 
2613				endm 
# End of macro NEXTW
2613			.DMRK: 
2613			CWHEAD .LSHIFT OPCODE_ZDUP "DMARK" 5 WORD_FLAG_CODE 
2613 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2614 53 26			dw .LSHIFT            
2616 06				db 5 + 1 
2617 .. 00			db "DMARK",0              
261d				endm 
# End of macro CWHEAD
261d			; | DMARK ( s --  )  Set the debug marker id to first three chars of s | DONE 
261d			; | | Most useful for tracing your code for errors as you can set various markers to display when MONITOR is called 
261d				if DEBUG_FORTH_WORDS_KEY 
261d					DMARK "DMK" 
261d f5				push af  
261e 3a 32 26			ld a, (.dmark)  
2621 32 9d fd			ld (debug_mark),a  
2624 3a 33 26			ld a, (.dmark+1)  
2627 32 9e fd			ld (debug_mark+1),a  
262a 3a 34 26			ld a, (.dmark+2)  
262d 32 9f fd			ld (debug_mark+2),a  
2630 18 03			jr .pastdmark  
2632 ..			.dmark: db "DMK"  
2635 f1			.pastdmark: pop af  
2636			endm  
# End of macro DMARK
2636					CALLMONITOR 
2636 cd aa fd			call debug_vector  
2639				endm  
# End of macro CALLMONITOR
2639				endif 
2639				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2639 cd fb 21			call macro_dsp_valuehl 
263c				endm 
# End of macro FORTH_DSP_VALUEHL
263c			 
263c 7e				ld a, (hl) 
263d 32 9d fd			ld (debug_mark),a 
2640 23				inc hl 
2641 7e				ld a, (hl) 
2642 32 9e fd			ld (debug_mark+1),a 
2645 23				inc hl 
2646 7e				ld a, (hl) 
2647 32 9f fd			ld (debug_mark+2),a 
264a			 
264a			 
264a				FORTH_DSP_POP 
264a cd b3 22			call macro_forth_dsp_pop 
264d				endm 
# End of macro FORTH_DSP_POP
264d				NEXTW 
264d cd a7 fd			call parse_vector 
2650 c3 e2 23			jp macro_next 
2653				endm 
# End of macro NEXTW
2653			.LSHIFT: 
2653			CWHEAD .RSHIFT OPCODE_ZDUP "LSHIFT" 6 WORD_FLAG_CODE 
2653 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2654 8a 26			dw .RSHIFT            
2656 07				db 6 + 1 
2657 .. 00			db "LSHIFT",0              
265e				endm 
# End of macro CWHEAD
265e			; | LSHIFT ( w -- w )    16 bit left shift | DONE 
265e				if DEBUG_FORTH_WORDS_KEY 
265e					DMARK "LSH" 
265e f5				push af  
265f 3a 73 26			ld a, (.dmark)  
2662 32 9d fd			ld (debug_mark),a  
2665 3a 74 26			ld a, (.dmark+1)  
2668 32 9e fd			ld (debug_mark+1),a  
266b 3a 75 26			ld a, (.dmark+2)  
266e 32 9f fd			ld (debug_mark+2),a  
2671 18 03			jr .pastdmark  
2673 ..			.dmark: db "LSH"  
2676 f1			.pastdmark: pop af  
2677			endm  
# End of macro DMARK
2677					CALLMONITOR 
2677 cd aa fd			call debug_vector  
267a				endm  
# End of macro CALLMONITOR
267a				endif 
267a				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
267a cd fb 21			call macro_dsp_valuehl 
267d				endm 
# End of macro FORTH_DSP_VALUEHL
267d				FORTH_DSP_POP 
267d cd b3 22			call macro_forth_dsp_pop 
2680				endm 
# End of macro FORTH_DSP_POP
2680			 
2680 29				add hl, hl 
2681 cd ff 1f			call forth_push_numhl 
2684				NEXTW 
2684 cd a7 fd			call parse_vector 
2687 c3 e2 23			jp macro_next 
268a				endm 
# End of macro NEXTW
268a			.RSHIFT: 
268a			CWHEAD .SWAP OPCODE_ZDUP "RSHIFT" 6 WORD_FLAG_CODE 
268a 99				db WORD_SYS_CORE+OPCODE_ZDUP             
268b c4 26			dw .SWAP            
268d 07				db 6 + 1 
268e .. 00			db "RSHIFT",0              
2695				endm 
# End of macro CWHEAD
2695			; | RSHIFT ( w -- w )    16 bit right shift | DONE 
2695				if DEBUG_FORTH_WORDS_KEY 
2695					DMARK "RSH" 
2695 f5				push af  
2696 3a aa 26			ld a, (.dmark)  
2699 32 9d fd			ld (debug_mark),a  
269c 3a ab 26			ld a, (.dmark+1)  
269f 32 9e fd			ld (debug_mark+1),a  
26a2 3a ac 26			ld a, (.dmark+2)  
26a5 32 9f fd			ld (debug_mark+2),a  
26a8 18 03			jr .pastdmark  
26aa ..			.dmark: db "RSH"  
26ad f1			.pastdmark: pop af  
26ae			endm  
# End of macro DMARK
26ae					CALLMONITOR 
26ae cd aa fd			call debug_vector  
26b1				endm  
# End of macro CALLMONITOR
26b1				endif 
26b1				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b1 cd fb 21			call macro_dsp_valuehl 
26b4				endm 
# End of macro FORTH_DSP_VALUEHL
26b4				FORTH_DSP_POP 
26b4 cd b3 22			call macro_forth_dsp_pop 
26b7				endm 
# End of macro FORTH_DSP_POP
26b7 cb 3c			srl h 
26b9 cb 1d			rr l 
26bb cd ff 1f			call forth_push_numhl 
26be				NEXTW 
26be cd a7 fd			call parse_vector 
26c1 c3 e2 23			jp macro_next 
26c4				endm 
# End of macro NEXTW
26c4			.SWAP: 
26c4			CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
26c4 18				db WORD_SYS_CORE+OPCODE_SWAP             
26c5 1b 27			dw .COLN            
26c7 05				db 4 + 1 
26c8 .. 00			db "SWAP",0              
26cd				endm 
# End of macro CWHEAD
26cd			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
26cd				if DEBUG_FORTH_WORDS_KEY 
26cd					DMARK "SWP" 
26cd f5				push af  
26ce 3a e2 26			ld a, (.dmark)  
26d1 32 9d fd			ld (debug_mark),a  
26d4 3a e3 26			ld a, (.dmark+1)  
26d7 32 9e fd			ld (debug_mark+1),a  
26da 3a e4 26			ld a, (.dmark+2)  
26dd 32 9f fd			ld (debug_mark+2),a  
26e0 18 03			jr .pastdmark  
26e2 ..			.dmark: db "SWP"  
26e5 f1			.pastdmark: pop af  
26e6			endm  
# End of macro DMARK
26e6					CALLMONITOR 
26e6 cd aa fd			call debug_vector  
26e9				endm  
# End of macro CALLMONITOR
26e9				endif 
26e9			 
26e9			; DONE Use os stack swap memory 
26e9			 
26e9				FORTH_DSP_PTR 0     ; TOS 
26e9 2a 20 f9			ld hl,(cli_data_sp) 
26ec 11 00 00			ld de, 0 * 3 
26ef ed 52			sbc hl, de 
26f1				endm 
# End of macro FORTH_DSP_PTR
26f1 cd 32 23			call hltostack1 
26f4			  
26f4				FORTH_DSP_PTR 1     ; TOS 
26f4 2a 20 f9			ld hl,(cli_data_sp) 
26f7 11 03 00			ld de, 1 * 3 
26fa ed 52			sbc hl, de 
26fc				endm 
# End of macro FORTH_DSP_PTR
26fc cd 38 23			call hltostack2 
26ff			 
26ff				FORTH_DSP_PTR 0     ; TOS 
26ff 2a 20 f9			ld hl,(cli_data_sp) 
2702 11 00 00			ld de, 0 * 3 
2705 ed 52			sbc hl, de 
2707				endm 
# End of macro FORTH_DSP_PTR
2707 cd 50 23			call hlfromstack2 
270a			 
270a				FORTH_DSP_PTR 1     ; TOS 
270a 2a 20 f9			ld hl,(cli_data_sp) 
270d 11 03 00			ld de, 1 * 3 
2710 ed 52			sbc hl, de 
2712				endm 
# End of macro FORTH_DSP_PTR
2712 cd 4a 23			call hlfromstack1 
2715			;	FORTH_DSP_VALUEHL 
2715			;	push hl     ; w2 
2715			; 
2715			;	FORTH_DSP_POP 
2715			; 
2715			;	FORTH_DSP_VALUEHL 
2715			; 
2715			;	FORTH_DSP_POP 
2715			; 
2715			;	pop de     ; w2	, hl = w1 
2715			; 
2715			;	ex de, hl 
2715			;	push de 
2715			; 
2715			;	call forth_push_numhl 
2715			; 
2715			;	pop hl 
2715			; 
2715			;	call forth_push_numhl 
2715				 
2715			 
2715				NEXTW 
2715 cd a7 fd			call parse_vector 
2718 c3 e2 23			jp macro_next 
271b				endm 
# End of macro NEXTW
271b			.COLN: 
271b			CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
271b 19				db WORD_SYS_CORE+OPCODE_COLN             
271c a6 28			dw .SCOLN            
271e 02				db 1 + 1 
271f .. 00			db ":",0              
2721				endm 
# End of macro CWHEAD
2721			; | : ( -- )         Create new word | DONE 
2721			 
2721				if DEBUG_FORTH_WORDS_KEY 
2721					DMARK "CLN" 
2721 f5				push af  
2722 3a 36 27			ld a, (.dmark)  
2725 32 9d fd			ld (debug_mark),a  
2728 3a 37 27			ld a, (.dmark+1)  
272b 32 9e fd			ld (debug_mark+1),a  
272e 3a 38 27			ld a, (.dmark+2)  
2731 32 9f fd			ld (debug_mark+2),a  
2734 18 03			jr .pastdmark  
2736 ..			.dmark: db "CLN"  
2739 f1			.pastdmark: pop af  
273a			endm  
# End of macro DMARK
273a					CALLMONITOR 
273a cd aa fd			call debug_vector  
273d				endm  
# End of macro CALLMONITOR
273d				endif 
273d			STACKFRAME OFF $8efe $989f 
273d				if DEBUG_STACK_IMB 
273d					if OFF 
273d						exx 
273d						ld de, $8efe 
273d						ld a, d 
273d						ld hl, curframe 
273d						call hexout 
273d						ld a, e 
273d						ld hl, curframe+2 
273d						call hexout 
273d						ld hl, $8efe 
273d						push hl 
273d						ld hl, $989f 
273d						push hl 
273d						exx 
273d					endif 
273d				endif 
273d			endm 
# End of macro STACKFRAME
273d			; get parser buffer length  of new word 
273d			 
273d			 
273d			 
273d				; move tok past this to start of name defintition 
273d				; TODO get word to define 
273d				; TODO Move past word token 
273d				; TODO get length of string up to the ';' 
273d			 
273d 2a f4 f3		ld hl, (os_tok_ptr) 
2740 23			inc hl 
2741 23			inc hl 
2742			 
2742 3e 3b		ld a, ';' 
2744 cd 0f 13		call strlent 
2747			 
2747 7d			ld a,l 
2748 32 e3 f0		ld (os_new_parse_len), a 
274b			 
274b			 
274b			if DEBUG_FORTH_UWORD 
274b ed 5b f4 f3	ld de, (os_tok_ptr) 
274f					DMARK ":01" 
274f f5				push af  
2750 3a 64 27			ld a, (.dmark)  
2753 32 9d fd			ld (debug_mark),a  
2756 3a 65 27			ld a, (.dmark+1)  
2759 32 9e fd			ld (debug_mark+1),a  
275c 3a 66 27			ld a, (.dmark+2)  
275f 32 9f fd			ld (debug_mark+2),a  
2762 18 03			jr .pastdmark  
2764 ..			.dmark: db ":01"  
2767 f1			.pastdmark: pop af  
2768			endm  
# End of macro DMARK
2768			CALLMONITOR 
2768 cd aa fd			call debug_vector  
276b				endm  
# End of macro CALLMONITOR
276b			endif 
276b			 
276b			; 
276b			;  new word memory layout: 
276b			;  
276b			;    : adg 6666 ;  
276b			; 
276b			;    db   1     ; user defined word  
276b 23			inc hl    
276c			;    dw   sysdict 
276c 23			inc hl 
276d 23			inc hl 
276e			;    db <word len>+1 (for null) 
276e 23			inc hl 
276f			;    db .... <word> 
276f			; 
276f			 
276f 23			inc hl    ; some extras for the word preamble before the above 
2770 23			inc hl 
2771 23			inc hl 
2772 23			inc hl 
2773 23			inc hl 
2774 23			inc hl 
2775 23			inc hl  
2776 23			inc hl 
2777 23			inc hl 
2778 23			inc hl 
2779 23			inc hl 
277a 23			inc hl 
277b 23			inc hl 
277c 23			inc hl     ; TODO how many do we really need?     maybe only 6 
277d			;       exec word buffer 
277d			;	<ptr word>   
277d 23			inc hl 
277e 23			inc hl 
277f			;       <word list><null term> 7F final term 
277f			 
277f			 
277f			if DEBUG_FORTH_UWORD 
277f					DMARK ":02" 
277f f5				push af  
2780 3a 94 27			ld a, (.dmark)  
2783 32 9d fd			ld (debug_mark),a  
2786 3a 95 27			ld a, (.dmark+1)  
2789 32 9e fd			ld (debug_mark+1),a  
278c 3a 96 27			ld a, (.dmark+2)  
278f 32 9f fd			ld (debug_mark+2),a  
2792 18 03			jr .pastdmark  
2794 ..			.dmark: db ":02"  
2797 f1			.pastdmark: pop af  
2798			endm  
# End of macro DMARK
2798			CALLMONITOR 
2798 cd aa fd			call debug_vector  
279b				endm  
# End of macro CALLMONITOR
279b			endif 
279b			 
279b			 
279b				; malloc the size 
279b			 
279b cd 78 13			call malloc 
279e 22 e5 f0			ld (os_new_malloc), hl     ; save malloc start 
27a1			 
27a1			;    db   1     ; user defined word  
27a1			;	ld a, WORD_SYS_UWORD  
27a1 36 01			ld (hl), WORD_SYS_UWORD 
27a3			 
27a3 23			inc hl    
27a4			;    dw   sysdict 
27a4 11 1b 25		ld de, sysdict       ; continue on with the scan to the system dict 
27a7 73			ld (hl), e 
27a8 23			inc hl 
27a9 72			ld (hl), d 
27aa 23			inc hl 
27ab			 
27ab			 
27ab			;    Setup dict word 
27ab			 
27ab 23			inc hl 
27ac 22 df f0		ld (os_new_work_ptr), hl     ; save start of dict word  
27af			 
27af			; 1. get length of dict word 
27af			 
27af			 
27af 2a f4 f3		ld hl, (os_tok_ptr) 
27b2 23			inc hl 
27b3 23			inc hl    ; position to start of dict word 
27b4 3e 00		ld a, 0 
27b6 cd 0f 13		call strlent 
27b9			 
27b9			 
27b9 23			inc hl    ; to include null??? 
27ba			 
27ba			; write length of dict word 
27ba			 
27ba ed 5b df f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27be 1b			dec de 
27bf eb			ex de, hl 
27c0 73			ld (hl), e 
27c1 eb			ex de, hl 
27c2			 
27c2			 
27c2			 
27c2			; copy  
27c2 4d			ld c, l 
27c3 06 00		ld b, 0 
27c5 ed 5b df f0	ld de, (os_new_work_ptr)   ; get dest for copy of word 
27c9 2a f4 f3		ld hl, (os_tok_ptr) 
27cc 23			inc hl 
27cd 23			inc hl    ; position to start of dict word 
27ce			 
27ce			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
27ce			 
27ce			; TODO need to convert word to upper case 
27ce			 
27ce			ucasetok:	 
27ce 7e			ld a,(hl) 
27cf cd fb 12		call toUpper 
27d2 77			ld (hl),a 
27d3 ed a0		ldi 
27d5 f2 ce 27		jp p, ucasetok 
27d8			 
27d8			 
27d8			 
27d8			; de now points to start of where the word body code should be placed 
27d8 ed 53 df f0	ld (os_new_work_ptr), de 
27dc			; hl now points to the words to throw at forthexec which needs to be copied 
27dc 22 dd f0		ld (os_new_src_ptr), hl 
27df			 
27df			; TODO add 'call to forthexec' 
27df			 
27df			if DEBUG_FORTH_UWORD 
27df c5			push bc 
27e0 ed 4b e5 f0	ld bc, (os_new_malloc) 
27e4					DMARK ":0x" 
27e4 f5				push af  
27e5 3a f9 27			ld a, (.dmark)  
27e8 32 9d fd			ld (debug_mark),a  
27eb 3a fa 27			ld a, (.dmark+1)  
27ee 32 9e fd			ld (debug_mark+1),a  
27f1 3a fb 27			ld a, (.dmark+2)  
27f4 32 9f fd			ld (debug_mark+2),a  
27f7 18 03			jr .pastdmark  
27f9 ..			.dmark: db ":0x"  
27fc f1			.pastdmark: pop af  
27fd			endm  
# End of macro DMARK
27fd			CALLMONITOR 
27fd cd aa fd			call debug_vector  
2800				endm  
# End of macro CALLMONITOR
2800 c1			pop bc 
2801			endif 
2801			 
2801			 
2801			; create word preamble which should be: 
2801			 
2801			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2801			 
2801			;    ld hl, <word code> 
2801			;    jp user_exec 
2801			;    <word code bytes> 
2801			 
2801			 
2801			;	inc de     ; TODO ??? or are we already past the word's null 
2801 eb			ex de, hl 
2802			 
2802 36 21		ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2804			 
2804 23			inc hl 
2805 22 d9 f0		ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
2808 23			inc hl 
2809			 
2809 23			inc hl 
280a 36 c3		ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
280c			 
280c 01 2b 65		ld bc, user_exec 
280f 23			inc hl 
2810 71			ld (hl), c     ; poke address of user_exec 
2811 23			inc hl 
2812 70			ld (hl), b     
2813			; 
2813			;	inc hl 
2813			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2813			; 
2813			; 
2813			;	ld bc, macro_forth_rsp_next 
2813			;	inc hl 
2813			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2813			;	inc hl 
2813			;	ld (hl), b     
2813			; 
2813			;	inc hl 
2813			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2813			; 
2813			; 
2813			;	inc hl 
2813			;	ld bc, forthexec 
2813			;	ld (hl), c     ; poke address of forthexec 
2813			;	inc hl 
2813			;	ld (hl), b      
2813			; 
2813			;	inc hl 
2813			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2813			; 
2813			;	ld bc, user_dict_next 
2813			;	inc hl 
2813			;	ld (hl), c     ; poke address of forthexec 
2813			;	inc hl 
2813			;	ld (hl), b      
2813			 
2813			; hl is now where we need to copy the word byte data to save this 
2813			 
2813 23			inc hl 
2814 22 db f0		ld (os_new_exec), hl 
2817			 
2817			; copy definition 
2817			 
2817 eb			ex de, hl 
2818			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
2818			;	inc de    ; skip the PC for this parse 
2818 3a e3 f0		ld a, (os_new_parse_len) 
281b 4f			ld c, a 
281c 06 00		ld b, 0 
281e ed b0		ldir		 ; copy defintion 
2820			 
2820			 
2820			; poke the address of where the new word bytes live for forthexec 
2820			 
2820 2a d9 f0		ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2823			 
2823 ed 5b db f0	ld de, (os_new_exec)      
2827			 
2827 73			ld (hl), e 
2828 23			inc hl 
2829 72			ld (hl), d 
282a			 
282a				; TODO copy last user dict word next link to this word 
282a				; TODO update last user dict word to point to this word 
282a			; 
282a			; hl f923 de 812a ; bc 811a 
282a			 
282a			if DEBUG_FORTH_UWORD 
282a c5			push bc 
282b ed 4b e5 f0	ld bc, (os_new_malloc) 
282f					DMARK ":0A" 
282f f5				push af  
2830 3a 44 28			ld a, (.dmark)  
2833 32 9d fd			ld (debug_mark),a  
2836 3a 45 28			ld a, (.dmark+1)  
2839 32 9e fd			ld (debug_mark+1),a  
283c 3a 46 28			ld a, (.dmark+2)  
283f 32 9f fd			ld (debug_mark+2),a  
2842 18 03			jr .pastdmark  
2844 ..			.dmark: db ":0A"  
2847 f1			.pastdmark: pop af  
2848			endm  
# End of macro DMARK
2848			CALLMONITOR 
2848 cd aa fd			call debug_vector  
284b				endm  
# End of macro CALLMONITOR
284b c1			pop bc 
284c			endif 
284c			if DEBUG_FORTH_UWORD 
284c c5			push bc 
284d ed 4b e5 f0	ld bc, (os_new_malloc) 
2851 03			inc bc 
2852 03			inc bc 
2853 03			inc bc 
2854 03			inc bc 
2855 03			inc bc 
2856 03			inc bc 
2857 03			inc bc 
2858 03			inc bc 
2859			 
2859					DMARK ":0B" 
2859 f5				push af  
285a 3a 6e 28			ld a, (.dmark)  
285d 32 9d fd			ld (debug_mark),a  
2860 3a 6f 28			ld a, (.dmark+1)  
2863 32 9e fd			ld (debug_mark+1),a  
2866 3a 70 28			ld a, (.dmark+2)  
2869 32 9f fd			ld (debug_mark+2),a  
286c 18 03			jr .pastdmark  
286e ..			.dmark: db ":0B"  
2871 f1			.pastdmark: pop af  
2872			endm  
# End of macro DMARK
2872			CALLMONITOR 
2872 cd aa fd			call debug_vector  
2875				endm  
# End of macro CALLMONITOR
2875 c1			pop bc 
2876			endif 
2876			 
2876			; update word dict linked list for new word 
2876			 
2876			 
2876 2a f0 f3		ld hl, (os_last_new_uword)		; get the start of the last added uword 
2879 23			inc hl     ; move to next work linked list ptr 
287a			 
287a ed 5b e5 f0	ld de, (os_new_malloc)		 ; new next word 
287e 73			ld (hl), e 
287f 23			inc hl 
2880 72			ld (hl), d 
2881			 
2881			if DEBUG_FORTH_UWORD 
2881 ed 4b f0 f3	ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2885			endif 
2885			 
2885 ed 53 f0 f3	ld (os_last_new_uword), de      ; update last new uword ptr 
2889			 
2889			 
2889			if DEBUG_FORTH_UWORD 
2889					DMARK ":0+" 
2889 f5				push af  
288a 3a 9e 28			ld a, (.dmark)  
288d 32 9d fd			ld (debug_mark),a  
2890 3a 9f 28			ld a, (.dmark+1)  
2893 32 9e fd			ld (debug_mark+1),a  
2896 3a a0 28			ld a, (.dmark+2)  
2899 32 9f fd			ld (debug_mark+2),a  
289c 18 03			jr .pastdmark  
289e ..			.dmark: db ":0+"  
28a1 f1			.pastdmark: pop af  
28a2			endm  
# End of macro DMARK
28a2			CALLMONITOR 
28a2 cd aa fd			call debug_vector  
28a5				endm  
# End of macro CALLMONITOR
28a5			endif 
28a5			 
28a5			STACKFRAMECHK OFF $8efe $989f 
28a5				if DEBUG_STACK_IMB 
28a5					if OFF 
28a5						exx 
28a5						ld hl, $989f 
28a5						pop de   ; $989f 
28a5						call cmp16 
28a5						jr nz, .spnosame 
28a5						ld hl, $8efe 
28a5						pop de   ; $8efe 
28a5						call cmp16 
28a5						jr z, .spfrsame 
28a5						.spnosame: call showsperror 
28a5						.spfrsame: nop 
28a5						exx 
28a5					endif 
28a5				endif 
28a5			endm 
# End of macro STACKFRAMECHK
28a5			 
28a5 c9			ret    ; dont process any remaining parser tokens as they form new word 
28a6			 
28a6			 
28a6			 
28a6			 
28a6			;		NEXT 
28a6			.SCOLN: 
28a6			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
28a6 06			db OPCODE_SCOLN 
28a7 f5 28		dw .DROP 
28a9 02			db 2 
28aa .. 00		db ";",0           
28ac			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
28ac				if DEBUG_FORTH_WORDS_KEY 
28ac					DMARK "SCN" 
28ac f5				push af  
28ad 3a c1 28			ld a, (.dmark)  
28b0 32 9d fd			ld (debug_mark),a  
28b3 3a c2 28			ld a, (.dmark+1)  
28b6 32 9e fd			ld (debug_mark+1),a  
28b9 3a c3 28			ld a, (.dmark+2)  
28bc 32 9f fd			ld (debug_mark+2),a  
28bf 18 03			jr .pastdmark  
28c1 ..			.dmark: db "SCN"  
28c4 f1			.pastdmark: pop af  
28c5			endm  
# End of macro DMARK
28c5					CALLMONITOR 
28c5 cd aa fd			call debug_vector  
28c8				endm  
# End of macro CALLMONITOR
28c8				endif 
28c8				FORTH_RSP_TOS 
28c8 cd bd 1f			call macro_forth_rsp_tos 
28cb				endm 
# End of macro FORTH_RSP_TOS
28cb e5				push hl 
28cc				FORTH_RSP_POP 
28cc cd c7 1f			call macro_forth_rsp_pop 
28cf				endm 
# End of macro FORTH_RSP_POP
28cf e1				pop hl 
28d0			;		ex de,hl 
28d0 22 f4 f3			ld (os_tok_ptr),hl 
28d3			 
28d3			if DEBUG_FORTH_UWORD 
28d3					DMARK "SCL" 
28d3 f5				push af  
28d4 3a e8 28			ld a, (.dmark)  
28d7 32 9d fd			ld (debug_mark),a  
28da 3a e9 28			ld a, (.dmark+1)  
28dd 32 9e fd			ld (debug_mark+1),a  
28e0 3a ea 28			ld a, (.dmark+2)  
28e3 32 9f fd			ld (debug_mark+2),a  
28e6 18 03			jr .pastdmark  
28e8 ..			.dmark: db "SCL"  
28eb f1			.pastdmark: pop af  
28ec			endm  
# End of macro DMARK
28ec			CALLMONITOR 
28ec cd aa fd			call debug_vector  
28ef				endm  
# End of macro CALLMONITOR
28ef			endif 
28ef				NEXTW 
28ef cd a7 fd			call parse_vector 
28f2 c3 e2 23			jp macro_next 
28f5				endm 
# End of macro NEXTW
28f5			 
28f5			.DROP: 
28f5			CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
28f5 1b				db WORD_SYS_CORE+OPCODE_DROP             
28f6 23 29			dw .DUP2            
28f8 05				db 4 + 1 
28f9 .. 00			db "DROP",0              
28fe				endm 
# End of macro CWHEAD
28fe			; | DROP ( w -- )   drop the TOS item   | DONE 
28fe				if DEBUG_FORTH_WORDS_KEY 
28fe					DMARK "DRP" 
28fe f5				push af  
28ff 3a 13 29			ld a, (.dmark)  
2902 32 9d fd			ld (debug_mark),a  
2905 3a 14 29			ld a, (.dmark+1)  
2908 32 9e fd			ld (debug_mark+1),a  
290b 3a 15 29			ld a, (.dmark+2)  
290e 32 9f fd			ld (debug_mark+2),a  
2911 18 03			jr .pastdmark  
2913 ..			.dmark: db "DRP"  
2916 f1			.pastdmark: pop af  
2917			endm  
# End of macro DMARK
2917					CALLMONITOR 
2917 cd aa fd			call debug_vector  
291a				endm  
# End of macro CALLMONITOR
291a				endif 
291a				FORTH_DSP_POP 
291a cd b3 22			call macro_forth_dsp_pop 
291d				endm 
# End of macro FORTH_DSP_POP
291d				NEXTW 
291d cd a7 fd			call parse_vector 
2920 c3 e2 23			jp macro_next 
2923				endm 
# End of macro NEXTW
2923			.DUP2: 
2923			CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2923 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2924 6b 29			dw .DROP2            
2926 05				db 4 + 1 
2927 .. 00			db "2DUP",0              
292c				endm 
# End of macro CWHEAD
292c			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  (Only works for numerics) | DONE 
292c			; | | >[!NOTE] 
292c			; | | > If the duplicated items are string pointers, string are not safely duplicated and remain as pointers to the origin 
292c				if DEBUG_FORTH_WORDS_KEY 
292c					DMARK "2DU" 
292c f5				push af  
292d 3a 41 29			ld a, (.dmark)  
2930 32 9d fd			ld (debug_mark),a  
2933 3a 42 29			ld a, (.dmark+1)  
2936 32 9e fd			ld (debug_mark+1),a  
2939 3a 43 29			ld a, (.dmark+2)  
293c 32 9f fd			ld (debug_mark+2),a  
293f 18 03			jr .pastdmark  
2941 ..			.dmark: db "2DU"  
2944 f1			.pastdmark: pop af  
2945			endm  
# End of macro DMARK
2945					CALLMONITOR 
2945 cd aa fd			call debug_vector  
2948				endm  
# End of macro CALLMONITOR
2948				endif 
2948				FORTH_DSP_VALUEHL 
2948 cd fb 21			call macro_dsp_valuehl 
294b				endm 
# End of macro FORTH_DSP_VALUEHL
294b e5				push hl      ; 2 
294c			 
294c				FORTH_DSP_POP 
294c cd b3 22			call macro_forth_dsp_pop 
294f				endm 
# End of macro FORTH_DSP_POP
294f				 
294f				FORTH_DSP_VALUEHL 
294f cd fb 21			call macro_dsp_valuehl 
2952				endm 
# End of macro FORTH_DSP_VALUEHL
2952			;		push hl      ; 1 
2952			 
2952				FORTH_DSP_POP 
2952 cd b3 22			call macro_forth_dsp_pop 
2955				endm 
# End of macro FORTH_DSP_POP
2955			 
2955			;		pop hl       ; 1 
2955 d1				pop de       ; 2 
2956			 
2956 cd ff 1f			call forth_push_numhl 
2959 eb				ex de, hl 
295a cd ff 1f			call forth_push_numhl 
295d			 
295d				 
295d eb				ex de, hl 
295e			 
295e cd ff 1f			call forth_push_numhl 
2961 eb				ex de, hl 
2962 cd ff 1f			call forth_push_numhl 
2965			 
2965			 
2965				NEXTW 
2965 cd a7 fd			call parse_vector 
2968 c3 e2 23			jp macro_next 
296b				endm 
# End of macro NEXTW
296b			.DROP2: 
296b			CWHEAD .PICK OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
296b 1d				db WORD_SYS_CORE+OPCODE_DROP2             
296c 9d 29			dw .PICK            
296e 06				db 5 + 1 
296f .. 00			db "2DROP",0              
2975				endm 
# End of macro CWHEAD
2975			; | 2DROP ( w w -- )    Double drop | DONE 
2975				if DEBUG_FORTH_WORDS_KEY 
2975					DMARK "2DR" 
2975 f5				push af  
2976 3a 8a 29			ld a, (.dmark)  
2979 32 9d fd			ld (debug_mark),a  
297c 3a 8b 29			ld a, (.dmark+1)  
297f 32 9e fd			ld (debug_mark+1),a  
2982 3a 8c 29			ld a, (.dmark+2)  
2985 32 9f fd			ld (debug_mark+2),a  
2988 18 03			jr .pastdmark  
298a ..			.dmark: db "2DR"  
298d f1			.pastdmark: pop af  
298e			endm  
# End of macro DMARK
298e					CALLMONITOR 
298e cd aa fd			call debug_vector  
2991				endm  
# End of macro CALLMONITOR
2991				endif 
2991				FORTH_DSP_POP 
2991 cd b3 22			call macro_forth_dsp_pop 
2994				endm 
# End of macro FORTH_DSP_POP
2994				FORTH_DSP_POP 
2994 cd b3 22			call macro_forth_dsp_pop 
2997				endm 
# End of macro FORTH_DSP_POP
2997				NEXTW 
2997 cd a7 fd			call parse_vector 
299a c3 e2 23			jp macro_next 
299d				endm 
# End of macro NEXTW
299d			.PICK: 
299d			CWHEAD .SWAP2 99 "PICK" 4 WORD_FLAG_CODE 
299d 77				db WORD_SYS_CORE+99             
299e 3a 2a			dw .SWAP2            
29a0 05				db 4 + 1 
29a1 .. 00			db "PICK",0              
29a6				endm 
# End of macro CWHEAD
29a6			; | PICK ( ux ... u x -- ux ... u n )    Replace x on stack with the item from position x on stack  | DONE 
29a6			; | | >[!NOTE] 
29a6			; | | > If the chosen item is a string the pointer is pushed to TOS. The string is not safely duplicated. 
29a6				if DEBUG_FORTH_WORDS_KEY 
29a6					DMARK "PIK" 
29a6 f5				push af  
29a7 3a bb 29			ld a, (.dmark)  
29aa 32 9d fd			ld (debug_mark),a  
29ad 3a bc 29			ld a, (.dmark+1)  
29b0 32 9e fd			ld (debug_mark+1),a  
29b3 3a bd 29			ld a, (.dmark+2)  
29b6 32 9f fd			ld (debug_mark+2),a  
29b9 18 03			jr .pastdmark  
29bb ..			.dmark: db "PIK"  
29be f1			.pastdmark: pop af  
29bf			endm  
# End of macro DMARK
29bf					CALLMONITOR 
29bf cd aa fd			call debug_vector  
29c2				endm  
# End of macro CALLMONITOR
29c2				endif 
29c2			 
29c2				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
29c2 cd fb 21			call macro_dsp_valuehl 
29c5				endm 
# End of macro FORTH_DSP_VALUEHL
29c5				 
29c5				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
29c5 cd b3 22			call macro_forth_dsp_pop 
29c8				endm 
# End of macro FORTH_DSP_POP
29c8			 
29c8				; init from TOS 
29c8 e5				push hl 
29c9				FORTH_DSP 
29c9 cd c1 21			call macro_forth_dsp 
29cc				endm 
# End of macro FORTH_DSP
29cc			;	ld hl, cli_data_sp 
29cc				if DEBUG_FORTH_WORDS 
29cc					DMARK "PK1" 
29cc f5				push af  
29cd 3a e1 29			ld a, (.dmark)  
29d0 32 9d fd			ld (debug_mark),a  
29d3 3a e2 29			ld a, (.dmark+1)  
29d6 32 9e fd			ld (debug_mark+1),a  
29d9 3a e3 29			ld a, (.dmark+2)  
29dc 32 9f fd			ld (debug_mark+2),a  
29df 18 03			jr .pastdmark  
29e1 ..			.dmark: db "PK1"  
29e4 f1			.pastdmark: pop af  
29e5			endm  
# End of macro DMARK
29e5					CALLMONITOR 
29e5 cd aa fd			call debug_vector  
29e8				endm  
# End of macro CALLMONITOR
29e8				endif 
29e8 c1				pop bc 
29e9 41				ld b,c 
29ea 3e 00			ld a, 0 
29ec b8				cp b 
29ed 28 21			jr z, .pdone	 
29ef			.pkl: 
29ef 2b				dec hl 
29f0 2b				dec hl 
29f1 2b				dec hl 
29f2			 
29f2				if DEBUG_FORTH_WORDS 
29f2					DMARK "PKl" 
29f2 f5				push af  
29f3 3a 07 2a			ld a, (.dmark)  
29f6 32 9d fd			ld (debug_mark),a  
29f9 3a 08 2a			ld a, (.dmark+1)  
29fc 32 9e fd			ld (debug_mark+1),a  
29ff 3a 09 2a			ld a, (.dmark+2)  
2a02 32 9f fd			ld (debug_mark+2),a  
2a05 18 03			jr .pastdmark  
2a07 ..			.dmark: db "PKl"  
2a0a f1			.pastdmark: pop af  
2a0b			endm  
# End of macro DMARK
2a0b					CALLMONITOR 
2a0b cd aa fd			call debug_vector  
2a0e				endm  
# End of macro CALLMONITOR
2a0e				endif 
2a0e 10 df			djnz .pkl 
2a10			.pdone: 
2a10				 
2a10				; TODO do type check with correct push 
2a10			 
2a10 23				inc hl 
2a11				;call loadwordinhl 
2a11 5e				ld e, (hl) 
2a12 23				inc hl 
2a13 56				ld d, (hl) 
2a14 eb				ex de,hl 
2a15				if DEBUG_FORTH_WORDS 
2a15					DMARK "PKp" 
2a15 f5				push af  
2a16 3a 2a 2a			ld a, (.dmark)  
2a19 32 9d fd			ld (debug_mark),a  
2a1c 3a 2b 2a			ld a, (.dmark+1)  
2a1f 32 9e fd			ld (debug_mark+1),a  
2a22 3a 2c 2a			ld a, (.dmark+2)  
2a25 32 9f fd			ld (debug_mark+2),a  
2a28 18 03			jr .pastdmark  
2a2a ..			.dmark: db "PKp"  
2a2d f1			.pastdmark: pop af  
2a2e			endm  
# End of macro DMARK
2a2e					CALLMONITOR 
2a2e cd aa fd			call debug_vector  
2a31				endm  
# End of macro CALLMONITOR
2a31				endif 
2a31 cd ff 1f			call forth_push_numhl 
2a34			 
2a34				NEXTW 
2a34 cd a7 fd			call parse_vector 
2a37 c3 e2 23			jp macro_next 
2a3a				endm 
# End of macro NEXTW
2a3a			.SWAP2: 
2a3a			CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2a3a 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2a3b be 2a			dw .AT            
2a3d 06				db 5 + 1 
2a3e .. 00			db "2SWAP",0              
2a44				endm 
# End of macro CWHEAD
2a44			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | DONE 
2a44				if DEBUG_FORTH_WORDS_KEY 
2a44					DMARK "2SW" 
2a44 f5				push af  
2a45 3a 59 2a			ld a, (.dmark)  
2a48 32 9d fd			ld (debug_mark),a  
2a4b 3a 5a 2a			ld a, (.dmark+1)  
2a4e 32 9e fd			ld (debug_mark+1),a  
2a51 3a 5b 2a			ld a, (.dmark+2)  
2a54 32 9f fd			ld (debug_mark+2),a  
2a57 18 03			jr .pastdmark  
2a59 ..			.dmark: db "2SW"  
2a5c f1			.pastdmark: pop af  
2a5d			endm  
# End of macro DMARK
2a5d					CALLMONITOR 
2a5d cd aa fd			call debug_vector  
2a60				endm  
# End of macro CALLMONITOR
2a60				endif 
2a60			; TODO Use os stack swap memory 
2a60			 
2a60				FORTH_DSP_PTR 0     ; TOS    w4 
2a60 2a 20 f9			ld hl,(cli_data_sp) 
2a63 11 00 00			ld de, 0 * 3 
2a66 ed 52			sbc hl, de 
2a68				endm 
# End of macro FORTH_DSP_PTR
2a68 cd 32 23			call hltostack1 
2a6b			  
2a6b				FORTH_DSP_PTR 1     ; TOS    w3 
2a6b 2a 20 f9			ld hl,(cli_data_sp) 
2a6e 11 03 00			ld de, 1 * 3 
2a71 ed 52			sbc hl, de 
2a73				endm 
# End of macro FORTH_DSP_PTR
2a73 cd 38 23			call hltostack2 
2a76			 
2a76			 
2a76			 
2a76				FORTH_DSP_PTR 2     ; TOS    w2 
2a76 2a 20 f9			ld hl,(cli_data_sp) 
2a79 11 06 00			ld de, 2 * 3 
2a7c ed 52			sbc hl, de 
2a7e				endm 
# End of macro FORTH_DSP_PTR
2a7e cd 3e 23			call hltostack3 
2a81			 
2a81				FORTH_DSP_PTR 3     ; TOS   w1 
2a81 2a 20 f9			ld hl,(cli_data_sp) 
2a84 11 09 00			ld de, 3 * 3 
2a87 ed 52			sbc hl, de 
2a89				endm 
# End of macro FORTH_DSP_PTR
2a89 cd 44 23			call hltostack4 
2a8c			 
2a8c			 
2a8c			 
2a8c			 
2a8c				FORTH_DSP_PTR 0     ; TOS 
2a8c 2a 20 f9			ld hl,(cli_data_sp) 
2a8f 11 00 00			ld de, 0 * 3 
2a92 ed 52			sbc hl, de 
2a94				endm 
# End of macro FORTH_DSP_PTR
2a94 cd 56 23			call hlfromstack3 
2a97			 
2a97				FORTH_DSP_PTR 1     ; TOS 
2a97 2a 20 f9			ld hl,(cli_data_sp) 
2a9a 11 03 00			ld de, 1 * 3 
2a9d ed 52			sbc hl, de 
2a9f				endm 
# End of macro FORTH_DSP_PTR
2a9f cd 5c 23			call hlfromstack4 
2aa2			 
2aa2			 
2aa2			 
2aa2				FORTH_DSP_PTR 2     ; TOS 
2aa2 2a 20 f9			ld hl,(cli_data_sp) 
2aa5 11 06 00			ld de, 2 * 3 
2aa8 ed 52			sbc hl, de 
2aaa				endm 
# End of macro FORTH_DSP_PTR
2aaa cd 4a 23			call hlfromstack1 
2aad			 
2aad				FORTH_DSP_PTR 3     ; TOS 
2aad 2a 20 f9			ld hl,(cli_data_sp) 
2ab0 11 09 00			ld de, 3 * 3 
2ab3 ed 52			sbc hl, de 
2ab5				endm 
# End of macro FORTH_DSP_PTR
2ab5 cd 50 23			call hlfromstack2 
2ab8			 
2ab8				NEXTW 
2ab8 cd a7 fd			call parse_vector 
2abb c3 e2 23			jp macro_next 
2abe				endm 
# End of macro NEXTW
2abe			.AT: 
2abe			CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
2abe 1f				db WORD_SYS_CORE+OPCODE_AT             
2abf f3 2a			dw .CAT            
2ac1 02				db 1 + 1 
2ac2 .. 00			db "@",0              
2ac4				endm 
# End of macro CWHEAD
2ac4			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2ac4			 
2ac4				if DEBUG_FORTH_WORDS_KEY 
2ac4					DMARK "AT." 
2ac4 f5				push af  
2ac5 3a d9 2a			ld a, (.dmark)  
2ac8 32 9d fd			ld (debug_mark),a  
2acb 3a da 2a			ld a, (.dmark+1)  
2ace 32 9e fd			ld (debug_mark+1),a  
2ad1 3a db 2a			ld a, (.dmark+2)  
2ad4 32 9f fd			ld (debug_mark+2),a  
2ad7 18 03			jr .pastdmark  
2ad9 ..			.dmark: db "AT."  
2adc f1			.pastdmark: pop af  
2add			endm  
# End of macro DMARK
2add					CALLMONITOR 
2add cd aa fd			call debug_vector  
2ae0				endm  
# End of macro CALLMONITOR
2ae0				endif 
2ae0			.getbyteat:	 
2ae0				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ae0 cd fb 21			call macro_dsp_valuehl 
2ae3				endm 
# End of macro FORTH_DSP_VALUEHL
2ae3				 
2ae3			;		push hl 
2ae3			 
2ae3				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2ae3 cd b3 22			call macro_forth_dsp_pop 
2ae6				endm 
# End of macro FORTH_DSP_POP
2ae6			 
2ae6			;		pop hl 
2ae6			 
2ae6 7e				ld a, (hl) 
2ae7			 
2ae7 6f				ld l, a 
2ae8 26 00			ld h, 0 
2aea cd ff 1f			call forth_push_numhl 
2aed			 
2aed				NEXTW 
2aed cd a7 fd			call parse_vector 
2af0 c3 e2 23			jp macro_next 
2af3				endm 
# End of macro NEXTW
2af3			.CAT: 
2af3			CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
2af3 20				db WORD_SYS_CORE+OPCODE_CAT             
2af4 1f 2b			dw .BANG            
2af6 03				db 2 + 1 
2af7 .. 00			db "C@",0              
2afa				endm 
# End of macro CWHEAD
2afa			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2afa				if DEBUG_FORTH_WORDS_KEY 
2afa					DMARK "CAA" 
2afa f5				push af  
2afb 3a 0f 2b			ld a, (.dmark)  
2afe 32 9d fd			ld (debug_mark),a  
2b01 3a 10 2b			ld a, (.dmark+1)  
2b04 32 9e fd			ld (debug_mark+1),a  
2b07 3a 11 2b			ld a, (.dmark+2)  
2b0a 32 9f fd			ld (debug_mark+2),a  
2b0d 18 03			jr .pastdmark  
2b0f ..			.dmark: db "CAA"  
2b12 f1			.pastdmark: pop af  
2b13			endm  
# End of macro DMARK
2b13					CALLMONITOR 
2b13 cd aa fd			call debug_vector  
2b16				endm  
# End of macro CALLMONITOR
2b16				endif 
2b16 c3 e0 2a			jp .getbyteat 
2b19				NEXTW 
2b19 cd a7 fd			call parse_vector 
2b1c c3 e2 23			jp macro_next 
2b1f				endm 
# End of macro NEXTW
2b1f			.BANG: 
2b1f			CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2b1f 21				db WORD_SYS_CORE+OPCODE_BANG             
2b20 58 2b			dw .CBANG            
2b22 02				db 1 + 1 
2b23 .. 00			db "!",0              
2b25				endm 
# End of macro CWHEAD
2b25			; | ! ( x w -- ) Store x at address w      | DONE 
2b25				if DEBUG_FORTH_WORDS_KEY 
2b25					DMARK "BNG" 
2b25 f5				push af  
2b26 3a 3a 2b			ld a, (.dmark)  
2b29 32 9d fd			ld (debug_mark),a  
2b2c 3a 3b 2b			ld a, (.dmark+1)  
2b2f 32 9e fd			ld (debug_mark+1),a  
2b32 3a 3c 2b			ld a, (.dmark+2)  
2b35 32 9f fd			ld (debug_mark+2),a  
2b38 18 03			jr .pastdmark  
2b3a ..			.dmark: db "BNG"  
2b3d f1			.pastdmark: pop af  
2b3e			endm  
# End of macro DMARK
2b3e					CALLMONITOR 
2b3e cd aa fd			call debug_vector  
2b41				endm  
# End of macro CALLMONITOR
2b41				endif 
2b41			 
2b41			.storebyteat:		 
2b41				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b41 cd fb 21			call macro_dsp_valuehl 
2b44				endm 
# End of macro FORTH_DSP_VALUEHL
2b44				 
2b44 e5				push hl 
2b45			 
2b45				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b45 cd b3 22			call macro_forth_dsp_pop 
2b48				endm 
# End of macro FORTH_DSP_POP
2b48			 
2b48				; get byte to poke 
2b48			 
2b48				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2b48 cd fb 21			call macro_dsp_valuehl 
2b4b				endm 
# End of macro FORTH_DSP_VALUEHL
2b4b e5				push hl 
2b4c			 
2b4c			 
2b4c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2b4c cd b3 22			call macro_forth_dsp_pop 
2b4f				endm 
# End of macro FORTH_DSP_POP
2b4f			 
2b4f			 
2b4f d1				pop de 
2b50 e1				pop hl 
2b51			 
2b51 73				ld (hl),e 
2b52			 
2b52			 
2b52				NEXTW 
2b52 cd a7 fd			call parse_vector 
2b55 c3 e2 23			jp macro_next 
2b58				endm 
# End of macro NEXTW
2b58			.CBANG: 
2b58			CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
2b58 22				db WORD_SYS_CORE+OPCODE_CBANG             
2b59 84 2b			dw .SCALL            
2b5b 03				db 2 + 1 
2b5c .. 00			db "C!",0              
2b5f				endm 
# End of macro CWHEAD
2b5f			; | C!  ( x w -- ) Store x at address w  | DONE 
2b5f				if DEBUG_FORTH_WORDS_KEY 
2b5f					DMARK "CBA" 
2b5f f5				push af  
2b60 3a 74 2b			ld a, (.dmark)  
2b63 32 9d fd			ld (debug_mark),a  
2b66 3a 75 2b			ld a, (.dmark+1)  
2b69 32 9e fd			ld (debug_mark+1),a  
2b6c 3a 76 2b			ld a, (.dmark+2)  
2b6f 32 9f fd			ld (debug_mark+2),a  
2b72 18 03			jr .pastdmark  
2b74 ..			.dmark: db "CBA"  
2b77 f1			.pastdmark: pop af  
2b78			endm  
# End of macro DMARK
2b78					CALLMONITOR 
2b78 cd aa fd			call debug_vector  
2b7b				endm  
# End of macro CALLMONITOR
2b7b				endif 
2b7b c3 41 2b			jp .storebyteat 
2b7e				NEXTW 
2b7e cd a7 fd			call parse_vector 
2b81 c3 e2 23			jp macro_next 
2b84				endm 
# End of macro NEXTW
2b84			.SCALL: 
2b84			CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2b84 23				db WORD_SYS_CORE+OPCODE_SCALL             
2b85 bb 2b			dw .DEPTH            
2b87 05				db 4 + 1 
2b88 .. 00			db "CALL",0              
2b8d				endm 
# End of macro CWHEAD
2b8d			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2b8d				if DEBUG_FORTH_WORDS_KEY 
2b8d					DMARK "CLL" 
2b8d f5				push af  
2b8e 3a a2 2b			ld a, (.dmark)  
2b91 32 9d fd			ld (debug_mark),a  
2b94 3a a3 2b			ld a, (.dmark+1)  
2b97 32 9e fd			ld (debug_mark+1),a  
2b9a 3a a4 2b			ld a, (.dmark+2)  
2b9d 32 9f fd			ld (debug_mark+2),a  
2ba0 18 03			jr .pastdmark  
2ba2 ..			.dmark: db "CLL"  
2ba5 f1			.pastdmark: pop af  
2ba6			endm  
# End of macro DMARK
2ba6					CALLMONITOR 
2ba6 cd aa fd			call debug_vector  
2ba9				endm  
# End of macro CALLMONITOR
2ba9				endif 
2ba9			 
2ba9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ba9 cd fb 21			call macro_dsp_valuehl 
2bac				endm 
# End of macro FORTH_DSP_VALUEHL
2bac			 
2bac			;		push hl 
2bac			 
2bac				; destroy value TOS 
2bac			 
2bac				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2bac cd b3 22			call macro_forth_dsp_pop 
2baf				endm 
# End of macro FORTH_DSP_POP
2baf			 
2baf					 
2baf			;		pop hl 
2baf			 
2baf				; how to do a call with hl???? save SP? 
2baf cd 86 23			call forth_call_hl 
2bb2			 
2bb2			 
2bb2				; TODO push value back onto stack for another op etc 
2bb2			 
2bb2 cd ff 1f			call forth_push_numhl 
2bb5				NEXTW 
2bb5 cd a7 fd			call parse_vector 
2bb8 c3 e2 23			jp macro_next 
2bbb				endm 
# End of macro NEXTW
2bbb			.DEPTH: 
2bbb			CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
2bbb 24				db WORD_SYS_CORE+OPCODE_DEPTH             
2bbc fb 2b			dw .OVER            
2bbe 06				db 5 + 1 
2bbf .. 00			db "DEPTH",0              
2bc5				endm 
# End of macro CWHEAD
2bc5			; | DEPTH ( -- u ) Push count of stack | DONE 
2bc5				; take current TOS and remove from base value div by two to get count 
2bc5				if DEBUG_FORTH_WORDS_KEY 
2bc5					DMARK "DEP" 
2bc5 f5				push af  
2bc6 3a da 2b			ld a, (.dmark)  
2bc9 32 9d fd			ld (debug_mark),a  
2bcc 3a db 2b			ld a, (.dmark+1)  
2bcf 32 9e fd			ld (debug_mark+1),a  
2bd2 3a dc 2b			ld a, (.dmark+2)  
2bd5 32 9f fd			ld (debug_mark+2),a  
2bd8 18 03			jr .pastdmark  
2bda ..			.dmark: db "DEP"  
2bdd f1			.pastdmark: pop af  
2bde			endm  
# End of macro DMARK
2bde					CALLMONITOR 
2bde cd aa fd			call debug_vector  
2be1				endm  
# End of macro CALLMONITOR
2be1				endif 
2be1			 
2be1			 
2be1 2a 20 f9		ld hl, (cli_data_sp) 
2be4 11 5a f6		ld de, cli_data_stack 
2be7 ed 52		sbc hl,de 
2be9			 
2be9			; div by size of stack item 
2be9			 
2be9 5d			ld e,l 
2bea 0e 03		ld c, 3 
2bec cd 3c 0f		call Div8 
2bef			 
2bef 6f			ld l,a 
2bf0 26 00		ld h,0 
2bf2			 
2bf2			;srl h 
2bf2			;rr l 
2bf2			 
2bf2 cd ff 1f			call forth_push_numhl 
2bf5				NEXTW 
2bf5 cd a7 fd			call parse_vector 
2bf8 c3 e2 23			jp macro_next 
2bfb				endm 
# End of macro NEXTW
2bfb			.OVER: 
2bfb			CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2bfb 42				db WORD_SYS_CORE+46             
2bfc 4b 2c			dw .PAUSE            
2bfe 05				db 4 + 1 
2bff .. 00			db "OVER",0              
2c04				endm 
# End of macro CWHEAD
2c04			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2c04			; | | >[!NOTE] 
2c04			; | | > If the copied item is a string it is properly duplicated allowing for a safe release after use.  
2c04				if DEBUG_FORTH_WORDS_KEY 
2c04					DMARK "OVR" 
2c04 f5				push af  
2c05 3a 19 2c			ld a, (.dmark)  
2c08 32 9d fd			ld (debug_mark),a  
2c0b 3a 1a 2c			ld a, (.dmark+1)  
2c0e 32 9e fd			ld (debug_mark+1),a  
2c11 3a 1b 2c			ld a, (.dmark+2)  
2c14 32 9f fd			ld (debug_mark+2),a  
2c17 18 03			jr .pastdmark  
2c19 ..			.dmark: db "OVR"  
2c1c f1			.pastdmark: pop af  
2c1d			endm  
# End of macro DMARK
2c1d					CALLMONITOR 
2c1d cd aa fd			call debug_vector  
2c20				endm  
# End of macro CALLMONITOR
2c20				endif 
2c20			 
2c20			; TODO Use os stack swap memory 
2c20			 
2c20				; work out what type we are looking at 
2c20			 
2c20				FORTH_DSP_PTR 1 
2c20 2a 20 f9			ld hl,(cli_data_sp) 
2c23 11 03 00			ld de, 1 * 3 
2c26 ed 52			sbc hl, de 
2c28				endm 
# End of macro FORTH_DSP_PTR
2c28			 
2c28 7e				ld a, (hl) 
2c29				 
2c29 f5				push af 
2c2a				; whatever the type lets get the pointer or word 
2c2a 23				inc hl 
2c2b			;; 
2c2b			 
2c2b				; type check now to decide on how to push  
2c2b			 
2c2b cd 68 23			call loadwordinhl 
2c2e f1				pop af 
2c2f fe 01			cp DS_TYPE_STR 
2c31 28 09			jr z, .ovstr 
2c33			 
2c33				; we have a numeric so load the word and push 
2c33			;	ld e, (hl) 
2c33			;	inc hl 
2c33			;	ld d, (hl) 
2c33			;	ex de, hl 
2c33 cd ff 1f			call forth_push_numhl 
2c36				NEXTW 
2c36 cd a7 fd			call parse_vector 
2c39 c3 e2 23			jp macro_next 
2c3c				endm 
# End of macro NEXTW
2c3c			 
2c3c			.ovstr: 
2c3c				; ok, a string so get the pointer and push as a string 
2c3c			 
2c3c			;	call loadwordinhl 
2c3c cd 69 20			call forth_push_str 
2c3f				NEXTW 
2c3f cd a7 fd			call parse_vector 
2c42 c3 e2 23			jp macro_next 
2c45				endm 
# End of macro NEXTW
2c45			 
2c45			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c45			;	push hl    ; n2 
2c45			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c45			; 
2c45			;	FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c45			;	push hl    ; n1 
2c45			;	FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c45			; 
2c45			;	pop de     ; n1 
2c45			;	pop hl     ; n2 
2c45			; 
2c45			;	push de 
2c45			;	push hl 
2c45			;	push de 
2c45			 
2c45				; push back  
2c45			 
2c45			;	pop hl 
2c45			;	call forth_push_numhl 
2c45			;	pop hl 
2c45			;	call forth_push_numhl 
2c45			;	pop hl 
2c45			;	call forth_push_numhl 
2c45				NEXTW 
2c45 cd a7 fd			call parse_vector 
2c48 c3 e2 23			jp macro_next 
2c4b				endm 
# End of macro NEXTW
2c4b			 
2c4b			.PAUSE: 
2c4b			CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
2c4b 43				db WORD_SYS_CORE+47             
2c4c 83 2c			dw .PAUSES            
2c4e 08				db 7 + 1 
2c4f .. 00			db "PAUSEMS",0              
2c57				endm 
# End of macro CWHEAD
2c57			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
2c57				if DEBUG_FORTH_WORDS_KEY 
2c57					DMARK "PMS" 
2c57 f5				push af  
2c58 3a 6c 2c			ld a, (.dmark)  
2c5b 32 9d fd			ld (debug_mark),a  
2c5e 3a 6d 2c			ld a, (.dmark+1)  
2c61 32 9e fd			ld (debug_mark+1),a  
2c64 3a 6e 2c			ld a, (.dmark+2)  
2c67 32 9f fd			ld (debug_mark+2),a  
2c6a 18 03			jr .pastdmark  
2c6c ..			.dmark: db "PMS"  
2c6f f1			.pastdmark: pop af  
2c70			endm  
# End of macro DMARK
2c70					CALLMONITOR 
2c70 cd aa fd			call debug_vector  
2c73				endm  
# End of macro CALLMONITOR
2c73				endif 
2c73				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2c73 cd fb 21			call macro_dsp_valuehl 
2c76				endm 
# End of macro FORTH_DSP_VALUEHL
2c76			;		push hl    ; n2 
2c76				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2c76 cd b3 22			call macro_forth_dsp_pop 
2c79				endm 
# End of macro FORTH_DSP_POP
2c79			;		pop hl 
2c79			 
2c79 7d				ld a, l 
2c7a cd a5 0c			call aDelayInMS 
2c7d			       NEXTW 
2c7d cd a7 fd			call parse_vector 
2c80 c3 e2 23			jp macro_next 
2c83				endm 
# End of macro NEXTW
2c83			.PAUSES:  
2c83			CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2c83 44				db WORD_SYS_CORE+48             
2c84 f5 2c			dw .ROT            
2c86 06				db 5 + 1 
2c87 .. 00			db "PAUSE",0              
2c8d				endm 
# End of macro CWHEAD
2c8d			; | PAUSE ( n -- )  Pause for n seconds | DONE 
2c8d				if DEBUG_FORTH_WORDS_KEY 
2c8d					DMARK "PAU" 
2c8d f5				push af  
2c8e 3a a2 2c			ld a, (.dmark)  
2c91 32 9d fd			ld (debug_mark),a  
2c94 3a a3 2c			ld a, (.dmark+1)  
2c97 32 9e fd			ld (debug_mark+1),a  
2c9a 3a a4 2c			ld a, (.dmark+2)  
2c9d 32 9f fd			ld (debug_mark+2),a  
2ca0 18 03			jr .pastdmark  
2ca2 ..			.dmark: db "PAU"  
2ca5 f1			.pastdmark: pop af  
2ca6			endm  
# End of macro DMARK
2ca6					CALLMONITOR 
2ca6 cd aa fd			call debug_vector  
2ca9				endm  
# End of macro CALLMONITOR
2ca9				endif 
2ca9				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2ca9 cd fb 21			call macro_dsp_valuehl 
2cac				endm 
# End of macro FORTH_DSP_VALUEHL
2cac			;		push hl    ; n2 
2cac				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2cac cd b3 22			call macro_forth_dsp_pop 
2caf				endm 
# End of macro FORTH_DSP_POP
2caf			;		pop hl 
2caf 45				ld b, l 
2cb0				if DEBUG_FORTH_WORDS 
2cb0					DMARK "PAU" 
2cb0 f5				push af  
2cb1 3a c5 2c			ld a, (.dmark)  
2cb4 32 9d fd			ld (debug_mark),a  
2cb7 3a c6 2c			ld a, (.dmark+1)  
2cba 32 9e fd			ld (debug_mark+1),a  
2cbd 3a c7 2c			ld a, (.dmark+2)  
2cc0 32 9f fd			ld (debug_mark+2),a  
2cc3 18 03			jr .pastdmark  
2cc5 ..			.dmark: db "PAU"  
2cc8 f1			.pastdmark: pop af  
2cc9			endm  
# End of macro DMARK
2cc9					CALLMONITOR 
2cc9 cd aa fd			call debug_vector  
2ccc				endm  
# End of macro CALLMONITOR
2ccc				endif 
2ccc c5			.pauses1:	push bc 
2ccd cd c0 0c			call delay1s 
2cd0 c1				pop bc 
2cd1				if DEBUG_FORTH_WORDS 
2cd1					DMARK "PA1" 
2cd1 f5				push af  
2cd2 3a e6 2c			ld a, (.dmark)  
2cd5 32 9d fd			ld (debug_mark),a  
2cd8 3a e7 2c			ld a, (.dmark+1)  
2cdb 32 9e fd			ld (debug_mark+1),a  
2cde 3a e8 2c			ld a, (.dmark+2)  
2ce1 32 9f fd			ld (debug_mark+2),a  
2ce4 18 03			jr .pastdmark  
2ce6 ..			.dmark: db "PA1"  
2ce9 f1			.pastdmark: pop af  
2cea			endm  
# End of macro DMARK
2cea					CALLMONITOR 
2cea cd aa fd			call debug_vector  
2ced				endm  
# End of macro CALLMONITOR
2ced				endif 
2ced 10 dd			djnz .pauses1 
2cef			 
2cef			       NEXTW 
2cef cd a7 fd			call parse_vector 
2cf2 c3 e2 23			jp macro_next 
2cf5				endm 
# End of macro NEXTW
2cf5			.ROT: 
2cf5			CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2cf5 45				db WORD_SYS_CORE+49             
2cf6 61 2d			dw .UWORDS            
2cf8 04				db 3 + 1 
2cf9 .. 00			db "ROT",0              
2cfd				endm 
# End of macro CWHEAD
2cfd			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
2cfd				if DEBUG_FORTH_WORDS_KEY 
2cfd					DMARK "ROT" 
2cfd f5				push af  
2cfe 3a 12 2d			ld a, (.dmark)  
2d01 32 9d fd			ld (debug_mark),a  
2d04 3a 13 2d			ld a, (.dmark+1)  
2d07 32 9e fd			ld (debug_mark+1),a  
2d0a 3a 14 2d			ld a, (.dmark+2)  
2d0d 32 9f fd			ld (debug_mark+2),a  
2d10 18 03			jr .pastdmark  
2d12 ..			.dmark: db "ROT"  
2d15 f1			.pastdmark: pop af  
2d16			endm  
# End of macro DMARK
2d16					CALLMONITOR 
2d16 cd aa fd			call debug_vector  
2d19				endm  
# End of macro CALLMONITOR
2d19				endif 
2d19			 
2d19			; DONE Use os stack swap memory 
2d19			 
2d19				FORTH_DSP_PTR 0     ; u3 
2d19 2a 20 f9			ld hl,(cli_data_sp) 
2d1c 11 00 00			ld de, 0 * 3 
2d1f ed 52			sbc hl, de 
2d21				endm 
# End of macro FORTH_DSP_PTR
2d21 cd 32 23			call hltostack1     
2d24			  
2d24				FORTH_DSP_PTR 1     ; u2 
2d24 2a 20 f9			ld hl,(cli_data_sp) 
2d27 11 03 00			ld de, 1 * 3 
2d2a ed 52			sbc hl, de 
2d2c				endm 
# End of macro FORTH_DSP_PTR
2d2c cd 38 23			call hltostack2      
2d2f			 
2d2f				FORTH_DSP_PTR 2     ; u1 
2d2f 2a 20 f9			ld hl,(cli_data_sp) 
2d32 11 06 00			ld de, 2 * 3 
2d35 ed 52			sbc hl, de 
2d37				endm 
# End of macro FORTH_DSP_PTR
2d37 cd 3e 23			call hltostack3 
2d3a			 
2d3a			 
2d3a				FORTH_DSP_PTR 0     ;  
2d3a 2a 20 f9			ld hl,(cli_data_sp) 
2d3d 11 00 00			ld de, 0 * 3 
2d40 ed 52			sbc hl, de 
2d42				endm 
# End of macro FORTH_DSP_PTR
2d42 cd 56 23			call hlfromstack3 
2d45			 
2d45				FORTH_DSP_PTR 1     ; TOS 
2d45 2a 20 f9			ld hl,(cli_data_sp) 
2d48 11 03 00			ld de, 1 * 3 
2d4b ed 52			sbc hl, de 
2d4d				endm 
# End of macro FORTH_DSP_PTR
2d4d cd 4a 23			call hlfromstack1 
2d50			 
2d50				FORTH_DSP_PTR 2     ; TOS 
2d50 2a 20 f9			ld hl,(cli_data_sp) 
2d53 11 06 00			ld de, 2 * 3 
2d56 ed 52			sbc hl, de 
2d58				endm 
# End of macro FORTH_DSP_PTR
2d58 cd 50 23			call hlfromstack2 
2d5b			 
2d5b			 
2d5b			;	FORTH_DSP_VALUEHL 
2d5b			;	push hl    ; u3  
2d5b			; 
2d5b			;	FORTH_DSP_POP 
2d5b			; 
2d5b			;	FORTH_DSP_VALUEHL 
2d5b			;	push hl     ; u2 
2d5b			; 
2d5b			;	FORTH_DSP_POP 
2d5b			; 
2d5b			;	FORTH_DSP_VALUEHL 
2d5b			;	push hl     ; u1 
2d5b			; 
2d5b			;	FORTH_DSP_POP 
2d5b			; 
2d5b			;	pop bc      ; u1 
2d5b			;	pop hl      ; u2 
2d5b			;	pop de      ; u3 
2d5b			; 
2d5b			; 
2d5b			;	push bc 
2d5b			;	push de 
2d5b			;	push hl 
2d5b			; 
2d5b			; 
2d5b			;	pop hl 
2d5b			;	call forth_push_numhl 
2d5b			; 
2d5b			;	pop hl 
2d5b			;	call forth_push_numhl 
2d5b			; 
2d5b			;	pop hl 
2d5b			;	call forth_push_numhl 
2d5b				 
2d5b			 
2d5b			 
2d5b			 
2d5b			 
2d5b			 
2d5b			       NEXTW 
2d5b cd a7 fd			call parse_vector 
2d5e c3 e2 23			jp macro_next 
2d61				endm 
# End of macro NEXTW
2d61			 
2d61			.UWORDS: 
2d61			CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2d61 50				db WORD_SYS_CORE+60             
2d62 26 2e			dw .BP            
2d64 07				db 6 + 1 
2d65 .. 00			db "UWORDS",0              
2d6c				endm 
# End of macro CWHEAD
2d6c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
2d6c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
2d6c			; | | Following the count are the individual words. 
2d6c			; | | 
2d6c			; | | e.g. UWORDS 
2d6c			; | | BOX DIRLIST 2 
2d6c			; | |  
2d6c			; | | Can be used to save the words to storage via: 
2d6c			; | | UWORDS $01 DO $01 APPEND LOOP 
2d6c			if DEBUG_FORTH_WORDS_KEY 
2d6c				DMARK "UWR" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 9d fd			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 9e fd			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 9f fd			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "UWR"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85				CALLMONITOR 
2d85 cd aa fd			call debug_vector  
2d88				endm  
# End of macro CALLMONITOR
2d88			endif 
2d88 21 00 80			ld hl, baseram 
2d8b				;ld hl, baseusermem 
2d8b 01 00 00			ld bc, 0    ; start a counter 
2d8e			 
2d8e			; skip dict stub 
2d8e			 
2d8e cd 14 25			call forth_tok_next 
2d91			 
2d91			 
2d91			; while we have words to look for 
2d91			 
2d91 7e			.douscan:	ld a, (hl)      
2d92			if DEBUG_FORTH_WORDS 
2d92				DMARK "UWs" 
2d92 f5				push af  
2d93 3a a7 2d			ld a, (.dmark)  
2d96 32 9d fd			ld (debug_mark),a  
2d99 3a a8 2d			ld a, (.dmark+1)  
2d9c 32 9e fd			ld (debug_mark+1),a  
2d9f 3a a9 2d			ld a, (.dmark+2)  
2da2 32 9f fd			ld (debug_mark+2),a  
2da5 18 03			jr .pastdmark  
2da7 ..			.dmark: db "UWs"  
2daa f1			.pastdmark: pop af  
2dab			endm  
# End of macro DMARK
2dab				CALLMONITOR 
2dab cd aa fd			call debug_vector  
2dae				endm  
# End of macro CALLMONITOR
2dae			endif 
2dae fe 00			cp WORD_SYS_END 
2db0 28 4d			jr z, .udone 
2db2 fe 01			cp WORD_SYS_UWORD 
2db4 20 44			jr nz, .nuword 
2db6			 
2db6			if DEBUG_FORTH_WORDS 
2db6				DMARK "UWu" 
2db6 f5				push af  
2db7 3a cb 2d			ld a, (.dmark)  
2dba 32 9d fd			ld (debug_mark),a  
2dbd 3a cc 2d			ld a, (.dmark+1)  
2dc0 32 9e fd			ld (debug_mark+1),a  
2dc3 3a cd 2d			ld a, (.dmark+2)  
2dc6 32 9f fd			ld (debug_mark+2),a  
2dc9 18 03			jr .pastdmark  
2dcb ..			.dmark: db "UWu"  
2dce f1			.pastdmark: pop af  
2dcf			endm  
# End of macro DMARK
2dcf				CALLMONITOR 
2dcf cd aa fd			call debug_vector  
2dd2				endm  
# End of macro CALLMONITOR
2dd2			endif 
2dd2				; we have a uword so push its name to the stack 
2dd2			 
2dd2 e5				push hl  ; save so we can move to next dict block 
2dd3			 
2dd3				; skip opcode 
2dd3 23				inc hl  
2dd4				; skip next ptr 
2dd4 23				inc hl  
2dd5 23				inc hl 
2dd6				; skip len 
2dd6 23				inc hl 
2dd7			if DEBUG_FORTH_WORDS 
2dd7				DMARK "UWt" 
2dd7 f5				push af  
2dd8 3a ec 2d			ld a, (.dmark)  
2ddb 32 9d fd			ld (debug_mark),a  
2dde 3a ed 2d			ld a, (.dmark+1)  
2de1 32 9e fd			ld (debug_mark+1),a  
2de4 3a ee 2d			ld a, (.dmark+2)  
2de7 32 9f fd			ld (debug_mark+2),a  
2dea 18 03			jr .pastdmark  
2dec ..			.dmark: db "UWt"  
2def f1			.pastdmark: pop af  
2df0			endm  
# End of macro DMARK
2df0				CALLMONITOR 
2df0 cd aa fd			call debug_vector  
2df3				endm  
# End of macro CALLMONITOR
2df3			endif 
2df3 03				inc bc 
2df4			 
2df4 c5				push bc 
2df5 cd 69 20			call forth_push_str 
2df8 c1				pop bc 
2df9			 
2df9 e1				pop hl 	 
2dfa			 
2dfa cd 14 25		.nuword:	call forth_tok_next 
2dfd 18 92			jr .douscan  
2dff			 
2dff			.udone:		 ; push count of uwords found 
2dff c5				push bc 
2e00 e1				pop hl 
2e01			 
2e01			if DEBUG_FORTH_WORDS 
2e01				DMARK "UWc" 
2e01 f5				push af  
2e02 3a 16 2e			ld a, (.dmark)  
2e05 32 9d fd			ld (debug_mark),a  
2e08 3a 17 2e			ld a, (.dmark+1)  
2e0b 32 9e fd			ld (debug_mark+1),a  
2e0e 3a 18 2e			ld a, (.dmark+2)  
2e11 32 9f fd			ld (debug_mark+2),a  
2e14 18 03			jr .pastdmark  
2e16 ..			.dmark: db "UWc"  
2e19 f1			.pastdmark: pop af  
2e1a			endm  
# End of macro DMARK
2e1a				CALLMONITOR 
2e1a cd aa fd			call debug_vector  
2e1d				endm  
# End of macro CALLMONITOR
2e1d			endif 
2e1d cd ff 1f			call forth_push_numhl 
2e20			 
2e20			 
2e20			       NEXTW 
2e20 cd a7 fd			call parse_vector 
2e23 c3 e2 23			jp macro_next 
2e26				endm 
# End of macro NEXTW
2e26			 
2e26			.BP: 
2e26			CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2e26 54				db WORD_SYS_CORE+64             
2e27 66 2e			dw .MONITOR            
2e29 03				db 2 + 1 
2e2a .. 00			db "BP",0              
2e2d				endm 
# End of macro CWHEAD
2e2d			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
2e2d			; | | $00 Will enable the break points within specific code paths 
2e2d			; | | $01 Will disable break points 
2e2d			; | |  
2e2d			; | | By default break points are off. Either the above can be used to enable them 
2e2d			; | | or if a key is held down during start up the spashscreen will appear to freeze 
2e2d			; | | and on release of the pressed key the CONFIG menu will be displayed where you 
2e2d			; | | can disable break points. Exiting will then continue boot process. 
2e2d				; get byte count 
2e2d				if DEBUG_FORTH_WORDS_KEY 
2e2d					DMARK "BP." 
2e2d f5				push af  
2e2e 3a 42 2e			ld a, (.dmark)  
2e31 32 9d fd			ld (debug_mark),a  
2e34 3a 43 2e			ld a, (.dmark+1)  
2e37 32 9e fd			ld (debug_mark+1),a  
2e3a 3a 44 2e			ld a, (.dmark+2)  
2e3d 32 9f fd			ld (debug_mark+2),a  
2e40 18 03			jr .pastdmark  
2e42 ..			.dmark: db "BP."  
2e45 f1			.pastdmark: pop af  
2e46			endm  
# End of macro DMARK
2e46					CALLMONITOR 
2e46 cd aa fd			call debug_vector  
2e49				endm  
# End of macro CALLMONITOR
2e49				endif 
2e49			 
2e49				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2e49 cd fb 21			call macro_dsp_valuehl 
2e4c				endm 
# End of macro FORTH_DSP_VALUEHL
2e4c			 
2e4c			;		push hl 
2e4c			 
2e4c				; destroy value TOS 
2e4c			 
2e4c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2e4c cd b3 22			call macro_forth_dsp_pop 
2e4f				endm 
# End of macro FORTH_DSP_POP
2e4f			 
2e4f			;		pop hl 
2e4f			 
2e4f 3e 00			ld a,0 
2e51 bd				cp l 
2e52 28 09			jr z, .bpset 
2e54			;		ld a, '*' 
2e54 cd da 18			call bp_off 
2e57				NEXTW 
2e57 cd a7 fd			call parse_vector 
2e5a c3 e2 23			jp macro_next 
2e5d				endm 
# End of macro NEXTW
2e5d			 
2e5d			.bpset:	 
2e5d				;	ld (os_view_disable), a 
2e5d cd ce 18			call bp_on 
2e60			 
2e60			 
2e60				NEXTW 
2e60 cd a7 fd			call parse_vector 
2e63 c3 e2 23			jp macro_next 
2e66				endm 
# End of macro NEXTW
2e66			 
2e66			 
2e66			.MONITOR: 
2e66			CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2e66 55				db WORD_SYS_CORE+65             
2e67 9a 2e			dw .MALLOC            
2e69 08				db 7 + 1 
2e6a .. 00			db "MONITOR",0              
2e72				endm 
# End of macro CWHEAD
2e72			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2e72			; | | At start the current various registers will be displayed with contents. 
2e72			; | | Top right corner will show the most recent debug marker seen. 
2e72			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2e72			; | | and the return stack pointer (RSP). 
2e72			; | | Pressing: 
2e72			; | |  
2e72			; | |    1 - Initial screen 
2e72			; | |  
2e72			; | |    2 - Display a data dump of HL 
2e72			; | |  
2e72			; | |    3 - Display a data dump of DE 
2e72			; | |  
2e72			; | |    4 - Display a data dump of BC 
2e72			; | |  
2e72			; | |    5 - Display a data dump of HL 
2e72			; | |  
2e72			; | |    6 - Display a data dump of DSP 
2e72			; | |  
2e72			; | |    7 - Display a data dump of RSP 
2e72			; | |  
2e72			; | |    8 - Display a data dump of what is at DSP 
2e72			; | |  
2e72			; | |    9 - Display a data dump of what is at RSP 
2e72			; | |  
2e72			; | |    0 - Exit monitor and continue running. This will also enable break points 
2e72			; | |  
2e72			; | |    * - Disable break points 
2e72			; | |  
2e72			; | |    # - Enter traditional monitor mode 
2e72			; | |  
2e72			; | | 
2e72			; | | Monitor Mode 
2e72			; | | ------------ 
2e72			; | | A prompt of '>' will be shown for various commands: 
2e72			; | |  
2e72			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2e72			; | |  
2e72			; | |    C - Continue display a data dump from the last set address 
2e72			; | |  
2e72			; | |    M xxxx - Set start of memory edit at address xx 
2e72			; | |  
2e72			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2e72			; | |  
2e72			; | |    G xxxx - Exec code at specific address 
2e72			; | |  
2e72			; | |    Q - Return to previous 
2e72				if DEBUG_FORTH_WORDS_KEY 
2e72					DMARK "MON" 
2e72 f5				push af  
2e73 3a 87 2e			ld a, (.dmark)  
2e76 32 9d fd			ld (debug_mark),a  
2e79 3a 88 2e			ld a, (.dmark+1)  
2e7c 32 9e fd			ld (debug_mark+1),a  
2e7f 3a 89 2e			ld a, (.dmark+2)  
2e82 32 9f fd			ld (debug_mark+2),a  
2e85 18 03			jr .pastdmark  
2e87 ..			.dmark: db "MON"  
2e8a f1			.pastdmark: pop af  
2e8b			endm  
# End of macro DMARK
2e8b					CALLMONITOR 
2e8b cd aa fd			call debug_vector  
2e8e				endm  
# End of macro CALLMONITOR
2e8e				endif 
2e8e			;		ld a, 0 
2e8e			;		ld (os_view_disable), a 
2e8e cd ce 18			call bp_on 
2e91			 
2e91				CALLMONITOR 
2e91 cd aa fd			call debug_vector  
2e94				endm  
# End of macro CALLMONITOR
2e94			 
2e94			;	call monitor 
2e94			 
2e94				NEXTW 
2e94 cd a7 fd			call parse_vector 
2e97 c3 e2 23			jp macro_next 
2e9a				endm 
# End of macro NEXTW
2e9a			 
2e9a			 
2e9a			.MALLOC: 
2e9a			CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
2e9a 56				db WORD_SYS_CORE+66             
2e9b c3 2e			dw .MALLOC2            
2e9d 06				db 5 + 1 
2e9e .. 00			db "ALLOT",0              
2ea4				endm 
# End of macro CWHEAD
2ea4			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ea4				if DEBUG_FORTH_WORDS_KEY 
2ea4					DMARK "ALL" 
2ea4 f5				push af  
2ea5 3a b9 2e			ld a, (.dmark)  
2ea8 32 9d fd			ld (debug_mark),a  
2eab 3a ba 2e			ld a, (.dmark+1)  
2eae 32 9e fd			ld (debug_mark+1),a  
2eb1 3a bb 2e			ld a, (.dmark+2)  
2eb4 32 9f fd			ld (debug_mark+2),a  
2eb7 18 03			jr .pastdmark  
2eb9 ..			.dmark: db "ALL"  
2ebc f1			.pastdmark: pop af  
2ebd			endm  
# End of macro DMARK
2ebd					CALLMONITOR 
2ebd cd aa fd			call debug_vector  
2ec0				endm  
# End of macro CALLMONITOR
2ec0				endif 
2ec0 c3 ea 2e			jp .mallocc 
2ec3			.MALLOC2: 
2ec3			CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2ec3 56				db WORD_SYS_CORE+66             
2ec4 04 2f			dw .FREE            
2ec6 07				db 6 + 1 
2ec7 .. 00			db "MALLOC",0              
2ece				endm 
# End of macro CWHEAD
2ece			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2ece				; get byte count 
2ece				if DEBUG_FORTH_WORDS_KEY 
2ece					DMARK "MAL" 
2ece f5				push af  
2ecf 3a e3 2e			ld a, (.dmark)  
2ed2 32 9d fd			ld (debug_mark),a  
2ed5 3a e4 2e			ld a, (.dmark+1)  
2ed8 32 9e fd			ld (debug_mark+1),a  
2edb 3a e5 2e			ld a, (.dmark+2)  
2ede 32 9f fd			ld (debug_mark+2),a  
2ee1 18 03			jr .pastdmark  
2ee3 ..			.dmark: db "MAL"  
2ee6 f1			.pastdmark: pop af  
2ee7			endm  
# End of macro DMARK
2ee7					CALLMONITOR 
2ee7 cd aa fd			call debug_vector  
2eea				endm  
# End of macro CALLMONITOR
2eea				endif 
2eea			.mallocc: 
2eea				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2eea cd fb 21			call macro_dsp_valuehl 
2eed				endm 
# End of macro FORTH_DSP_VALUEHL
2eed			 
2eed			;		push hl 
2eed			 
2eed				; destroy value TOS 
2eed			 
2eed				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2eed cd b3 22			call macro_forth_dsp_pop 
2ef0				endm 
# End of macro FORTH_DSP_POP
2ef0			 
2ef0			;		pop hl 
2ef0 cd 78 13			call malloc 
2ef3			if DEBUG_FORTH_MALLOC_GUARD 
2ef3 f5				push af 
2ef4 cd d5 0f			call ishlzero 
2ef7			;		ld a, l 
2ef7			;		add h 
2ef7			;		cp 0 
2ef7 f1				pop af 
2ef8				 
2ef8 cc fd 65			call z,malloc_error 
2efb			endif 
2efb			 
2efb cd ff 1f			call forth_push_numhl 
2efe				NEXTW 
2efe cd a7 fd			call parse_vector 
2f01 c3 e2 23			jp macro_next 
2f04				endm 
# End of macro NEXTW
2f04			 
2f04			.FREE: 
2f04			CWHEAD .UPTR 67 "FREE" 4 WORD_FLAG_CODE 
2f04 57				db WORD_SYS_CORE+67             
2f05 38 2f			dw .UPTR            
2f07 05				db 4 + 1 
2f08 .. 00			db "FREE",0              
2f0d				endm 
# End of macro CWHEAD
2f0d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
2f0d				if DEBUG_FORTH_WORDS_KEY 
2f0d					DMARK "FRE" 
2f0d f5				push af  
2f0e 3a 22 2f			ld a, (.dmark)  
2f11 32 9d fd			ld (debug_mark),a  
2f14 3a 23 2f			ld a, (.dmark+1)  
2f17 32 9e fd			ld (debug_mark+1),a  
2f1a 3a 24 2f			ld a, (.dmark+2)  
2f1d 32 9f fd			ld (debug_mark+2),a  
2f20 18 03			jr .pastdmark  
2f22 ..			.dmark: db "FRE"  
2f25 f1			.pastdmark: pop af  
2f26			endm  
# End of macro DMARK
2f26					CALLMONITOR 
2f26 cd aa fd			call debug_vector  
2f29				endm  
# End of macro CALLMONITOR
2f29				endif 
2f29				; get address 
2f29			 
2f29				FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2f29 cd fb 21			call macro_dsp_valuehl 
2f2c				endm 
# End of macro FORTH_DSP_VALUEHL
2f2c			 
2f2c			;		push hl 
2f2c			 
2f2c				; destroy value TOS 
2f2c			 
2f2c				FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2f2c cd b3 22			call macro_forth_dsp_pop 
2f2f				endm 
# End of macro FORTH_DSP_POP
2f2f			 
2f2f			;		pop hl 
2f2f			if FORTH_ENABLE_MALLOCFREE 
2f2f cd 42 14			call free 
2f32			endif 
2f32				NEXTW 
2f32 cd a7 fd			call parse_vector 
2f35 c3 e2 23			jp macro_next 
2f38				endm 
# End of macro NEXTW
2f38			.UPTR: 
2f38			CWHEAD .LIST 67 "UPTR" 4 WORD_FLAG_CODE 
2f38 57				db WORD_SYS_CORE+67             
2f39 3e 30			dw .LIST            
2f3b 05				db 4 + 1 
2f3c .. 00			db "UPTR",0              
2f41				endm 
# End of macro CWHEAD
2f41			; | UPTR ( s -- u ) Push the address of the exec code for the quoted used word s  | TODO 
2f41				if DEBUG_FORTH_WORDS_KEY 
2f41					DMARK "UPT" 
2f41 f5				push af  
2f42 3a 56 2f			ld a, (.dmark)  
2f45 32 9d fd			ld (debug_mark),a  
2f48 3a 57 2f			ld a, (.dmark+1)  
2f4b 32 9e fd			ld (debug_mark+1),a  
2f4e 3a 58 2f			ld a, (.dmark+2)  
2f51 32 9f fd			ld (debug_mark+2),a  
2f54 18 03			jr .pastdmark  
2f56 ..			.dmark: db "UPT"  
2f59 f1			.pastdmark: pop af  
2f5a			endm  
# End of macro DMARK
2f5a					CALLMONITOR 
2f5a cd aa fd			call debug_vector  
2f5d				endm  
# End of macro CALLMONITOR
2f5d				endif 
2f5d				FORTH_DSP_VALUEHL 
2f5d cd fb 21			call macro_dsp_valuehl 
2f60				endm 
# End of macro FORTH_DSP_VALUEHL
2f60			 
2f60 e5				push hl 
2f61				FORTH_DSP_POP 
2f61 cd b3 22			call macro_forth_dsp_pop 
2f64				endm 
# End of macro FORTH_DSP_POP
2f64 c1				pop bc 
2f65			 
2f65			 
2f65				; Get ptr to the word we need to look up 
2f65			 
2f65			;		FORTH_DSP_VALUEHL 
2f65				;v5 FORTH_DSP_VALUE 
2f65			; TODO type check 
2f65			;		inc hl    ; Skip type check  
2f65			;		push hl 
2f65			;		ex de, hl    ; put into DE 
2f65			 
2f65			 
2f65 21 00 80			ld hl, baseram 
2f68				;ld hl, baseusermem 
2f68			 
2f68 e5			push hl   ; sacreifical push 
2f69			 
2f69			.uldouscanm: 
2f69 e1			pop hl 
2f6a			.uldouscan: 
2f6a			if DEBUG_FORTH_WORDS 
2f6a				DMARK "LSs" 
2f6a f5				push af  
2f6b 3a 7f 2f			ld a, (.dmark)  
2f6e 32 9d fd			ld (debug_mark),a  
2f71 3a 80 2f			ld a, (.dmark+1)  
2f74 32 9e fd			ld (debug_mark+1),a  
2f77 3a 81 2f			ld a, (.dmark+2)  
2f7a 32 9f fd			ld (debug_mark+2),a  
2f7d 18 03			jr .pastdmark  
2f7f ..			.dmark: db "LSs"  
2f82 f1			.pastdmark: pop af  
2f83			endm  
# End of macro DMARK
2f83				CALLMONITOR 
2f83 cd aa fd			call debug_vector  
2f86				endm  
# End of macro CALLMONITOR
2f86			endif 
2f86			; skip dict stub 
2f86 cd 14 25			call forth_tok_next 
2f89			 
2f89			 
2f89			; while we have words to look for 
2f89			 
2f89 7e			ld a, (hl)      
2f8a			if DEBUG_FORTH_WORDS 
2f8a				DMARK "LSk" 
2f8a f5				push af  
2f8b 3a 9f 2f			ld a, (.dmark)  
2f8e 32 9d fd			ld (debug_mark),a  
2f91 3a a0 2f			ld a, (.dmark+1)  
2f94 32 9e fd			ld (debug_mark+1),a  
2f97 3a a1 2f			ld a, (.dmark+2)  
2f9a 32 9f fd			ld (debug_mark+2),a  
2f9d 18 03			jr .pastdmark  
2f9f ..			.dmark: db "LSk"  
2fa2 f1			.pastdmark: pop af  
2fa3			endm  
# End of macro DMARK
2fa3				CALLMONITOR 
2fa3 cd aa fd			call debug_vector  
2fa6				endm  
# End of macro CALLMONITOR
2fa6			endif 
2fa6				;cp WORD_SYS_END 
2fa6				;jp z, .lunotfound 
2fa6			 
2fa6					; if we hit non uwords then gone too far 
2fa6 fe 01				cp WORD_SYS_UWORD 
2fa8 c2 35 30				jp nz, .ulunotfound 
2fab			 
2fab				if DEBUG_FORTH_WORDS 
2fab					DMARK "LSu" 
2fab f5				push af  
2fac 3a c0 2f			ld a, (.dmark)  
2faf 32 9d fd			ld (debug_mark),a  
2fb2 3a c1 2f			ld a, (.dmark+1)  
2fb5 32 9e fd			ld (debug_mark+1),a  
2fb8 3a c2 2f			ld a, (.dmark+2)  
2fbb 32 9f fd			ld (debug_mark+2),a  
2fbe 18 03			jr .pastdmark  
2fc0 ..			.dmark: db "LSu"  
2fc3 f1			.pastdmark: pop af  
2fc4			endm  
# End of macro DMARK
2fc4					CALLMONITOR 
2fc4 cd aa fd			call debug_vector  
2fc7				endm  
# End of macro CALLMONITOR
2fc7				endif 
2fc7			 
2fc7					; found a uword but is it the one we want... 
2fc7			 
2fc7 c5					push bc     ; uword to find is on bc 
2fc8 d1					pop de 
2fc9			 
2fc9 e5					push hl  ; to save the ptr 
2fca			 
2fca					; skip opcode 
2fca 23					inc hl  
2fcb					; skip next ptr 
2fcb 23					inc hl  
2fcc 23					inc hl 
2fcd					; skip len 
2fcd 23					inc hl 
2fce			 
2fce				if DEBUG_FORTH_WORDS 
2fce					DMARK "LSc" 
2fce f5				push af  
2fcf 3a e3 2f			ld a, (.dmark)  
2fd2 32 9d fd			ld (debug_mark),a  
2fd5 3a e4 2f			ld a, (.dmark+1)  
2fd8 32 9e fd			ld (debug_mark+1),a  
2fdb 3a e5 2f			ld a, (.dmark+2)  
2fde 32 9f fd			ld (debug_mark+2),a  
2fe1 18 03			jr .pastdmark  
2fe3 ..			.dmark: db "LSc"  
2fe6 f1			.pastdmark: pop af  
2fe7			endm  
# End of macro DMARK
2fe7					CALLMONITOR 
2fe7 cd aa fd			call debug_vector  
2fea				endm  
# End of macro CALLMONITOR
2fea				endif 
2fea			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
2fea			; ie. If WOO is defined first and then WO. Couldnt list WO. 
2fea			; Nope that has gone the other way. It needs to be exact not on first zero 
2fea			;		call strcmp 
2fea c5					push bc 
2feb cd 48 13				call StrictStrCmp 
2fee c1					pop bc 
2fef c2 69 2f				jp nz, .uldouscanm 
2ff2				 
2ff2			 
2ff2			 
2ff2					; we have a uword so push its name to the stack 
2ff2			 
2ff2			;	   	push hl  ; save so we can move to next dict block 
2ff2 e1			pop hl 
2ff3			 
2ff3				if DEBUG_FORTH_WORDS 
2ff3					DMARK "LSm" 
2ff3 f5				push af  
2ff4 3a 08 30			ld a, (.dmark)  
2ff7 32 9d fd			ld (debug_mark),a  
2ffa 3a 09 30			ld a, (.dmark+1)  
2ffd 32 9e fd			ld (debug_mark+1),a  
3000 3a 0a 30			ld a, (.dmark+2)  
3003 32 9f fd			ld (debug_mark+2),a  
3006 18 03			jr .pastdmark  
3008 ..			.dmark: db "LSm"  
300b f1			.pastdmark: pop af  
300c			endm  
# End of macro DMARK
300c					CALLMONITOR 
300c cd aa fd			call debug_vector  
300f				endm  
# End of macro CALLMONITOR
300f				endif 
300f			 
300f					; skip opcode 
300f 23					inc hl  
3010					; skip next ptr 
3010 23					inc hl  
3011 23					inc hl 
3012					; skip len 
3012 7e					ld a, (hl)   ; save length to add 
3013				if DEBUG_FORTH_WORDS 
3013					DMARK "LS2" 
3013 f5				push af  
3014 3a 28 30			ld a, (.dmark)  
3017 32 9d fd			ld (debug_mark),a  
301a 3a 29 30			ld a, (.dmark+1)  
301d 32 9e fd			ld (debug_mark+1),a  
3020 3a 2a 30			ld a, (.dmark+2)  
3023 32 9f fd			ld (debug_mark+2),a  
3026 18 03			jr .pastdmark  
3028 ..			.dmark: db "LS2"  
302b f1			.pastdmark: pop af  
302c			endm  
# End of macro DMARK
302c					CALLMONITOR 
302c cd aa fd			call debug_vector  
302f				endm  
# End of macro CALLMONITOR
302f				endif 
302f			 
302f				; skip zero term and other uword defs to position right at the exec code 
302f 06 04			ld b, 4 
3031 80				add a,b 
3032			 
3032 cd ac 0f			call addatohl 
3035					; save this location 
3035				 
3035			.ulunotfound: 
3035 cd ff 1f			call forth_push_numhl 
3038						 
3038				NEXTW 
3038 cd a7 fd			call parse_vector 
303b c3 e2 23			jp macro_next 
303e				endm 
# End of macro NEXTW
303e			.LIST: 
303e			CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
303e 5c				db WORD_SYS_CORE+72             
303f 40 32			dw .FORGET            
3041 05				db 4 + 1 
3042 .. 00			db "LIST",0              
3047				endm 
# End of macro CWHEAD
3047			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
3047			; | | The quoted word must be in upper case. 
3047			if DEBUG_FORTH_WORDS_KEY 
3047				DMARK "LST" 
3047 f5				push af  
3048 3a 5c 30			ld a, (.dmark)  
304b 32 9d fd			ld (debug_mark),a  
304e 3a 5d 30			ld a, (.dmark+1)  
3051 32 9e fd			ld (debug_mark+1),a  
3054 3a 5e 30			ld a, (.dmark+2)  
3057 32 9f fd			ld (debug_mark+2),a  
305a 18 03			jr .pastdmark  
305c ..			.dmark: db "LST"  
305f f1			.pastdmark: pop af  
3060			endm  
# End of macro DMARK
3060				CALLMONITOR 
3060 cd aa fd			call debug_vector  
3063				endm  
# End of macro CALLMONITOR
3063			endif 
3063			 
3063				FORTH_DSP_VALUEHL 
3063 cd fb 21			call macro_dsp_valuehl 
3066				endm 
# End of macro FORTH_DSP_VALUEHL
3066			 
3066 e5				push hl 
3067				FORTH_DSP_POP 
3067 cd b3 22			call macro_forth_dsp_pop 
306a				endm 
# End of macro FORTH_DSP_POP
306a c1				pop bc 
306b			 
306b			; Start format of scratch string 
306b			 
306b 21 f3 f0			ld hl, scratch 
306e			 
306e			;	ld a, ':' 
306e 36 3a			ld (hl),':' 
3070 23				inc hl 
3071			;	ld a, ' ' 
3071 36 20			ld (hl), ' ' 
3073			 
3073				; Get ptr to the word we need to look up 
3073			 
3073			;		FORTH_DSP_VALUEHL 
3073				;v5 FORTH_DSP_VALUE 
3073			; TODO type check 
3073			;		inc hl    ; Skip type check  
3073			;		push hl 
3073			;		ex de, hl    ; put into DE 
3073			 
3073			 
3073 21 00 80			ld hl, baseram 
3076				;ld hl, baseusermem 
3076			 
3076 e5			push hl   ; sacreifical push 
3077			 
3077			.ldouscanm: 
3077 e1			pop hl 
3078			.ldouscan: 
3078			if DEBUG_FORTH_WORDS 
3078				DMARK "LSs" 
3078 f5				push af  
3079 3a 8d 30			ld a, (.dmark)  
307c 32 9d fd			ld (debug_mark),a  
307f 3a 8e 30			ld a, (.dmark+1)  
3082 32 9e fd			ld (debug_mark+1),a  
3085 3a 8f 30			ld a, (.dmark+2)  
3088 32 9f fd			ld (debug_mark+2),a  
308b 18 03			jr .pastdmark  
308d ..			.dmark: db "LSs"  
3090 f1			.pastdmark: pop af  
3091			endm  
# End of macro DMARK
3091				CALLMONITOR 
3091 cd aa fd			call debug_vector  
3094				endm  
# End of macro CALLMONITOR
3094			endif 
3094			; skip dict stub 
3094 cd 14 25			call forth_tok_next 
3097			 
3097			 
3097			; while we have words to look for 
3097			 
3097 7e			ld a, (hl)      
3098			if DEBUG_FORTH_WORDS 
3098				DMARK "LSk" 
3098 f5				push af  
3099 3a ad 30			ld a, (.dmark)  
309c 32 9d fd			ld (debug_mark),a  
309f 3a ae 30			ld a, (.dmark+1)  
30a2 32 9e fd			ld (debug_mark+1),a  
30a5 3a af 30			ld a, (.dmark+2)  
30a8 32 9f fd			ld (debug_mark+2),a  
30ab 18 03			jr .pastdmark  
30ad ..			.dmark: db "LSk"  
30b0 f1			.pastdmark: pop af  
30b1			endm  
# End of macro DMARK
30b1				CALLMONITOR 
30b1 cd aa fd			call debug_vector  
30b4				endm  
# End of macro CALLMONITOR
30b4			endif 
30b4				;cp WORD_SYS_END 
30b4				;jp z, .lunotfound 
30b4			 
30b4					; if we hit non uwords then gone too far 
30b4 fe 01				cp WORD_SYS_UWORD 
30b6 c2 f3 31				jp nz, .lunotfound 
30b9			 
30b9				if DEBUG_FORTH_WORDS 
30b9					DMARK "LSu" 
30b9 f5				push af  
30ba 3a ce 30			ld a, (.dmark)  
30bd 32 9d fd			ld (debug_mark),a  
30c0 3a cf 30			ld a, (.dmark+1)  
30c3 32 9e fd			ld (debug_mark+1),a  
30c6 3a d0 30			ld a, (.dmark+2)  
30c9 32 9f fd			ld (debug_mark+2),a  
30cc 18 03			jr .pastdmark  
30ce ..			.dmark: db "LSu"  
30d1 f1			.pastdmark: pop af  
30d2			endm  
# End of macro DMARK
30d2					CALLMONITOR 
30d2 cd aa fd			call debug_vector  
30d5				endm  
# End of macro CALLMONITOR
30d5				endif 
30d5			 
30d5					; found a uword but is it the one we want... 
30d5			 
30d5 c5					push bc     ; uword to find is on bc 
30d6 d1					pop de 
30d7			 
30d7 e5					push hl  ; to save the ptr 
30d8			 
30d8					; skip opcode 
30d8 23					inc hl  
30d9					; skip next ptr 
30d9 23					inc hl  
30da 23					inc hl 
30db					; skip len 
30db 23					inc hl 
30dc			 
30dc				if DEBUG_FORTH_WORDS 
30dc					DMARK "LSc" 
30dc f5				push af  
30dd 3a f1 30			ld a, (.dmark)  
30e0 32 9d fd			ld (debug_mark),a  
30e3 3a f2 30			ld a, (.dmark+1)  
30e6 32 9e fd			ld (debug_mark+1),a  
30e9 3a f3 30			ld a, (.dmark+2)  
30ec 32 9f fd			ld (debug_mark+2),a  
30ef 18 03			jr .pastdmark  
30f1 ..			.dmark: db "LSc"  
30f4 f1			.pastdmark: pop af  
30f5			endm  
# End of macro DMARK
30f5					CALLMONITOR 
30f5 cd aa fd			call debug_vector  
30f8				endm  
# End of macro CALLMONITOR
30f8				endif 
30f8			; was exiting on the shorter of the words. swap and test is in favour of the longer word. 
30f8			; ie. If WOO is defined first and then WO. Couldnt list WO. 
30f8			; Nope that has gone the other way. It needs to be exact not on first zero 
30f8			;		call strcmp 
30f8 c5					push bc 
30f9 cd 48 13				call StrictStrCmp 
30fc c1					pop bc 
30fd c2 77 30				jp nz, .ldouscanm 
3100				 
3100			 
3100			 
3100					; we have a uword so push its name to the stack 
3100			 
3100			;	   	push hl  ; save so we can move to next dict block 
3100 e1			pop hl 
3101			 
3101				if DEBUG_FORTH_WORDS 
3101					DMARK "LSm" 
3101 f5				push af  
3102 3a 16 31			ld a, (.dmark)  
3105 32 9d fd			ld (debug_mark),a  
3108 3a 17 31			ld a, (.dmark+1)  
310b 32 9e fd			ld (debug_mark+1),a  
310e 3a 18 31			ld a, (.dmark+2)  
3111 32 9f fd			ld (debug_mark+2),a  
3114 18 03			jr .pastdmark  
3116 ..			.dmark: db "LSm"  
3119 f1			.pastdmark: pop af  
311a			endm  
# End of macro DMARK
311a					CALLMONITOR 
311a cd aa fd			call debug_vector  
311d				endm  
# End of macro CALLMONITOR
311d				endif 
311d			 
311d					; skip opcode 
311d 23					inc hl  
311e					; skip next ptr 
311e 23					inc hl  
311f 23					inc hl 
3120					; skip len 
3120 7e					ld a, (hl)   ; save length to add 
3121				if DEBUG_FORTH_WORDS 
3121					DMARK "LS2" 
3121 f5				push af  
3122 3a 36 31			ld a, (.dmark)  
3125 32 9d fd			ld (debug_mark),a  
3128 3a 37 31			ld a, (.dmark+1)  
312b 32 9e fd			ld (debug_mark+1),a  
312e 3a 38 31			ld a, (.dmark+2)  
3131 32 9f fd			ld (debug_mark+2),a  
3134 18 03			jr .pastdmark  
3136 ..			.dmark: db "LS2"  
3139 f1			.pastdmark: pop af  
313a			endm  
# End of macro DMARK
313a					CALLMONITOR 
313a cd aa fd			call debug_vector  
313d				endm  
# End of macro CALLMONITOR
313d				endif 
313d			 
313d					; save this location 
313d				 
313d e5					push hl 
313e			 
313e 23					inc hl 
313f 11 f5 f0				ld de, scratch+2 
3142 4f					ld c, a 
3143 06 00				ld b, 0 
3145			 
3145				if DEBUG_FORTH_WORDS 
3145					DMARK "LSn" 
3145 f5				push af  
3146 3a 5a 31			ld a, (.dmark)  
3149 32 9d fd			ld (debug_mark),a  
314c 3a 5b 31			ld a, (.dmark+1)  
314f 32 9e fd			ld (debug_mark+1),a  
3152 3a 5c 31			ld a, (.dmark+2)  
3155 32 9f fd			ld (debug_mark+2),a  
3158 18 03			jr .pastdmark  
315a ..			.dmark: db "LSn"  
315d f1			.pastdmark: pop af  
315e			endm  
# End of macro DMARK
315e					CALLMONITOR 
315e cd aa fd			call debug_vector  
3161				endm  
# End of macro CALLMONITOR
3161				endif 
3161			 
3161					; copy uword name to scratch 
3161			 
3161			;		ldir 
3161			.licplw:	; copy uword name to scratch converting to lower case as we go 
3161 ed a0				ldi 
3163 1b					dec de 
3164 1a					ld a, (de) 
3165 cd 1d 12				call to_lower 
3168 12					ld (de),a 
3169 13					inc de 
316a 3e 00				ld a, 0 
316c b9					cp c 
316d 20 f2				jr nz, .licplw 
316f			 
316f			 
316f			 
316f 1b					dec de 
3170 3e 20				ld a, ' '    ; change null to space 
3172 12					ld (de), a 
3173			 
3173 13					inc de 
3174			 
3174 d5					push de 
3175 c1					pop bc     ; move scratch pointer to end of word name and save it 
3176			 
3176 e1					pop hl 
3177 7e					ld a, (hl) 
3178					;inc hl 
3178					; skip word string 
3178 cd ac 0f				call addatohl 
317b			 
317b 23					inc hl 
317c			 
317c				if DEBUG_FORTH_WORDS 
317c					DMARK "LS3" 
317c f5				push af  
317d 3a 91 31			ld a, (.dmark)  
3180 32 9d fd			ld (debug_mark),a  
3183 3a 92 31			ld a, (.dmark+1)  
3186 32 9e fd			ld (debug_mark+1),a  
3189 3a 93 31			ld a, (.dmark+2)  
318c 32 9f fd			ld (debug_mark+2),a  
318f 18 03			jr .pastdmark  
3191 ..			.dmark: db "LS3"  
3194 f1			.pastdmark: pop af  
3195			endm  
# End of macro DMARK
3195					CALLMONITOR 
3195 cd aa fd			call debug_vector  
3198				endm  
# End of macro CALLMONITOR
3198				endif 
3198					; should now be at the start of the machine code to setup the eval of the uword 
3198					; now locate the ptr to the string defintion 
3198			 
3198					; skip ld hl, 
3198					; then load the ptr 
3198			; TODO use get from hl ptr 
3198 23					inc hl 
3199 5e					ld e, (hl) 
319a 23					inc hl 
319b 56					ld d, (hl) 
319c eb					ex de, hl 
319d			 
319d			 
319d				if DEBUG_FORTH_WORDS 
319d					DMARK "LSt" 
319d f5				push af  
319e 3a b2 31			ld a, (.dmark)  
31a1 32 9d fd			ld (debug_mark),a  
31a4 3a b3 31			ld a, (.dmark+1)  
31a7 32 9e fd			ld (debug_mark+1),a  
31aa 3a b4 31			ld a, (.dmark+2)  
31ad 32 9f fd			ld (debug_mark+2),a  
31b0 18 03			jr .pastdmark  
31b2 ..			.dmark: db "LSt"  
31b5 f1			.pastdmark: pop af  
31b6			endm  
# End of macro DMARK
31b6					CALLMONITOR 
31b6 cd aa fd			call debug_vector  
31b9				endm  
# End of macro CALLMONITOR
31b9				endif 
31b9			 
31b9			; cant push right now due to tokenised strings  
31b9			 
31b9			; get the destination of where to copy this definition to. 
31b9			 
31b9 c5					push bc 
31ba d1					pop de 
31bb			 
31bb 7e			.listl:         ld a,(hl) 
31bc			;		cp 0 
31bc b7					or a 
31bd 28 09				jr z, .lreplsp     ; replace zero with space 
31bf					;cp FORTH_END_BUFFER 
31bf fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
31c1 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
31c3				 
31c3					; just copy this char as is then 
31c3			 
31c3 12					ld (de), a 
31c4			 
31c4 23			.listnxt:	inc hl 
31c5 13					inc de 
31c6 18 f3				jr .listl 
31c8			 
31c8 3e 20		.lreplsp:	ld a,' ' 
31ca 12					ld (de), a 
31cb 18 f7				jr .listnxt 
31cd			 
31cd			; close up uword def 
31cd			 
31cd			.listdone: 
31cd 12					ld (de), a 
31ce 13					inc de 
31cf 3e 00				ld a, 0 
31d1 12					ld (de), a 
31d2			 
31d2			; now have def so clean up and push to stack 
31d2			 
31d2 21 f3 f0				ld hl, scratch 
31d5				if DEBUG_FORTH_WORDS 
31d5					DMARK "Ltp" 
31d5 f5				push af  
31d6 3a ea 31			ld a, (.dmark)  
31d9 32 9d fd			ld (debug_mark),a  
31dc 3a eb 31			ld a, (.dmark+1)  
31df 32 9e fd			ld (debug_mark+1),a  
31e2 3a ec 31			ld a, (.dmark+2)  
31e5 32 9f fd			ld (debug_mark+2),a  
31e8 18 03			jr .pastdmark  
31ea ..			.dmark: db "Ltp"  
31ed f1			.pastdmark: pop af  
31ee			endm  
# End of macro DMARK
31ee					CALLMONITOR 
31ee cd aa fd			call debug_vector  
31f1				endm  
# End of macro CALLMONITOR
31f1				endif 
31f1			 
31f1 18 22			jr .listpush 
31f3			 
31f3			;.lnuword:	pop hl 
31f3			;		call forth_tok_next 
31f3			;		jp .ldouscan  
31f3			 
31f3			.lunotfound:		  
31f3			 
31f3				if DEBUG_FORTH_WORDS 
31f3					DMARK "LSn" 
31f3 f5				push af  
31f4 3a 08 32			ld a, (.dmark)  
31f7 32 9d fd			ld (debug_mark),a  
31fa 3a 09 32			ld a, (.dmark+1)  
31fd 32 9e fd			ld (debug_mark+1),a  
3200 3a 0a 32			ld a, (.dmark+2)  
3203 32 9f fd			ld (debug_mark+2),a  
3206 18 03			jr .pastdmark  
3208 ..			.dmark: db "LSn"  
320b f1			.pastdmark: pop af  
320c			endm  
# End of macro DMARK
320c					CALLMONITOR 
320c cd aa fd			call debug_vector  
320f				endm  
# End of macro CALLMONITOR
320f				endif 
320f			 
320f					 
320f			;		FORTH_DSP_POP 
320f			;		ld hl, .luno 
320f			 
320f					NEXTW			 
320f cd a7 fd			call parse_vector 
3212 c3 e2 23			jp macro_next 
3215				endm 
# End of macro NEXTW
3215			 
3215			.listpush: 
3215				if DEBUG_FORTH_WORDS 
3215					DMARK "LS>" 
3215 f5				push af  
3216 3a 2a 32			ld a, (.dmark)  
3219 32 9d fd			ld (debug_mark),a  
321c 3a 2b 32			ld a, (.dmark+1)  
321f 32 9e fd			ld (debug_mark+1),a  
3222 3a 2c 32			ld a, (.dmark+2)  
3225 32 9f fd			ld (debug_mark+2),a  
3228 18 03			jr .pastdmark  
322a ..			.dmark: db "LS>"  
322d f1			.pastdmark: pop af  
322e			endm  
# End of macro DMARK
322e					CALLMONITOR 
322e cd aa fd			call debug_vector  
3231				endm  
# End of macro CALLMONITOR
3231				endif 
3231 cd 69 20				call forth_push_str 
3234			 
3234			 
3234			 
3234					NEXTW 
3234 cd a7 fd			call parse_vector 
3237 c3 e2 23			jp macro_next 
323a				endm 
# End of macro NEXTW
323a			 
323a			;.luno:    db "Word not found",0 
323a			 
323a			 
323a			 
323a			 
323a			 
323a			;		push hl   ; save pointer to start of uword def string 
323a			; 
323a			;; look for FORTH_EOL_LINE 
323a			;		ld a, FORTH_END_BUFFER 
323a			;		call strlent 
323a			; 
323a			;		inc hl		 ; space for coln def 
323a			;		inc hl 
323a			;		inc hl          ; space for terms 
323a			;		inc hl 
323a			; 
323a			;		ld a, 20   ; TODO get actual length 
323a			;		call addatohl    ; include a random amount of room for the uword name 
323a			; 
323a			;		 
323a			;	if DEBUG_FORTH_WORDS 
323a			;		DMARK "Lt1" 
323a			;		CALLMONITOR 
323a			;	endif 
323a			;		 
323a			; 
323a			;; malloc space for the string because we cant change it 
323a			; 
323a			;		call malloc 
323a			;	if DEBUG_FORTH_MALLOC_GUARD 
323a			;		push af 
323a			;		call ishlzero 
323a			;		pop af 
323a			;		 
323a			;		call z,malloc_error 
323a			;	endif 
323a			; 
323a			;	if DEBUG_FORTH_WORDS 
323a			;		DMARK "Lt2" 
323a			;		CALLMONITOR 
323a			;	endif 
323a			;		pop de 
323a			;		push hl    ; push the malloc to release later 
323a			;		push hl   ;  push back a copy for the later stack push 
323a			;		 
323a			;; copy the string swapping out the zero terms for spaces 
323a			; 
323a			;		; de has our source 
323a			;		; hl has our dest 
323a			; 
323a			;; add the coln def 
323a			; 
323a			;		ld a, ':' 
323a			;		ld (hl), a 
323a			;		inc hl 
323a			;		ld a, ' ' 
323a			;		ld (hl), a 
323a			;		inc hl 
323a			; 
323a			;; add the uname word 
323a			;		push de   ; save our string for now 
323a			;		ex de, hl 
323a			; 
323a			;		FORTH_DSP_VALUE 
323a			;		;v5 FORTH_DSP_VALUE 
323a			; 
323a			;		inc hl   ; skip type but we know by now this is OK 
323a			; 
323a			;.luword:	ld a,(hl) 
323a			;		cp 0 
323a			;		jr z, .luword2 
323a			;		ld (de), a 
323a			;		inc de 
323a			;		inc hl 
323a			;		jr .luword 
323a			; 
323a			;.luword2:	ld a, ' ' 
323a			;		ld (de), a 
323a			;;		inc hl 
323a			;;		inc de 
323a			;;		ld (de), a 
323a			;;		inc hl 
323a			;		inc de 
323a			; 
323a			;		ex de, hl 
323a			;		pop de 
323a			;		 
323a			;		 
323a			; 
323a			;; detoken that string and copy it 
323a			; 
323a			;	if DEBUG_FORTH_WORDS 
323a			;		DMARK "Lt2" 
323a			;		CALLMONITOR 
323a			;	endif 
323a			;.ldetok:	ld a, (de) 
323a			;		cp FORTH_END_BUFFER 
323a			;		jr z, .ldetokend 
323a			;		; swap out any zero term for space 
323a			;		cp 0 
323a			;		jr nz, .ldetoknext 
323a			;		ld a, ' ' 
323a			; 
323a			;	if DEBUG_FORTH_WORDS 
323a			;		DMARK "LtS" 
323a			;		CALLMONITOR 
323a			;	endif 
323a			;.ldetoknext:	ld (hl), a 
323a			;		inc de 
323a			;		inc hl 
323a			;		jr .ldetok 
323a			; 
323a			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
323a			;		ld (hl), a  
323a			; 
323a			;; free that temp malloc 
323a			; 
323a			;		pop hl    
323a			; 
323a			;	if DEBUG_FORTH_WORDS 
323a			;		DMARK "Lt4" 
323a			;		CALLMONITOR 
323a			;	endif 
323a			;		call forth_apushstrhl 
323a			; 
323a			;		; get rid of temp malloc area 
323a			; 
323a			;		pop hl 
323a			;		call free 
323a			; 
323a			;		jr .ludone 
323a			; 
323a			;.lnuword:	pop hl 
323a			;		call forth_tok_next 
323a			;		jp .ldouscan  
323a			; 
323a			;.ludone:		 pop hl 
323a			; 
323a					NEXTW 
323a cd a7 fd			call parse_vector 
323d c3 e2 23			jp macro_next 
3240				endm 
# End of macro NEXTW
3240			 
3240			.FORGET: 
3240				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
3240 5d				db WORD_SYS_CORE+73             
3241 bb 32			dw .NOP            
3243 07				db 6 + 1 
3244 .. 00			db "FORGET",0              
324b				endm 
# End of macro CWHEAD
324b			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
324b			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quoted uword name must be in caps. 
324b			; | |  
324b			; | | e.g. "MORE" forget 
324b					if DEBUG_FORTH_WORDS_KEY 
324b						DMARK "FRG" 
324b f5				push af  
324c 3a 60 32			ld a, (.dmark)  
324f 32 9d fd			ld (debug_mark),a  
3252 3a 61 32			ld a, (.dmark+1)  
3255 32 9e fd			ld (debug_mark+1),a  
3258 3a 62 32			ld a, (.dmark+2)  
325b 32 9f fd			ld (debug_mark+2),a  
325e 18 03			jr .pastdmark  
3260 ..			.dmark: db "FRG"  
3263 f1			.pastdmark: pop af  
3264			endm  
# End of macro DMARK
3264						CALLMONITOR 
3264 cd aa fd			call debug_vector  
3267				endm  
# End of macro CALLMONITOR
3267					endif 
3267			 
3267				; find uword 
3267			        ; update start of word with "_" 
3267				; replace uword with deleted flag 
3267			 
3267			 
3267			;	if DEBUG_FORTH_WORDS 
3267			;		DMARK "FOG" 
3267			;		CALLMONITOR 
3267			;	endif 
3267			 
3267			 
3267					; Get ptr to the word we need to look up 
3267			 
3267					FORTH_DSP_VALUEHL 
3267 cd fb 21			call macro_dsp_valuehl 
326a				endm 
# End of macro FORTH_DSP_VALUEHL
326a					;v5 FORTH_DSP_VALUE 
326a				; TODO type check 
326a			;		inc hl    ; Skip type check  
326a e5					push hl 
326b c1					pop bc 
326c			;		ex de, hl    ; put into DE 
326c			 
326c			 
326c 21 00 80				ld hl, baseram 
326f					;ld hl, baseusermem 
326f			 
326f				; skip dict stub 
326f			;	call forth_tok_next 
326f e5			push hl   ; sacreifical push 
3270			 
3270			.fldouscanm: 
3270 e1				pop hl 
3271			.fldouscan: 
3271			;	if DEBUG_FORTH_WORDS 
3271			;		DMARK "LSs" 
3271			;		CALLMONITOR 
3271			;	endif 
3271				; skip dict stub 
3271 cd 14 25				call forth_tok_next 
3274			 
3274			 
3274			; while we have words to look for 
3274			 
3274 7e				ld a, (hl)      
3275			;	if DEBUG_FORTH_WORDS 
3275			;		DMARK "LSk" 
3275			;		CALLMONITOR 
3275			;	endif 
3275 fe 00				cp WORD_SYS_END 
3277 ca b2 32				jp z, .flunotfound 
327a fe 01				cp WORD_SYS_UWORD 
327c c2 71 32				jp nz, .fldouscan 
327f			 
327f			;	if DEBUG_FORTH_WORDS 
327f			;		DMARK "LSu" 
327f			;		CALLMONITOR 
327f			;	endif 
327f			 
327f					; found a uword but is it the one we want... 
327f			 
327f c5					push bc     ; uword to find is on bc 
3280 d1					pop de 
3281			 
3281 e5					push hl  ; to save the ptr 
3282			 
3282					; skip opcode 
3282 23					inc hl  
3283					; skip next ptr 
3283 23					inc hl  
3284 23					inc hl 
3285					; skip len 
3285 23					inc hl 
3286			 
3286			;	if DEBUG_FORTH_WORDS 
3286			;		DMARK "LSc" 
3286			;		CALLMONITOR 
3286			;	endif 
3286 cd 3c 13				call strcmp 
3289 c2 70 32				jp nz, .fldouscanm 
328c			; 
328c			; 
328c			;; while we have words to look for 
328c			; 
328c			;.fdouscan:	ld a, (hl)      
328c			;	if DEBUG_FORTH_WORDS 
328c			;		DMARK "LSs" 
328c			;		CALLMONITOR 
328c			;	endif 
328c			;		cp WORD_SYS_END 
328c			;		jp z, .fudone 
328c			;		cp WORD_SYS_UWORD 
328c			;		jp nz, .fnuword 
328c			; 
328c			;	if DEBUG_FORTH_WORDS 
328c			;		DMARK "FGu" 
328c			;		CALLMONITOR 
328c			;	endif 
328c			; 
328c			;		; found a uword but is it the one we want... 
328c			; 
328c			; 
328c			;	        pop de   ; get back the dsp name 
328c			;		push de 
328c			; 
328c			;		push hl  ; to save the ptr 
328c			; 
328c			;		; skip opcode 
328c			;		inc hl  
328c			;		; skip next ptr 
328c			;		inc hl  
328c			;		inc hl 
328c			;		; skip len 
328c			;		inc hl 
328c			; 
328c			;	if DEBUG_FORTH_WORDS 
328c			;		DMARK "FGc" 
328c			;		CALLMONITOR 
328c			;	endif 
328c			;		call strcmp 
328c			;		jp nz, .fnuword 
328c			 
328c			 
328c e1			pop hl 
328d			 
328d				 
328d				if DEBUG_FORTH_WORDS 
328d					DMARK "FGm" 
328d f5				push af  
328e 3a a2 32			ld a, (.dmark)  
3291 32 9d fd			ld (debug_mark),a  
3294 3a a3 32			ld a, (.dmark+1)  
3297 32 9e fd			ld (debug_mark+1),a  
329a 3a a4 32			ld a, (.dmark+2)  
329d 32 9f fd			ld (debug_mark+2),a  
32a0 18 03			jr .pastdmark  
32a2 ..			.dmark: db "FGm"  
32a5 f1			.pastdmark: pop af  
32a6			endm  
# End of macro DMARK
32a6					CALLMONITOR 
32a6 cd aa fd			call debug_vector  
32a9				endm  
# End of macro CALLMONITOR
32a9				endif 
32a9			 
32a9			 
32a9			 
32a9					; we have a uword so push its name to the stack 
32a9			 
32a9			;	   	push hl  ; save so we can move to next dict block 
32a9			;pop hl 
32a9			 
32a9					; update opcode to deleted 
32a9			;		ld a, WORD_SYS_DELETED 
32a9 36 03				ld (hl), WORD_SYS_DELETED 
32ab			 
32ab 23					inc hl  
32ac					; skip next ptr 
32ac 23					inc hl  
32ad 23					inc hl 
32ae					; skip len 
32ae 23					inc hl 
32af			 
32af					; TODO change parser to skip deleted words but for now mark it out 
32af 3e 5f				ld a, "_" 
32b1 77					ld  (hl),a 
32b2			 
32b2			;		jr .fudone 
32b2			; 
32b2			;.fnuword:	pop hl 
32b2			;		call forth_tok_next 
32b2			;		jp .fdouscan  
32b2			 
32b2			.flunotfound:		  
32b2			 
32b2			 
32b2					 
32b2					FORTH_DSP_POP 
32b2 cd b3 22			call macro_forth_dsp_pop 
32b5				endm 
# End of macro FORTH_DSP_POP
32b5			;		ld hl, .luno 
32b5			;.fudone:		 pop hl 
32b5					NEXTW 
32b5 cd a7 fd			call parse_vector 
32b8 c3 e2 23			jp macro_next 
32bb				endm 
# End of macro NEXTW
32bb			.NOP: 
32bb				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
32bb 61				db WORD_SYS_CORE+77             
32bc e5 32			dw .COMO            
32be 04				db 3 + 1 
32bf .. 00			db "NOP",0              
32c3				endm 
# End of macro CWHEAD
32c3			; | NOP (  --  ) Do nothing | DONE 
32c3					if DEBUG_FORTH_WORDS_KEY 
32c3						DMARK "NOP" 
32c3 f5				push af  
32c4 3a d8 32			ld a, (.dmark)  
32c7 32 9d fd			ld (debug_mark),a  
32ca 3a d9 32			ld a, (.dmark+1)  
32cd 32 9e fd			ld (debug_mark+1),a  
32d0 3a da 32			ld a, (.dmark+2)  
32d3 32 9f fd			ld (debug_mark+2),a  
32d6 18 03			jr .pastdmark  
32d8 ..			.dmark: db "NOP"  
32db f1			.pastdmark: pop af  
32dc			endm  
# End of macro DMARK
32dc						CALLMONITOR 
32dc cd aa fd			call debug_vector  
32df				endm  
# End of macro CALLMONITOR
32df					endif 
32df				       NEXTW 
32df cd a7 fd			call parse_vector 
32e2 c3 e2 23			jp macro_next 
32e5				endm 
# End of macro NEXTW
32e5			.COMO: 
32e5				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
32e5 6e				db WORD_SYS_CORE+90             
32e6 3a 33			dw .COMC            
32e8 02				db 1 + 1 
32e9 .. 00			db "(",0              
32eb				endm 
# End of macro CWHEAD
32eb			; | ( ( -- )  Start of comment | DONE 
32eb			 
32eb			 
32eb 2a f4 f3				ld hl, ( os_tok_ptr) 
32ee 11 32 33			ld de, .closepar 
32f1					 
32f1					if DEBUG_FORTH_WORDS 
32f1						DMARK ").." 
32f1 f5				push af  
32f2 3a 06 33			ld a, (.dmark)  
32f5 32 9d fd			ld (debug_mark),a  
32f8 3a 07 33			ld a, (.dmark+1)  
32fb 32 9e fd			ld (debug_mark+1),a  
32fe 3a 08 33			ld a, (.dmark+2)  
3301 32 9f fd			ld (debug_mark+2),a  
3304 18 03			jr .pastdmark  
3306 ..			.dmark: db ").."  
3309 f1			.pastdmark: pop af  
330a			endm  
# End of macro DMARK
330a						CALLMONITOR 
330a cd aa fd			call debug_vector  
330d				endm  
# End of macro CALLMONITOR
330d					endif 
330d cd df 24			call findnexttok  
3310			 
3310					if DEBUG_FORTH_WORDS 
3310						DMARK "IF5" 
3310 f5				push af  
3311 3a 25 33			ld a, (.dmark)  
3314 32 9d fd			ld (debug_mark),a  
3317 3a 26 33			ld a, (.dmark+1)  
331a 32 9e fd			ld (debug_mark+1),a  
331d 3a 27 33			ld a, (.dmark+2)  
3320 32 9f fd			ld (debug_mark+2),a  
3323 18 03			jr .pastdmark  
3325 ..			.dmark: db "IF5"  
3328 f1			.pastdmark: pop af  
3329			endm  
# End of macro DMARK
3329						CALLMONITOR 
3329 cd aa fd			call debug_vector  
332c				endm  
# End of macro CALLMONITOR
332c					endif 
332c				; replace below with ) exec using tok_ptr 
332c 22 f4 f3			ld (os_tok_ptr), hl 
332f c3 63 24			jp exec1 
3332			 
3332 .. 00			.closepar:   db ")",0 
3334			 
3334				       NEXTW 
3334 cd a7 fd			call parse_vector 
3337 c3 e2 23			jp macro_next 
333a				endm 
# End of macro NEXTW
333a			.COMC: 
333a				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
333a 6f				db WORD_SYS_CORE+91             
333b 46 33			dw .SCRATCH            
333d 02				db 1 + 1 
333e .. 00			db ")",0              
3340				endm 
# End of macro CWHEAD
3340			; | ) ( -- )  End of comment |  DONE  
3340				       NEXTW 
3340 cd a7 fd			call parse_vector 
3343 c3 e2 23			jp macro_next 
3346				endm 
# End of macro NEXTW
3346			 
3346			.SCRATCH: 
3346				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
3346 6f				db WORD_SYS_CORE+91             
3347 84 33			dw .INC            
3349 08				db 7 + 1 
334a .. 00			db "SCRATCH",0              
3352				endm 
# End of macro CWHEAD
3352			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
3352			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
3352			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
3352			; | |  
3352			; | | e.g.    : score $00 scratch ; 
3352			; | |  
3352			; | | $00 score ! 
3352			; | | $01 score +! 
3352			; | |  
3352			; | | e.g.   : varword $0a scratch ;  
3352			; | | 
3352			; | | $8000 varword ! 
3352					if DEBUG_FORTH_WORDS_KEY 
3352						DMARK "SCR" 
3352 f5				push af  
3353 3a 67 33			ld a, (.dmark)  
3356 32 9d fd			ld (debug_mark),a  
3359 3a 68 33			ld a, (.dmark+1)  
335c 32 9e fd			ld (debug_mark+1),a  
335f 3a 69 33			ld a, (.dmark+2)  
3362 32 9f fd			ld (debug_mark+2),a  
3365 18 03			jr .pastdmark  
3367 ..			.dmark: db "SCR"  
336a f1			.pastdmark: pop af  
336b			endm  
# End of macro DMARK
336b						CALLMONITOR 
336b cd aa fd			call debug_vector  
336e				endm  
# End of macro CALLMONITOR
336e					endif 
336e			 
336e					FORTH_DSP_VALUEHL 
336e cd fb 21			call macro_dsp_valuehl 
3371				endm 
# End of macro FORTH_DSP_VALUEHL
3371				 
3371					FORTH_DSP_POP 
3371 cd b3 22			call macro_forth_dsp_pop 
3374				endm 
# End of macro FORTH_DSP_POP
3374			 
3374 7d					ld a, l 
3375 21 18 f6				ld hl, os_var_array 
3378 cd ac 0f				call addatohl 
337b			 
337b cd ff 1f				call forth_push_numhl 
337e			 
337e				       NEXTW 
337e cd a7 fd			call parse_vector 
3381 c3 e2 23			jp macro_next 
3384				endm 
# End of macro NEXTW
3384			 
3384			.INC: 
3384				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
3384 6f				db WORD_SYS_CORE+91             
3385 dd 33			dw .DEC            
3387 03				db 2 + 1 
3388 .. 00			db "+!",0              
338b				endm 
# End of macro CWHEAD
338b			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
338b					if DEBUG_FORTH_WORDS_KEY 
338b						DMARK "+s_" 
338b f5				push af  
338c 3a a0 33			ld a, (.dmark)  
338f 32 9d fd			ld (debug_mark),a  
3392 3a a1 33			ld a, (.dmark+1)  
3395 32 9e fd			ld (debug_mark+1),a  
3398 3a a2 33			ld a, (.dmark+2)  
339b 32 9f fd			ld (debug_mark+2),a  
339e 18 03			jr .pastdmark  
33a0 ..			.dmark: db "+s_"  
33a3 f1			.pastdmark: pop af  
33a4			endm  
# End of macro DMARK
33a4						CALLMONITOR 
33a4 cd aa fd			call debug_vector  
33a7				endm  
# End of macro CALLMONITOR
33a7					endif 
33a7			 
33a7					FORTH_DSP_VALUEHL 
33a7 cd fb 21			call macro_dsp_valuehl 
33aa				endm 
# End of macro FORTH_DSP_VALUEHL
33aa			 
33aa e5					push hl   ; save address 
33ab			 
33ab					FORTH_DSP_POP 
33ab cd b3 22			call macro_forth_dsp_pop 
33ae				endm 
# End of macro FORTH_DSP_POP
33ae			 
33ae					FORTH_DSP_VALUEHL 
33ae cd fb 21			call macro_dsp_valuehl 
33b1				endm 
# End of macro FORTH_DSP_VALUEHL
33b1			 
33b1 e5					push hl 
33b2					FORTH_DSP_POP 
33b2 cd b3 22			call macro_forth_dsp_pop 
33b5				endm 
# End of macro FORTH_DSP_POP
33b5 e1					pop hl 
33b6			 
33b6					; hl contains value to add to byte at a 
33b6				 
33b6 eb					ex de, hl 
33b7			 
33b7 e1					pop hl 
33b8			 
33b8					if DEBUG_FORTH_WORDS 
33b8						DMARK "INC" 
33b8 f5				push af  
33b9 3a cd 33			ld a, (.dmark)  
33bc 32 9d fd			ld (debug_mark),a  
33bf 3a ce 33			ld a, (.dmark+1)  
33c2 32 9e fd			ld (debug_mark+1),a  
33c5 3a cf 33			ld a, (.dmark+2)  
33c8 32 9f fd			ld (debug_mark+2),a  
33cb 18 03			jr .pastdmark  
33cd ..			.dmark: db "INC"  
33d0 f1			.pastdmark: pop af  
33d1			endm  
# End of macro DMARK
33d1						CALLMONITOR 
33d1 cd aa fd			call debug_vector  
33d4				endm  
# End of macro CALLMONITOR
33d4					endif 
33d4			 
33d4 7e					ld a,(hl) 
33d5 83					add e 
33d6 77					ld (hl),a 
33d7			 
33d7			 
33d7			 
33d7				       NEXTW 
33d7 cd a7 fd			call parse_vector 
33da c3 e2 23			jp macro_next 
33dd				endm 
# End of macro NEXTW
33dd			 
33dd			.DEC: 
33dd				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
33dd 6f				db WORD_SYS_CORE+91             
33de 34 34			dw .INC2            
33e0 03				db 2 + 1 
33e1 .. 00			db "-!",0              
33e4				endm 
# End of macro CWHEAD
33e4			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
33e4					if DEBUG_FORTH_WORDS_KEY 
33e4						DMARK "-s_" 
33e4 f5				push af  
33e5 3a f9 33			ld a, (.dmark)  
33e8 32 9d fd			ld (debug_mark),a  
33eb 3a fa 33			ld a, (.dmark+1)  
33ee 32 9e fd			ld (debug_mark+1),a  
33f1 3a fb 33			ld a, (.dmark+2)  
33f4 32 9f fd			ld (debug_mark+2),a  
33f7 18 03			jr .pastdmark  
33f9 ..			.dmark: db "-s_"  
33fc f1			.pastdmark: pop af  
33fd			endm  
# End of macro DMARK
33fd						CALLMONITOR 
33fd cd aa fd			call debug_vector  
3400				endm  
# End of macro CALLMONITOR
3400					endif 
3400			 
3400					FORTH_DSP_VALUEHL 
3400 cd fb 21			call macro_dsp_valuehl 
3403				endm 
# End of macro FORTH_DSP_VALUEHL
3403			 
3403 e5					push hl   ; save address 
3404			 
3404					FORTH_DSP_POP 
3404 cd b3 22			call macro_forth_dsp_pop 
3407				endm 
# End of macro FORTH_DSP_POP
3407			 
3407					FORTH_DSP_VALUEHL 
3407 cd fb 21			call macro_dsp_valuehl 
340a				endm 
# End of macro FORTH_DSP_VALUEHL
340a			 
340a					; hl contains value to add to byte at a 
340a				 
340a eb					ex de, hl 
340b			 
340b e1					pop hl 
340c			 
340c					if DEBUG_FORTH_WORDS 
340c						DMARK "DEC" 
340c f5				push af  
340d 3a 21 34			ld a, (.dmark)  
3410 32 9d fd			ld (debug_mark),a  
3413 3a 22 34			ld a, (.dmark+1)  
3416 32 9e fd			ld (debug_mark+1),a  
3419 3a 23 34			ld a, (.dmark+2)  
341c 32 9f fd			ld (debug_mark+2),a  
341f 18 03			jr .pastdmark  
3421 ..			.dmark: db "DEC"  
3424 f1			.pastdmark: pop af  
3425			endm  
# End of macro DMARK
3425						CALLMONITOR 
3425 cd aa fd			call debug_vector  
3428				endm  
# End of macro CALLMONITOR
3428					endif 
3428			 
3428 7e					ld a,(hl) 
3429 93					sub e 
342a 77					ld (hl),a 
342b			 
342b			 
342b					FORTH_DSP_POP 
342b cd b3 22			call macro_forth_dsp_pop 
342e				endm 
# End of macro FORTH_DSP_POP
342e			 
342e				       NEXTW 
342e cd a7 fd			call parse_vector 
3431 c3 e2 23			jp macro_next 
3434				endm 
# End of macro NEXTW
3434			 
3434			.INC2: 
3434				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
3434 6f				db WORD_SYS_CORE+91             
3435 e4 34			dw .DEC2            
3437 04				db 3 + 1 
3438 .. 00			db "+2!",0              
343c				endm 
# End of macro CWHEAD
343c			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
343c			 
343c					if DEBUG_FORTH_WORDS_KEY 
343c						DMARK "+2s" 
343c f5				push af  
343d 3a 51 34			ld a, (.dmark)  
3440 32 9d fd			ld (debug_mark),a  
3443 3a 52 34			ld a, (.dmark+1)  
3446 32 9e fd			ld (debug_mark+1),a  
3449 3a 53 34			ld a, (.dmark+2)  
344c 32 9f fd			ld (debug_mark+2),a  
344f 18 03			jr .pastdmark  
3451 ..			.dmark: db "+2s"  
3454 f1			.pastdmark: pop af  
3455			endm  
# End of macro DMARK
3455						CALLMONITOR 
3455 cd aa fd			call debug_vector  
3458				endm  
# End of macro CALLMONITOR
3458					endif 
3458			 
3458					; Address 
3458			 
3458					FORTH_DSP_VALUEHL 
3458 cd fb 21			call macro_dsp_valuehl 
345b				endm 
# End of macro FORTH_DSP_VALUEHL
345b			 
345b e5					push hl    ; save address 
345c			 
345c					; load content into de 
345c			 
345c 5e					ld e,(hl) 
345d 23					inc hl 
345e 56					ld d, (hl) 
345f			 
345f					if DEBUG_FORTH_WORDS 
345f						DMARK "+2a" 
345f f5				push af  
3460 3a 74 34			ld a, (.dmark)  
3463 32 9d fd			ld (debug_mark),a  
3466 3a 75 34			ld a, (.dmark+1)  
3469 32 9e fd			ld (debug_mark+1),a  
346c 3a 76 34			ld a, (.dmark+2)  
346f 32 9f fd			ld (debug_mark+2),a  
3472 18 03			jr .pastdmark  
3474 ..			.dmark: db "+2a"  
3477 f1			.pastdmark: pop af  
3478			endm  
# End of macro DMARK
3478						CALLMONITOR 
3478 cd aa fd			call debug_vector  
347b				endm  
# End of macro CALLMONITOR
347b					endif 
347b			 
347b					FORTH_DSP_POP 
347b cd b3 22			call macro_forth_dsp_pop 
347e				endm 
# End of macro FORTH_DSP_POP
347e			 
347e					; Get value to add 
347e			 
347e					FORTH_DSP_VALUE 
347e cd e4 21			call macro_forth_dsp_value 
3481				endm 
# End of macro FORTH_DSP_VALUE
3481			 
3481					if DEBUG_FORTH_WORDS 
3481						DMARK "+2v" 
3481 f5				push af  
3482 3a 96 34			ld a, (.dmark)  
3485 32 9d fd			ld (debug_mark),a  
3488 3a 97 34			ld a, (.dmark+1)  
348b 32 9e fd			ld (debug_mark+1),a  
348e 3a 98 34			ld a, (.dmark+2)  
3491 32 9f fd			ld (debug_mark+2),a  
3494 18 03			jr .pastdmark  
3496 ..			.dmark: db "+2v"  
3499 f1			.pastdmark: pop af  
349a			endm  
# End of macro DMARK
349a						CALLMONITOR 
349a cd aa fd			call debug_vector  
349d				endm  
# End of macro CALLMONITOR
349d					endif 
349d			 
349d 19					add hl, de 
349e			 
349e					if DEBUG_FORTH_WORDS 
349e						DMARK "+2+" 
349e f5				push af  
349f 3a b3 34			ld a, (.dmark)  
34a2 32 9d fd			ld (debug_mark),a  
34a5 3a b4 34			ld a, (.dmark+1)  
34a8 32 9e fd			ld (debug_mark+1),a  
34ab 3a b5 34			ld a, (.dmark+2)  
34ae 32 9f fd			ld (debug_mark+2),a  
34b1 18 03			jr .pastdmark  
34b3 ..			.dmark: db "+2+"  
34b6 f1			.pastdmark: pop af  
34b7			endm  
# End of macro DMARK
34b7						CALLMONITOR 
34b7 cd aa fd			call debug_vector  
34ba				endm  
# End of macro CALLMONITOR
34ba					endif 
34ba			 
34ba					; move result to de 
34ba			 
34ba eb					ex de, hl 
34bb			 
34bb					; Address 
34bb			 
34bb e1					pop hl 
34bc			 
34bc					; save it back 
34bc			 
34bc 73					ld (hl), e 
34bd 23					inc hl 
34be 72					ld (hl), d 
34bf			 
34bf					if DEBUG_FORTH_WORDS 
34bf						DMARK "+2e" 
34bf f5				push af  
34c0 3a d4 34			ld a, (.dmark)  
34c3 32 9d fd			ld (debug_mark),a  
34c6 3a d5 34			ld a, (.dmark+1)  
34c9 32 9e fd			ld (debug_mark+1),a  
34cc 3a d6 34			ld a, (.dmark+2)  
34cf 32 9f fd			ld (debug_mark+2),a  
34d2 18 03			jr .pastdmark  
34d4 ..			.dmark: db "+2e"  
34d7 f1			.pastdmark: pop af  
34d8			endm  
# End of macro DMARK
34d8						CALLMONITOR 
34d8 cd aa fd			call debug_vector  
34db				endm  
# End of macro CALLMONITOR
34db					endif 
34db			 
34db			 
34db			 
34db					FORTH_DSP_POP 
34db cd b3 22			call macro_forth_dsp_pop 
34de				endm 
# End of macro FORTH_DSP_POP
34de			 
34de			 
34de				       NEXTW 
34de cd a7 fd			call parse_vector 
34e1 c3 e2 23			jp macro_next 
34e4				endm 
# End of macro NEXTW
34e4			 
34e4			.DEC2: 
34e4				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
34e4 6f				db WORD_SYS_CORE+91             
34e5 96 35			dw .GET2            
34e7 04				db 3 + 1 
34e8 .. 00			db "-2!",0              
34ec				endm 
# End of macro CWHEAD
34ec			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
34ec			 
34ec			 
34ec					if DEBUG_FORTH_WORDS_KEY 
34ec						DMARK "-2s" 
34ec f5				push af  
34ed 3a 01 35			ld a, (.dmark)  
34f0 32 9d fd			ld (debug_mark),a  
34f3 3a 02 35			ld a, (.dmark+1)  
34f6 32 9e fd			ld (debug_mark+1),a  
34f9 3a 03 35			ld a, (.dmark+2)  
34fc 32 9f fd			ld (debug_mark+2),a  
34ff 18 03			jr .pastdmark  
3501 ..			.dmark: db "-2s"  
3504 f1			.pastdmark: pop af  
3505			endm  
# End of macro DMARK
3505						CALLMONITOR 
3505 cd aa fd			call debug_vector  
3508				endm  
# End of macro CALLMONITOR
3508					endif 
3508			 
3508					; Address 
3508			 
3508					FORTH_DSP_VALUEHL 
3508 cd fb 21			call macro_dsp_valuehl 
350b				endm 
# End of macro FORTH_DSP_VALUEHL
350b			 
350b e5					push hl    ; save address 
350c			 
350c					; load content into de 
350c			 
350c 5e					ld e,(hl) 
350d 23					inc hl 
350e 56					ld d, (hl) 
350f			 
350f					if DEBUG_FORTH_WORDS 
350f						DMARK "-2a" 
350f f5				push af  
3510 3a 24 35			ld a, (.dmark)  
3513 32 9d fd			ld (debug_mark),a  
3516 3a 25 35			ld a, (.dmark+1)  
3519 32 9e fd			ld (debug_mark+1),a  
351c 3a 26 35			ld a, (.dmark+2)  
351f 32 9f fd			ld (debug_mark+2),a  
3522 18 03			jr .pastdmark  
3524 ..			.dmark: db "-2a"  
3527 f1			.pastdmark: pop af  
3528			endm  
# End of macro DMARK
3528						CALLMONITOR 
3528 cd aa fd			call debug_vector  
352b				endm  
# End of macro CALLMONITOR
352b					endif 
352b			 
352b					FORTH_DSP_POP 
352b cd b3 22			call macro_forth_dsp_pop 
352e				endm 
# End of macro FORTH_DSP_POP
352e			 
352e					; Get value to remove 
352e			 
352e					FORTH_DSP_VALUE 
352e cd e4 21			call macro_forth_dsp_value 
3531				endm 
# End of macro FORTH_DSP_VALUE
3531			 
3531					if DEBUG_FORTH_WORDS 
3531						DMARK "-2v" 
3531 f5				push af  
3532 3a 46 35			ld a, (.dmark)  
3535 32 9d fd			ld (debug_mark),a  
3538 3a 47 35			ld a, (.dmark+1)  
353b 32 9e fd			ld (debug_mark+1),a  
353e 3a 48 35			ld a, (.dmark+2)  
3541 32 9f fd			ld (debug_mark+2),a  
3544 18 03			jr .pastdmark  
3546 ..			.dmark: db "-2v"  
3549 f1			.pastdmark: pop af  
354a			endm  
# End of macro DMARK
354a						CALLMONITOR 
354a cd aa fd			call debug_vector  
354d				endm  
# End of macro CALLMONITOR
354d					endif 
354d			 
354d eb					ex de, hl 
354e ed 52				sbc hl, de 
3550			 
3550					if DEBUG_FORTH_WORDS 
3550						DMARK "-2d" 
3550 f5				push af  
3551 3a 65 35			ld a, (.dmark)  
3554 32 9d fd			ld (debug_mark),a  
3557 3a 66 35			ld a, (.dmark+1)  
355a 32 9e fd			ld (debug_mark+1),a  
355d 3a 67 35			ld a, (.dmark+2)  
3560 32 9f fd			ld (debug_mark+2),a  
3563 18 03			jr .pastdmark  
3565 ..			.dmark: db "-2d"  
3568 f1			.pastdmark: pop af  
3569			endm  
# End of macro DMARK
3569						CALLMONITOR 
3569 cd aa fd			call debug_vector  
356c				endm  
# End of macro CALLMONITOR
356c					endif 
356c			 
356c					; move result to de 
356c			 
356c eb					ex de, hl 
356d			 
356d					; Address 
356d			 
356d e1					pop hl 
356e			 
356e					; save it back 
356e			 
356e 73					ld (hl), e 
356f 23					inc hl 
3570 72					ld (hl), d 
3571			 
3571					if DEBUG_FORTH_WORDS 
3571						DMARK "-2e" 
3571 f5				push af  
3572 3a 86 35			ld a, (.dmark)  
3575 32 9d fd			ld (debug_mark),a  
3578 3a 87 35			ld a, (.dmark+1)  
357b 32 9e fd			ld (debug_mark+1),a  
357e 3a 88 35			ld a, (.dmark+2)  
3581 32 9f fd			ld (debug_mark+2),a  
3584 18 03			jr .pastdmark  
3586 ..			.dmark: db "-2e"  
3589 f1			.pastdmark: pop af  
358a			endm  
# End of macro DMARK
358a						CALLMONITOR 
358a cd aa fd			call debug_vector  
358d				endm  
# End of macro CALLMONITOR
358d					endif 
358d			 
358d			 
358d					FORTH_DSP_POP 
358d cd b3 22			call macro_forth_dsp_pop 
3590				endm 
# End of macro FORTH_DSP_POP
3590			 
3590			 
3590			 
3590				       NEXTW 
3590 cd a7 fd			call parse_vector 
3593 c3 e2 23			jp macro_next 
3596				endm 
# End of macro NEXTW
3596			.GET2: 
3596				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
3596 6f				db WORD_SYS_CORE+91             
3597 ce 35			dw .BANG2            
3599 03				db 2 + 1 
359a .. 00			db "2@",0              
359d				endm 
# End of macro CWHEAD
359d			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
359d					if DEBUG_FORTH_WORDS_KEY 
359d						DMARK "2A_" 
359d f5				push af  
359e 3a b2 35			ld a, (.dmark)  
35a1 32 9d fd			ld (debug_mark),a  
35a4 3a b3 35			ld a, (.dmark+1)  
35a7 32 9e fd			ld (debug_mark+1),a  
35aa 3a b4 35			ld a, (.dmark+2)  
35ad 32 9f fd			ld (debug_mark+2),a  
35b0 18 03			jr .pastdmark  
35b2 ..			.dmark: db "2A_"  
35b5 f1			.pastdmark: pop af  
35b6			endm  
# End of macro DMARK
35b6						CALLMONITOR 
35b6 cd aa fd			call debug_vector  
35b9				endm  
# End of macro CALLMONITOR
35b9					endif 
35b9			 
35b9					FORTH_DSP_VALUEHL 
35b9 cd fb 21			call macro_dsp_valuehl 
35bc				endm 
# End of macro FORTH_DSP_VALUEHL
35bc			 
35bc e5					push hl   ; save address 
35bd			 
35bd					FORTH_DSP_POP 
35bd cd b3 22			call macro_forth_dsp_pop 
35c0				endm 
# End of macro FORTH_DSP_POP
35c0			 
35c0 e1					pop hl 
35c1			 
35c1 5e					ld e, (hl) 
35c2 23					inc hl 
35c3 56					ld d, (hl) 
35c4			 
35c4 eb					ex de, hl 
35c5			 
35c5 cd ff 1f				call forth_push_numhl 
35c8			 
35c8				       NEXTW 
35c8 cd a7 fd			call parse_vector 
35cb c3 e2 23			jp macro_next 
35ce				endm 
# End of macro NEXTW
35ce			.BANG2: 
35ce				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
35ce 6f				db WORD_SYS_CORE+91             
35cf 09 36			dw .CONFIG            
35d1 03				db 2 + 1 
35d2 .. 00			db "2!",0              
35d5				endm 
# End of macro CWHEAD
35d5			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
35d5					if DEBUG_FORTH_WORDS_KEY 
35d5						DMARK "2S_" 
35d5 f5				push af  
35d6 3a ea 35			ld a, (.dmark)  
35d9 32 9d fd			ld (debug_mark),a  
35dc 3a eb 35			ld a, (.dmark+1)  
35df 32 9e fd			ld (debug_mark+1),a  
35e2 3a ec 35			ld a, (.dmark+2)  
35e5 32 9f fd			ld (debug_mark+2),a  
35e8 18 03			jr .pastdmark  
35ea ..			.dmark: db "2S_"  
35ed f1			.pastdmark: pop af  
35ee			endm  
# End of macro DMARK
35ee						CALLMONITOR 
35ee cd aa fd			call debug_vector  
35f1				endm  
# End of macro CALLMONITOR
35f1					endif 
35f1			 
35f1					FORTH_DSP_VALUEHL 
35f1 cd fb 21			call macro_dsp_valuehl 
35f4				endm 
# End of macro FORTH_DSP_VALUEHL
35f4			 
35f4 e5					push hl   ; save address 
35f5			 
35f5			 
35f5					FORTH_DSP_POP 
35f5 cd b3 22			call macro_forth_dsp_pop 
35f8				endm 
# End of macro FORTH_DSP_POP
35f8			 
35f8					 
35f8					FORTH_DSP_VALUEHL 
35f8 cd fb 21			call macro_dsp_valuehl 
35fb				endm 
# End of macro FORTH_DSP_VALUEHL
35fb			 
35fb					FORTH_DSP_POP 
35fb cd b3 22			call macro_forth_dsp_pop 
35fe				endm 
# End of macro FORTH_DSP_POP
35fe			 
35fe eb					ex de, hl    ; value now in de 
35ff			 
35ff e1					pop hl 
3600			 
3600 73					ld (hl), e 
3601			 
3601 23					inc hl 
3602			 
3602 72					ld (hl), d 
3603			 
3603			 
3603				       NEXTW 
3603 cd a7 fd			call parse_vector 
3606 c3 e2 23			jp macro_next 
3609				endm 
# End of macro NEXTW
3609			.CONFIG: 
3609				CWHEAD .ADTOS 91 "CONFIG" 6 WORD_FLAG_CODE 
3609 6f				db WORD_SYS_CORE+91             
360a 1d 36			dw .ADTOS            
360c 07				db 6 + 1 
360d .. 00			db "CONFIG",0              
3614				endm 
# End of macro CWHEAD
3614			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
3614			 
3614 cd 11 15				call config 
3617					NEXTW 
3617 cd a7 fd			call parse_vector 
361a c3 e2 23			jp macro_next 
361d				endm 
# End of macro NEXTW
361d			 
361d			.ADTOS: 
361d				CWHEAD .SBTOS 91 "1+" 2 WORD_FLAG_CODE 
361d 6f				db WORD_SYS_CORE+91             
361e 36 36			dw .SBTOS            
3620 03				db 2 + 1 
3621 .. 00			db "1+",0              
3624				endm 
# End of macro CWHEAD
3624			; | 1+ ( u -- u )  Increment value on TOS | DONE 
3624			 
3624					FORTH_DSP_VALUEHL 
3624 cd fb 21			call macro_dsp_valuehl 
3627				endm 
# End of macro FORTH_DSP_VALUEHL
3627 e5					push hl 
3628			 
3628					FORTH_DSP_POP 
3628 cd b3 22			call macro_forth_dsp_pop 
362b				endm 
# End of macro FORTH_DSP_POP
362b e1					pop hl 
362c			 
362c 23					inc hl 
362d cd ff 1f				call forth_push_numhl 
3630					 
3630					NEXTW 
3630 cd a7 fd			call parse_vector 
3633 c3 e2 23			jp macro_next 
3636				endm 
# End of macro NEXTW
3636			.SBTOS: 
3636				CWHEAD .ADSTORE 91 "1-" 2 WORD_FLAG_CODE 
3636 6f				db WORD_SYS_CORE+91             
3637 4f 36			dw .ADSTORE            
3639 03				db 2 + 1 
363a .. 00			db "1-",0              
363d				endm 
# End of macro CWHEAD
363d			; | 1- ( u -- u )  Decrement value on TOS | DONE 
363d			 
363d					FORTH_DSP_VALUEHL 
363d cd fb 21			call macro_dsp_valuehl 
3640				endm 
# End of macro FORTH_DSP_VALUEHL
3640 e5					push hl 
3641			 
3641					FORTH_DSP_POP 
3641 cd b3 22			call macro_forth_dsp_pop 
3644				endm 
# End of macro FORTH_DSP_POP
3644 e1					pop hl 
3645			 
3645 2b					dec hl 
3646 cd ff 1f				call forth_push_numhl 
3649					 
3649					NEXTW 
3649 cd a7 fd			call parse_vector 
364c c3 e2 23			jp macro_next 
364f				endm 
# End of macro NEXTW
364f			.ADSTORE: 
364f				CWHEAD .ADWSTORE 91 "1+!" 3 WORD_FLAG_CODE 
364f 6f				db WORD_SYS_CORE+91             
3650 68 36			dw .ADWSTORE            
3652 04				db 3 + 1 
3653 .. 00			db "1+!",0              
3657				endm 
# End of macro CWHEAD
3657			; | 1+! ( addr -- )  Increment byte at address addr | DONE 
3657			 
3657					FORTH_DSP_VALUEHL 
3657 cd fb 21			call macro_dsp_valuehl 
365a				endm 
# End of macro FORTH_DSP_VALUEHL
365a e5					push hl 
365b			 
365b					FORTH_DSP_POP 
365b cd b3 22			call macro_forth_dsp_pop 
365e				endm 
# End of macro FORTH_DSP_POP
365e e1					pop hl 
365f			 
365f 7e					ld a, (hl) 
3660 3c					inc a 
3661 77					ld (hl), a 
3662					 
3662					NEXTW 
3662 cd a7 fd			call parse_vector 
3665 c3 e2 23			jp macro_next 
3668				endm 
# End of macro NEXTW
3668			.ADWSTORE: 
3668				CWHEAD .SBSTORE 91 "1+2!" 4 WORD_FLAG_CODE 
3668 6f				db WORD_SYS_CORE+91             
3669 89 36			dw .SBSTORE            
366b 05				db 4 + 1 
366c .. 00			db "1+2!",0              
3671				endm 
# End of macro CWHEAD
3671			; | 1+2! ( addr -- )  Increment word at address addr | DONE 
3671			 
3671					FORTH_DSP_VALUEHL 
3671 cd fb 21			call macro_dsp_valuehl 
3674				endm 
# End of macro FORTH_DSP_VALUEHL
3674 e5					push hl 
3675			 
3675					FORTH_DSP_POP 
3675 cd b3 22			call macro_forth_dsp_pop 
3678				endm 
# End of macro FORTH_DSP_POP
3678 e1					pop hl 
3679			 
3679 e5					push hl 
367a			 
367a cd 68 23				call loadwordinhl 
367d 23					inc hl 
367e			 
367e d1					pop de 
367f eb					ex de, hl 
3680 73					ld (hl), e 
3681 23					inc hl 
3682 72					ld (hl), d 
3683					 
3683					NEXTW 
3683 cd a7 fd			call parse_vector 
3686 c3 e2 23			jp macro_next 
3689				endm 
# End of macro NEXTW
3689			.SBSTORE: 
3689				CWHEAD .SBWSTORE 91 "1-!" 3 WORD_FLAG_CODE 
3689 6f				db WORD_SYS_CORE+91             
368a a2 36			dw .SBWSTORE            
368c 04				db 3 + 1 
368d .. 00			db "1-!",0              
3691				endm 
# End of macro CWHEAD
3691			; | 1-! ( addr -- )  Decrement byte at address addr | DONE 
3691			 
3691					FORTH_DSP_VALUEHL 
3691 cd fb 21			call macro_dsp_valuehl 
3694				endm 
# End of macro FORTH_DSP_VALUEHL
3694 e5					push hl 
3695			 
3695					FORTH_DSP_POP 
3695 cd b3 22			call macro_forth_dsp_pop 
3698				endm 
# End of macro FORTH_DSP_POP
3698 e1					pop hl 
3699			 
3699 7e					ld a, (hl) 
369a 3d					dec a 
369b 77					ld (hl), a 
369c					 
369c					NEXTW 
369c cd a7 fd			call parse_vector 
369f c3 e2 23			jp macro_next 
36a2				endm 
# End of macro NEXTW
36a2			.SBWSTORE: 
36a2				CWHEAD .ENDCORE 91 "1-2!" 4 WORD_FLAG_CODE 
36a2 6f				db WORD_SYS_CORE+91             
36a3 c3 36			dw .ENDCORE            
36a5 05				db 4 + 1 
36a6 .. 00			db "1-2!",0              
36ab				endm 
# End of macro CWHEAD
36ab			; | 1-2! ( addr -- )  Decrement word at address addr | DONE 
36ab			 
36ab					FORTH_DSP_VALUEHL 
36ab cd fb 21			call macro_dsp_valuehl 
36ae				endm 
# End of macro FORTH_DSP_VALUEHL
36ae e5					push hl 
36af			 
36af					FORTH_DSP_POP 
36af cd b3 22			call macro_forth_dsp_pop 
36b2				endm 
# End of macro FORTH_DSP_POP
36b2 e1					pop hl 
36b3			 
36b3 e5					push hl 
36b4			 
36b4 cd 68 23				call loadwordinhl 
36b7 2b					dec hl 
36b8			 
36b8 d1					pop de 
36b9 eb					ex de, hl 
36ba 73					ld (hl), e 
36bb 23					inc hl 
36bc 72					ld (hl), d 
36bd					 
36bd					NEXTW 
36bd cd a7 fd			call parse_vector 
36c0 c3 e2 23			jp macro_next 
36c3				endm 
# End of macro NEXTW
36c3			.ENDCORE: 
36c3			 
36c3			; eof 
36c3			 
36c3			 
# End of file forth_words_core.asm
36c3			include "forth_words_flow.asm" 
36c3			 
36c3			; | ## Program Flow Words 
36c3			 
36c3			.IF: 
36c3				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
36c3 1e				db WORD_SYS_CORE+10             
36c4 be 37			dw .THEN            
36c6 03				db 2 + 1 
36c7 .. 00			db "IF",0              
36ca				endm 
# End of macro CWHEAD
36ca			; | IF ( w -- f ) If TOS is true exec code following up to THEN  | DONE 
36ca			; | | Note: currently not supporting ELSE or nested IF 
36ca			; 
36ca					if DEBUG_FORTH_WORDS_KEY 
36ca						DMARK "IF." 
36ca f5				push af  
36cb 3a df 36			ld a, (.dmark)  
36ce 32 9d fd			ld (debug_mark),a  
36d1 3a e0 36			ld a, (.dmark+1)  
36d4 32 9e fd			ld (debug_mark+1),a  
36d7 3a e1 36			ld a, (.dmark+2)  
36da 32 9f fd			ld (debug_mark+2),a  
36dd 18 03			jr .pastdmark  
36df ..			.dmark: db "IF."  
36e2 f1			.pastdmark: pop af  
36e3			endm  
# End of macro DMARK
36e3						CALLMONITOR 
36e3 cd aa fd			call debug_vector  
36e6				endm  
# End of macro CALLMONITOR
36e6					endif 
36e6			; eval TOS 
36e6			 
36e6				FORTH_DSP_VALUEHL 
36e6 cd fb 21			call macro_dsp_valuehl 
36e9				endm 
# End of macro FORTH_DSP_VALUEHL
36e9			 
36e9			;	push hl 
36e9				FORTH_DSP_POP 
36e9 cd b3 22			call macro_forth_dsp_pop 
36ec				endm 
# End of macro FORTH_DSP_POP
36ec			;	pop hl 
36ec			 
36ec					if DEBUG_FORTH_WORDS 
36ec						DMARK "IF1" 
36ec f5				push af  
36ed 3a 01 37			ld a, (.dmark)  
36f0 32 9d fd			ld (debug_mark),a  
36f3 3a 02 37			ld a, (.dmark+1)  
36f6 32 9e fd			ld (debug_mark+1),a  
36f9 3a 03 37			ld a, (.dmark+2)  
36fc 32 9f fd			ld (debug_mark+2),a  
36ff 18 03			jr .pastdmark  
3701 ..			.dmark: db "IF1"  
3704 f1			.pastdmark: pop af  
3705			endm  
# End of macro DMARK
3705						CALLMONITOR 
3705 cd aa fd			call debug_vector  
3708				endm  
# End of macro CALLMONITOR
3708					endif 
3708 b7				or a        ; clear carry flag 
3709 11 00 00			ld de, 0 
370c eb				ex de,hl 
370d ed 52			sbc hl, de 
370f c2 9c 37			jp nz, .iftrue 
3712			 
3712					if DEBUG_FORTH_WORDS 
3712						DMARK "IF2" 
3712 f5				push af  
3713 3a 27 37			ld a, (.dmark)  
3716 32 9d fd			ld (debug_mark),a  
3719 3a 28 37			ld a, (.dmark+1)  
371c 32 9e fd			ld (debug_mark+1),a  
371f 3a 29 37			ld a, (.dmark+2)  
3722 32 9f fd			ld (debug_mark+2),a  
3725 18 03			jr .pastdmark  
3727 ..			.dmark: db "IF2"  
372a f1			.pastdmark: pop af  
372b			endm  
# End of macro DMARK
372b						CALLMONITOR 
372b cd aa fd			call debug_vector  
372e				endm  
# End of macro CALLMONITOR
372e					endif 
372e			 
372e			; if not true then skip to THEN 
372e			 
372e				; TODO get tok_ptr 
372e				; TODO consume toks until we get to THEN 
372e			 
372e 2a f4 f3			ld hl, (os_tok_ptr) 
3731					if DEBUG_FORTH_WORDS 
3731						DMARK "IF3" 
3731 f5				push af  
3732 3a 46 37			ld a, (.dmark)  
3735 32 9d fd			ld (debug_mark),a  
3738 3a 47 37			ld a, (.dmark+1)  
373b 32 9e fd			ld (debug_mark+1),a  
373e 3a 48 37			ld a, (.dmark+2)  
3741 32 9f fd			ld (debug_mark+2),a  
3744 18 03			jr .pastdmark  
3746 ..			.dmark: db "IF3"  
3749 f1			.pastdmark: pop af  
374a			endm  
# End of macro DMARK
374a						CALLMONITOR 
374a cd aa fd			call debug_vector  
374d				endm  
# End of macro CALLMONITOR
374d						 
374d					endif 
374d 11 97 37			ld de, .ifthen 
3750					if DEBUG_FORTH_WORDS 
3750						DMARK "IF4" 
3750 f5				push af  
3751 3a 65 37			ld a, (.dmark)  
3754 32 9d fd			ld (debug_mark),a  
3757 3a 66 37			ld a, (.dmark+1)  
375a 32 9e fd			ld (debug_mark+1),a  
375d 3a 67 37			ld a, (.dmark+2)  
3760 32 9f fd			ld (debug_mark+2),a  
3763 18 03			jr .pastdmark  
3765 ..			.dmark: db "IF4"  
3768 f1			.pastdmark: pop af  
3769			endm  
# End of macro DMARK
3769						CALLMONITOR 
3769 cd aa fd			call debug_vector  
376c				endm  
# End of macro CALLMONITOR
376c					endif 
376c cd df 24			call findnexttok  
376f			 
376f					if DEBUG_FORTH_WORDS 
376f						DMARK "IF5" 
376f f5				push af  
3770 3a 84 37			ld a, (.dmark)  
3773 32 9d fd			ld (debug_mark),a  
3776 3a 85 37			ld a, (.dmark+1)  
3779 32 9e fd			ld (debug_mark+1),a  
377c 3a 86 37			ld a, (.dmark+2)  
377f 32 9f fd			ld (debug_mark+2),a  
3782 18 03			jr .pastdmark  
3784 ..			.dmark: db "IF5"  
3787 f1			.pastdmark: pop af  
3788			endm  
# End of macro DMARK
3788						CALLMONITOR 
3788 cd aa fd			call debug_vector  
378b				endm  
# End of macro CALLMONITOR
378b					endif 
378b				; TODO replace below with ; exec using tok_ptr 
378b 22 f4 f3			ld (os_tok_ptr), hl 
378e c3 63 24			jp exec1 
3791				NEXTW 
3791 cd a7 fd			call parse_vector 
3794 c3 e2 23			jp macro_next 
3797				endm 
# End of macro NEXTW
3797			 
3797 .. 00		.ifthen:  db "THEN",0 
379c			 
379c			.iftrue:		 
379c				; Exec next words normally 
379c			 
379c				; if true then exec following IF as normal 
379c					if DEBUG_FORTH_WORDS 
379c						DMARK "IFT" 
379c f5				push af  
379d 3a b1 37			ld a, (.dmark)  
37a0 32 9d fd			ld (debug_mark),a  
37a3 3a b2 37			ld a, (.dmark+1)  
37a6 32 9e fd			ld (debug_mark+1),a  
37a9 3a b3 37			ld a, (.dmark+2)  
37ac 32 9f fd			ld (debug_mark+2),a  
37af 18 03			jr .pastdmark  
37b1 ..			.dmark: db "IFT"  
37b4 f1			.pastdmark: pop af  
37b5			endm  
# End of macro DMARK
37b5						CALLMONITOR 
37b5 cd aa fd			call debug_vector  
37b8				endm  
# End of macro CALLMONITOR
37b8					endif 
37b8			 
37b8					NEXTW 
37b8 cd a7 fd			call parse_vector 
37bb c3 e2 23			jp macro_next 
37be				endm 
# End of macro NEXTW
37be			.THEN: 
37be				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
37be 1f				db WORD_SYS_CORE+11             
37bf e9 37			dw .ELSE            
37c1 05				db 4 + 1 
37c2 .. 00			db "THEN",0              
37c7				endm 
# End of macro CWHEAD
37c7			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
37c7					if DEBUG_FORTH_WORDS_KEY 
37c7						DMARK "THN" 
37c7 f5				push af  
37c8 3a dc 37			ld a, (.dmark)  
37cb 32 9d fd			ld (debug_mark),a  
37ce 3a dd 37			ld a, (.dmark+1)  
37d1 32 9e fd			ld (debug_mark+1),a  
37d4 3a de 37			ld a, (.dmark+2)  
37d7 32 9f fd			ld (debug_mark+2),a  
37da 18 03			jr .pastdmark  
37dc ..			.dmark: db "THN"  
37df f1			.pastdmark: pop af  
37e0			endm  
# End of macro DMARK
37e0						CALLMONITOR 
37e0 cd aa fd			call debug_vector  
37e3				endm  
# End of macro CALLMONITOR
37e3					endif 
37e3					NEXTW 
37e3 cd a7 fd			call parse_vector 
37e6 c3 e2 23			jp macro_next 
37e9				endm 
# End of macro NEXTW
37e9			.ELSE: 
37e9				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
37e9 20				db WORD_SYS_CORE+12             
37ea 14 38			dw .DO            
37ec 03				db 2 + 1 
37ed .. 00			db "ELSE",0              
37f2				endm 
# End of macro CWHEAD
37f2			; | ELSE ( -- ) Not supported - does nothing | TODO 
37f2			 
37f2					if DEBUG_FORTH_WORDS_KEY 
37f2						DMARK "ELS" 
37f2 f5				push af  
37f3 3a 07 38			ld a, (.dmark)  
37f6 32 9d fd			ld (debug_mark),a  
37f9 3a 08 38			ld a, (.dmark+1)  
37fc 32 9e fd			ld (debug_mark+1),a  
37ff 3a 09 38			ld a, (.dmark+2)  
3802 32 9f fd			ld (debug_mark+2),a  
3805 18 03			jr .pastdmark  
3807 ..			.dmark: db "ELS"  
380a f1			.pastdmark: pop af  
380b			endm  
# End of macro DMARK
380b						CALLMONITOR 
380b cd aa fd			call debug_vector  
380e				endm  
# End of macro CALLMONITOR
380e					endif 
380e			 
380e			 
380e					NEXTW 
380e cd a7 fd			call parse_vector 
3811 c3 e2 23			jp macro_next 
3814				endm 
# End of macro NEXTW
3814			.DO: 
3814				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
3814 21				db WORD_SYS_CORE+13             
3815 3e 39			dw .LOOP            
3817 03				db 2 + 1 
3818 .. 00			db "DO",0              
381b				endm 
# End of macro CWHEAD
381b			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
381b			 
381b					if DEBUG_FORTH_WORDS_KEY 
381b						DMARK "DO." 
381b f5				push af  
381c 3a 30 38			ld a, (.dmark)  
381f 32 9d fd			ld (debug_mark),a  
3822 3a 31 38			ld a, (.dmark+1)  
3825 32 9e fd			ld (debug_mark+1),a  
3828 3a 32 38			ld a, (.dmark+2)  
382b 32 9f fd			ld (debug_mark+2),a  
382e 18 03			jr .pastdmark  
3830 ..			.dmark: db "DO."  
3833 f1			.pastdmark: pop af  
3834			endm  
# End of macro DMARK
3834						CALLMONITOR 
3834 cd aa fd			call debug_vector  
3837				endm  
# End of macro CALLMONITOR
3837					endif 
3837			;  push pc to rsp stack past the DO 
3837			 
3837 2a f4 f3				ld hl, (os_tok_ptr) 
383a 23					inc hl   ; D 
383b 23					inc hl  ; O 
383c 23					inc hl   ; null 
383d					if DEBUG_FORTH_WORDS 
383d						DMARK "DO2" 
383d f5				push af  
383e 3a 52 38			ld a, (.dmark)  
3841 32 9d fd			ld (debug_mark),a  
3844 3a 53 38			ld a, (.dmark+1)  
3847 32 9e fd			ld (debug_mark+1),a  
384a 3a 54 38			ld a, (.dmark+2)  
384d 32 9f fd			ld (debug_mark+2),a  
3850 18 03			jr .pastdmark  
3852 ..			.dmark: db "DO2"  
3855 f1			.pastdmark: pop af  
3856			endm  
# End of macro DMARK
3856						CALLMONITOR 
3856 cd aa fd			call debug_vector  
3859				endm  
# End of macro CALLMONITOR
3859					endif 
3859					FORTH_RSP_NEXT 
3859 cd a6 1f			call macro_forth_rsp_next 
385c				endm 
# End of macro FORTH_RSP_NEXT
385c					if DEBUG_FORTH_WORDS 
385c						DMARK "DO3" 
385c f5				push af  
385d 3a 71 38			ld a, (.dmark)  
3860 32 9d fd			ld (debug_mark),a  
3863 3a 72 38			ld a, (.dmark+1)  
3866 32 9e fd			ld (debug_mark+1),a  
3869 3a 73 38			ld a, (.dmark+2)  
386c 32 9f fd			ld (debug_mark+2),a  
386f 18 03			jr .pastdmark  
3871 ..			.dmark: db "DO3"  
3874 f1			.pastdmark: pop af  
3875			endm  
# End of macro DMARK
3875						CALLMONITOR 
3875 cd aa fd			call debug_vector  
3878				endm  
# End of macro CALLMONITOR
3878					endif 
3878			 
3878					;if DEBUG_FORTH_WORDS 
3878				;		push hl 
3878			;		endif  
3878			 
3878			; get counters from data stack 
3878			 
3878			 
3878					FORTH_DSP_VALUEHL 
3878 cd fb 21			call macro_dsp_valuehl 
387b				endm 
# End of macro FORTH_DSP_VALUEHL
387b e5					push hl		 ; hl now has starting counter which needs to be tos 
387c			 
387c					if DEBUG_FORTH_WORDS 
387c						DMARK "DO4" 
387c f5				push af  
387d 3a 91 38			ld a, (.dmark)  
3880 32 9d fd			ld (debug_mark),a  
3883 3a 92 38			ld a, (.dmark+1)  
3886 32 9e fd			ld (debug_mark+1),a  
3889 3a 93 38			ld a, (.dmark+2)  
388c 32 9f fd			ld (debug_mark+2),a  
388f 18 03			jr .pastdmark  
3891 ..			.dmark: db "DO4"  
3894 f1			.pastdmark: pop af  
3895			endm  
# End of macro DMARK
3895						CALLMONITOR 
3895 cd aa fd			call debug_vector  
3898				endm  
# End of macro CALLMONITOR
3898					endif 
3898					FORTH_DSP_POP 
3898 cd b3 22			call macro_forth_dsp_pop 
389b				endm 
# End of macro FORTH_DSP_POP
389b			 
389b					if DEBUG_FORTH_WORDS 
389b						DMARK "DO5" 
389b f5				push af  
389c 3a b0 38			ld a, (.dmark)  
389f 32 9d fd			ld (debug_mark),a  
38a2 3a b1 38			ld a, (.dmark+1)  
38a5 32 9e fd			ld (debug_mark+1),a  
38a8 3a b2 38			ld a, (.dmark+2)  
38ab 32 9f fd			ld (debug_mark+2),a  
38ae 18 03			jr .pastdmark  
38b0 ..			.dmark: db "DO5"  
38b3 f1			.pastdmark: pop af  
38b4			endm  
# End of macro DMARK
38b4						CALLMONITOR 
38b4 cd aa fd			call debug_vector  
38b7				endm  
# End of macro CALLMONITOR
38b7					endif 
38b7			 
38b7					FORTH_DSP_VALUEHL 
38b7 cd fb 21			call macro_dsp_valuehl 
38ba				endm 
# End of macro FORTH_DSP_VALUEHL
38ba			;		push hl		 ; hl now has starting limit counter 
38ba			 
38ba					if DEBUG_FORTH_WORDS 
38ba						DMARK "DO6" 
38ba f5				push af  
38bb 3a cf 38			ld a, (.dmark)  
38be 32 9d fd			ld (debug_mark),a  
38c1 3a d0 38			ld a, (.dmark+1)  
38c4 32 9e fd			ld (debug_mark+1),a  
38c7 3a d1 38			ld a, (.dmark+2)  
38ca 32 9f fd			ld (debug_mark+2),a  
38cd 18 03			jr .pastdmark  
38cf ..			.dmark: db "DO6"  
38d2 f1			.pastdmark: pop af  
38d3			endm  
# End of macro DMARK
38d3						CALLMONITOR 
38d3 cd aa fd			call debug_vector  
38d6				endm  
# End of macro CALLMONITOR
38d6					endif 
38d6					FORTH_DSP_POP 
38d6 cd b3 22			call macro_forth_dsp_pop 
38d9				endm 
# End of macro FORTH_DSP_POP
38d9			 
38d9			; put counters on the loop stack 
38d9			 
38d9			;		pop hl			 ; limit counter 
38d9 d1					pop de			; start counter 
38da			 
38da					; push limit counter 
38da			 
38da					if DEBUG_FORTH_WORDS 
38da						DMARK "DO7" 
38da f5				push af  
38db 3a ef 38			ld a, (.dmark)  
38de 32 9d fd			ld (debug_mark),a  
38e1 3a f0 38			ld a, (.dmark+1)  
38e4 32 9e fd			ld (debug_mark+1),a  
38e7 3a f1 38			ld a, (.dmark+2)  
38ea 32 9f fd			ld (debug_mark+2),a  
38ed 18 03			jr .pastdmark  
38ef ..			.dmark: db "DO7"  
38f2 f1			.pastdmark: pop af  
38f3			endm  
# End of macro DMARK
38f3						CALLMONITOR 
38f3 cd aa fd			call debug_vector  
38f6				endm  
# End of macro CALLMONITOR
38f6					endif 
38f6					FORTH_LOOP_NEXT 
38f6 cd 2c 22			call macro_forth_loop_next 
38f9				endm 
# End of macro FORTH_LOOP_NEXT
38f9			 
38f9					; push start counter 
38f9			 
38f9 eb					ex de, hl 
38fa					if DEBUG_FORTH_WORDS 
38fa						DMARK "DO7" 
38fa f5				push af  
38fb 3a 0f 39			ld a, (.dmark)  
38fe 32 9d fd			ld (debug_mark),a  
3901 3a 10 39			ld a, (.dmark+1)  
3904 32 9e fd			ld (debug_mark+1),a  
3907 3a 11 39			ld a, (.dmark+2)  
390a 32 9f fd			ld (debug_mark+2),a  
390d 18 03			jr .pastdmark  
390f ..			.dmark: db "DO7"  
3912 f1			.pastdmark: pop af  
3913			endm  
# End of macro DMARK
3913						CALLMONITOR 
3913 cd aa fd			call debug_vector  
3916				endm  
# End of macro CALLMONITOR
3916					endif 
3916					FORTH_LOOP_NEXT 
3916 cd 2c 22			call macro_forth_loop_next 
3919				endm 
# End of macro FORTH_LOOP_NEXT
3919			 
3919			 
3919					; init first round of I counter 
3919			 
3919 22 18 f4				ld (os_current_i), hl 
391c			 
391c					if DEBUG_FORTH_WORDS 
391c						DMARK "DO8" 
391c f5				push af  
391d 3a 31 39			ld a, (.dmark)  
3920 32 9d fd			ld (debug_mark),a  
3923 3a 32 39			ld a, (.dmark+1)  
3926 32 9e fd			ld (debug_mark+1),a  
3929 3a 33 39			ld a, (.dmark+2)  
392c 32 9f fd			ld (debug_mark+2),a  
392f 18 03			jr .pastdmark  
3931 ..			.dmark: db "DO8"  
3934 f1			.pastdmark: pop af  
3935			endm  
# End of macro DMARK
3935						CALLMONITOR 
3935 cd aa fd			call debug_vector  
3938				endm  
# End of macro CALLMONITOR
3938					endif 
3938			 
3938					NEXTW 
3938 cd a7 fd			call parse_vector 
393b c3 e2 23			jp macro_next 
393e				endm 
# End of macro NEXTW
393e			.LOOP: 
393e				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
393e 22				db WORD_SYS_CORE+14             
393f 5c 3a			dw .I            
3941 05				db 4 + 1 
3942 .. 00			db "LOOP",0              
3947				endm 
# End of macro CWHEAD
3947			; | LOOP ( -- ) Increment and test loop counter  | DONE 
3947			 
3947				; pop tos as current loop count to hl 
3947			 
3947				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3947			 
3947				FORTH_LOOP_TOS 
3947 cd 5f 22			call macro_forth_loop_tos 
394a				endm 
# End of macro FORTH_LOOP_TOS
394a e5				push hl 
394b			 
394b					if DEBUG_FORTH_WORDS_KEY 
394b						DMARK "LOP" 
394b f5				push af  
394c 3a 60 39			ld a, (.dmark)  
394f 32 9d fd			ld (debug_mark),a  
3952 3a 61 39			ld a, (.dmark+1)  
3955 32 9e fd			ld (debug_mark+1),a  
3958 3a 62 39			ld a, (.dmark+2)  
395b 32 9f fd			ld (debug_mark+2),a  
395e 18 03			jr .pastdmark  
3960 ..			.dmark: db "LOP"  
3963 f1			.pastdmark: pop af  
3964			endm  
# End of macro DMARK
3964						CALLMONITOR 
3964 cd aa fd			call debug_vector  
3967				endm  
# End of macro CALLMONITOR
3967					endif 
3967				; next item on the stack is the limit. get it 
3967			 
3967			 
3967				FORTH_LOOP_POP 
3967 cd 69 22			call macro_forth_loop_pop 
396a				endm 
# End of macro FORTH_LOOP_POP
396a			 
396a				FORTH_LOOP_TOS 
396a cd 5f 22			call macro_forth_loop_tos 
396d				endm 
# End of macro FORTH_LOOP_TOS
396d			 
396d d1				pop de		 ; de = i, hl = limit 
396e			 
396e					if DEBUG_FORTH_WORDS 
396e						DMARK "LP1" 
396e f5				push af  
396f 3a 83 39			ld a, (.dmark)  
3972 32 9d fd			ld (debug_mark),a  
3975 3a 84 39			ld a, (.dmark+1)  
3978 32 9e fd			ld (debug_mark+1),a  
397b 3a 85 39			ld a, (.dmark+2)  
397e 32 9f fd			ld (debug_mark+2),a  
3981 18 03			jr .pastdmark  
3983 ..			.dmark: db "LP1"  
3986 f1			.pastdmark: pop af  
3987			endm  
# End of macro DMARK
3987						CALLMONITOR 
3987 cd aa fd			call debug_vector  
398a				endm  
# End of macro CALLMONITOR
398a					endif 
398a			 
398a				; go back to previous word 
398a			 
398a d5				push de    ; save I for inc later 
398b			 
398b			 
398b				; get limit 
398b				;  is I at limit? 
398b			 
398b			 
398b					if DEBUG_FORTH_WORDS 
398b						DMARK "LP1" 
398b f5				push af  
398c 3a a0 39			ld a, (.dmark)  
398f 32 9d fd			ld (debug_mark),a  
3992 3a a1 39			ld a, (.dmark+1)  
3995 32 9e fd			ld (debug_mark+1),a  
3998 3a a2 39			ld a, (.dmark+2)  
399b 32 9f fd			ld (debug_mark+2),a  
399e 18 03			jr .pastdmark  
39a0 ..			.dmark: db "LP1"  
39a3 f1			.pastdmark: pop af  
39a4			endm  
# End of macro DMARK
39a4						CALLMONITOR 
39a4 cd aa fd			call debug_vector  
39a7				endm  
# End of macro CALLMONITOR
39a7					endif 
39a7			 
39a7 ed 52			sbc hl, de 
39a9			 
39a9			 
39a9				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
39a9			 
39a9 20 29				jr nz, .loopnotdone 
39ab			 
39ab e1				pop hl   ; get rid of saved I 
39ac				FORTH_LOOP_POP     ; get rid of limit 
39ac cd 69 22			call macro_forth_loop_pop 
39af				endm 
# End of macro FORTH_LOOP_POP
39af			 
39af				FORTH_RSP_POP     ; get rid of DO ptr 
39af cd c7 1f			call macro_forth_rsp_pop 
39b2				endm 
# End of macro FORTH_RSP_POP
39b2			 
39b2			if DEBUG_FORTH_WORDS 
39b2						DMARK "LP>" 
39b2 f5				push af  
39b3 3a c7 39			ld a, (.dmark)  
39b6 32 9d fd			ld (debug_mark),a  
39b9 3a c8 39			ld a, (.dmark+1)  
39bc 32 9e fd			ld (debug_mark+1),a  
39bf 3a c9 39			ld a, (.dmark+2)  
39c2 32 9f fd			ld (debug_mark+2),a  
39c5 18 03			jr .pastdmark  
39c7 ..			.dmark: db "LP>"  
39ca f1			.pastdmark: pop af  
39cb			endm  
# End of macro DMARK
39cb				CALLMONITOR 
39cb cd aa fd			call debug_vector  
39ce				endm  
# End of macro CALLMONITOR
39ce			endif 
39ce			 
39ce					NEXTW 
39ce cd a7 fd			call parse_vector 
39d1 c3 e2 23			jp macro_next 
39d4				endm 
# End of macro NEXTW
39d4				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
39d4			 
39d4			.loopnotdone: 
39d4			 
39d4 e1				pop hl    ; get I 
39d5 23				inc hl 
39d6			 
39d6			   	; save new I 
39d6			 
39d6			 
39d6					; set I counter 
39d6			 
39d6 22 18 f4				ld (os_current_i), hl 
39d9			 
39d9					if DEBUG_FORTH_WORDS 
39d9						DMARK "LPN" 
39d9 f5				push af  
39da 3a ee 39			ld a, (.dmark)  
39dd 32 9d fd			ld (debug_mark),a  
39e0 3a ef 39			ld a, (.dmark+1)  
39e3 32 9e fd			ld (debug_mark+1),a  
39e6 3a f0 39			ld a, (.dmark+2)  
39e9 32 9f fd			ld (debug_mark+2),a  
39ec 18 03			jr .pastdmark  
39ee ..			.dmark: db "LPN"  
39f1 f1			.pastdmark: pop af  
39f2			endm  
# End of macro DMARK
39f2					CALLMONITOR 
39f2 cd aa fd			call debug_vector  
39f5				endm  
# End of macro CALLMONITOR
39f5					endif 
39f5					 
39f5				FORTH_LOOP_NEXT 
39f5 cd 2c 22			call macro_forth_loop_next 
39f8				endm 
# End of macro FORTH_LOOP_NEXT
39f8			 
39f8			 
39f8					if DEBUG_FORTH_WORDS 
39f8 eb						ex de,hl 
39f9					endif 
39f9			 
39f9			;	; get DO ptr 
39f9			; 
39f9					if DEBUG_FORTH_WORDS 
39f9						DMARK "LP7" 
39f9 f5				push af  
39fa 3a 0e 3a			ld a, (.dmark)  
39fd 32 9d fd			ld (debug_mark),a  
3a00 3a 0f 3a			ld a, (.dmark+1)  
3a03 32 9e fd			ld (debug_mark+1),a  
3a06 3a 10 3a			ld a, (.dmark+2)  
3a09 32 9f fd			ld (debug_mark+2),a  
3a0c 18 03			jr .pastdmark  
3a0e ..			.dmark: db "LP7"  
3a11 f1			.pastdmark: pop af  
3a12			endm  
# End of macro DMARK
3a12					CALLMONITOR 
3a12 cd aa fd			call debug_vector  
3a15				endm  
# End of macro CALLMONITOR
3a15					endif 
3a15				FORTH_RSP_TOS 
3a15 cd bd 1f			call macro_forth_rsp_tos 
3a18				endm 
# End of macro FORTH_RSP_TOS
3a18			 
3a18					if DEBUG_FORTH_WORDS 
3a18						DMARK "LP8" 
3a18 f5				push af  
3a19 3a 2d 3a			ld a, (.dmark)  
3a1c 32 9d fd			ld (debug_mark),a  
3a1f 3a 2e 3a			ld a, (.dmark+1)  
3a22 32 9e fd			ld (debug_mark+1),a  
3a25 3a 2f 3a			ld a, (.dmark+2)  
3a28 32 9f fd			ld (debug_mark+2),a  
3a2b 18 03			jr .pastdmark  
3a2d ..			.dmark: db "LP8"  
3a30 f1			.pastdmark: pop af  
3a31			endm  
# End of macro DMARK
3a31					CALLMONITOR 
3a31 cd aa fd			call debug_vector  
3a34				endm  
# End of macro CALLMONITOR
3a34					endif 
3a34				;push hl 
3a34			 
3a34				; not going to DO any more 
3a34				; get rid of the RSP pointer as DO will add it back in 
3a34				;FORTH_RSP_POP 
3a34				;pop hl 
3a34			 
3a34				;ld hl,(cli_ret_sp) 
3a34				;ld e, (hl) 
3a34				;inc hl 
3a34				;ld d, (hl) 
3a34				;ex de,hl 
3a34 22 f4 f3			ld (os_tok_ptr), hl 
3a37					if DEBUG_FORTH_WORDS 
3a37						DMARK "LP<" 
3a37 f5				push af  
3a38 3a 4c 3a			ld a, (.dmark)  
3a3b 32 9d fd			ld (debug_mark),a  
3a3e 3a 4d 3a			ld a, (.dmark+1)  
3a41 32 9e fd			ld (debug_mark+1),a  
3a44 3a 4e 3a			ld a, (.dmark+2)  
3a47 32 9f fd			ld (debug_mark+2),a  
3a4a 18 03			jr .pastdmark  
3a4c ..			.dmark: db "LP<"  
3a4f f1			.pastdmark: pop af  
3a50			endm  
# End of macro DMARK
3a50					CALLMONITOR 
3a50 cd aa fd			call debug_vector  
3a53				endm  
# End of macro CALLMONITOR
3a53				endif 
3a53 c3 63 24			jp exec1 
3a56			 
3a56					 
3a56			 
3a56			 
3a56					NEXTW 
3a56 cd a7 fd			call parse_vector 
3a59 c3 e2 23			jp macro_next 
3a5c				endm 
# End of macro NEXTW
3a5c			.I:  
3a5c			 
3a5c				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
3a5c 5e				db WORD_SYS_CORE+74             
3a5d 8a 3a			dw .DLOOP            
3a5f 02				db 1 + 1 
3a60 .. 00			db "I",0              
3a62				endm 
# End of macro CWHEAD
3a62			; | I ( -- ) Current loop counter | DONE 
3a62					if DEBUG_FORTH_WORDS_KEY 
3a62						DMARK "I.." 
3a62 f5				push af  
3a63 3a 77 3a			ld a, (.dmark)  
3a66 32 9d fd			ld (debug_mark),a  
3a69 3a 78 3a			ld a, (.dmark+1)  
3a6c 32 9e fd			ld (debug_mark+1),a  
3a6f 3a 79 3a			ld a, (.dmark+2)  
3a72 32 9f fd			ld (debug_mark+2),a  
3a75 18 03			jr .pastdmark  
3a77 ..			.dmark: db "I.."  
3a7a f1			.pastdmark: pop af  
3a7b			endm  
# End of macro DMARK
3a7b						CALLMONITOR 
3a7b cd aa fd			call debug_vector  
3a7e				endm  
# End of macro CALLMONITOR
3a7e					endif 
3a7e			 
3a7e 2a 18 f4				ld hl,(os_current_i) 
3a81 cd ff 1f				call forth_push_numhl 
3a84			 
3a84					NEXTW 
3a84 cd a7 fd			call parse_vector 
3a87 c3 e2 23			jp macro_next 
3a8a				endm 
# End of macro NEXTW
3a8a			.DLOOP: 
3a8a				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
3a8a 5f				db WORD_SYS_CORE+75             
3a8b 71 3b			dw .REPEAT            
3a8d 06				db 5 + 1 
3a8e .. 00			db "-LOOP",0              
3a94				endm 
# End of macro CWHEAD
3a94			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
3a94				; pop tos as current loop count to hl 
3a94					if DEBUG_FORTH_WORDS_KEY 
3a94						DMARK "-LP" 
3a94 f5				push af  
3a95 3a a9 3a			ld a, (.dmark)  
3a98 32 9d fd			ld (debug_mark),a  
3a9b 3a aa 3a			ld a, (.dmark+1)  
3a9e 32 9e fd			ld (debug_mark+1),a  
3aa1 3a ab 3a			ld a, (.dmark+2)  
3aa4 32 9f fd			ld (debug_mark+2),a  
3aa7 18 03			jr .pastdmark  
3aa9 ..			.dmark: db "-LP"  
3aac f1			.pastdmark: pop af  
3aad			endm  
# End of macro DMARK
3aad						CALLMONITOR 
3aad cd aa fd			call debug_vector  
3ab0				endm  
# End of macro CALLMONITOR
3ab0					endif 
3ab0			 
3ab0				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3ab0			 
3ab0				FORTH_LOOP_TOS 
3ab0 cd 5f 22			call macro_forth_loop_tos 
3ab3				endm 
# End of macro FORTH_LOOP_TOS
3ab3 e5				push hl 
3ab4			 
3ab4					if DEBUG_FORTH_WORDS 
3ab4						DMARK "-LP" 
3ab4 f5				push af  
3ab5 3a c9 3a			ld a, (.dmark)  
3ab8 32 9d fd			ld (debug_mark),a  
3abb 3a ca 3a			ld a, (.dmark+1)  
3abe 32 9e fd			ld (debug_mark+1),a  
3ac1 3a cb 3a			ld a, (.dmark+2)  
3ac4 32 9f fd			ld (debug_mark+2),a  
3ac7 18 03			jr .pastdmark  
3ac9 ..			.dmark: db "-LP"  
3acc f1			.pastdmark: pop af  
3acd			endm  
# End of macro DMARK
3acd						CALLMONITOR 
3acd cd aa fd			call debug_vector  
3ad0				endm  
# End of macro CALLMONITOR
3ad0					endif 
3ad0				; next item on the stack is the limit. get it 
3ad0			 
3ad0			 
3ad0				FORTH_LOOP_POP 
3ad0 cd 69 22			call macro_forth_loop_pop 
3ad3				endm 
# End of macro FORTH_LOOP_POP
3ad3			 
3ad3				FORTH_LOOP_TOS 
3ad3 cd 5f 22			call macro_forth_loop_tos 
3ad6				endm 
# End of macro FORTH_LOOP_TOS
3ad6			 
3ad6 d1				pop de		 ; de = i, hl = limit 
3ad7			 
3ad7					if DEBUG_FORTH_WORDS 
3ad7						DMARK "-L1" 
3ad7 f5				push af  
3ad8 3a ec 3a			ld a, (.dmark)  
3adb 32 9d fd			ld (debug_mark),a  
3ade 3a ed 3a			ld a, (.dmark+1)  
3ae1 32 9e fd			ld (debug_mark+1),a  
3ae4 3a ee 3a			ld a, (.dmark+2)  
3ae7 32 9f fd			ld (debug_mark+2),a  
3aea 18 03			jr .pastdmark  
3aec ..			.dmark: db "-L1"  
3aef f1			.pastdmark: pop af  
3af0			endm  
# End of macro DMARK
3af0						CALLMONITOR 
3af0 cd aa fd			call debug_vector  
3af3				endm  
# End of macro CALLMONITOR
3af3					endif 
3af3			 
3af3				; go back to previous word 
3af3			 
3af3 d5				push de    ; save I for inc later 
3af4			 
3af4			 
3af4				; get limit 
3af4				;  is I at limit? 
3af4			 
3af4			 
3af4					if DEBUG_FORTH_WORDS 
3af4						DMARK "-L1" 
3af4 f5				push af  
3af5 3a 09 3b			ld a, (.dmark)  
3af8 32 9d fd			ld (debug_mark),a  
3afb 3a 0a 3b			ld a, (.dmark+1)  
3afe 32 9e fd			ld (debug_mark+1),a  
3b01 3a 0b 3b			ld a, (.dmark+2)  
3b04 32 9f fd			ld (debug_mark+2),a  
3b07 18 03			jr .pastdmark  
3b09 ..			.dmark: db "-L1"  
3b0c f1			.pastdmark: pop af  
3b0d			endm  
# End of macro DMARK
3b0d						CALLMONITOR 
3b0d cd aa fd			call debug_vector  
3b10				endm  
# End of macro CALLMONITOR
3b10					endif 
3b10			 
3b10 ed 52			sbc hl, de 
3b12			 
3b12			 
3b12				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3b12			 
3b12 20 29				jr nz, .mloopnotdone 
3b14			 
3b14 e1				pop hl   ; get rid of saved I 
3b15				FORTH_LOOP_POP     ; get rid of limit 
3b15 cd 69 22			call macro_forth_loop_pop 
3b18				endm 
# End of macro FORTH_LOOP_POP
3b18			 
3b18				FORTH_RSP_POP     ; get rid of DO ptr 
3b18 cd c7 1f			call macro_forth_rsp_pop 
3b1b				endm 
# End of macro FORTH_RSP_POP
3b1b			 
3b1b			if DEBUG_FORTH_WORDS 
3b1b						DMARK "-L>" 
3b1b f5				push af  
3b1c 3a 30 3b			ld a, (.dmark)  
3b1f 32 9d fd			ld (debug_mark),a  
3b22 3a 31 3b			ld a, (.dmark+1)  
3b25 32 9e fd			ld (debug_mark+1),a  
3b28 3a 32 3b			ld a, (.dmark+2)  
3b2b 32 9f fd			ld (debug_mark+2),a  
3b2e 18 03			jr .pastdmark  
3b30 ..			.dmark: db "-L>"  
3b33 f1			.pastdmark: pop af  
3b34			endm  
# End of macro DMARK
3b34				CALLMONITOR 
3b34 cd aa fd			call debug_vector  
3b37				endm  
# End of macro CALLMONITOR
3b37			endif 
3b37			 
3b37					NEXTW 
3b37 cd a7 fd			call parse_vector 
3b3a c3 e2 23			jp macro_next 
3b3d				endm 
# End of macro NEXTW
3b3d				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3b3d			 
3b3d			.mloopnotdone: 
3b3d			 
3b3d e1				pop hl    ; get I 
3b3e 2b				dec hl 
3b3f			 
3b3f			   	; save new I 
3b3f			 
3b3f			 
3b3f					; set I counter 
3b3f			 
3b3f 22 18 f4				ld (os_current_i), hl 
3b42			 
3b42					 
3b42				FORTH_LOOP_NEXT 
3b42 cd 2c 22			call macro_forth_loop_next 
3b45				endm 
# End of macro FORTH_LOOP_NEXT
3b45			 
3b45			 
3b45					if DEBUG_FORTH_WORDS 
3b45 eb						ex de,hl 
3b46					endif 
3b46			 
3b46			;	; get DO ptr 
3b46			; 
3b46				FORTH_RSP_TOS 
3b46 cd bd 1f			call macro_forth_rsp_tos 
3b49				endm 
# End of macro FORTH_RSP_TOS
3b49			 
3b49				;push hl 
3b49			 
3b49				; not going to DO any more 
3b49				; get rid of the RSP pointer as DO will add it back in 
3b49				;FORTH_RSP_POP 
3b49				;pop hl 
3b49			 
3b49			 
3b49 22 f4 f3			ld (os_tok_ptr), hl 
3b4c					if DEBUG_FORTH_WORDS 
3b4c						DMARK "-L<" 
3b4c f5				push af  
3b4d 3a 61 3b			ld a, (.dmark)  
3b50 32 9d fd			ld (debug_mark),a  
3b53 3a 62 3b			ld a, (.dmark+1)  
3b56 32 9e fd			ld (debug_mark+1),a  
3b59 3a 63 3b			ld a, (.dmark+2)  
3b5c 32 9f fd			ld (debug_mark+2),a  
3b5f 18 03			jr .pastdmark  
3b61 ..			.dmark: db "-L<"  
3b64 f1			.pastdmark: pop af  
3b65			endm  
# End of macro DMARK
3b65					CALLMONITOR 
3b65 cd aa fd			call debug_vector  
3b68				endm  
# End of macro CALLMONITOR
3b68				endif 
3b68 c3 63 24			jp exec1 
3b6b			 
3b6b					 
3b6b			 
3b6b			 
3b6b			 
3b6b				NEXTW 
3b6b cd a7 fd			call parse_vector 
3b6e c3 e2 23			jp macro_next 
3b71				endm 
# End of macro NEXTW
3b71			 
3b71			 
3b71			 
3b71			 
3b71			.REPEAT: 
3b71				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3b71 71				db WORD_SYS_CORE+93             
3b72 c7 3b			dw .UNTIL            
3b74 06				db 5 + 1 
3b75 .. 00			db "REPEAT",0              
3b7c				endm 
# End of macro CWHEAD
3b7c			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
3b7c			;  push pc to rsp stack past the REPEAT 
3b7c					if DEBUG_FORTH_WORDS_KEY 
3b7c						DMARK "REP" 
3b7c f5				push af  
3b7d 3a 91 3b			ld a, (.dmark)  
3b80 32 9d fd			ld (debug_mark),a  
3b83 3a 92 3b			ld a, (.dmark+1)  
3b86 32 9e fd			ld (debug_mark+1),a  
3b89 3a 93 3b			ld a, (.dmark+2)  
3b8c 32 9f fd			ld (debug_mark+2),a  
3b8f 18 03			jr .pastdmark  
3b91 ..			.dmark: db "REP"  
3b94 f1			.pastdmark: pop af  
3b95			endm  
# End of macro DMARK
3b95						CALLMONITOR 
3b95 cd aa fd			call debug_vector  
3b98				endm  
# End of macro CALLMONITOR
3b98					endif 
3b98			 
3b98 2a f4 f3				ld hl, (os_tok_ptr) 
3b9b 23					inc hl   ; R 
3b9c 23					inc hl  ; E 
3b9d 23					inc hl   ; P 
3b9e 23					inc hl   ; E 
3b9f 23					inc hl   ; A 
3ba0 23					inc hl   ; T 
3ba1 23					inc hl   ; zero 
3ba2					FORTH_RSP_NEXT 
3ba2 cd a6 1f			call macro_forth_rsp_next 
3ba5				endm 
# End of macro FORTH_RSP_NEXT
3ba5			 
3ba5			 
3ba5					if DEBUG_FORTH_WORDS 
3ba5						DMARK "REP" 
3ba5 f5				push af  
3ba6 3a ba 3b			ld a, (.dmark)  
3ba9 32 9d fd			ld (debug_mark),a  
3bac 3a bb 3b			ld a, (.dmark+1)  
3baf 32 9e fd			ld (debug_mark+1),a  
3bb2 3a bc 3b			ld a, (.dmark+2)  
3bb5 32 9f fd			ld (debug_mark+2),a  
3bb8 18 03			jr .pastdmark  
3bba ..			.dmark: db "REP"  
3bbd f1			.pastdmark: pop af  
3bbe			endm  
# End of macro DMARK
3bbe						;pop bc    ; TODO BUG ?????? what is this for???? 
3bbe						CALLMONITOR 
3bbe cd aa fd			call debug_vector  
3bc1				endm  
# End of macro CALLMONITOR
3bc1					endif 
3bc1			 
3bc1					NEXTW 
3bc1 cd a7 fd			call parse_vector 
3bc4 c3 e2 23			jp macro_next 
3bc7				endm 
# End of macro NEXTW
3bc7			;	       NEXTW 
3bc7			 
3bc7			.UNTIL: 
3bc7				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3bc7 72				db WORD_SYS_CORE+94             
3bc8 64 3c			dw .ENDFLOW            
3bca 06				db 5 + 1 
3bcb .. 00			db "UNTIL",0              
3bd1				endm 
# End of macro CWHEAD
3bd1			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
3bd1			 
3bd1				; pop tos as check 
3bd1			 
3bd1				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3bd1			 
3bd1				FORTH_DSP_VALUEHL 
3bd1 cd fb 21			call macro_dsp_valuehl 
3bd4				endm 
# End of macro FORTH_DSP_VALUEHL
3bd4			 
3bd4					if DEBUG_FORTH_WORDS_KEY 
3bd4						DMARK "UNT" 
3bd4 f5				push af  
3bd5 3a e9 3b			ld a, (.dmark)  
3bd8 32 9d fd			ld (debug_mark),a  
3bdb 3a ea 3b			ld a, (.dmark+1)  
3bde 32 9e fd			ld (debug_mark+1),a  
3be1 3a eb 3b			ld a, (.dmark+2)  
3be4 32 9f fd			ld (debug_mark+2),a  
3be7 18 03			jr .pastdmark  
3be9 ..			.dmark: db "UNT"  
3bec f1			.pastdmark: pop af  
3bed			endm  
# End of macro DMARK
3bed						CALLMONITOR 
3bed cd aa fd			call debug_vector  
3bf0				endm  
# End of macro CALLMONITOR
3bf0					endif 
3bf0			 
3bf0			;	push hl 
3bf0				FORTH_DSP_POP 
3bf0 cd b3 22			call macro_forth_dsp_pop 
3bf3				endm 
# End of macro FORTH_DSP_POP
3bf3			 
3bf3			;	pop hl 
3bf3			 
3bf3				; test if true 
3bf3			 
3bf3 cd d5 0f			call ishlzero 
3bf6			;	ld a,l 
3bf6			;	add h 
3bf6			; 
3bf6			;	cp 0 
3bf6			 
3bf6 20 41			jr nz, .untilnotdone 
3bf8			 
3bf8					if DEBUG_FORTH_WORDS 
3bf8						DMARK "UNf" 
3bf8 f5				push af  
3bf9 3a 0d 3c			ld a, (.dmark)  
3bfc 32 9d fd			ld (debug_mark),a  
3bff 3a 0e 3c			ld a, (.dmark+1)  
3c02 32 9e fd			ld (debug_mark+1),a  
3c05 3a 0f 3c			ld a, (.dmark+2)  
3c08 32 9f fd			ld (debug_mark+2),a  
3c0b 18 03			jr .pastdmark  
3c0d ..			.dmark: db "UNf"  
3c10 f1			.pastdmark: pop af  
3c11			endm  
# End of macro DMARK
3c11						CALLMONITOR 
3c11 cd aa fd			call debug_vector  
3c14				endm  
# End of macro CALLMONITOR
3c14					endif 
3c14			 
3c14			 
3c14			 
3c14				FORTH_RSP_POP     ; get rid of DO ptr 
3c14 cd c7 1f			call macro_forth_rsp_pop 
3c17				endm 
# End of macro FORTH_RSP_POP
3c17			 
3c17			if DEBUG_FORTH_WORDS 
3c17						DMARK "UN>" 
3c17 f5				push af  
3c18 3a 2c 3c			ld a, (.dmark)  
3c1b 32 9d fd			ld (debug_mark),a  
3c1e 3a 2d 3c			ld a, (.dmark+1)  
3c21 32 9e fd			ld (debug_mark+1),a  
3c24 3a 2e 3c			ld a, (.dmark+2)  
3c27 32 9f fd			ld (debug_mark+2),a  
3c2a 18 03			jr .pastdmark  
3c2c ..			.dmark: db "UN>"  
3c2f f1			.pastdmark: pop af  
3c30			endm  
# End of macro DMARK
3c30				CALLMONITOR 
3c30 cd aa fd			call debug_vector  
3c33				endm  
# End of macro CALLMONITOR
3c33			endif 
3c33			 
3c33					NEXTW 
3c33 cd a7 fd			call parse_vector 
3c36 c3 e2 23			jp macro_next 
3c39				endm 
# End of macro NEXTW
3c39				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
3c39			 
3c39			.untilnotdone: 
3c39			 
3c39			 
3c39			;	; get DO ptr 
3c39			; 
3c39				FORTH_RSP_TOS 
3c39 cd bd 1f			call macro_forth_rsp_tos 
3c3c				endm 
# End of macro FORTH_RSP_TOS
3c3c			 
3c3c				;push hl 
3c3c			 
3c3c				; not going to DO any more 
3c3c				; get rid of the RSP pointer as DO will add it back in 
3c3c				;FORTH_RSP_POP 
3c3c				;pop hl 
3c3c			 
3c3c			 
3c3c 22 f4 f3			ld (os_tok_ptr), hl 
3c3f					if DEBUG_FORTH_WORDS 
3c3f						DMARK "UN<" 
3c3f f5				push af  
3c40 3a 54 3c			ld a, (.dmark)  
3c43 32 9d fd			ld (debug_mark),a  
3c46 3a 55 3c			ld a, (.dmark+1)  
3c49 32 9e fd			ld (debug_mark+1),a  
3c4c 3a 56 3c			ld a, (.dmark+2)  
3c4f 32 9f fd			ld (debug_mark+2),a  
3c52 18 03			jr .pastdmark  
3c54 ..			.dmark: db "UN<"  
3c57 f1			.pastdmark: pop af  
3c58			endm  
# End of macro DMARK
3c58					CALLMONITOR 
3c58 cd aa fd			call debug_vector  
3c5b				endm  
# End of macro CALLMONITOR
3c5b				endif 
3c5b c3 63 24			jp exec1 
3c5e			 
3c5e					 
3c5e			 
3c5e			 
3c5e					NEXTW 
3c5e cd a7 fd			call parse_vector 
3c61 c3 e2 23			jp macro_next 
3c64				endm 
# End of macro NEXTW
3c64			 
3c64			 
3c64			.ENDFLOW: 
3c64			 
3c64			; eof 
3c64			 
# End of file forth_words_flow.asm
3c64			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
3c64			include "forth_words_logic.asm" 
3c64			 
3c64			; | ## Logic Words 
3c64			 
3c64			.NOT: 
3c64				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
3c64 2d				db WORD_SYS_CORE+25             
3c65 b2 3c			dw .IS            
3c67 04				db 3 + 1 
3c68 .. 00			db "NOT",0              
3c6c				endm 
# End of macro CWHEAD
3c6c			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3c6c					if DEBUG_FORTH_WORDS_KEY 
3c6c						DMARK "NOT" 
3c6c f5				push af  
3c6d 3a 81 3c			ld a, (.dmark)  
3c70 32 9d fd			ld (debug_mark),a  
3c73 3a 82 3c			ld a, (.dmark+1)  
3c76 32 9e fd			ld (debug_mark+1),a  
3c79 3a 83 3c			ld a, (.dmark+2)  
3c7c 32 9f fd			ld (debug_mark+2),a  
3c7f 18 03			jr .pastdmark  
3c81 ..			.dmark: db "NOT"  
3c84 f1			.pastdmark: pop af  
3c85			endm  
# End of macro DMARK
3c85						CALLMONITOR 
3c85 cd aa fd			call debug_vector  
3c88				endm  
# End of macro CALLMONITOR
3c88					endif 
3c88					FORTH_DSP 
3c88 cd c1 21			call macro_forth_dsp 
3c8b				endm 
# End of macro FORTH_DSP
3c8b 7e					ld a,(hl)	; get type of value on TOS 
3c8c fe 02				cp DS_TYPE_INUM  
3c8e 28 06				jr z, .noti 
3c90					NEXTW 
3c90 cd a7 fd			call parse_vector 
3c93 c3 e2 23			jp macro_next 
3c96				endm 
# End of macro NEXTW
3c96			.noti:          FORTH_DSP_VALUEHL 
3c96 cd fb 21			call macro_dsp_valuehl 
3c99				endm 
# End of macro FORTH_DSP_VALUEHL
3c99			;		push hl 
3c99					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c99 cd b3 22			call macro_forth_dsp_pop 
3c9c				endm 
# End of macro FORTH_DSP_POP
3c9c			;		pop hl 
3c9c 3e 00				ld a,0 
3c9e bd					cp l 
3c9f 28 04				jr z, .not2t 
3ca1 2e 00				ld l, 0 
3ca3 18 02				jr .notip 
3ca5			 
3ca5 2e ff		.not2t:		ld l, 255 
3ca7			 
3ca7 26 00		.notip:		ld h, 0	 
3ca9			 
3ca9 cd ff 1f				call forth_push_numhl 
3cac					NEXTW 
3cac cd a7 fd			call parse_vector 
3caf c3 e2 23			jp macro_next 
3cb2				endm 
# End of macro NEXTW
3cb2			 
3cb2			.IS: 
3cb2				CWHEAD .LZERO 25 "COMPARE" 7 WORD_FLAG_CODE 
3cb2 2d				db WORD_SYS_CORE+25             
3cb3 f6 3c			dw .LZERO            
3cb5 08				db 7 + 1 
3cb6 .. 00			db "COMPARE",0              
3cbe				endm 
# End of macro CWHEAD
3cbe			; | COMPARE ( s1 s2  -- f ) Push true if string s1 is the same as s2 | DONE 
3cbe					if DEBUG_FORTH_WORDS_KEY 
3cbe						DMARK "CMP" 
3cbe f5				push af  
3cbf 3a d3 3c			ld a, (.dmark)  
3cc2 32 9d fd			ld (debug_mark),a  
3cc5 3a d4 3c			ld a, (.dmark+1)  
3cc8 32 9e fd			ld (debug_mark+1),a  
3ccb 3a d5 3c			ld a, (.dmark+2)  
3cce 32 9f fd			ld (debug_mark+2),a  
3cd1 18 03			jr .pastdmark  
3cd3 ..			.dmark: db "CMP"  
3cd6 f1			.pastdmark: pop af  
3cd7			endm  
# End of macro DMARK
3cd7						CALLMONITOR 
3cd7 cd aa fd			call debug_vector  
3cda				endm  
# End of macro CALLMONITOR
3cda					endif 
3cda			 
3cda					FORTH_DSP_VALUEHL 
3cda cd fb 21			call macro_dsp_valuehl 
3cdd				endm 
# End of macro FORTH_DSP_VALUEHL
3cdd			 
3cdd e5					push hl 
3cde			 
3cde					FORTH_DSP_VALUEM1 
3cde cd ef 21			call macro_forth_dsp_value_m1 
3ce1				endm 
# End of macro FORTH_DSP_VALUEM1
3ce1			 
3ce1 d1					pop de 
3ce2			 
3ce2					; got pointers to both. Now check. 
3ce2			 
3ce2 cd 3c 13				call strcmp 
3ce5				 
3ce5 26 00				ld h, 0 
3ce7 2e 00				ld l, 0 
3ce9 20 02				jr nz, .compnsame 
3ceb 2e 01				ld l, 1	 
3ced			.compnsame: 
3ced cd ff 1f				call forth_push_numhl 
3cf0			 
3cf0					NEXTW 
3cf0 cd a7 fd			call parse_vector 
3cf3 c3 e2 23			jp macro_next 
3cf6				endm 
# End of macro NEXTW
3cf6			.LZERO: 
3cf6				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3cf6 2d				db WORD_SYS_CORE+25             
3cf7 03 3d			dw .TZERO            
3cf9 03				db 2 + 1 
3cfa .. 00			db "0<",0              
3cfd				endm 
# End of macro CWHEAD
3cfd			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
3cfd					NEXTW 
3cfd cd a7 fd			call parse_vector 
3d00 c3 e2 23			jp macro_next 
3d03				endm 
# End of macro NEXTW
3d03			.TZERO: 
3d03				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3d03 2e				db WORD_SYS_CORE+26             
3d04 4d 3d			dw .LESS            
3d06 03				db 2 + 1 
3d07 .. 00			db "0=",0              
3d0a				endm 
# End of macro CWHEAD
3d0a			; | 0= ( u -- f ) Push true if u equals 0 | DONE 
3d0a				; TODO add floating point number detection 
3d0a					;v5 FORTH_DSP_VALUE 
3d0a					if DEBUG_FORTH_WORDS_KEY 
3d0a						DMARK "0=." 
3d0a f5				push af  
3d0b 3a 1f 3d			ld a, (.dmark)  
3d0e 32 9d fd			ld (debug_mark),a  
3d11 3a 20 3d			ld a, (.dmark+1)  
3d14 32 9e fd			ld (debug_mark+1),a  
3d17 3a 21 3d			ld a, (.dmark+2)  
3d1a 32 9f fd			ld (debug_mark+2),a  
3d1d 18 03			jr .pastdmark  
3d1f ..			.dmark: db "0=."  
3d22 f1			.pastdmark: pop af  
3d23			endm  
# End of macro DMARK
3d23						CALLMONITOR 
3d23 cd aa fd			call debug_vector  
3d26				endm  
# End of macro CALLMONITOR
3d26					endif 
3d26					FORTH_DSP 
3d26 cd c1 21			call macro_forth_dsp 
3d29				endm 
# End of macro FORTH_DSP
3d29 7e					ld a,(hl)	; get type of value on TOS 
3d2a fe 02				cp DS_TYPE_INUM  
3d2c 28 00				jr z, .tz_inum 
3d2e			 
3d2e				if FORTH_ENABLE_FLOATMATH 
3d2e					jr .tz_done 
3d2e			 
3d2e				endif 
3d2e					 
3d2e			 
3d2e			.tz_inum: 
3d2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d2e cd fb 21			call macro_dsp_valuehl 
3d31				endm 
# End of macro FORTH_DSP_VALUEHL
3d31			 
3d31			;		push hl 
3d31			 
3d31					; destroy value TOS 
3d31			 
3d31					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d31 cd b3 22			call macro_forth_dsp_pop 
3d34				endm 
# End of macro FORTH_DSP_POP
3d34			 
3d34			;		pop hl 
3d34			 
3d34 3e 00				ld a,0 
3d36			 
3d36 bd					cp l 
3d37 20 08				jr nz, .tz_notzero 
3d39			 
3d39 bc					cp h 
3d3a			 
3d3a 20 05				jr nz, .tz_notzero 
3d3c			 
3d3c			 
3d3c 21 01 00				ld hl, FORTH_TRUE 
3d3f 18 03				jr .tz_done 
3d41			 
3d41 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3d44			 
3d44					; push value back onto stack for another op etc 
3d44			 
3d44			.tz_done: 
3d44 cd ff 1f				call forth_push_numhl 
3d47			 
3d47					NEXTW 
3d47 cd a7 fd			call parse_vector 
3d4a c3 e2 23			jp macro_next 
3d4d				endm 
# End of macro NEXTW
3d4d			.LESS: 
3d4d				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3d4d 2f				db WORD_SYS_CORE+27             
3d4e b9 3d			dw .GT            
3d50 02				db 1 + 1 
3d51 .. 00			db "<",0              
3d53				endm 
# End of macro CWHEAD
3d53			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
3d53				; TODO add floating point number detection 
3d53					if DEBUG_FORTH_WORDS_KEY 
3d53						DMARK "LES" 
3d53 f5				push af  
3d54 3a 68 3d			ld a, (.dmark)  
3d57 32 9d fd			ld (debug_mark),a  
3d5a 3a 69 3d			ld a, (.dmark+1)  
3d5d 32 9e fd			ld (debug_mark+1),a  
3d60 3a 6a 3d			ld a, (.dmark+2)  
3d63 32 9f fd			ld (debug_mark+2),a  
3d66 18 03			jr .pastdmark  
3d68 ..			.dmark: db "LES"  
3d6b f1			.pastdmark: pop af  
3d6c			endm  
# End of macro DMARK
3d6c						CALLMONITOR 
3d6c cd aa fd			call debug_vector  
3d6f				endm  
# End of macro CALLMONITOR
3d6f					endif 
3d6f					FORTH_DSP 
3d6f cd c1 21			call macro_forth_dsp 
3d72				endm 
# End of macro FORTH_DSP
3d72					;v5 FORTH_DSP_VALUE 
3d72 7e					ld a,(hl)	; get type of value on TOS 
3d73 fe 02				cp DS_TYPE_INUM  
3d75 28 00				jr z, .less_inum 
3d77			 
3d77				if FORTH_ENABLE_FLOATMATH 
3d77					jr .less_done 
3d77			 
3d77				endif 
3d77					 
3d77			 
3d77			.less_inum: 
3d77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d77 cd fb 21			call macro_dsp_valuehl 
3d7a				endm 
# End of macro FORTH_DSP_VALUEHL
3d7a			 
3d7a e5					push hl  ; u2 
3d7b			 
3d7b					; destroy value TOS 
3d7b			 
3d7b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d7b cd b3 22			call macro_forth_dsp_pop 
3d7e				endm 
# End of macro FORTH_DSP_POP
3d7e			 
3d7e			 
3d7e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d7e cd fb 21			call macro_dsp_valuehl 
3d81				endm 
# End of macro FORTH_DSP_VALUEHL
3d81			 
3d81 e5					push hl    ; u1 
3d82			 
3d82					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d82 cd b3 22			call macro_forth_dsp_pop 
3d85				endm 
# End of macro FORTH_DSP_POP
3d85			 
3d85			 
3d85 b7			 or a      ;clear carry flag 
3d86 01 00 00		 ld bc, FORTH_FALSE 
3d89 e1			  pop hl    ; u1 
3d8a d1			  pop de    ; u2 
3d8b ed 52		  sbc hl,de 
3d8d 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
3d8f			 
3d8f 01 01 00		 ld bc, FORTH_TRUE 
3d92			.lscont:  
3d92 c5					push bc 
3d93 e1					pop hl 
3d94			 
3d94					if DEBUG_FORTH_WORDS 
3d94						DMARK "LT1" 
3d94 f5				push af  
3d95 3a a9 3d			ld a, (.dmark)  
3d98 32 9d fd			ld (debug_mark),a  
3d9b 3a aa 3d			ld a, (.dmark+1)  
3d9e 32 9e fd			ld (debug_mark+1),a  
3da1 3a ab 3d			ld a, (.dmark+2)  
3da4 32 9f fd			ld (debug_mark+2),a  
3da7 18 03			jr .pastdmark  
3da9 ..			.dmark: db "LT1"  
3dac f1			.pastdmark: pop af  
3dad			endm  
# End of macro DMARK
3dad						CALLMONITOR 
3dad cd aa fd			call debug_vector  
3db0				endm  
# End of macro CALLMONITOR
3db0					endif 
3db0 cd ff 1f				call forth_push_numhl 
3db3			 
3db3					NEXTW 
3db3 cd a7 fd			call parse_vector 
3db6 c3 e2 23			jp macro_next 
3db9				endm 
# End of macro NEXTW
3db9			.GT: 
3db9				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3db9 30				db WORD_SYS_CORE+28             
3dba 25 3e			dw .EQUAL            
3dbc 02				db 1 + 1 
3dbd .. 00			db ">",0              
3dbf				endm 
# End of macro CWHEAD
3dbf			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3dbf				; TODO add floating point number detection 
3dbf					if DEBUG_FORTH_WORDS_KEY 
3dbf						DMARK "GRT" 
3dbf f5				push af  
3dc0 3a d4 3d			ld a, (.dmark)  
3dc3 32 9d fd			ld (debug_mark),a  
3dc6 3a d5 3d			ld a, (.dmark+1)  
3dc9 32 9e fd			ld (debug_mark+1),a  
3dcc 3a d6 3d			ld a, (.dmark+2)  
3dcf 32 9f fd			ld (debug_mark+2),a  
3dd2 18 03			jr .pastdmark  
3dd4 ..			.dmark: db "GRT"  
3dd7 f1			.pastdmark: pop af  
3dd8			endm  
# End of macro DMARK
3dd8						CALLMONITOR 
3dd8 cd aa fd			call debug_vector  
3ddb				endm  
# End of macro CALLMONITOR
3ddb					endif 
3ddb					FORTH_DSP 
3ddb cd c1 21			call macro_forth_dsp 
3dde				endm 
# End of macro FORTH_DSP
3dde					;FORTH_DSP_VALUE 
3dde 7e					ld a,(hl)	; get type of value on TOS 
3ddf fe 02				cp DS_TYPE_INUM  
3de1 28 00				jr z, .gt_inum 
3de3			 
3de3				if FORTH_ENABLE_FLOATMATH 
3de3					jr .gt_done 
3de3			 
3de3				endif 
3de3					 
3de3			 
3de3			.gt_inum: 
3de3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3de3 cd fb 21			call macro_dsp_valuehl 
3de6				endm 
# End of macro FORTH_DSP_VALUEHL
3de6			 
3de6 e5					push hl  ; u2 
3de7			 
3de7					; destroy value TOS 
3de7			 
3de7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3de7 cd b3 22			call macro_forth_dsp_pop 
3dea				endm 
# End of macro FORTH_DSP_POP
3dea			 
3dea			 
3dea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3dea cd fb 21			call macro_dsp_valuehl 
3ded				endm 
# End of macro FORTH_DSP_VALUEHL
3ded			 
3ded e5					push hl    ; u1 
3dee			 
3dee					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3dee cd b3 22			call macro_forth_dsp_pop 
3df1				endm 
# End of macro FORTH_DSP_POP
3df1			 
3df1			 
3df1 b7			 or a      ;clear carry flag 
3df2 01 00 00		 ld bc, FORTH_FALSE 
3df5 e1			  pop hl    ; u1 
3df6 d1			  pop de    ; u2 
3df7 ed 52		  sbc hl,de 
3df9 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3dfb			 
3dfb 01 01 00		 ld bc, FORTH_TRUE 
3dfe			.gtcont:  
3dfe c5					push bc 
3dff e1					pop hl 
3e00			 
3e00					if DEBUG_FORTH_WORDS 
3e00						DMARK "GT1" 
3e00 f5				push af  
3e01 3a 15 3e			ld a, (.dmark)  
3e04 32 9d fd			ld (debug_mark),a  
3e07 3a 16 3e			ld a, (.dmark+1)  
3e0a 32 9e fd			ld (debug_mark+1),a  
3e0d 3a 17 3e			ld a, (.dmark+2)  
3e10 32 9f fd			ld (debug_mark+2),a  
3e13 18 03			jr .pastdmark  
3e15 ..			.dmark: db "GT1"  
3e18 f1			.pastdmark: pop af  
3e19			endm  
# End of macro DMARK
3e19						CALLMONITOR 
3e19 cd aa fd			call debug_vector  
3e1c				endm  
# End of macro CALLMONITOR
3e1c					endif 
3e1c cd ff 1f				call forth_push_numhl 
3e1f			 
3e1f					NEXTW 
3e1f cd a7 fd			call parse_vector 
3e22 c3 e2 23			jp macro_next 
3e25				endm 
# End of macro NEXTW
3e25			.EQUAL: 
3e25				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3e25 31				db WORD_SYS_CORE+29             
3e26 93 3e			dw .ENDLOGIC            
3e28 02				db 1 + 1 
3e29 .. 00			db "=",0              
3e2b				endm 
# End of macro CWHEAD
3e2b			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
3e2b				; TODO add floating point number detection 
3e2b					if DEBUG_FORTH_WORDS_KEY 
3e2b						DMARK "EQ." 
3e2b f5				push af  
3e2c 3a 40 3e			ld a, (.dmark)  
3e2f 32 9d fd			ld (debug_mark),a  
3e32 3a 41 3e			ld a, (.dmark+1)  
3e35 32 9e fd			ld (debug_mark+1),a  
3e38 3a 42 3e			ld a, (.dmark+2)  
3e3b 32 9f fd			ld (debug_mark+2),a  
3e3e 18 03			jr .pastdmark  
3e40 ..			.dmark: db "EQ."  
3e43 f1			.pastdmark: pop af  
3e44			endm  
# End of macro DMARK
3e44						CALLMONITOR 
3e44 cd aa fd			call debug_vector  
3e47				endm  
# End of macro CALLMONITOR
3e47					endif 
3e47					FORTH_DSP 
3e47 cd c1 21			call macro_forth_dsp 
3e4a				endm 
# End of macro FORTH_DSP
3e4a					;v5 FORTH_DSP_VALUE 
3e4a 7e					ld a,(hl)	; get type of value on TOS 
3e4b fe 02				cp DS_TYPE_INUM  
3e4d 28 00				jr z, .eq_inum 
3e4f			 
3e4f				if FORTH_ENABLE_FLOATMATH 
3e4f					jr .eq_done 
3e4f			 
3e4f				endif 
3e4f					 
3e4f			 
3e4f			.eq_inum: 
3e4f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e4f cd fb 21			call macro_dsp_valuehl 
3e52				endm 
# End of macro FORTH_DSP_VALUEHL
3e52			 
3e52 e5					push hl 
3e53			 
3e53					; destroy value TOS 
3e53			 
3e53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e53 cd b3 22			call macro_forth_dsp_pop 
3e56				endm 
# End of macro FORTH_DSP_POP
3e56			 
3e56			 
3e56					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3e56 cd fb 21			call macro_dsp_valuehl 
3e59				endm 
# End of macro FORTH_DSP_VALUEHL
3e59			 
3e59					; one value on hl get other one back 
3e59			 
3e59 e5					push hl 
3e5a			 
3e5a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3e5a cd b3 22			call macro_forth_dsp_pop 
3e5d				endm 
# End of macro FORTH_DSP_POP
3e5d			 
3e5d 0e 00				ld c, FORTH_FALSE 
3e5f			 
3e5f e1					pop hl 
3e60 d1					pop de 
3e61			 
3e61 7b					ld a, e 
3e62 bd					cp l 
3e63			 
3e63 20 06				jr nz, .eq_done 
3e65			 
3e65 7a					ld a, d 
3e66 bc					cp h 
3e67			 
3e67 20 02				jr nz, .eq_done 
3e69			 
3e69 0e 01				ld c, FORTH_TRUE 
3e6b					 
3e6b			 
3e6b			 
3e6b			.eq_done: 
3e6b			 
3e6b					; TODO push value back onto stack for another op etc 
3e6b			 
3e6b 26 00				ld h, 0 
3e6d 69					ld l, c 
3e6e					if DEBUG_FORTH_WORDS 
3e6e						DMARK "EQ1" 
3e6e f5				push af  
3e6f 3a 83 3e			ld a, (.dmark)  
3e72 32 9d fd			ld (debug_mark),a  
3e75 3a 84 3e			ld a, (.dmark+1)  
3e78 32 9e fd			ld (debug_mark+1),a  
3e7b 3a 85 3e			ld a, (.dmark+2)  
3e7e 32 9f fd			ld (debug_mark+2),a  
3e81 18 03			jr .pastdmark  
3e83 ..			.dmark: db "EQ1"  
3e86 f1			.pastdmark: pop af  
3e87			endm  
# End of macro DMARK
3e87						CALLMONITOR 
3e87 cd aa fd			call debug_vector  
3e8a				endm  
# End of macro CALLMONITOR
3e8a					endif 
3e8a cd ff 1f				call forth_push_numhl 
3e8d			 
3e8d					NEXTW 
3e8d cd a7 fd			call parse_vector 
3e90 c3 e2 23			jp macro_next 
3e93				endm 
# End of macro NEXTW
3e93			 
3e93			 
3e93			.ENDLOGIC: 
3e93			; eof 
3e93			 
3e93			 
# End of file forth_words_logic.asm
3e93			include "forth_words_maths.asm" 
3e93			 
3e93			; | ## Maths Words 
3e93			 
3e93			.PLUS:	 
3e93				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3e93 15				db WORD_SYS_CORE+1             
3e94 f7 3e			dw .NEG            
3e96 02				db 1 + 1 
3e97 .. 00			db "+",0              
3e99				endm 
# End of macro CWHEAD
3e99			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
3e99					if DEBUG_FORTH_WORDS_KEY 
3e99						DMARK "PLU" 
3e99 f5				push af  
3e9a 3a ae 3e			ld a, (.dmark)  
3e9d 32 9d fd			ld (debug_mark),a  
3ea0 3a af 3e			ld a, (.dmark+1)  
3ea3 32 9e fd			ld (debug_mark+1),a  
3ea6 3a b0 3e			ld a, (.dmark+2)  
3ea9 32 9f fd			ld (debug_mark+2),a  
3eac 18 03			jr .pastdmark  
3eae ..			.dmark: db "PLU"  
3eb1 f1			.pastdmark: pop af  
3eb2			endm  
# End of macro DMARK
3eb2						CALLMONITOR 
3eb2 cd aa fd			call debug_vector  
3eb5				endm  
# End of macro CALLMONITOR
3eb5					endif 
3eb5					; add top two values and push back result 
3eb5			 
3eb5					;for v5 FORTH_DSP_VALUE 
3eb5					FORTH_DSP 
3eb5 cd c1 21			call macro_forth_dsp 
3eb8				endm 
# End of macro FORTH_DSP
3eb8 7e					ld a,(hl)	; get type of value on TOS 
3eb9 fe 02				cp DS_TYPE_INUM  
3ebb 28 06				jr z, .dot_inum 
3ebd			 
3ebd					NEXTW 
3ebd cd a7 fd			call parse_vector 
3ec0 c3 e2 23			jp macro_next 
3ec3				endm 
# End of macro NEXTW
3ec3			 
3ec3			; float maths 
3ec3			 
3ec3				if FORTH_ENABLE_FLOATMATH 
3ec3						inc hl      ; now at start of numeric as string 
3ec3			 
3ec3					if DEBUG_FORTH_MATHS 
3ec3						DMARK "ADD" 
3ec3				CALLMONITOR 
3ec3					endif 
3ec3			 
3ec3					;ld ix, hl 
3ec3					call CON 
3ec3			 
3ec3			 
3ec3					push hl 
3ec3					 
3ec3					 
3ec3			 
3ec3						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3ec3			 
3ec3					; get next number 
3ec3			 
3ec3						FORTH_DSP_VALUE 
3ec3			 
3ec3						inc hl      ; now at start of numeric as string 
3ec3			 
3ec3					;ld ix, hl 
3ec3					call CON 
3ec3			 
3ec3					push hl 
3ec3			 
3ec3			 
3ec3						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ec3			 
3ec3						; TODO do add 
3ec3			 
3ec3						call IADD 
3ec3			 
3ec3						; TODO get result back as ascii 
3ec3			 
3ec3						; TODO push result  
3ec3			 
3ec3			 
3ec3			 
3ec3						jr .dot_done 
3ec3				endif 
3ec3			 
3ec3			.dot_inum: 
3ec3			 
3ec3			 
3ec3					if DEBUG_FORTH_DOT 
3ec3						DMARK "+IT" 
3ec3 f5				push af  
3ec4 3a d8 3e			ld a, (.dmark)  
3ec7 32 9d fd			ld (debug_mark),a  
3eca 3a d9 3e			ld a, (.dmark+1)  
3ecd 32 9e fd			ld (debug_mark+1),a  
3ed0 3a da 3e			ld a, (.dmark+2)  
3ed3 32 9f fd			ld (debug_mark+2),a  
3ed6 18 03			jr .pastdmark  
3ed8 ..			.dmark: db "+IT"  
3edb f1			.pastdmark: pop af  
3edc			endm  
# End of macro DMARK
3edc				CALLMONITOR 
3edc cd aa fd			call debug_vector  
3edf				endm  
# End of macro CALLMONITOR
3edf					endif 
3edf			 
3edf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3edf cd fb 21			call macro_dsp_valuehl 
3ee2				endm 
# End of macro FORTH_DSP_VALUEHL
3ee2			 
3ee2				; TODO add floating point number detection 
3ee2			 
3ee2 e5					push hl 
3ee3			 
3ee3					; destroy value TOS 
3ee3			 
3ee3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ee3 cd b3 22			call macro_forth_dsp_pop 
3ee6				endm 
# End of macro FORTH_DSP_POP
3ee6			 
3ee6			 
3ee6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ee6 cd fb 21			call macro_dsp_valuehl 
3ee9				endm 
# End of macro FORTH_DSP_VALUEHL
3ee9			 
3ee9					; one value on hl get other one back 
3ee9			 
3ee9 d1					pop de 
3eea			 
3eea					; do the add 
3eea			 
3eea 19					add hl,de 
3eeb			 
3eeb					; save it 
3eeb			 
3eeb			;		push hl	 
3eeb			 
3eeb					; 
3eeb			 
3eeb					; destroy value TOS 
3eeb			 
3eeb					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3eeb cd b3 22			call macro_forth_dsp_pop 
3eee				endm 
# End of macro FORTH_DSP_POP
3eee			 
3eee					; TODO push value back onto stack for another op etc 
3eee			 
3eee			;		pop hl 
3eee			 
3eee			.dot_done: 
3eee cd ff 1f				call forth_push_numhl 
3ef1			 
3ef1					NEXTW 
3ef1 cd a7 fd			call parse_vector 
3ef4 c3 e2 23			jp macro_next 
3ef7				endm 
# End of macro NEXTW
3ef7			.NEG: 
3ef7			 
3ef7				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3ef7 17				db WORD_SYS_CORE+3             
3ef8 40 3f			dw .DIV            
3efa 02				db 1 + 1 
3efb .. 00			db "-",0              
3efd				endm 
# End of macro CWHEAD
3efd			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
3efd					if DEBUG_FORTH_WORDS_KEY 
3efd						DMARK "SUB" 
3efd f5				push af  
3efe 3a 12 3f			ld a, (.dmark)  
3f01 32 9d fd			ld (debug_mark),a  
3f04 3a 13 3f			ld a, (.dmark+1)  
3f07 32 9e fd			ld (debug_mark+1),a  
3f0a 3a 14 3f			ld a, (.dmark+2)  
3f0d 32 9f fd			ld (debug_mark+2),a  
3f10 18 03			jr .pastdmark  
3f12 ..			.dmark: db "SUB"  
3f15 f1			.pastdmark: pop af  
3f16			endm  
# End of macro DMARK
3f16						CALLMONITOR 
3f16 cd aa fd			call debug_vector  
3f19				endm  
# End of macro CALLMONITOR
3f19					endif 
3f19			 
3f19			 
3f19				; TODO add floating point number detection 
3f19					; v5 FORTH_DSP_VALUE 
3f19					FORTH_DSP 
3f19 cd c1 21			call macro_forth_dsp 
3f1c				endm 
# End of macro FORTH_DSP
3f1c 7e					ld a,(hl)	; get type of value on TOS 
3f1d fe 02				cp DS_TYPE_INUM  
3f1f 28 06				jr z, .neg_inum 
3f21			 
3f21					NEXTW 
3f21 cd a7 fd			call parse_vector 
3f24 c3 e2 23			jp macro_next 
3f27				endm 
# End of macro NEXTW
3f27			 
3f27			; float maths 
3f27			 
3f27				if FORTH_ENABLE_FLOATMATH 
3f27					jr .neg_done 
3f27			 
3f27				endif 
3f27					 
3f27			 
3f27			.neg_inum: 
3f27					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f27 cd fb 21			call macro_dsp_valuehl 
3f2a				endm 
# End of macro FORTH_DSP_VALUEHL
3f2a			 
3f2a e5					push hl 
3f2b			 
3f2b					; destroy value TOS 
3f2b			 
3f2b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f2b cd b3 22			call macro_forth_dsp_pop 
3f2e				endm 
# End of macro FORTH_DSP_POP
3f2e			 
3f2e			 
3f2e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f2e cd fb 21			call macro_dsp_valuehl 
3f31				endm 
# End of macro FORTH_DSP_VALUEHL
3f31			 
3f31					; one value on hl get other one back 
3f31			 
3f31 d1					pop de 
3f32			 
3f32					; do the sub 
3f32			;		ex de, hl 
3f32			 
3f32 ed 52				sbc hl,de 
3f34			 
3f34					; save it 
3f34			 
3f34			;		push hl	 
3f34			 
3f34					; 
3f34			 
3f34					; destroy value TOS 
3f34			 
3f34					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f34 cd b3 22			call macro_forth_dsp_pop 
3f37				endm 
# End of macro FORTH_DSP_POP
3f37			 
3f37					; TODO push value back onto stack for another op etc 
3f37			 
3f37			;		pop hl 
3f37			 
3f37 cd ff 1f				call forth_push_numhl 
3f3a			.neg_done: 
3f3a			 
3f3a					NEXTW 
3f3a cd a7 fd			call parse_vector 
3f3d c3 e2 23			jp macro_next 
3f40				endm 
# End of macro NEXTW
3f40			.DIV: 
3f40				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3f40 18				db WORD_SYS_CORE+4             
3f41 93 3f			dw .MUL            
3f43 02				db 1 + 1 
3f44 .. 00			db "/",0              
3f46				endm 
# End of macro CWHEAD
3f46			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
3f46					if DEBUG_FORTH_WORDS_KEY 
3f46						DMARK "DIV" 
3f46 f5				push af  
3f47 3a 5b 3f			ld a, (.dmark)  
3f4a 32 9d fd			ld (debug_mark),a  
3f4d 3a 5c 3f			ld a, (.dmark+1)  
3f50 32 9e fd			ld (debug_mark+1),a  
3f53 3a 5d 3f			ld a, (.dmark+2)  
3f56 32 9f fd			ld (debug_mark+2),a  
3f59 18 03			jr .pastdmark  
3f5b ..			.dmark: db "DIV"  
3f5e f1			.pastdmark: pop af  
3f5f			endm  
# End of macro DMARK
3f5f						CALLMONITOR 
3f5f cd aa fd			call debug_vector  
3f62				endm  
# End of macro CALLMONITOR
3f62					endif 
3f62				; TODO add floating point number detection 
3f62					; v5 FORTH_DSP_VALUE 
3f62					FORTH_DSP 
3f62 cd c1 21			call macro_forth_dsp 
3f65				endm 
# End of macro FORTH_DSP
3f65 7e					ld a,(hl)	; get type of value on TOS 
3f66 fe 02				cp DS_TYPE_INUM  
3f68 28 06				jr z, .div_inum 
3f6a			 
3f6a				if FORTH_ENABLE_FLOATMATH 
3f6a					jr .div_done 
3f6a			 
3f6a				endif 
3f6a					NEXTW 
3f6a cd a7 fd			call parse_vector 
3f6d c3 e2 23			jp macro_next 
3f70				endm 
# End of macro NEXTW
3f70			.div_inum: 
3f70			 
3f70					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f70 cd fb 21			call macro_dsp_valuehl 
3f73				endm 
# End of macro FORTH_DSP_VALUEHL
3f73			 
3f73 e5					push hl    ; to go to bc 
3f74			 
3f74					; destroy value TOS 
3f74			 
3f74					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f74 cd b3 22			call macro_forth_dsp_pop 
3f77				endm 
# End of macro FORTH_DSP_POP
3f77			 
3f77			 
3f77					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3f77 cd fb 21			call macro_dsp_valuehl 
3f7a				endm 
# End of macro FORTH_DSP_VALUEHL
3f7a			 
3f7a					; hl to go to de 
3f7a			 
3f7a e5					push hl 
3f7b			 
3f7b c1					pop bc 
3f7c d1					pop de		 
3f7d			 
3f7d			 
3f7d					if DEBUG_FORTH_MATHS 
3f7d						DMARK "DIV" 
3f7d				CALLMONITOR 
3f7d					endif 
3f7d					; one value on hl but move to a get other one back 
3f7d			 
3f7d			        
3f7d cd 09 0f			call Div16 
3f80			 
3f80			;	push af	 
3f80 e5				push hl 
3f81 c5				push bc 
3f82			 
3f82					if DEBUG_FORTH_MATHS 
3f82						DMARK "DI1" 
3f82				CALLMONITOR 
3f82					endif 
3f82			 
3f82					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3f82 cd b3 22			call macro_forth_dsp_pop 
3f85				endm 
# End of macro FORTH_DSP_POP
3f85			 
3f85			 
3f85			 
3f85 e1					pop hl    ; result 
3f86			 
3f86 cd ff 1f				call forth_push_numhl 
3f89			 
3f89 e1					pop hl    ; reminder 
3f8a			;		ld h,0 
3f8a			;		ld l,d 
3f8a			 
3f8a cd ff 1f				call forth_push_numhl 
3f8d			.div_done: 
3f8d					NEXTW 
3f8d cd a7 fd			call parse_vector 
3f90 c3 e2 23			jp macro_next 
3f93				endm 
# End of macro NEXTW
3f93			.MUL: 
3f93				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3f93 19				db WORD_SYS_CORE+5             
3f94 de 3f			dw .MIN            
3f96 02				db 1 + 1 
3f97 .. 00			db "*",0              
3f99				endm 
# End of macro CWHEAD
3f99			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
3f99				; TODO add floating point number detection 
3f99					if DEBUG_FORTH_WORDS_KEY 
3f99						DMARK "MUL" 
3f99 f5				push af  
3f9a 3a ae 3f			ld a, (.dmark)  
3f9d 32 9d fd			ld (debug_mark),a  
3fa0 3a af 3f			ld a, (.dmark+1)  
3fa3 32 9e fd			ld (debug_mark+1),a  
3fa6 3a b0 3f			ld a, (.dmark+2)  
3fa9 32 9f fd			ld (debug_mark+2),a  
3fac 18 03			jr .pastdmark  
3fae ..			.dmark: db "MUL"  
3fb1 f1			.pastdmark: pop af  
3fb2			endm  
# End of macro DMARK
3fb2						CALLMONITOR 
3fb2 cd aa fd			call debug_vector  
3fb5				endm  
# End of macro CALLMONITOR
3fb5					endif 
3fb5					FORTH_DSP 
3fb5 cd c1 21			call macro_forth_dsp 
3fb8				endm 
# End of macro FORTH_DSP
3fb8					; v5 FORTH_DSP_VALUE 
3fb8 7e					ld a,(hl)	; get type of value on TOS 
3fb9 fe 02				cp DS_TYPE_INUM  
3fbb 28 06				jr z, .mul_inum 
3fbd			 
3fbd				if FORTH_ENABLE_FLOATMATH 
3fbd					jr .mul_done 
3fbd			 
3fbd				endif 
3fbd			 
3fbd					NEXTW 
3fbd cd a7 fd			call parse_vector 
3fc0 c3 e2 23			jp macro_next 
3fc3				endm 
# End of macro NEXTW
3fc3			.mul_inum:	 
3fc3			 
3fc3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fc3 cd fb 21			call macro_dsp_valuehl 
3fc6				endm 
# End of macro FORTH_DSP_VALUEHL
3fc6			 
3fc6 e5					push hl 
3fc7			 
3fc7					; destroy value TOS 
3fc7			 
3fc7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fc7 cd b3 22			call macro_forth_dsp_pop 
3fca				endm 
# End of macro FORTH_DSP_POP
3fca			 
3fca			 
3fca					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3fca cd fb 21			call macro_dsp_valuehl 
3fcd				endm 
# End of macro FORTH_DSP_VALUEHL
3fcd			 
3fcd					; one value on hl but move to a get other one back 
3fcd			 
3fcd 7d					ld a, l 
3fce			 
3fce d1					pop de 
3fcf			 
3fcf					; do the mull 
3fcf			;		ex de, hl 
3fcf			 
3fcf cd 2f 0f				call Mult16 
3fd2					; save it 
3fd2			 
3fd2			;		push hl	 
3fd2			 
3fd2					; 
3fd2			 
3fd2					; destroy value TOS 
3fd2			 
3fd2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3fd2 cd b3 22			call macro_forth_dsp_pop 
3fd5				endm 
# End of macro FORTH_DSP_POP
3fd5			 
3fd5					; TODO push value back onto stack for another op etc 
3fd5			 
3fd5			;		pop hl 
3fd5			 
3fd5 cd ff 1f				call forth_push_numhl 
3fd8			 
3fd8			.mul_done: 
3fd8					NEXTW 
3fd8 cd a7 fd			call parse_vector 
3fdb c3 e2 23			jp macro_next 
3fde				endm 
# End of macro NEXTW
3fde			 
3fde			 
3fde			 
3fde			 
3fde			.MIN: 
3fde				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
3fde 49				db WORD_SYS_CORE+53             
3fdf 65 40			dw .MAX            
3fe1 04				db 3 + 1 
3fe2 .. 00			db "MIN",0              
3fe6				endm 
# End of macro CWHEAD
3fe6			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3fe6					if DEBUG_FORTH_WORDS_KEY 
3fe6						DMARK "MIN" 
3fe6 f5				push af  
3fe7 3a fb 3f			ld a, (.dmark)  
3fea 32 9d fd			ld (debug_mark),a  
3fed 3a fc 3f			ld a, (.dmark+1)  
3ff0 32 9e fd			ld (debug_mark+1),a  
3ff3 3a fd 3f			ld a, (.dmark+2)  
3ff6 32 9f fd			ld (debug_mark+2),a  
3ff9 18 03			jr .pastdmark  
3ffb ..			.dmark: db "MIN"  
3ffe f1			.pastdmark: pop af  
3fff			endm  
# End of macro DMARK
3fff						CALLMONITOR 
3fff cd aa fd			call debug_vector  
4002				endm  
# End of macro CALLMONITOR
4002					endif 
4002					; get u2 
4002			 
4002					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4002 cd fb 21			call macro_dsp_valuehl 
4005				endm 
# End of macro FORTH_DSP_VALUEHL
4005			 
4005 e5					push hl   ; u2 
4006			 
4006					; destroy value TOS 
4006			 
4006					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4006 cd b3 22			call macro_forth_dsp_pop 
4009				endm 
# End of macro FORTH_DSP_POP
4009			 
4009					; get u1 
4009			 
4009					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4009 cd fb 21			call macro_dsp_valuehl 
400c				endm 
# End of macro FORTH_DSP_VALUEHL
400c			 
400c e5					push hl  ; u1 
400d			 
400d					; destroy value TOS 
400d			 
400d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
400d cd b3 22			call macro_forth_dsp_pop 
4010				endm 
# End of macro FORTH_DSP_POP
4010			 
4010 b7			 or a      ;clear carry flag 
4011 e1			  pop hl    ; u1 
4012 d1			  pop de    ; u2 
4013 e5				push hl   ; saved in case hl is lowest 
4014 ed 52		  sbc hl,de 
4016 30 26		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
4018			 
4018 e1				pop hl 
4019					if DEBUG_FORTH_WORDS 
4019						DMARK "MIN" 
4019 f5				push af  
401a 3a 2e 40			ld a, (.dmark)  
401d 32 9d fd			ld (debug_mark),a  
4020 3a 2f 40			ld a, (.dmark+1)  
4023 32 9e fd			ld (debug_mark+1),a  
4026 3a 30 40			ld a, (.dmark+2)  
4029 32 9f fd			ld (debug_mark+2),a  
402c 18 03			jr .pastdmark  
402e ..			.dmark: db "MIN"  
4031 f1			.pastdmark: pop af  
4032			endm  
# End of macro DMARK
4032						CALLMONITOR 
4032 cd aa fd			call debug_vector  
4035				endm  
# End of macro CALLMONITOR
4035					endif 
4035 cd ff 1f				call forth_push_numhl 
4038			 
4038				       NEXTW 
4038 cd a7 fd			call parse_vector 
403b c3 e2 23			jp macro_next 
403e				endm 
# End of macro NEXTW
403e			 
403e			.mincont:  
403e c1				pop bc   ; tidy up 
403f eb				ex de , hl  
4040					if DEBUG_FORTH_WORDS 
4040						DMARK "MI1" 
4040 f5				push af  
4041 3a 55 40			ld a, (.dmark)  
4044 32 9d fd			ld (debug_mark),a  
4047 3a 56 40			ld a, (.dmark+1)  
404a 32 9e fd			ld (debug_mark+1),a  
404d 3a 57 40			ld a, (.dmark+2)  
4050 32 9f fd			ld (debug_mark+2),a  
4053 18 03			jr .pastdmark  
4055 ..			.dmark: db "MI1"  
4058 f1			.pastdmark: pop af  
4059			endm  
# End of macro DMARK
4059						CALLMONITOR 
4059 cd aa fd			call debug_vector  
405c				endm  
# End of macro CALLMONITOR
405c					endif 
405c cd ff 1f				call forth_push_numhl 
405f			 
405f				       NEXTW 
405f cd a7 fd			call parse_vector 
4062 c3 e2 23			jp macro_next 
4065				endm 
# End of macro NEXTW
4065			.MAX: 
4065				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
4065 4a				db WORD_SYS_CORE+54             
4066 ec 40			dw .RND16            
4068 04				db 3 + 1 
4069 .. 00			db "MAX",0              
406d				endm 
# End of macro CWHEAD
406d			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
406d					if DEBUG_FORTH_WORDS_KEY 
406d						DMARK "MAX" 
406d f5				push af  
406e 3a 82 40			ld a, (.dmark)  
4071 32 9d fd			ld (debug_mark),a  
4074 3a 83 40			ld a, (.dmark+1)  
4077 32 9e fd			ld (debug_mark+1),a  
407a 3a 84 40			ld a, (.dmark+2)  
407d 32 9f fd			ld (debug_mark+2),a  
4080 18 03			jr .pastdmark  
4082 ..			.dmark: db "MAX"  
4085 f1			.pastdmark: pop af  
4086			endm  
# End of macro DMARK
4086						CALLMONITOR 
4086 cd aa fd			call debug_vector  
4089				endm  
# End of macro CALLMONITOR
4089					endif 
4089					; get u2 
4089			 
4089					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4089 cd fb 21			call macro_dsp_valuehl 
408c				endm 
# End of macro FORTH_DSP_VALUEHL
408c			 
408c e5					push hl   ; u2 
408d			 
408d					; destroy value TOS 
408d			 
408d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
408d cd b3 22			call macro_forth_dsp_pop 
4090				endm 
# End of macro FORTH_DSP_POP
4090			 
4090					; get u1 
4090			 
4090					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4090 cd fb 21			call macro_dsp_valuehl 
4093				endm 
# End of macro FORTH_DSP_VALUEHL
4093			 
4093 e5					push hl  ; u1 
4094			 
4094					; destroy value TOS 
4094			 
4094					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4094 cd b3 22			call macro_forth_dsp_pop 
4097				endm 
# End of macro FORTH_DSP_POP
4097			 
4097 b7			 or a      ;clear carry flag 
4098 e1			  pop hl    ; u1 
4099 d1			  pop de    ; u2 
409a e5				push hl   ; saved in case hl is lowest 
409b ed 52		  sbc hl,de 
409d 38 26		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
409f			 
409f e1				pop hl 
40a0					if DEBUG_FORTH_WORDS 
40a0						DMARK "MAX" 
40a0 f5				push af  
40a1 3a b5 40			ld a, (.dmark)  
40a4 32 9d fd			ld (debug_mark),a  
40a7 3a b6 40			ld a, (.dmark+1)  
40aa 32 9e fd			ld (debug_mark+1),a  
40ad 3a b7 40			ld a, (.dmark+2)  
40b0 32 9f fd			ld (debug_mark+2),a  
40b3 18 03			jr .pastdmark  
40b5 ..			.dmark: db "MAX"  
40b8 f1			.pastdmark: pop af  
40b9			endm  
# End of macro DMARK
40b9						CALLMONITOR 
40b9 cd aa fd			call debug_vector  
40bc				endm  
# End of macro CALLMONITOR
40bc					endif 
40bc cd ff 1f				call forth_push_numhl 
40bf			 
40bf				       NEXTW 
40bf cd a7 fd			call parse_vector 
40c2 c3 e2 23			jp macro_next 
40c5				endm 
# End of macro NEXTW
40c5			 
40c5			.maxcont:  
40c5 c1				pop bc   ; tidy up 
40c6 eb				ex de , hl  
40c7					if DEBUG_FORTH_WORDS 
40c7						DMARK "MA1" 
40c7 f5				push af  
40c8 3a dc 40			ld a, (.dmark)  
40cb 32 9d fd			ld (debug_mark),a  
40ce 3a dd 40			ld a, (.dmark+1)  
40d1 32 9e fd			ld (debug_mark+1),a  
40d4 3a de 40			ld a, (.dmark+2)  
40d7 32 9f fd			ld (debug_mark+2),a  
40da 18 03			jr .pastdmark  
40dc ..			.dmark: db "MA1"  
40df f1			.pastdmark: pop af  
40e0			endm  
# End of macro DMARK
40e0						CALLMONITOR 
40e0 cd aa fd			call debug_vector  
40e3				endm  
# End of macro CALLMONITOR
40e3					endif 
40e3 cd ff 1f				call forth_push_numhl 
40e6				       NEXTW 
40e6 cd a7 fd			call parse_vector 
40e9 c3 e2 23			jp macro_next 
40ec				endm 
# End of macro NEXTW
40ec			 
40ec			.RND16: 
40ec				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
40ec 4e				db WORD_SYS_CORE+58             
40ed 1e 41			dw .RND8            
40ef 06				db 5 + 1 
40f0 .. 00			db "RND16",0              
40f6				endm 
# End of macro CWHEAD
40f6			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
40f6					if DEBUG_FORTH_WORDS_KEY 
40f6						DMARK "R16" 
40f6 f5				push af  
40f7 3a 0b 41			ld a, (.dmark)  
40fa 32 9d fd			ld (debug_mark),a  
40fd 3a 0c 41			ld a, (.dmark+1)  
4100 32 9e fd			ld (debug_mark+1),a  
4103 3a 0d 41			ld a, (.dmark+2)  
4106 32 9f fd			ld (debug_mark+2),a  
4109 18 03			jr .pastdmark  
410b ..			.dmark: db "R16"  
410e f1			.pastdmark: pop af  
410f			endm  
# End of macro DMARK
410f						CALLMONITOR 
410f cd aa fd			call debug_vector  
4112				endm  
# End of macro CALLMONITOR
4112					endif 
4112 cd d3 0e				call prng16  
4115 cd ff 1f				call forth_push_numhl 
4118				       NEXTW 
4118 cd a7 fd			call parse_vector 
411b c3 e2 23			jp macro_next 
411e				endm 
# End of macro NEXTW
411e			.RND8: 
411e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
411e 60				db WORD_SYS_CORE+76             
411f 56 41			dw .RND            
4121 05				db 4 + 1 
4122 .. 00			db "RND8",0              
4127				endm 
# End of macro CWHEAD
4127			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
4127					if DEBUG_FORTH_WORDS_KEY 
4127						DMARK "RN8" 
4127 f5				push af  
4128 3a 3c 41			ld a, (.dmark)  
412b 32 9d fd			ld (debug_mark),a  
412e 3a 3d 41			ld a, (.dmark+1)  
4131 32 9e fd			ld (debug_mark+1),a  
4134 3a 3e 41			ld a, (.dmark+2)  
4137 32 9f fd			ld (debug_mark+2),a  
413a 18 03			jr .pastdmark  
413c ..			.dmark: db "RN8"  
413f f1			.pastdmark: pop af  
4140			endm  
# End of macro DMARK
4140						CALLMONITOR 
4140 cd aa fd			call debug_vector  
4143				endm  
# End of macro CALLMONITOR
4143					endif 
4143 2a db fa				ld hl,(xrandc) 
4146 23					inc hl 
4147 cd ed 0e				call xrnd 
414a 6f					ld l,a	 
414b 26 00				ld h,0 
414d cd ff 1f				call forth_push_numhl 
4150				       NEXTW 
4150 cd a7 fd			call parse_vector 
4153 c3 e2 23			jp macro_next 
4156				endm 
# End of macro NEXTW
4156			.RND: 
4156				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
4156 60				db WORD_SYS_CORE+76             
4157 5f 42			dw .ENDMATHS            
4159 04				db 3 + 1 
415a .. 00			db "RND",0              
415e				endm 
# End of macro CWHEAD
415e			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
415e			 
415e					if DEBUG_FORTH_WORDS_KEY 
415e						DMARK "RND" 
415e f5				push af  
415f 3a 73 41			ld a, (.dmark)  
4162 32 9d fd			ld (debug_mark),a  
4165 3a 74 41			ld a, (.dmark+1)  
4168 32 9e fd			ld (debug_mark+1),a  
416b 3a 75 41			ld a, (.dmark+2)  
416e 32 9f fd			ld (debug_mark+2),a  
4171 18 03			jr .pastdmark  
4173 ..			.dmark: db "RND"  
4176 f1			.pastdmark: pop af  
4177			endm  
# End of macro DMARK
4177						CALLMONITOR 
4177 cd aa fd			call debug_vector  
417a				endm  
# End of macro CALLMONITOR
417a					endif 
417a					 
417a					FORTH_DSP_VALUEHL    ; upper range 
417a cd fb 21			call macro_dsp_valuehl 
417d				endm 
# End of macro FORTH_DSP_VALUEHL
417d			 
417d 22 df fa				ld (LFSRSeed), hl	 
4180			 
4180					if DEBUG_FORTH_WORDS 
4180						DMARK "RN1" 
4180 f5				push af  
4181 3a 95 41			ld a, (.dmark)  
4184 32 9d fd			ld (debug_mark),a  
4187 3a 96 41			ld a, (.dmark+1)  
418a 32 9e fd			ld (debug_mark+1),a  
418d 3a 97 41			ld a, (.dmark+2)  
4190 32 9f fd			ld (debug_mark+2),a  
4193 18 03			jr .pastdmark  
4195 ..			.dmark: db "RN1"  
4198 f1			.pastdmark: pop af  
4199			endm  
# End of macro DMARK
4199						CALLMONITOR 
4199 cd aa fd			call debug_vector  
419c				endm  
# End of macro CALLMONITOR
419c					endif 
419c					FORTH_DSP_POP 
419c cd b3 22			call macro_forth_dsp_pop 
419f				endm 
# End of macro FORTH_DSP_POP
419f			 
419f					FORTH_DSP_VALUEHL    ; low range 
419f cd fb 21			call macro_dsp_valuehl 
41a2				endm 
# End of macro FORTH_DSP_VALUEHL
41a2			 
41a2					if DEBUG_FORTH_WORDS 
41a2						DMARK "RN2" 
41a2 f5				push af  
41a3 3a b7 41			ld a, (.dmark)  
41a6 32 9d fd			ld (debug_mark),a  
41a9 3a b8 41			ld a, (.dmark+1)  
41ac 32 9e fd			ld (debug_mark+1),a  
41af 3a b9 41			ld a, (.dmark+2)  
41b2 32 9f fd			ld (debug_mark+2),a  
41b5 18 03			jr .pastdmark  
41b7 ..			.dmark: db "RN2"  
41ba f1			.pastdmark: pop af  
41bb			endm  
# End of macro DMARK
41bb						CALLMONITOR 
41bb cd aa fd			call debug_vector  
41be				endm  
# End of macro CALLMONITOR
41be					endif 
41be 22 e1 fa				ld (LFSRSeed+2), hl 
41c1			 
41c1					FORTH_DSP_POP 
41c1 cd b3 22			call macro_forth_dsp_pop 
41c4				endm 
# End of macro FORTH_DSP_POP
41c4			 
41c4 e5					push hl 
41c5			 
41c5 e1			.inrange:	pop hl 
41c6 cd d3 0e				call prng16  
41c9					if DEBUG_FORTH_WORDS 
41c9						DMARK "RN3" 
41c9 f5				push af  
41ca 3a de 41			ld a, (.dmark)  
41cd 32 9d fd			ld (debug_mark),a  
41d0 3a df 41			ld a, (.dmark+1)  
41d3 32 9e fd			ld (debug_mark+1),a  
41d6 3a e0 41			ld a, (.dmark+2)  
41d9 32 9f fd			ld (debug_mark+2),a  
41dc 18 03			jr .pastdmark  
41de ..			.dmark: db "RN3"  
41e1 f1			.pastdmark: pop af  
41e2			endm  
# End of macro DMARK
41e2						CALLMONITOR 
41e2 cd aa fd			call debug_vector  
41e5				endm  
# End of macro CALLMONITOR
41e5					endif 
41e5					 
41e5					; if the range is 8bit knock out the high byte 
41e5			 
41e5 ed 5b df fa			ld de, (LFSRSeed)     ; check high level 
41e9			 
41e9 3e 00				ld a, 0 
41eb ba					cp d  
41ec 20 1e				jr nz, .hirange 
41ee 26 00				ld h, 0   ; knock it down to 8bit 
41f0			 
41f0					if DEBUG_FORTH_WORDS 
41f0						DMARK "RNk" 
41f0 f5				push af  
41f1 3a 05 42			ld a, (.dmark)  
41f4 32 9d fd			ld (debug_mark),a  
41f7 3a 06 42			ld a, (.dmark+1)  
41fa 32 9e fd			ld (debug_mark+1),a  
41fd 3a 07 42			ld a, (.dmark+2)  
4200 32 9f fd			ld (debug_mark+2),a  
4203 18 03			jr .pastdmark  
4205 ..			.dmark: db "RNk"  
4208 f1			.pastdmark: pop af  
4209			endm  
# End of macro DMARK
4209						CALLMONITOR 
4209 cd aa fd			call debug_vector  
420c				endm  
# End of macro CALLMONITOR
420c					endif 
420c			.hirange:   
420c e5					push hl  
420d b7					or a  
420e ed 52		                sbc hl, de 
4210			 
4210					;call cmp16 
4210			 
4210 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
4212 e1					pop hl 
4213 e5					push hl 
4214			 
4214					if DEBUG_FORTH_WORDS 
4214						DMARK "RN4" 
4214 f5				push af  
4215 3a 29 42			ld a, (.dmark)  
4218 32 9d fd			ld (debug_mark),a  
421b 3a 2a 42			ld a, (.dmark+1)  
421e 32 9e fd			ld (debug_mark+1),a  
4221 3a 2b 42			ld a, (.dmark+2)  
4224 32 9f fd			ld (debug_mark+2),a  
4227 18 03			jr .pastdmark  
4229 ..			.dmark: db "RN4"  
422c f1			.pastdmark: pop af  
422d			endm  
# End of macro DMARK
422d						CALLMONITOR 
422d cd aa fd			call debug_vector  
4230				endm  
# End of macro CALLMONITOR
4230					endif 
4230 ed 5b e1 fa			ld de, (LFSRSeed+2)   ; check low range 
4234					;call cmp16 
4234				 
4234 b7					or a  
4235 ed 52		                sbc hl, de 
4237 38 8c				jr c, .inrange 
4239			 
4239 e1					pop hl 
423a					 
423a					if DEBUG_FORTH_WORDS 
423a						DMARK "RNd" 
423a f5				push af  
423b 3a 4f 42			ld a, (.dmark)  
423e 32 9d fd			ld (debug_mark),a  
4241 3a 50 42			ld a, (.dmark+1)  
4244 32 9e fd			ld (debug_mark+1),a  
4247 3a 51 42			ld a, (.dmark+2)  
424a 32 9f fd			ld (debug_mark+2),a  
424d 18 03			jr .pastdmark  
424f ..			.dmark: db "RNd"  
4252 f1			.pastdmark: pop af  
4253			endm  
# End of macro DMARK
4253						CALLMONITOR 
4253 cd aa fd			call debug_vector  
4256				endm  
# End of macro CALLMONITOR
4256					endif 
4256			 
4256			 
4256 cd ff 1f				call forth_push_numhl 
4259				       NEXTW 
4259 cd a7 fd			call parse_vector 
425c c3 e2 23			jp macro_next 
425f				endm 
# End of macro NEXTW
425f			 
425f			.ENDMATHS: 
425f			 
425f			; eof 
425f			 
# End of file forth_words_maths.asm
425f			include "forth_words_display.asm" 
425f			 
425f			; | ## Display Words 
425f			 
425f			.ACT: 
425f			 
425f				CWHEAD .INFO 78 "ACTIVE" 6 WORD_FLAG_CODE 
425f 62				db WORD_SYS_CORE+78             
4260 ae 42			dw .INFO            
4262 07				db 6 + 1 
4263 .. 00			db "ACTIVE",0              
426a				endm 
# End of macro CWHEAD
426a			; | ACTIVE ( -- s ) Push the next char for an activity indicator to TOS | DONE 
426a			;  
426a			; | | To display a pulsing activity indicator in a processing loop do this... 
426a			; | | e.g. $ff $00 do active . ..... Your code ..... loop 
426a			 
426a					if DEBUG_FORTH_WORDS_KEY 
426a						DMARK "ACT" 
426a f5				push af  
426b 3a 7f 42			ld a, (.dmark)  
426e 32 9d fd			ld (debug_mark),a  
4271 3a 80 42			ld a, (.dmark+1)  
4274 32 9e fd			ld (debug_mark+1),a  
4277 3a 81 42			ld a, (.dmark+2)  
427a 32 9f fd			ld (debug_mark+2),a  
427d 18 03			jr .pastdmark  
427f ..			.dmark: db "ACT"  
4282 f1			.pastdmark: pop af  
4283			endm  
# End of macro DMARK
4283						CALLMONITOR 
4283 cd aa fd			call debug_vector  
4286				endm  
# End of macro CALLMONITOR
4286					endif 
4286 cd d4 0c				call active 
4289					if DEBUG_FORTH_WORDS 
4289						DMARK "ACp" 
4289 f5				push af  
428a 3a 9e 42			ld a, (.dmark)  
428d 32 9d fd			ld (debug_mark),a  
4290 3a 9f 42			ld a, (.dmark+1)  
4293 32 9e fd			ld (debug_mark+1),a  
4296 3a a0 42			ld a, (.dmark+2)  
4299 32 9f fd			ld (debug_mark+2),a  
429c 18 03			jr .pastdmark  
429e ..			.dmark: db "ACp"  
42a1 f1			.pastdmark: pop af  
42a2			endm  
# End of macro DMARK
42a2						CALLMONITOR 
42a2 cd aa fd			call debug_vector  
42a5				endm  
# End of macro CALLMONITOR
42a5					endif 
42a5 cd 69 20				call forth_push_str 
42a8			 
42a8					NEXTW 
42a8 cd a7 fd			call parse_vector 
42ab c3 e2 23			jp macro_next 
42ae				endm 
# End of macro NEXTW
42ae			.INFO: 
42ae			 
42ae				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
42ae 62				db WORD_SYS_CORE+78             
42af ce 42			dw .ATP            
42b1 05				db 4 + 1 
42b2 .. 00			db "INFO",0              
42b7				endm 
# End of macro CWHEAD
42b7			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
42b7					FORTH_DSP_VALUEHL 
42b7 cd fb 21			call macro_dsp_valuehl 
42ba				endm 
# End of macro FORTH_DSP_VALUEHL
42ba			 
42ba					FORTH_DSP_POP 
42ba cd b3 22			call macro_forth_dsp_pop 
42bd				endm 
# End of macro FORTH_DSP_POP
42bd			 
42bd e5					push hl 
42be			 
42be					FORTH_DSP_VALUEHL 
42be cd fb 21			call macro_dsp_valuehl 
42c1				endm 
# End of macro FORTH_DSP_VALUEHL
42c1			 
42c1					FORTH_DSP_POP 
42c1 cd b3 22			call macro_forth_dsp_pop 
42c4				endm 
# End of macro FORTH_DSP_POP
42c4			 
42c4 d1					pop de 
42c5			 
42c5 cd 0e 0d				call info_panel 
42c8			 
42c8			 
42c8					NEXTW 
42c8 cd a7 fd			call parse_vector 
42cb c3 e2 23			jp macro_next 
42ce				endm 
# End of macro NEXTW
42ce			.ATP: 
42ce				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
42ce 62				db WORD_SYS_CORE+78             
42cf 48 43			dw .FB            
42d1 04				db 3 + 1 
42d2 .. 00			db "AT?",0              
42d6				endm 
# End of macro CWHEAD
42d6			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
42d6					if DEBUG_FORTH_WORDS_KEY 
42d6						DMARK "AT?" 
42d6 f5				push af  
42d7 3a eb 42			ld a, (.dmark)  
42da 32 9d fd			ld (debug_mark),a  
42dd 3a ec 42			ld a, (.dmark+1)  
42e0 32 9e fd			ld (debug_mark+1),a  
42e3 3a ed 42			ld a, (.dmark+2)  
42e6 32 9f fd			ld (debug_mark+2),a  
42e9 18 03			jr .pastdmark  
42eb ..			.dmark: db "AT?"  
42ee f1			.pastdmark: pop af  
42ef			endm  
# End of macro DMARK
42ef						CALLMONITOR 
42ef cd aa fd			call debug_vector  
42f2				endm  
# End of macro CALLMONITOR
42f2					endif 
42f2 3a 90 f9				ld a, (f_cursor_ptr) 
42f5			 
42f5			if DEBUG_FORTH_WORDS 
42f5				DMARK "AT?" 
42f5 f5				push af  
42f6 3a 0a 43			ld a, (.dmark)  
42f9 32 9d fd			ld (debug_mark),a  
42fc 3a 0b 43			ld a, (.dmark+1)  
42ff 32 9e fd			ld (debug_mark+1),a  
4302 3a 0c 43			ld a, (.dmark+2)  
4305 32 9f fd			ld (debug_mark+2),a  
4308 18 03			jr .pastdmark  
430a ..			.dmark: db "AT?"  
430d f1			.pastdmark: pop af  
430e			endm  
# End of macro DMARK
430e				CALLMONITOR 
430e cd aa fd			call debug_vector  
4311				endm  
# End of macro CALLMONITOR
4311			endif	 
4311					; count the number of rows 
4311			 
4311 06 00				ld b, 0 
4313 4f			.atpr:		ld c, a    ; save in case we go below zero 
4314 d6 28				sub display_cols 
4316 f2 1c 43				jp p, .atprunder 
4319 04					inc b 
431a 18 f7				jr .atpr 
431c			.atprunder:	 
431c			if DEBUG_FORTH_WORDS 
431c				DMARK "A?2" 
431c f5				push af  
431d 3a 31 43			ld a, (.dmark)  
4320 32 9d fd			ld (debug_mark),a  
4323 3a 32 43			ld a, (.dmark+1)  
4326 32 9e fd			ld (debug_mark+1),a  
4329 3a 33 43			ld a, (.dmark+2)  
432c 32 9f fd			ld (debug_mark+2),a  
432f 18 03			jr .pastdmark  
4331 ..			.dmark: db "A?2"  
4334 f1			.pastdmark: pop af  
4335			endm  
# End of macro DMARK
4335				CALLMONITOR 
4335 cd aa fd			call debug_vector  
4338				endm  
# End of macro CALLMONITOR
4338			endif	 
4338 26 00				ld h, 0 
433a 69					ld l, c 
433b cd ff 1f				call forth_push_numhl 
433e 68					ld l, b  
433f cd ff 1f				call forth_push_numhl 
4342			 
4342			 
4342				NEXTW 
4342 cd a7 fd			call parse_vector 
4345 c3 e2 23			jp macro_next 
4348				endm 
# End of macro NEXTW
4348			 
4348			.FB: 
4348				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
4348 1b				db WORD_SYS_CORE+7             
4349 99 43			dw .EMIT            
434b 03				db 2 + 1 
434c .. 00			db "FB",0              
434f				endm 
# End of macro CWHEAD
434f			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
434f			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
434f			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
434f			; | | If automatic display is off then updates will not be shown until DRAW is used. 
434f					if DEBUG_FORTH_WORDS_KEY 
434f						DMARK "FB." 
434f f5				push af  
4350 3a 64 43			ld a, (.dmark)  
4353 32 9d fd			ld (debug_mark),a  
4356 3a 65 43			ld a, (.dmark+1)  
4359 32 9e fd			ld (debug_mark+1),a  
435c 3a 66 43			ld a, (.dmark+2)  
435f 32 9f fd			ld (debug_mark+2),a  
4362 18 03			jr .pastdmark  
4364 ..			.dmark: db "FB."  
4367 f1			.pastdmark: pop af  
4368			endm  
# End of macro DMARK
4368						CALLMONITOR 
4368 cd aa fd			call debug_vector  
436b				endm  
# End of macro CALLMONITOR
436b					endif 
436b			 
436b					FORTH_DSP_VALUEHL 
436b cd fb 21			call macro_dsp_valuehl 
436e				endm 
# End of macro FORTH_DSP_VALUEHL
436e			 
436e 7d					ld a, l 
436f fe 01				cp 1 
4371 20 05				jr nz, .fbn1 
4373 21 42 fc				ld hl, display_fb1 
4376 18 15				jr .fbset 
4378 fe 02		.fbn1:		cp 2 
437a 20 05				jr nz, .fbn2 
437c 21 00 fb				ld hl, display_fb2 
437f 18 0c				jr .fbset 
4381 fe 03		.fbn2:		cp 3 
4383 20 05				jr nz, .fbn3 
4385 21 a1 fb				ld hl, display_fb3 
4388 18 03				jr .fbset 
438a			.fbn3:		 ; if invalid number select first 
438a 21 42 fc				ld hl, display_fb1 
438d 22 fe fa		.fbset:		ld (display_fb_active), hl 
4390			 
4390					FORTH_DSP_POP 
4390 cd b3 22			call macro_forth_dsp_pop 
4393				endm 
# End of macro FORTH_DSP_POP
4393			 
4393					NEXTW 
4393 cd a7 fd			call parse_vector 
4396 c3 e2 23			jp macro_next 
4399				endm 
# End of macro NEXTW
4399			 
4399			 
4399			.EMIT: 
4399				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
4399 1b				db WORD_SYS_CORE+7             
439a ec 43			dw .DOTH            
439c 05				db 4 + 1 
439d .. 00			db "EMIT",0              
43a2				endm 
# End of macro CWHEAD
43a2			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
43a2					; get value off TOS and display it 
43a2			 
43a2					if DEBUG_FORTH_WORDS_KEY 
43a2						DMARK "EMT" 
43a2 f5				push af  
43a3 3a b7 43			ld a, (.dmark)  
43a6 32 9d fd			ld (debug_mark),a  
43a9 3a b8 43			ld a, (.dmark+1)  
43ac 32 9e fd			ld (debug_mark+1),a  
43af 3a b9 43			ld a, (.dmark+2)  
43b2 32 9f fd			ld (debug_mark+2),a  
43b5 18 03			jr .pastdmark  
43b7 ..			.dmark: db "EMT"  
43ba f1			.pastdmark: pop af  
43bb			endm  
# End of macro DMARK
43bb						CALLMONITOR 
43bb cd aa fd			call debug_vector  
43be				endm  
# End of macro CALLMONITOR
43be					endif 
43be			 
43be					FORTH_DSP_VALUEHL 
43be cd fb 21			call macro_dsp_valuehl 
43c1				endm 
# End of macro FORTH_DSP_VALUEHL
43c1			 
43c1 7d					ld a,l 
43c2			 
43c2					; TODO write to display 
43c2			 
43c2 32 f1 f2				ld (os_input), a 
43c5 3e 00				ld a, 0 
43c7 32 f2 f2				ld (os_input+1), a 
43ca					 
43ca 3a 90 f9				ld a, (f_cursor_ptr) 
43cd 11 f1 f2				ld de, os_input 
43d0 cd 8e 0d				call str_at_display 
43d3			 
43d3			 
43d3 3a 6e f9				ld a,(cli_autodisplay) 
43d6			;		cp 0 
43d6 b7					or a 
43d7 28 03				jr z, .enoupdate 
43d9 cd 9e 0d						call update_display 
43dc					.enoupdate: 
43dc			 
43dc 3a 90 f9				ld a, (f_cursor_ptr) 
43df 3c					inc a 
43e0 32 90 f9				ld (f_cursor_ptr), a   ; save new pos 
43e3			 
43e3			 
43e3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
43e3 cd b3 22			call macro_forth_dsp_pop 
43e6				endm 
# End of macro FORTH_DSP_POP
43e6			  
43e6			 
43e6					NEXTW 
43e6 cd a7 fd			call parse_vector 
43e9 c3 e2 23			jp macro_next 
43ec				endm 
# End of macro NEXTW
43ec			.DOTH: 
43ec				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
43ec 1c				db WORD_SYS_CORE+8             
43ed 1f 44			dw .DOTF            
43ef 03				db 2 + 1 
43f0 .. 00			db ".-",0              
43f3				endm 
# End of macro CWHEAD
43f3			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
43f3					; get value off TOS and display it 
43f3					if DEBUG_FORTH_WORDS_KEY 
43f3						DMARK "DTD" 
43f3 f5				push af  
43f4 3a 08 44			ld a, (.dmark)  
43f7 32 9d fd			ld (debug_mark),a  
43fa 3a 09 44			ld a, (.dmark+1)  
43fd 32 9e fd			ld (debug_mark+1),a  
4400 3a 0a 44			ld a, (.dmark+2)  
4403 32 9f fd			ld (debug_mark+2),a  
4406 18 03			jr .pastdmark  
4408 ..			.dmark: db "DTD"  
440b f1			.pastdmark: pop af  
440c			endm  
# End of macro DMARK
440c						CALLMONITOR 
440c cd aa fd			call debug_vector  
440f				endm  
# End of macro CALLMONITOR
440f					endif 
440f 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
4411 3e 00			ld a, 0 
4413 32 6f f9			ld (cli_mvdot), a 
4416 c3 79 44			jp .dotgo 
4419				NEXTW 
4419 cd a7 fd			call parse_vector 
441c c3 e2 23			jp macro_next 
441f				endm 
# End of macro NEXTW
441f			.DOTF: 
441f				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
441f 1c				db WORD_SYS_CORE+8             
4420 50 44			dw .DOT            
4422 03				db 2 + 1 
4423 .. 00			db ".>",0              
4426				endm 
# End of macro CWHEAD
4426			        ; | .> ( u -- ) Display TOS and move the next display point with display  | DONE 
4426					; get value off TOS and display it 
4426			        ; TODO BUG adds extra spaces 
4426			        ; TODO BUG handle numerics? 
4426					if DEBUG_FORTH_WORDS_KEY 
4426						DMARK "DTC" 
4426 f5				push af  
4427 3a 3b 44			ld a, (.dmark)  
442a 32 9d fd			ld (debug_mark),a  
442d 3a 3c 44			ld a, (.dmark+1)  
4430 32 9e fd			ld (debug_mark+1),a  
4433 3a 3d 44			ld a, (.dmark+2)  
4436 32 9f fd			ld (debug_mark+2),a  
4439 18 03			jr .pastdmark  
443b ..			.dmark: db "DTC"  
443e f1			.pastdmark: pop af  
443f			endm  
# End of macro DMARK
443f						CALLMONITOR 
443f cd aa fd			call debug_vector  
4442				endm  
# End of macro CALLMONITOR
4442					endif 
4442 3e 01			ld a, 1 
4444 32 6f f9			ld (cli_mvdot), a 
4447 c3 79 44			jp .dotgo 
444a				NEXTW 
444a cd a7 fd			call parse_vector 
444d c3 e2 23			jp macro_next 
4450				endm 
# End of macro NEXTW
4450			 
4450			.DOT: 
4450				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
4450 1c				db WORD_SYS_CORE+8             
4451 2b 46			dw .CLS            
4453 02				db 1 + 1 
4454 .. 00			db ".",0              
4456				endm 
# End of macro CWHEAD
4456			        ; | . ( u -- ) Display TOS. Does not move next print position. Use .> if you want that. | DONE 
4456					; get value off TOS and display it 
4456			 
4456					if DEBUG_FORTH_WORDS_KEY 
4456						DMARK "DOT" 
4456 f5				push af  
4457 3a 6b 44			ld a, (.dmark)  
445a 32 9d fd			ld (debug_mark),a  
445d 3a 6c 44			ld a, (.dmark+1)  
4460 32 9e fd			ld (debug_mark+1),a  
4463 3a 6d 44			ld a, (.dmark+2)  
4466 32 9f fd			ld (debug_mark+2),a  
4469 18 03			jr .pastdmark  
446b ..			.dmark: db "DOT"  
446e f1			.pastdmark: pop af  
446f			endm  
# End of macro DMARK
446f						CALLMONITOR 
446f cd aa fd			call debug_vector  
4472				endm  
# End of macro CALLMONITOR
4472					endif 
4472 3e 00			ld a, 0 
4474 32 6f f9			ld (cli_mvdot), a 
4477 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
4479				 
4479			 
4479			.dotgo: 
4479			 
4479			; move up type to on stack for parserv5 
4479					FORTH_DSP 
4479 cd c1 21			call macro_forth_dsp 
447c				endm 
# End of macro FORTH_DSP
447c				;FORTH_DSP_VALUE  
447c			 
447c			if DEBUG_FORTH_DOT 
447c				DMARK "DOT" 
447c f5				push af  
447d 3a 91 44			ld a, (.dmark)  
4480 32 9d fd			ld (debug_mark),a  
4483 3a 92 44			ld a, (.dmark+1)  
4486 32 9e fd			ld (debug_mark+1),a  
4489 3a 93 44			ld a, (.dmark+2)  
448c 32 9f fd			ld (debug_mark+2),a  
448f 18 03			jr .pastdmark  
4491 ..			.dmark: db "DOT"  
4494 f1			.pastdmark: pop af  
4495			endm  
# End of macro DMARK
4495				CALLMONITOR 
4495 cd aa fd			call debug_vector  
4498				endm  
# End of macro CALLMONITOR
4498			endif	 
4498			;		.print: 
4498			 
4498 7e				ld a,(hl)  ; work out what type of value is on the TOS 
4499 23				inc hl   ; position to the actual value 
449a fe 01			cp DS_TYPE_STR 
449c 20 06			jr nz, .dotnum1  
449e			 
449e			; display string 
449e				FORTH_DSP_VALUE  
449e cd e4 21			call macro_forth_dsp_value 
44a1				endm 
# End of macro FORTH_DSP_VALUE
44a1 eb				ex de,hl 
44a2 18 49			jr .dotwrite 
44a4			 
44a4			.dotnum1: 
44a4 fe 02			cp DS_TYPE_INUM 
44a6 20 44			jr nz, .dotflot 
44a8			 
44a8			 
44a8			; display number 
44a8			 
44a8			;	push hl 
44a8			;	call clear_display 
44a8			;	pop hl 
44a8			 
44a8 5e				ld e, (hl) 
44a9 23				inc hl 
44aa 56				ld d, (hl) 
44ab 21 f3 f0			ld hl, scratch 
44ae			if DEBUG_FORTH_DOT 
44ae				DMARK "DT1" 
44ae f5				push af  
44af 3a c3 44			ld a, (.dmark)  
44b2 32 9d fd			ld (debug_mark),a  
44b5 3a c4 44			ld a, (.dmark+1)  
44b8 32 9e fd			ld (debug_mark+1),a  
44bb 3a c5 44			ld a, (.dmark+2)  
44be 32 9f fd			ld (debug_mark+2),a  
44c1 18 03			jr .pastdmark  
44c3 ..			.dmark: db "DT1"  
44c6 f1			.pastdmark: pop af  
44c7			endm  
# End of macro DMARK
44c7				CALLMONITOR 
44c7 cd aa fd			call debug_vector  
44ca				endm  
# End of macro CALLMONITOR
44ca			endif	 
44ca			 
44ca cd b3 12			call uitoa_16 
44cd eb				ex de,hl 
44ce			 
44ce			if DEBUG_FORTH_DOT 
44ce				DMARK "DT2" 
44ce f5				push af  
44cf 3a e3 44			ld a, (.dmark)  
44d2 32 9d fd			ld (debug_mark),a  
44d5 3a e4 44			ld a, (.dmark+1)  
44d8 32 9e fd			ld (debug_mark+1),a  
44db 3a e5 44			ld a, (.dmark+2)  
44de 32 9f fd			ld (debug_mark+2),a  
44e1 18 03			jr .pastdmark  
44e3 ..			.dmark: db "DT2"  
44e6 f1			.pastdmark: pop af  
44e7			endm  
# End of macro DMARK
44e7				CALLMONITOR 
44e7 cd aa fd			call debug_vector  
44ea				endm  
# End of macro CALLMONITOR
44ea			endif	 
44ea			 
44ea			;	ld de, os_word_scratch 
44ea 18 01			jr .dotwrite 
44ec			 
44ec 00			.dotflot:   nop 
44ed			; TODO print floating point number 
44ed			 
44ed			.dotwrite:		 
44ed			 
44ed					; if c is set then set all '-' to spaces 
44ed					; need to also take into account .>  
44ed			 
44ed 3e 01				ld a, 1 
44ef b9					cp c 
44f0 20 65				jr nz, .nodashswap 
44f2			 
44f2					; DE has the string to write, working with HL 
44f2			 
44f2 06 ff				ld b, 255 
44f4 d5					push de 
44f5 e1					pop hl 
44f6			 
44f6			if DEBUG_FORTH_DOT 
44f6				DMARK "DT-" 
44f6 f5				push af  
44f7 3a 0b 45			ld a, (.dmark)  
44fa 32 9d fd			ld (debug_mark),a  
44fd 3a 0c 45			ld a, (.dmark+1)  
4500 32 9e fd			ld (debug_mark+1),a  
4503 3a 0d 45			ld a, (.dmark+2)  
4506 32 9f fd			ld (debug_mark+2),a  
4509 18 03			jr .pastdmark  
450b ..			.dmark: db "DT-"  
450e f1			.pastdmark: pop af  
450f			endm  
# End of macro DMARK
450f				CALLMONITOR 
450f cd aa fd			call debug_vector  
4512				endm  
# End of macro CALLMONITOR
4512			endif	 
4512 7e			.dashscan:	ld a, (hl) 
4513			;		cp 0 
4513 b7					or a 
4514 28 41				jr z, .nodashswap 
4516 fe 2d				cp '-' 
4518 20 02				jr nz, .dashskip 
451a			;		ld a, ' ' 
451a 36 20				ld (hl), ' ' 
451c 23			.dashskip:	inc hl 
451d			if DEBUG_FORTH_DOT 
451d				DMARK "D-2" 
451d f5				push af  
451e 3a 32 45			ld a, (.dmark)  
4521 32 9d fd			ld (debug_mark),a  
4524 3a 33 45			ld a, (.dmark+1)  
4527 32 9e fd			ld (debug_mark+1),a  
452a 3a 34 45			ld a, (.dmark+2)  
452d 32 9f fd			ld (debug_mark+2),a  
4530 18 03			jr .pastdmark  
4532 ..			.dmark: db "D-2"  
4535 f1			.pastdmark: pop af  
4536			endm  
# End of macro DMARK
4536				CALLMONITOR 
4536 cd aa fd			call debug_vector  
4539				endm  
# End of macro CALLMONITOR
4539			endif	 
4539 10 d7				djnz .dashscan 
453b			 
453b			if DEBUG_FORTH_DOT 
453b				DMARK "D-1" 
453b f5				push af  
453c 3a 50 45			ld a, (.dmark)  
453f 32 9d fd			ld (debug_mark),a  
4542 3a 51 45			ld a, (.dmark+1)  
4545 32 9e fd			ld (debug_mark+1),a  
4548 3a 52 45			ld a, (.dmark+2)  
454b 32 9f fd			ld (debug_mark+2),a  
454e 18 03			jr .pastdmark  
4550 ..			.dmark: db "D-1"  
4553 f1			.pastdmark: pop af  
4554			endm  
# End of macro DMARK
4554				CALLMONITOR 
4554 cd aa fd			call debug_vector  
4557				endm  
# End of macro CALLMONITOR
4557			endif	 
4557			 
4557			.nodashswap: 
4557			 
4557			if DEBUG_FORTH_DOT 
4557				DMARK "D-o" 
4557 f5				push af  
4558 3a 6c 45			ld a, (.dmark)  
455b 32 9d fd			ld (debug_mark),a  
455e 3a 6d 45			ld a, (.dmark+1)  
4561 32 9e fd			ld (debug_mark+1),a  
4564 3a 6e 45			ld a, (.dmark+2)  
4567 32 9f fd			ld (debug_mark+2),a  
456a 18 03			jr .pastdmark  
456c ..			.dmark: db "D-o"  
456f f1			.pastdmark: pop af  
4570			endm  
# End of macro DMARK
4570				CALLMONITOR 
4570 cd aa fd			call debug_vector  
4573				endm  
# End of macro CALLMONITOR
4573			endif	 
4573			 
4573 d5					push de   ; save string start in case we need to advance print 
4574			 
4574 3a 90 f9				ld a, (f_cursor_ptr) 
4577 cd 8e 0d				call str_at_display 
457a 3a 6e f9				ld a,(cli_autodisplay) 
457d			;		cp 0 
457d b7					or a 
457e 28 03				jr z, .noupdate 
4580 cd 9e 0d						call update_display 
4583					.noupdate: 
4583			 
4583			 
4583					; see if we need to advance the print position 
4583			 
4583 e1					pop hl   ; get back string 
4584			;		ex de,hl 
4584			 
4584 3a 6f f9				ld a, (cli_mvdot) 
4587			if DEBUG_FORTH_DOT 
4587			;		ld e,a 
4587				DMARK "D>1" 
4587 f5				push af  
4588 3a 9c 45			ld a, (.dmark)  
458b 32 9d fd			ld (debug_mark),a  
458e 3a 9d 45			ld a, (.dmark+1)  
4591 32 9e fd			ld (debug_mark+1),a  
4594 3a 9e 45			ld a, (.dmark+2)  
4597 32 9f fd			ld (debug_mark+2),a  
459a 18 03			jr .pastdmark  
459c ..			.dmark: db "D>1"  
459f f1			.pastdmark: pop af  
45a0			endm  
# End of macro DMARK
45a0				CALLMONITOR 
45a0 cd aa fd			call debug_vector  
45a3				endm  
# End of macro CALLMONITOR
45a3			endif	 
45a3			;		cp 0 
45a3 b7					or a 
45a4 28 44				jr z, .noadv 
45a6					; yes, lets advance the print position 
45a6 3e 00				ld a, 0 
45a8 cd 0f 13				call strlent 
45ab			if DEBUG_FORTH_DOT 
45ab				DMARK "D-?" 
45ab f5				push af  
45ac 3a c0 45			ld a, (.dmark)  
45af 32 9d fd			ld (debug_mark),a  
45b2 3a c1 45			ld a, (.dmark+1)  
45b5 32 9e fd			ld (debug_mark+1),a  
45b8 3a c2 45			ld a, (.dmark+2)  
45bb 32 9f fd			ld (debug_mark+2),a  
45be 18 03			jr .pastdmark  
45c0 ..			.dmark: db "D-?"  
45c3 f1			.pastdmark: pop af  
45c4			endm  
# End of macro DMARK
45c4				CALLMONITOR 
45c4 cd aa fd			call debug_vector  
45c7				endm  
# End of macro CALLMONITOR
45c7			endif	 
45c7 3a 90 f9				ld a, (f_cursor_ptr) 
45ca 85					add a,l 
45cb					;call addatohl 
45cb					;ld a, l 
45cb 32 90 f9				ld (f_cursor_ptr), a   ; save new pos 
45ce			 
45ce			if DEBUG_FORTH_DOT 
45ce				DMARK "D->" 
45ce f5				push af  
45cf 3a e3 45			ld a, (.dmark)  
45d2 32 9d fd			ld (debug_mark),a  
45d5 3a e4 45			ld a, (.dmark+1)  
45d8 32 9e fd			ld (debug_mark+1),a  
45db 3a e5 45			ld a, (.dmark+2)  
45de 32 9f fd			ld (debug_mark+2),a  
45e1 18 03			jr .pastdmark  
45e3 ..			.dmark: db "D->"  
45e6 f1			.pastdmark: pop af  
45e7			endm  
# End of macro DMARK
45e7				CALLMONITOR 
45e7 cd aa fd			call debug_vector  
45ea				endm  
# End of macro CALLMONITOR
45ea			endif	 
45ea			 
45ea			.noadv:	 
45ea			 
45ea					if DEBUG_FORTH_DOT_WAIT 
45ea							call next_page_prompt 
45ea					endif	 
45ea			; TODO this pop off the stack causes a crash. i dont know why 
45ea			 
45ea			 
45ea			if DEBUG_FORTH_DOT 
45ea				DMARK "DTh" 
45ea f5				push af  
45eb 3a ff 45			ld a, (.dmark)  
45ee 32 9d fd			ld (debug_mark),a  
45f1 3a 00 46			ld a, (.dmark+1)  
45f4 32 9e fd			ld (debug_mark+1),a  
45f7 3a 01 46			ld a, (.dmark+2)  
45fa 32 9f fd			ld (debug_mark+2),a  
45fd 18 03			jr .pastdmark  
45ff ..			.dmark: db "DTh"  
4602 f1			.pastdmark: pop af  
4603			endm  
# End of macro DMARK
4603				CALLMONITOR 
4603 cd aa fd			call debug_vector  
4606				endm  
# End of macro CALLMONITOR
4606			endif	 
4606			 
4606					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4606 cd b3 22			call macro_forth_dsp_pop 
4609				endm 
# End of macro FORTH_DSP_POP
4609			 
4609			if DEBUG_FORTH_DOT 
4609				DMARK "DTi" 
4609 f5				push af  
460a 3a 1e 46			ld a, (.dmark)  
460d 32 9d fd			ld (debug_mark),a  
4610 3a 1f 46			ld a, (.dmark+1)  
4613 32 9e fd			ld (debug_mark+1),a  
4616 3a 20 46			ld a, (.dmark+2)  
4619 32 9f fd			ld (debug_mark+2),a  
461c 18 03			jr .pastdmark  
461e ..			.dmark: db "DTi"  
4621 f1			.pastdmark: pop af  
4622			endm  
# End of macro DMARK
4622				CALLMONITOR 
4622 cd aa fd			call debug_vector  
4625				endm  
# End of macro CALLMONITOR
4625			endif	 
4625			 
4625			 
4625					NEXTW 
4625 cd a7 fd			call parse_vector 
4628 c3 e2 23			jp macro_next 
462b				endm 
# End of macro NEXTW
462b			 
462b			.CLS: 
462b				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
462b 35				db WORD_SYS_CORE+33             
462c 5b 46			dw .DRAW            
462e 04				db 3 + 1 
462f .. 00			db "CLS",0              
4633				endm 
# End of macro CWHEAD
4633			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
4633					if DEBUG_FORTH_WORDS_KEY 
4633						DMARK "CLS" 
4633 f5				push af  
4634 3a 48 46			ld a, (.dmark)  
4637 32 9d fd			ld (debug_mark),a  
463a 3a 49 46			ld a, (.dmark+1)  
463d 32 9e fd			ld (debug_mark+1),a  
4640 3a 4a 46			ld a, (.dmark+2)  
4643 32 9f fd			ld (debug_mark+2),a  
4646 18 03			jr .pastdmark  
4648 ..			.dmark: db "CLS"  
464b f1			.pastdmark: pop af  
464c			endm  
# End of macro DMARK
464c						CALLMONITOR 
464c cd aa fd			call debug_vector  
464f				endm  
# End of macro CALLMONITOR
464f					endif 
464f cd 7c 0d				call clear_display 
4652 c3 75 47				jp .home		; and home cursor 
4655					NEXTW 
4655 cd a7 fd			call parse_vector 
4658 c3 e2 23			jp macro_next 
465b				endm 
# End of macro NEXTW
465b			 
465b			.DRAW: 
465b				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
465b 36				db WORD_SYS_CORE+34             
465c 89 46			dw .DUMP            
465e 05				db 4 + 1 
465f .. 00			db "DRAW",0              
4664				endm 
# End of macro CWHEAD
4664			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
4664					if DEBUG_FORTH_WORDS_KEY 
4664						DMARK "DRW" 
4664 f5				push af  
4665 3a 79 46			ld a, (.dmark)  
4668 32 9d fd			ld (debug_mark),a  
466b 3a 7a 46			ld a, (.dmark+1)  
466e 32 9e fd			ld (debug_mark+1),a  
4671 3a 7b 46			ld a, (.dmark+2)  
4674 32 9f fd			ld (debug_mark+2),a  
4677 18 03			jr .pastdmark  
4679 ..			.dmark: db "DRW"  
467c f1			.pastdmark: pop af  
467d			endm  
# End of macro DMARK
467d						CALLMONITOR 
467d cd aa fd			call debug_vector  
4680				endm  
# End of macro CALLMONITOR
4680					endif 
4680 cd 9e 0d				call update_display 
4683					NEXTW 
4683 cd a7 fd			call parse_vector 
4686 c3 e2 23			jp macro_next 
4689				endm 
# End of macro NEXTW
4689			 
4689			.DUMP: 
4689				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
4689 37				db WORD_SYS_CORE+35             
468a c4 46			dw .CDUMP            
468c 05				db 4 + 1 
468d .. 00			db "DUMP",0              
4692				endm 
# End of macro CWHEAD
4692			; | DUMP ( x -- ) With address x display dump   | DONE 
4692			; TODO pop address to use off of the stack 
4692					if DEBUG_FORTH_WORDS_KEY 
4692						DMARK "DUM" 
4692 f5				push af  
4693 3a a7 46			ld a, (.dmark)  
4696 32 9d fd			ld (debug_mark),a  
4699 3a a8 46			ld a, (.dmark+1)  
469c 32 9e fd			ld (debug_mark+1),a  
469f 3a a9 46			ld a, (.dmark+2)  
46a2 32 9f fd			ld (debug_mark+2),a  
46a5 18 03			jr .pastdmark  
46a7 ..			.dmark: db "DUM"  
46aa f1			.pastdmark: pop af  
46ab			endm  
# End of macro DMARK
46ab						CALLMONITOR 
46ab cd aa fd			call debug_vector  
46ae				endm  
# End of macro CALLMONITOR
46ae					endif 
46ae cd 7c 0d				call clear_display 
46b1			 
46b1					; get address 
46b1			 
46b1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
46b1 cd fb 21			call macro_dsp_valuehl 
46b4				endm 
# End of macro FORTH_DSP_VALUEHL
46b4				 
46b4					; save it for cdump 
46b4			 
46b4 22 16 f4				ld (os_cur_ptr),hl 
46b7			 
46b7					; destroy value TOS 
46b7			 
46b7					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
46b7 cd b3 22			call macro_forth_dsp_pop 
46ba				endm 
# End of macro FORTH_DSP_POP
46ba			 
46ba cd 83 1e				call dumpcont	; skip old style of param parsing	 
46bd c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
46be					NEXTW 
46be cd a7 fd			call parse_vector 
46c1 c3 e2 23			jp macro_next 
46c4				endm 
# End of macro NEXTW
46c4			.CDUMP: 
46c4				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
46c4 38				db WORD_SYS_CORE+36             
46c5 f7 46			dw .DAT            
46c7 06				db 5 + 1 
46c8 .. 00			db "CDUMP",0              
46ce				endm 
# End of macro CWHEAD
46ce			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
46ce					if DEBUG_FORTH_WORDS_KEY 
46ce						DMARK "CDP" 
46ce f5				push af  
46cf 3a e3 46			ld a, (.dmark)  
46d2 32 9d fd			ld (debug_mark),a  
46d5 3a e4 46			ld a, (.dmark+1)  
46d8 32 9e fd			ld (debug_mark+1),a  
46db 3a e5 46			ld a, (.dmark+2)  
46de 32 9f fd			ld (debug_mark+2),a  
46e1 18 03			jr .pastdmark  
46e3 ..			.dmark: db "CDP"  
46e6 f1			.pastdmark: pop af  
46e7			endm  
# End of macro DMARK
46e7						CALLMONITOR 
46e7 cd aa fd			call debug_vector  
46ea				endm  
# End of macro CALLMONITOR
46ea					endif 
46ea cd 7c 0d				call clear_display 
46ed cd 83 1e				call dumpcont	 
46f0 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
46f1					NEXTW 
46f1 cd a7 fd			call parse_vector 
46f4 c3 e2 23			jp macro_next 
46f7				endm 
# End of macro NEXTW
46f7			 
46f7			 
46f7			 
46f7			 
46f7			.DAT: 
46f7				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
46f7 3d				db WORD_SYS_CORE+41             
46f8 50 47			dw .HOME            
46fa 03				db 2 + 1 
46fb .. 00			db "AT",0              
46fe				endm 
# End of macro CWHEAD
46fe			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
46fe					if DEBUG_FORTH_WORDS_KEY 
46fe						DMARK "AT." 
46fe f5				push af  
46ff 3a 13 47			ld a, (.dmark)  
4702 32 9d fd			ld (debug_mark),a  
4705 3a 14 47			ld a, (.dmark+1)  
4708 32 9e fd			ld (debug_mark+1),a  
470b 3a 15 47			ld a, (.dmark+2)  
470e 32 9f fd			ld (debug_mark+2),a  
4711 18 03			jr .pastdmark  
4713 ..			.dmark: db "AT."  
4716 f1			.pastdmark: pop af  
4717			endm  
# End of macro DMARK
4717						CALLMONITOR 
4717 cd aa fd			call debug_vector  
471a				endm  
# End of macro CALLMONITOR
471a					endif 
471a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
471a cd fb 21			call macro_dsp_valuehl 
471d				endm 
# End of macro FORTH_DSP_VALUEHL
471d			 
471d			 
471d					; TODO save cursor row 
471d 7d					ld a,l 
471e fe 02				cp 2 
4720 20 04				jr nz, .crow3 
4722 3e 28				ld a, display_row_2 
4724 18 12				jr .ccol1 
4726 fe 03		.crow3:		cp 3 
4728 20 04				jr nz, .crow4 
472a 3e 50				ld a, display_row_3 
472c 18 0a				jr .ccol1 
472e fe 04		.crow4:		cp 4 
4730 20 04				jr nz, .crow1 
4732 3e 78				ld a, display_row_4 
4734 18 02				jr .ccol1 
4736 3e 00		.crow1:		ld a,display_row_1 
4738 f5			.ccol1:		push af			; got row offset 
4739 6f					ld l,a 
473a 26 00				ld h,0 
473c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
473c cd b3 22			call macro_forth_dsp_pop 
473f				endm 
# End of macro FORTH_DSP_POP
473f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
473f cd fb 21			call macro_dsp_valuehl 
4742				endm 
# End of macro FORTH_DSP_VALUEHL
4742					; TODO save cursor col 
4742 f1					pop af 
4743 85					add l		; add col offset 
4744 32 90 f9				ld (f_cursor_ptr), a 
4747					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4747 cd b3 22			call macro_forth_dsp_pop 
474a				endm 
# End of macro FORTH_DSP_POP
474a			 
474a					; calculate  
474a			 
474a					NEXTW 
474a cd a7 fd			call parse_vector 
474d c3 e2 23			jp macro_next 
4750				endm 
# End of macro NEXTW
4750			 
4750			 
4750			.HOME: 
4750				CWHEAD .CR 45 "HOME" 4 WORD_FLAG_CODE 
4750 41				db WORD_SYS_CORE+45             
4751 80 47			dw .CR            
4753 05				db 4 + 1 
4754 .. 00			db "HOME",0              
4759				endm 
# End of macro CWHEAD
4759			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
4759					if DEBUG_FORTH_WORDS_KEY 
4759						DMARK "HOM" 
4759 f5				push af  
475a 3a 6e 47			ld a, (.dmark)  
475d 32 9d fd			ld (debug_mark),a  
4760 3a 6f 47			ld a, (.dmark+1)  
4763 32 9e fd			ld (debug_mark+1),a  
4766 3a 70 47			ld a, (.dmark+2)  
4769 32 9f fd			ld (debug_mark+2),a  
476c 18 03			jr .pastdmark  
476e ..			.dmark: db "HOM"  
4771 f1			.pastdmark: pop af  
4772			endm  
# End of macro DMARK
4772						CALLMONITOR 
4772 cd aa fd			call debug_vector  
4775				endm  
# End of macro CALLMONITOR
4775					endif 
4775 3e 00		.home:		ld a, 0		; and home cursor 
4777 32 90 f9				ld (f_cursor_ptr), a 
477a					NEXTW 
477a cd a7 fd			call parse_vector 
477d c3 e2 23			jp macro_next 
4780				endm 
# End of macro NEXTW
4780			 
4780			 
4780			.CR: 
4780				CWHEAD .SPACE 50 "CR" 2 WORD_FLAG_CODE 
4780 46				db WORD_SYS_CORE+50             
4781 be 47			dw .SPACE            
4783 03				db 2 + 1 
4784 .. 00			db "CR",0              
4787				endm 
# End of macro CWHEAD
4787			; | CR (  -- s ) Push CR/LF pair onto the stack as a string  | DONE 
4787					if DEBUG_FORTH_WORDS_KEY 
4787						DMARK "CR." 
4787 f5				push af  
4788 3a 9c 47			ld a, (.dmark)  
478b 32 9d fd			ld (debug_mark),a  
478e 3a 9d 47			ld a, (.dmark+1)  
4791 32 9e fd			ld (debug_mark+1),a  
4794 3a 9e 47			ld a, (.dmark+2)  
4797 32 9f fd			ld (debug_mark+2),a  
479a 18 03			jr .pastdmark  
479c ..			.dmark: db "CR."  
479f f1			.pastdmark: pop af  
47a0			endm  
# End of macro DMARK
47a0						CALLMONITOR 
47a0 cd aa fd			call debug_vector  
47a3				endm  
# End of macro CALLMONITOR
47a3					endif 
47a3 3e 0d				ld a, 13 
47a5 32 f3 f0				ld (scratch),a 
47a8 3e 0a				ld a, 10 
47aa 32 f4 f0				ld (scratch+1),a 
47ad 3e 00				ld a, 0 
47af 32 f5 f0				ld (scratch+2),a 
47b2 21 f3 f0				ld hl, scratch 
47b5 cd 69 20				call forth_push_str 
47b8					 
47b8				       NEXTW 
47b8 cd a7 fd			call parse_vector 
47bb c3 e2 23			jp macro_next 
47be				endm 
# End of macro NEXTW
47be			.SPACE: 
47be				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
47be 46				db WORD_SYS_CORE+50             
47bf f7 47			dw .SPACES            
47c1 03				db 2 + 1 
47c2 .. 00			db "BL",0              
47c5				endm 
# End of macro CWHEAD
47c5			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
47c5					if DEBUG_FORTH_WORDS_KEY 
47c5						DMARK "BL." 
47c5 f5				push af  
47c6 3a da 47			ld a, (.dmark)  
47c9 32 9d fd			ld (debug_mark),a  
47cc 3a db 47			ld a, (.dmark+1)  
47cf 32 9e fd			ld (debug_mark+1),a  
47d2 3a dc 47			ld a, (.dmark+2)  
47d5 32 9f fd			ld (debug_mark+2),a  
47d8 18 03			jr .pastdmark  
47da ..			.dmark: db "BL."  
47dd f1			.pastdmark: pop af  
47de			endm  
# End of macro DMARK
47de						CALLMONITOR 
47de cd aa fd			call debug_vector  
47e1				endm  
# End of macro CALLMONITOR
47e1					endif 
47e1 3e 20				ld a, " " 
47e3 32 f3 f0				ld (scratch),a 
47e6 3e 00				ld a, 0 
47e8 32 f4 f0				ld (scratch+1),a 
47eb 21 f3 f0				ld hl, scratch 
47ee cd 69 20				call forth_push_str 
47f1					 
47f1				       NEXTW 
47f1 cd a7 fd			call parse_vector 
47f4 c3 e2 23			jp macro_next 
47f7				endm 
# End of macro NEXTW
47f7			 
47f7			;.blstr: db " ", 0 
47f7			 
47f7			.SPACES: 
47f7				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
47f7 47				db WORD_SYS_CORE+51             
47f8 93 48			dw .SCROLL            
47fa 07				db 6 + 1 
47fb .. 00			db "SPACES",0              
4802				endm 
# End of macro CWHEAD
4802			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | DONE 
4802					if DEBUG_FORTH_WORDS_KEY 
4802						DMARK "SPS" 
4802 f5				push af  
4803 3a 17 48			ld a, (.dmark)  
4806 32 9d fd			ld (debug_mark),a  
4809 3a 18 48			ld a, (.dmark+1)  
480c 32 9e fd			ld (debug_mark+1),a  
480f 3a 19 48			ld a, (.dmark+2)  
4812 32 9f fd			ld (debug_mark+2),a  
4815 18 03			jr .pastdmark  
4817 ..			.dmark: db "SPS"  
481a f1			.pastdmark: pop af  
481b			endm  
# End of macro DMARK
481b						CALLMONITOR 
481b cd aa fd			call debug_vector  
481e				endm  
# End of macro CALLMONITOR
481e					endif 
481e			 
481e			 
481e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
481e cd fb 21			call macro_dsp_valuehl 
4821				endm 
# End of macro FORTH_DSP_VALUEHL
4821			 
4821 e5					push hl    ; u 
4822					if DEBUG_FORTH_WORDS 
4822						DMARK "SPA" 
4822 f5				push af  
4823 3a 37 48			ld a, (.dmark)  
4826 32 9d fd			ld (debug_mark),a  
4829 3a 38 48			ld a, (.dmark+1)  
482c 32 9e fd			ld (debug_mark+1),a  
482f 3a 39 48			ld a, (.dmark+2)  
4832 32 9f fd			ld (debug_mark+2),a  
4835 18 03			jr .pastdmark  
4837 ..			.dmark: db "SPA"  
483a f1			.pastdmark: pop af  
483b			endm  
# End of macro DMARK
483b						CALLMONITOR 
483b cd aa fd			call debug_vector  
483e				endm  
# End of macro CALLMONITOR
483e					endif 
483e			 
483e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
483e cd b3 22			call macro_forth_dsp_pop 
4841				endm 
# End of macro FORTH_DSP_POP
4841 e1					pop hl 
4842 0e 00				ld c, 0 
4844 45					ld b, l 
4845 21 f3 f0				ld hl, scratch  
4848			 
4848					if DEBUG_FORTH_WORDS 
4848						DMARK "SP2" 
4848 f5				push af  
4849 3a 5d 48			ld a, (.dmark)  
484c 32 9d fd			ld (debug_mark),a  
484f 3a 5e 48			ld a, (.dmark+1)  
4852 32 9e fd			ld (debug_mark+1),a  
4855 3a 5f 48			ld a, (.dmark+2)  
4858 32 9f fd			ld (debug_mark+2),a  
485b 18 03			jr .pastdmark  
485d ..			.dmark: db "SP2"  
4860 f1			.pastdmark: pop af  
4861			endm  
# End of macro DMARK
4861						CALLMONITOR 
4861 cd aa fd			call debug_vector  
4864				endm  
# End of macro CALLMONITOR
4864					endif 
4864			;		ld a, ' ' 
4864			.spaces1:	 
4864 36 20				ld (hl),' ' 
4866 23					inc hl 
4867					 
4867 10 fb				djnz .spaces1 
4869			;		ld a,0 
4869 36 00				ld (hl),0 
486b 21 f3 f0				ld hl, scratch 
486e					if DEBUG_FORTH_WORDS 
486e						DMARK "SP3" 
486e f5				push af  
486f 3a 83 48			ld a, (.dmark)  
4872 32 9d fd			ld (debug_mark),a  
4875 3a 84 48			ld a, (.dmark+1)  
4878 32 9e fd			ld (debug_mark+1),a  
487b 3a 85 48			ld a, (.dmark+2)  
487e 32 9f fd			ld (debug_mark+2),a  
4881 18 03			jr .pastdmark  
4883 ..			.dmark: db "SP3"  
4886 f1			.pastdmark: pop af  
4887			endm  
# End of macro DMARK
4887						CALLMONITOR 
4887 cd aa fd			call debug_vector  
488a				endm  
# End of macro CALLMONITOR
488a					endif 
488a cd 69 20				call forth_push_str 
488d			 
488d				       NEXTW 
488d cd a7 fd			call parse_vector 
4890 c3 e2 23			jp macro_next 
4893				endm 
# End of macro NEXTW
4893			 
4893			 
4893			 
4893			.SCROLL: 
4893				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
4893 53				db WORD_SYS_CORE+63             
4894 c3 48			dw .SCROLLD            
4896 07				db 6 + 1 
4897 .. 00			db "SCROLL",0              
489e				endm 
# End of macro CWHEAD
489e			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
489e					if DEBUG_FORTH_WORDS_KEY 
489e						DMARK "SCR" 
489e f5				push af  
489f 3a b3 48			ld a, (.dmark)  
48a2 32 9d fd			ld (debug_mark),a  
48a5 3a b4 48			ld a, (.dmark+1)  
48a8 32 9e fd			ld (debug_mark+1),a  
48ab 3a b5 48			ld a, (.dmark+2)  
48ae 32 9f fd			ld (debug_mark+2),a  
48b1 18 03			jr .pastdmark  
48b3 ..			.dmark: db "SCR"  
48b6 f1			.pastdmark: pop af  
48b7			endm  
# End of macro DMARK
48b7						CALLMONITOR 
48b7 cd aa fd			call debug_vector  
48ba				endm  
# End of macro CALLMONITOR
48ba					endif 
48ba			 
48ba cd 3f 0d			call scroll_up 
48bd			;	call update_display 
48bd			 
48bd					NEXTW 
48bd cd a7 fd			call parse_vector 
48c0 c3 e2 23			jp macro_next 
48c3				endm 
# End of macro NEXTW
48c3			 
48c3			 
48c3			 
48c3			;		; get dir 
48c3			; 
48c3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48c3			; 
48c3			;		push hl 
48c3			; 
48c3			;		; destroy value TOS 
48c3			; 
48c3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48c3			; 
48c3			;		; get count 
48c3			; 
48c3			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
48c3			; 
48c3			;		push hl 
48c3			; 
48c3			;		; destroy value TOS 
48c3			; 
48c3			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
48c3			; 
48c3			;		; one value on hl get other one back 
48c3			; 
48c3			;		pop bc    ; count 
48c3			; 
48c3			;		pop de   ; dir 
48c3			; 
48c3			; 
48c3			;		ld b, c 
48c3			; 
48c3			;.scrolldir:     push bc 
48c3			;		push de 
48c3			; 
48c3			;		ld a, 0 
48c3			;		cp e 
48c3			;		jr z, .scrollup  
48c3			;		call scroll_down 
48c3			;		jr .scrollnext 
48c3			;.scrollup:	call scroll_up 
48c3			; 
48c3			;		 
48c3			;.scrollnext: 
48c3			;		pop de 
48c3			;		pop bc 
48c3			;		djnz .scrolldir 
48c3			; 
48c3			; 
48c3			; 
48c3			; 
48c3			; 
48c3			;		NEXTW 
48c3			 
48c3			.SCROLLD: 
48c3				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
48c3 53				db WORD_SYS_CORE+63             
48c4 f4 48			dw .ATQ            
48c6 08				db 7 + 1 
48c7 .. 00			db "SCROLLD",0              
48cf				endm 
# End of macro CWHEAD
48cf			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
48cf					if DEBUG_FORTH_WORDS_KEY 
48cf						DMARK "SCD" 
48cf f5				push af  
48d0 3a e4 48			ld a, (.dmark)  
48d3 32 9d fd			ld (debug_mark),a  
48d6 3a e5 48			ld a, (.dmark+1)  
48d9 32 9e fd			ld (debug_mark+1),a  
48dc 3a e6 48			ld a, (.dmark+2)  
48df 32 9f fd			ld (debug_mark+2),a  
48e2 18 03			jr .pastdmark  
48e4 ..			.dmark: db "SCD"  
48e7 f1			.pastdmark: pop af  
48e8			endm  
# End of macro DMARK
48e8						CALLMONITOR 
48e8 cd aa fd			call debug_vector  
48eb				endm  
# End of macro CALLMONITOR
48eb					endif 
48eb			 
48eb cd 62 0d			call scroll_down 
48ee			;	call update_display 
48ee			 
48ee					NEXTW 
48ee cd a7 fd			call parse_vector 
48f1 c3 e2 23			jp macro_next 
48f4				endm 
# End of macro NEXTW
48f4			 
48f4			 
48f4			.ATQ: 
48f4				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
48f4 62				db WORD_SYS_CORE+78             
48f5 55 49			dw .AUTODSP            
48f7 04				db 3 + 1 
48f8 .. 00			db "AT@",0              
48fc				endm 
# End of macro CWHEAD
48fc			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
48fc					if DEBUG_FORTH_WORDS_KEY 
48fc						DMARK "ATA" 
48fc f5				push af  
48fd 3a 11 49			ld a, (.dmark)  
4900 32 9d fd			ld (debug_mark),a  
4903 3a 12 49			ld a, (.dmark+1)  
4906 32 9e fd			ld (debug_mark+1),a  
4909 3a 13 49			ld a, (.dmark+2)  
490c 32 9f fd			ld (debug_mark+2),a  
490f 18 03			jr .pastdmark  
4911 ..			.dmark: db "ATA"  
4914 f1			.pastdmark: pop af  
4915			endm  
# End of macro DMARK
4915						CALLMONITOR 
4915 cd aa fd			call debug_vector  
4918				endm  
# End of macro CALLMONITOR
4918					endif 
4918			 
4918			 
4918					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4918 cd fb 21			call macro_dsp_valuehl 
491b				endm 
# End of macro FORTH_DSP_VALUEHL
491b			 
491b					; TODO save cursor row 
491b 7d					ld a,l 
491c fe 02				cp 2 
491e 20 04				jr nz, .crow3aq 
4920 3e 28				ld a, display_row_2 
4922 18 12				jr .ccol1aq 
4924 fe 03		.crow3aq:		cp 3 
4926 20 04				jr nz, .crow4aq 
4928 3e 50				ld a, display_row_3 
492a 18 0a				jr .ccol1aq 
492c fe 04		.crow4aq:		cp 4 
492e 20 04				jr nz, .crow1aq 
4930 3e 78				ld a, display_row_4 
4932 18 02				jr .ccol1aq 
4934 3e 00		.crow1aq:		ld a,display_row_1 
4936 f5			.ccol1aq:		push af			; got row offset 
4937 6f					ld l,a 
4938 26 00				ld h,0 
493a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
493a cd b3 22			call macro_forth_dsp_pop 
493d				endm 
# End of macro FORTH_DSP_POP
493d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
493d cd fb 21			call macro_dsp_valuehl 
4940				endm 
# End of macro FORTH_DSP_VALUEHL
4940					; TODO save cursor col 
4940 f1					pop af 
4941 85					add l		; add col offset 
4942			 
4942					; add current frame buffer address 
4942 2a fe fa				ld hl, (display_fb_active) 
4945 cd ac 0f				call addatohl 
4948			 
4948			 
4948			 
4948			 
4948					; get char frame buffer location offset in hl 
4948			 
4948 7e					ld a,(hl) 
4949 26 00				ld h, 0 
494b 6f					ld l, a 
494c			 
494c cd ff 1f				call forth_push_numhl 
494f			 
494f			 
494f					NEXTW 
494f cd a7 fd			call parse_vector 
4952 c3 e2 23			jp macro_next 
4955				endm 
# End of macro NEXTW
4955			 
4955			.AUTODSP: 
4955				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
4955 63				db WORD_SYS_CORE+79             
4956 6e 49			dw .MENU            
4958 05				db 4 + 1 
4959 .. 00			db "ADSP",0              
495e				endm 
# End of macro CWHEAD
495e			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
495e			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
495e			 
495e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
495e cd fb 21			call macro_dsp_valuehl 
4961				endm 
# End of macro FORTH_DSP_VALUEHL
4961			 
4961			;		push hl 
4961			 
4961					; destroy value TOS 
4961			 
4961					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4961 cd b3 22			call macro_forth_dsp_pop 
4964				endm 
# End of macro FORTH_DSP_POP
4964			 
4964			;		pop hl 
4964			 
4964 7d					ld a,l 
4965 32 6e f9				ld (cli_autodisplay), a 
4968				       NEXTW 
4968 cd a7 fd			call parse_vector 
496b c3 e2 23			jp macro_next 
496e				endm 
# End of macro NEXTW
496e			 
496e			.MENU: 
496e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
496e 70				db WORD_SYS_CORE+92             
496f 1a 4a			dw .ENDDISPLAY            
4971 05				db 4 + 1 
4972 .. 00			db "MENU",0              
4977				endm 
# End of macro CWHEAD
4977			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | DONE 
4977			 
4977			;		; get number of items on the stack 
4977			; 
4977				 
4977					FORTH_DSP_VALUEHL 
4977 cd fb 21			call macro_dsp_valuehl 
497a				endm 
# End of macro FORTH_DSP_VALUEHL
497a				 
497a					if DEBUG_FORTH_WORDS_KEY 
497a						DMARK "MNU" 
497a f5				push af  
497b 3a 8f 49			ld a, (.dmark)  
497e 32 9d fd			ld (debug_mark),a  
4981 3a 90 49			ld a, (.dmark+1)  
4984 32 9e fd			ld (debug_mark+1),a  
4987 3a 91 49			ld a, (.dmark+2)  
498a 32 9f fd			ld (debug_mark+2),a  
498d 18 03			jr .pastdmark  
498f ..			.dmark: db "MNU"  
4992 f1			.pastdmark: pop af  
4993			endm  
# End of macro DMARK
4993						CALLMONITOR 
4993 cd aa fd			call debug_vector  
4996				endm  
# End of macro CALLMONITOR
4996					endif 
4996			 
4996 45					ld b, l	 
4997 05					dec b 
4998			 
4998					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4998 cd b3 22			call macro_forth_dsp_pop 
499b				endm 
# End of macro FORTH_DSP_POP
499b			 
499b			 
499b					; go directly through the stack to pluck out the string pointers and build an array 
499b			 
499b			;		FORTH_DSP 
499b			 
499b					; hl contains top most stack item 
499b				 
499b 11 f3 f0				ld de, scratch 
499e			 
499e			.mbuild: 
499e			 
499e					FORTH_DSP_VALUEHL 
499e cd fb 21			call macro_dsp_valuehl 
49a1				endm 
# End of macro FORTH_DSP_VALUEHL
49a1			 
49a1					if DEBUG_FORTH_WORDS 
49a1						DMARK "MN3" 
49a1 f5				push af  
49a2 3a b6 49			ld a, (.dmark)  
49a5 32 9d fd			ld (debug_mark),a  
49a8 3a b7 49			ld a, (.dmark+1)  
49ab 32 9e fd			ld (debug_mark+1),a  
49ae 3a b8 49			ld a, (.dmark+2)  
49b1 32 9f fd			ld (debug_mark+2),a  
49b4 18 03			jr .pastdmark  
49b6 ..			.dmark: db "MN3"  
49b9 f1			.pastdmark: pop af  
49ba			endm  
# End of macro DMARK
49ba						CALLMONITOR 
49ba cd aa fd			call debug_vector  
49bd				endm  
# End of macro CALLMONITOR
49bd					endif 
49bd eb					ex de, hl 
49be 73					ld (hl), e 
49bf 23					inc hl 
49c0 72					ld (hl), d 
49c1 23					inc hl 
49c2 eb					ex de, hl 
49c3			 
49c3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
49c3 cd b3 22			call macro_forth_dsp_pop 
49c6				endm 
# End of macro FORTH_DSP_POP
49c6			 
49c6 10 d6				djnz .mbuild 
49c8			 
49c8					; done add term 
49c8			 
49c8 eb					ex de, hl 
49c9 36 00				ld (hl), 0 
49cb 23					inc hl 
49cc 36 00				ld (hl), 0 
49ce			 
49ce				 
49ce					 
49ce 21 f3 f0				ld hl, scratch 
49d1			 
49d1					if DEBUG_FORTH_WORDS 
49d1						DMARK "MNx" 
49d1 f5				push af  
49d2 3a e6 49			ld a, (.dmark)  
49d5 32 9d fd			ld (debug_mark),a  
49d8 3a e7 49			ld a, (.dmark+1)  
49db 32 9e fd			ld (debug_mark+1),a  
49de 3a e8 49			ld a, (.dmark+2)  
49e1 32 9f fd			ld (debug_mark+2),a  
49e4 18 03			jr .pastdmark  
49e6 ..			.dmark: db "MNx"  
49e9 f1			.pastdmark: pop af  
49ea			endm  
# End of macro DMARK
49ea						CALLMONITOR 
49ea cd aa fd			call debug_vector  
49ed				endm  
# End of macro CALLMONITOR
49ed					endif 
49ed			 
49ed			 
49ed			 
49ed 3e 00				ld a, 0 
49ef cd ac 0d				call menu 
49f2			 
49f2			 
49f2 6f					ld l, a 
49f3 26 00				ld h, 0 
49f5			 
49f5					if DEBUG_FORTH_WORDS 
49f5						DMARK "MNr" 
49f5 f5				push af  
49f6 3a 0a 4a			ld a, (.dmark)  
49f9 32 9d fd			ld (debug_mark),a  
49fc 3a 0b 4a			ld a, (.dmark+1)  
49ff 32 9e fd			ld (debug_mark+1),a  
4a02 3a 0c 4a			ld a, (.dmark+2)  
4a05 32 9f fd			ld (debug_mark+2),a  
4a08 18 03			jr .pastdmark  
4a0a ..			.dmark: db "MNr"  
4a0d f1			.pastdmark: pop af  
4a0e			endm  
# End of macro DMARK
4a0e						CALLMONITOR 
4a0e cd aa fd			call debug_vector  
4a11				endm  
# End of macro CALLMONITOR
4a11					endif 
4a11			 
4a11 cd ff 1f				call forth_push_numhl 
4a14			 
4a14			 
4a14			 
4a14			 
4a14				       NEXTW 
4a14 cd a7 fd			call parse_vector 
4a17 c3 e2 23			jp macro_next 
4a1a				endm 
# End of macro NEXTW
4a1a			 
4a1a			 
4a1a			.ENDDISPLAY: 
4a1a			 
4a1a			; eof 
# End of file forth_words_display.asm
4a1a			include "forth_words_str.asm" 
4a1a			 
4a1a			; | ## String Words 
4a1a			 
4a1a			.CONST: 
4a1a				 
4a1a				CWHEAD .MOVE 52 "CONST" 5 WORD_FLAG_CODE 
4a1a 48				db WORD_SYS_CORE+52             
4a1b 2f 4a			dw .MOVE            
4a1d 06				db 5 + 1 
4a1e .. 00			db "CONST",0              
4a24				endm 
# End of macro CWHEAD
4a24			; | CONST ( u -- u ) Change the type of var on TOS to a constant. i.e. if a string it won't be freed on consuption, | TODO 
4a24					FORTH_DSP 
4a24 cd c1 21			call macro_forth_dsp 
4a27				endm 
# End of macro FORTH_DSP
4a27 36 04				ld (hl), DS_TYPE_CONST 
4a29					NEXTW 
4a29 cd a7 fd			call parse_vector 
4a2c c3 e2 23			jp macro_next 
4a2f				endm 
# End of macro NEXTW
4a2f			 
4a2f			.MOVE:   
4a2f			 
4a2f				CWHEAD .ZMOVE 52 "MOVE" 4 WORD_FLAG_CODE 
4a2f 48				db WORD_SYS_CORE+52             
4a30 56 4a			dw .ZMOVE            
4a32 05				db 4 + 1 
4a33 .. 00			db "MOVE",0              
4a38				endm 
# End of macro CWHEAD
4a38			; | MOVE ( a1 a2 c -- ) Copy from address a1 to address a2 for the length of c | DONE 
4a38			 
4a38					FORTH_DSP_VALUEHL 
4a38 cd fb 21			call macro_dsp_valuehl 
4a3b				endm 
# End of macro FORTH_DSP_VALUEHL
4a3b e5					push hl    ; push count 
4a3c			 
4a3c					FORTH_DSP_POP 
4a3c cd b3 22			call macro_forth_dsp_pop 
4a3f				endm 
# End of macro FORTH_DSP_POP
4a3f			 
4a3f					FORTH_DSP_VALUEHL 
4a3f cd fb 21			call macro_dsp_valuehl 
4a42				endm 
# End of macro FORTH_DSP_VALUEHL
4a42 e5					push hl    ; dest 
4a43			 
4a43					FORTH_DSP_POP 
4a43 cd b3 22			call macro_forth_dsp_pop 
4a46				endm 
# End of macro FORTH_DSP_POP
4a46			 
4a46					FORTH_DSP_VALUEHL 
4a46 cd fb 21			call macro_dsp_valuehl 
4a49				endm 
# End of macro FORTH_DSP_VALUEHL
4a49			 
4a49					FORTH_DSP_POP 
4a49 cd b3 22			call macro_forth_dsp_pop 
4a4c				endm 
# End of macro FORTH_DSP_POP
4a4c			 
4a4c d1					pop de 
4a4d c1					pop bc 
4a4e				 
4a4e ed b0				ldir 
4a50				NEXTW 
4a50 cd a7 fd			call parse_vector 
4a53 c3 e2 23			jp macro_next 
4a56				endm 
# End of macro NEXTW
4a56			.ZMOVE:   
4a56			 
4a56				CWHEAD .TABLE 52 "ZMOVE" 5 WORD_FLAG_CODE 
4a56 48				db WORD_SYS_CORE+52             
4a57 7f 4a			dw .TABLE            
4a59 06				db 5 + 1 
4a5a .. 00			db "ZMOVE",0              
4a60				endm 
# End of macro CWHEAD
4a60					 
4a60			; | ZMOVE ( a1 a2 -- ) Copy from address a1 to address a2 until a1 hits zero term string | DONE 
4a60			; | | Ensure you have enough space! 
4a60			 
4a60			 
4a60					FORTH_DSP_VALUEHL 
4a60 cd fb 21			call macro_dsp_valuehl 
4a63				endm 
# End of macro FORTH_DSP_VALUEHL
4a63 e5					push hl    ; dest 
4a64			 
4a64					FORTH_DSP_POP 
4a64 cd b3 22			call macro_forth_dsp_pop 
4a67				endm 
# End of macro FORTH_DSP_POP
4a67			 
4a67					FORTH_DSP_VALUEHL 
4a67 cd fb 21			call macro_dsp_valuehl 
4a6a				endm 
# End of macro FORTH_DSP_VALUEHL
4a6a			 
4a6a					FORTH_DSP_POP 
4a6a cd b3 22			call macro_forth_dsp_pop 
4a6d				endm 
# End of macro FORTH_DSP_POP
4a6d			 
4a6d d1					pop de 
4a6e			 
4a6e 01 ff 00				ld bc, 255 
4a71 ed a0		.zmovel:	ldi 
4a73 2b					dec hl 
4a74 7e					ld a,(hl) 
4a75 23					inc hl 
4a76 b7					or a  
4a77 20 f8				jr nz, .zmovel    
4a79					 
4a79			 
4a79				NEXTW 
4a79 cd a7 fd			call parse_vector 
4a7c c3 e2 23			jp macro_next 
4a7f				endm 
# End of macro NEXTW
4a7f			 
4a7f			.TABLE:   
4a7f			 
4a7f				CWHEAD .SPLIT 52 "TABLE" 5 WORD_FLAG_CODE 
4a7f 48				db WORD_SYS_CORE+52             
4a80 e4 4a			dw .SPLIT            
4a82 06				db 5 + 1 
4a83 .. 00			db "TABLE",0              
4a89				endm 
# End of macro CWHEAD
4a89					 
4a89			; | TABLE ( s .. sx c -- a) For the number c of strings s on the stack. Generate a look up table array a | DONE 
4a89			; | | Takes a list of strings and creates a block of pointers to each string which can then be used 
4a89			; | | in any kind of lookup or iteration.  
4a89			; | | Last item in the array will be a zero pointer for ease of iteration 
4a89			 
4a89			 
4a89				; get the count of strings 
4a89			 
4a89					FORTH_DSP_VALUEHL 
4a89 cd fb 21			call macro_dsp_valuehl 
4a8c				endm 
# End of macro FORTH_DSP_VALUEHL
4a8c			 
4a8c					FORTH_DSP_POP 
4a8c cd b3 22			call macro_forth_dsp_pop 
4a8f				endm 
# End of macro FORTH_DSP_POP
4a8f			 
4a8f				; allocate memory for (count + 1 ) * 2 for word array plus zero pointer 
4a8f			 
4a8f					; l contains count 
4a8f			 
4a8f 7d					ld a,l 
4a90 32 f3 f0				ld (scratch), a     ; save it for the loading loop 
4a93			 
4a93 2c					inc l  ; for zero pointer 
4a94 eb					ex de, hl 
4a95 3e 02				ld a, 2 
4a97 cd 2f 0f				call Mult16 
4a9a			 
4a9a					; hl is the size of block to allocate 
4a9a			 
4a9a cd 78 13				call malloc 
4a9d				if DEBUG_FORTH_MALLOC_GUARD 
4a9d cc fd 65				call z,malloc_error 
4aa0				endif 
4aa0					; hl is the pointer to the array block 
4aa0						 
4aa0 22 f4 f0				ld (scratch+1), hl    ; save the base for later push to stack 
4aa3 22 f6 f0				ld (scratch+3), hl    ; save the base for current string to push 
4aa6			 
4aa6 3a f3 f0				ld a, (scratch) 
4aa9 47					ld b, a 
4aaa			 
4aaa				; for each string 
4aaa			 
4aaa			.tablelop: 
4aaa			 
4aaa c5					push bc 
4aab			 
4aab				;     get string pointer 
4aab			 
4aab					FORTH_DSP_VALUEHL 
4aab cd fb 21			call macro_dsp_valuehl 
4aae				endm 
# End of macro FORTH_DSP_VALUEHL
4aae			 
4aae e5					push hl 
4aaf			 
4aaf				;     get string length 
4aaf			 
4aaf 3e 00				ld a,0 
4ab1 cd 0f 13				call strlent 
4ab4			 
4ab4 23					inc hl 
4ab5 e5					push hl 
4ab6			 
4ab6				;     allocate string length 
4ab6			 
4ab6 cd 78 13				call malloc 
4ab9			 
4ab9			        ;     copy string to block 
4ab9			 
4ab9 c1					pop bc 
4aba eb					ex de, hl 
4abb e1					pop hl 
4abc d5					push de 
4abd			 
4abd ed b0				ldir 
4abf			 
4abf			 
4abf			        ;     add pointer to string to array block 
4abf			 
4abf 2a f6 f0				ld hl, (scratch+3)    ; save the base for current string to push 
4ac2			 
4ac2 d1					pop de     ; the pointer to the newly copied string to add to the array 
4ac3 73					ld (hl), e 
4ac4 23					inc hl 
4ac5 72					ld (hl), d	 
4ac6 23					inc hl 
4ac7				 
4ac7 22 f6 f0				ld (scratch+3), hl    ; save the base for current string to push 
4aca			 
4aca					FORTH_DSP_POP 
4aca cd b3 22			call macro_forth_dsp_pop 
4acd				endm 
# End of macro FORTH_DSP_POP
4acd			 
4acd c1					pop bc 
4ace 10 da				djnz .tablelop 
4ad0			 
4ad0			        ;  push array block pointer 
4ad0			 
4ad0 2a f6 f0				ld hl, (scratch+3)    ; save the base for current string to push 
4ad3 36 00				ld (hl), 0 
4ad5 23					inc hl 
4ad6 36 00				ld (hl), 0 
4ad8			 
4ad8			 
4ad8				 
4ad8 2a f4 f0				ld hl, (scratch+1)    ; save the base for current string to push 
4adb cd ff 1f				call forth_push_numhl 
4ade			 
4ade				NEXTW 
4ade cd a7 fd			call parse_vector 
4ae1 c3 e2 23			jp macro_next 
4ae4				endm 
# End of macro NEXTW
4ae4			 
4ae4			.SPLIT:   
4ae4			 
4ae4				CWHEAD .PTR 52 "SPLIT" 5 WORD_FLAG_CODE 
4ae4 48				db WORD_SYS_CORE+52             
4ae5 db 4b			dw .PTR            
4ae7 06				db 5 + 1 
4ae8 .. 00			db "SPLIT",0              
4aee				endm 
# End of macro CWHEAD
4aee			; | SPLIT ( s d -- s s...sn c ) Using delimter d, add strings found in s to stack pushing item count c | DONE 
4aee					if DEBUG_FORTH_WORDS_KEY 
4aee						DMARK "SPT" 
4aee f5				push af  
4aef 3a 03 4b			ld a, (.dmark)  
4af2 32 9d fd			ld (debug_mark),a  
4af5 3a 04 4b			ld a, (.dmark+1)  
4af8 32 9e fd			ld (debug_mark+1),a  
4afb 3a 05 4b			ld a, (.dmark+2)  
4afe 32 9f fd			ld (debug_mark+2),a  
4b01 18 03			jr .pastdmark  
4b03 ..			.dmark: db "SPT"  
4b06 f1			.pastdmark: pop af  
4b07			endm  
# End of macro DMARK
4b07						CALLMONITOR 
4b07 cd aa fd			call debug_vector  
4b0a				endm  
# End of macro CALLMONITOR
4b0a					endif 
4b0a			 
4b0a					; get delim 
4b0a					FORTH_DSP_VALUEHL 
4b0a cd fb 21			call macro_dsp_valuehl 
4b0d				endm 
# End of macro FORTH_DSP_VALUEHL
4b0d			 
4b0d					FORTH_DSP_POP 
4b0d cd b3 22			call macro_forth_dsp_pop 
4b10				endm 
# End of macro FORTH_DSP_POP
4b10					 
4b10			 
4b10 45					ld b, l    ; move delim to b 
4b11 0e 01				ld c, 1   ; count of poritions 
4b13			 
4b13 c5					push bc 
4b14			 
4b14					if DEBUG_FORTH_WORDS 
4b14						DMARK "SPa" 
4b14 f5				push af  
4b15 3a 29 4b			ld a, (.dmark)  
4b18 32 9d fd			ld (debug_mark),a  
4b1b 3a 2a 4b			ld a, (.dmark+1)  
4b1e 32 9e fd			ld (debug_mark+1),a  
4b21 3a 2b 4b			ld a, (.dmark+2)  
4b24 32 9f fd			ld (debug_mark+2),a  
4b27 18 03			jr .pastdmark  
4b29 ..			.dmark: db "SPa"  
4b2c f1			.pastdmark: pop af  
4b2d			endm  
# End of macro DMARK
4b2d						CALLMONITOR 
4b2d cd aa fd			call debug_vector  
4b30				endm  
# End of macro CALLMONITOR
4b30					endif 
4b30					; get pointer to string to chop up 
4b30					FORTH_DSP_VALUEHL 
4b30 cd fb 21			call macro_dsp_valuehl 
4b33				endm 
# End of macro FORTH_DSP_VALUEHL
4b33			 
4b33			;		push hl 
4b33 11 f3 f0				ld de, scratch 
4b36			.spllop: 
4b36 c1					pop bc 
4b37 c5					push bc 
4b38			;		pop hl 
4b38					if DEBUG_FORTH_WORDS 
4b38						DMARK "SPl" 
4b38 f5				push af  
4b39 3a 4d 4b			ld a, (.dmark)  
4b3c 32 9d fd			ld (debug_mark),a  
4b3f 3a 4e 4b			ld a, (.dmark+1)  
4b42 32 9e fd			ld (debug_mark+1),a  
4b45 3a 4f 4b			ld a, (.dmark+2)  
4b48 32 9f fd			ld (debug_mark+2),a  
4b4b 18 03			jr .pastdmark  
4b4d ..			.dmark: db "SPl"  
4b50 f1			.pastdmark: pop af  
4b51			endm  
# End of macro DMARK
4b51						CALLMONITOR 
4b51 cd aa fd			call debug_vector  
4b54				endm  
# End of macro CALLMONITOR
4b54					endif 
4b54 7e					ld a, (hl) 
4b55 b8					cp b 
4b56 28 07				jr z, .splnxt 
4b58			;		cp 0 
4b58 b7					or a 
4b59 28 34				jr z, .splend 
4b5b ed a0				ldi 
4b5d 18 d7				jr .spllop 
4b5f			 
4b5f					; hit dlim 
4b5f			 
4b5f			.splnxt: 
4b5f					if DEBUG_FORTH_WORDS 
4b5f						DMARK "SPx" 
4b5f f5				push af  
4b60 3a 74 4b			ld a, (.dmark)  
4b63 32 9d fd			ld (debug_mark),a  
4b66 3a 75 4b			ld a, (.dmark+1)  
4b69 32 9e fd			ld (debug_mark+1),a  
4b6c 3a 76 4b			ld a, (.dmark+2)  
4b6f 32 9f fd			ld (debug_mark+2),a  
4b72 18 03			jr .pastdmark  
4b74 ..			.dmark: db "SPx"  
4b77 f1			.pastdmark: pop af  
4b78			endm  
# End of macro DMARK
4b78						CALLMONITOR 
4b78 cd aa fd			call debug_vector  
4b7b				endm  
# End of macro CALLMONITOR
4b7b					endif 
4b7b 3e 00				ld a, 0 
4b7d 12					ld (de), a 
4b7e					;ex de, hl 
4b7e e5					push hl 
4b7f 21 f3 f0				ld hl, scratch 
4b82 cd 69 20				call forth_push_str 
4b85 e1					pop hl 
4b86					;ex de, hl 
4b86 23					inc hl 
4b87 c1					pop bc 
4b88 0c					inc c 
4b89 c5					push bc 
4b8a 11 f3 f0				ld de, scratch 
4b8d 18 a7				jr .spllop 
4b8f			 
4b8f			.splend:		 
4b8f					if DEBUG_FORTH_WORDS 
4b8f						DMARK "SPe" 
4b8f f5				push af  
4b90 3a a4 4b			ld a, (.dmark)  
4b93 32 9d fd			ld (debug_mark),a  
4b96 3a a5 4b			ld a, (.dmark+1)  
4b99 32 9e fd			ld (debug_mark+1),a  
4b9c 3a a6 4b			ld a, (.dmark+2)  
4b9f 32 9f fd			ld (debug_mark+2),a  
4ba2 18 03			jr .pastdmark  
4ba4 ..			.dmark: db "SPe"  
4ba7 f1			.pastdmark: pop af  
4ba8			endm  
# End of macro DMARK
4ba8						CALLMONITOR 
4ba8 cd aa fd			call debug_vector  
4bab				endm  
# End of macro CALLMONITOR
4bab					endif 
4bab 12					ld (de), a 
4bac eb					ex de, hl 
4bad			;		push hl 
4bad 21 f3 f0				ld hl, scratch 
4bb0 cd 69 20				call forth_push_str 
4bb3					 
4bb3					if DEBUG_FORTH_WORDS 
4bb3						DMARK "SPc" 
4bb3 f5				push af  
4bb4 3a c8 4b			ld a, (.dmark)  
4bb7 32 9d fd			ld (debug_mark),a  
4bba 3a c9 4b			ld a, (.dmark+1)  
4bbd 32 9e fd			ld (debug_mark+1),a  
4bc0 3a ca 4b			ld a, (.dmark+2)  
4bc3 32 9f fd			ld (debug_mark+2),a  
4bc6 18 03			jr .pastdmark  
4bc8 ..			.dmark: db "SPc"  
4bcb f1			.pastdmark: pop af  
4bcc			endm  
# End of macro DMARK
4bcc						CALLMONITOR 
4bcc cd aa fd			call debug_vector  
4bcf				endm  
# End of macro CALLMONITOR
4bcf					endif 
4bcf			 
4bcf e1					pop hl    ; get counter from bc which has been push 
4bd0 26 00				ld h, 0 
4bd2			;		ld l, c 
4bd2 cd ff 1f				call forth_push_numhl 
4bd5			 
4bd5			 
4bd5				NEXTW 
4bd5 cd a7 fd			call parse_vector 
4bd8 c3 e2 23			jp macro_next 
4bdb				endm 
# End of macro NEXTW
4bdb			.PTR:   
4bdb			 
4bdb				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
4bdb 48				db WORD_SYS_CORE+52             
4bdc 0b 4c			dw .STYPE            
4bde 04				db 3 + 1 
4bdf .. 00			db "PTR",0              
4be3				endm 
# End of macro CWHEAD
4be3			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
4be3			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
4be3			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
4be3			 
4be3					if DEBUG_FORTH_WORDS_KEY 
4be3						DMARK "PTR" 
4be3 f5				push af  
4be4 3a f8 4b			ld a, (.dmark)  
4be7 32 9d fd			ld (debug_mark),a  
4bea 3a f9 4b			ld a, (.dmark+1)  
4bed 32 9e fd			ld (debug_mark+1),a  
4bf0 3a fa 4b			ld a, (.dmark+2)  
4bf3 32 9f fd			ld (debug_mark+2),a  
4bf6 18 03			jr .pastdmark  
4bf8 ..			.dmark: db "PTR"  
4bfb f1			.pastdmark: pop af  
4bfc			endm  
# End of macro DMARK
4bfc						CALLMONITOR 
4bfc cd aa fd			call debug_vector  
4bff				endm  
# End of macro CALLMONITOR
4bff					endif 
4bff					FORTH_DSP_VALUEHL 
4bff cd fb 21			call macro_dsp_valuehl 
4c02				endm 
# End of macro FORTH_DSP_VALUEHL
4c02 cd ff 1f				call forth_push_numhl 
4c05			 
4c05			 
4c05					NEXTW 
4c05 cd a7 fd			call parse_vector 
4c08 c3 e2 23			jp macro_next 
4c0b				endm 
# End of macro NEXTW
4c0b			.STYPE: 
4c0b				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
4c0b 48				db WORD_SYS_CORE+52             
4c0c 68 4c			dw .UPPER            
4c0e 06				db 5 + 1 
4c0f .. 00			db "STYPE",0              
4c15				endm 
# End of macro CWHEAD
4c15			; | STYPE ( u -- u type ) Push type of value on TOS  | DONE 
4c15			; | | 's' string or 'i' integer or 'c' const 
4c15					if DEBUG_FORTH_WORDS_KEY 
4c15						DMARK "STY" 
4c15 f5				push af  
4c16 3a 2a 4c			ld a, (.dmark)  
4c19 32 9d fd			ld (debug_mark),a  
4c1c 3a 2b 4c			ld a, (.dmark+1)  
4c1f 32 9e fd			ld (debug_mark+1),a  
4c22 3a 2c 4c			ld a, (.dmark+2)  
4c25 32 9f fd			ld (debug_mark+2),a  
4c28 18 03			jr .pastdmark  
4c2a ..			.dmark: db "STY"  
4c2d f1			.pastdmark: pop af  
4c2e			endm  
# End of macro DMARK
4c2e						CALLMONITOR 
4c2e cd aa fd			call debug_vector  
4c31				endm  
# End of macro CALLMONITOR
4c31					endif 
4c31					FORTH_DSP 
4c31 cd c1 21			call macro_forth_dsp 
4c34				endm 
# End of macro FORTH_DSP
4c34					;v5 FORTH_DSP_VALUE 
4c34			 
4c34 7e					ld a, (hl) 
4c35			 
4c35 f5					push af 
4c36			 
4c36			; Dont destroy TOS		FORTH_DSP_POP 
4c36			 
4c36 f1					pop af 
4c37			 
4c37 fe 01				cp DS_TYPE_STR 
4c39 28 12				jr z, .typestr 
4c3b fe 04				cp DS_TYPE_CONST 
4c3d 28 09				jr z, .typeconst 
4c3f			 
4c3f fe 02				cp DS_TYPE_INUM 
4c41 28 0f				jr z, .typeinum 
4c43			 
4c43 21 66 4c				ld hl, .tna 
4c46 18 0f				jr .tpush 
4c48			 
4c48 21 62 4c		.typeconst:	ld hl, .tconst 
4c4b 18 0a				jr .tpush 
4c4d 21 60 4c		.typestr:	ld hl, .tstr 
4c50 18 05				jr .tpush 
4c52 21 64 4c		.typeinum:	ld hl, .tinum 
4c55 18 00				jr .tpush 
4c57			 
4c57			.tpush: 
4c57			 
4c57 cd 69 20				call forth_push_str 
4c5a			 
4c5a					NEXTW 
4c5a cd a7 fd			call parse_vector 
4c5d c3 e2 23			jp macro_next 
4c60				endm 
# End of macro NEXTW
4c60 .. 00		.tstr:	db "s",0 
4c62 .. 00		.tconst:	db "c",0 
4c64 .. 00		.tinum:  db "i",0 
4c66 .. 00		.tna:   db "?", 0 
4c68			 
4c68			 
4c68			.UPPER: 
4c68				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
4c68 48				db WORD_SYS_CORE+52             
4c69 a5 4c			dw .LOWER            
4c6b 06				db 5 + 1 
4c6c .. 00			db "UPPER",0              
4c72				endm 
# End of macro CWHEAD
4c72			; | UPPER ( s -- s ) Upper case string s  | DONE 
4c72					if DEBUG_FORTH_WORDS_KEY 
4c72						DMARK "UPR" 
4c72 f5				push af  
4c73 3a 87 4c			ld a, (.dmark)  
4c76 32 9d fd			ld (debug_mark),a  
4c79 3a 88 4c			ld a, (.dmark+1)  
4c7c 32 9e fd			ld (debug_mark+1),a  
4c7f 3a 89 4c			ld a, (.dmark+2)  
4c82 32 9f fd			ld (debug_mark+2),a  
4c85 18 03			jr .pastdmark  
4c87 ..			.dmark: db "UPR"  
4c8a f1			.pastdmark: pop af  
4c8b			endm  
# End of macro DMARK
4c8b						CALLMONITOR 
4c8b cd aa fd			call debug_vector  
4c8e				endm  
# End of macro CALLMONITOR
4c8e					endif 
4c8e			 
4c8e					FORTH_DSP 
4c8e cd c1 21			call macro_forth_dsp 
4c91				endm 
# End of macro FORTH_DSP
4c91					 
4c91			; TODO check is string type 
4c91			 
4c91					FORTH_DSP_VALUEHL 
4c91 cd fb 21			call macro_dsp_valuehl 
4c94				endm 
# End of macro FORTH_DSP_VALUEHL
4c94			; get pointer to string in hl 
4c94			 
4c94 7e			.toup:		ld a, (hl) 
4c95			;		cp 0 
4c95 b7					or a 
4c96 28 07				jr z, .toupdone 
4c98			 
4c98 cd 14 12				call to_upper 
4c9b			 
4c9b 77					ld (hl), a 
4c9c 23					inc hl 
4c9d 18 f5				jr .toup 
4c9f			 
4c9f					 
4c9f			 
4c9f			 
4c9f			; for each char convert to upper 
4c9f					 
4c9f			.toupdone: 
4c9f			 
4c9f			 
4c9f					NEXTW 
4c9f cd a7 fd			call parse_vector 
4ca2 c3 e2 23			jp macro_next 
4ca5				endm 
# End of macro NEXTW
4ca5			.LOWER: 
4ca5				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
4ca5 48				db WORD_SYS_CORE+52             
4ca6 e2 4c			dw .TCASE            
4ca8 06				db 5 + 1 
4ca9 .. 00			db "LOWER",0              
4caf				endm 
# End of macro CWHEAD
4caf			; | LOWER ( s -- s ) Lower case string s  | DONE 
4caf					if DEBUG_FORTH_WORDS_KEY 
4caf						DMARK "LWR" 
4caf f5				push af  
4cb0 3a c4 4c			ld a, (.dmark)  
4cb3 32 9d fd			ld (debug_mark),a  
4cb6 3a c5 4c			ld a, (.dmark+1)  
4cb9 32 9e fd			ld (debug_mark+1),a  
4cbc 3a c6 4c			ld a, (.dmark+2)  
4cbf 32 9f fd			ld (debug_mark+2),a  
4cc2 18 03			jr .pastdmark  
4cc4 ..			.dmark: db "LWR"  
4cc7 f1			.pastdmark: pop af  
4cc8			endm  
# End of macro DMARK
4cc8						CALLMONITOR 
4cc8 cd aa fd			call debug_vector  
4ccb				endm  
# End of macro CALLMONITOR
4ccb					endif 
4ccb			 
4ccb					FORTH_DSP 
4ccb cd c1 21			call macro_forth_dsp 
4cce				endm 
# End of macro FORTH_DSP
4cce					 
4cce			; TODO check is string type 
4cce			 
4cce					FORTH_DSP_VALUEHL 
4cce cd fb 21			call macro_dsp_valuehl 
4cd1				endm 
# End of macro FORTH_DSP_VALUEHL
4cd1			; get pointer to string in hl 
4cd1			 
4cd1 7e			.tolow:		ld a, (hl) 
4cd2			;		cp 0 
4cd2 b7					or a 
4cd3 28 07				jr z, .tolowdone 
4cd5			 
4cd5 cd 1d 12				call to_lower 
4cd8			 
4cd8 77					ld (hl), a 
4cd9 23					inc hl 
4cda 18 f5				jr .tolow 
4cdc			 
4cdc					 
4cdc			 
4cdc			 
4cdc			; for each char convert to low 
4cdc					 
4cdc			.tolowdone: 
4cdc					NEXTW 
4cdc cd a7 fd			call parse_vector 
4cdf c3 e2 23			jp macro_next 
4ce2				endm 
# End of macro NEXTW
4ce2			.TCASE: 
4ce2				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
4ce2 48				db WORD_SYS_CORE+52             
4ce3 19 4e			dw .SUBSTR            
4ce5 06				db 5 + 1 
4ce6 .. 00			db "TCASE",0              
4cec				endm 
# End of macro CWHEAD
4cec			; | TCASE ( s -- s ) Title case string s  | DONE 
4cec					if DEBUG_FORTH_WORDS_KEY 
4cec						DMARK "TCS" 
4cec f5				push af  
4ced 3a 01 4d			ld a, (.dmark)  
4cf0 32 9d fd			ld (debug_mark),a  
4cf3 3a 02 4d			ld a, (.dmark+1)  
4cf6 32 9e fd			ld (debug_mark+1),a  
4cf9 3a 03 4d			ld a, (.dmark+2)  
4cfc 32 9f fd			ld (debug_mark+2),a  
4cff 18 03			jr .pastdmark  
4d01 ..			.dmark: db "TCS"  
4d04 f1			.pastdmark: pop af  
4d05			endm  
# End of macro DMARK
4d05						CALLMONITOR 
4d05 cd aa fd			call debug_vector  
4d08				endm  
# End of macro CALLMONITOR
4d08					endif 
4d08			 
4d08					FORTH_DSP 
4d08 cd c1 21			call macro_forth_dsp 
4d0b				endm 
# End of macro FORTH_DSP
4d0b					 
4d0b			; TODO check is string type 
4d0b			 
4d0b					FORTH_DSP_VALUEHL 
4d0b cd fb 21			call macro_dsp_valuehl 
4d0e				endm 
# End of macro FORTH_DSP_VALUEHL
4d0e			; get pointer to string in hl 
4d0e			 
4d0e					if DEBUG_FORTH_WORDS 
4d0e						DMARK "TC1" 
4d0e f5				push af  
4d0f 3a 23 4d			ld a, (.dmark)  
4d12 32 9d fd			ld (debug_mark),a  
4d15 3a 24 4d			ld a, (.dmark+1)  
4d18 32 9e fd			ld (debug_mark+1),a  
4d1b 3a 25 4d			ld a, (.dmark+2)  
4d1e 32 9f fd			ld (debug_mark+2),a  
4d21 18 03			jr .pastdmark  
4d23 ..			.dmark: db "TC1"  
4d26 f1			.pastdmark: pop af  
4d27			endm  
# End of macro DMARK
4d27						CALLMONITOR 
4d27 cd aa fd			call debug_vector  
4d2a				endm  
# End of macro CALLMONITOR
4d2a					endif 
4d2a			 
4d2a					; first time in turn to upper case first char 
4d2a			 
4d2a 7e					ld a, (hl) 
4d2b c3 b4 4d				jp .totsiptou 
4d2e			 
4d2e			 
4d2e 7e			.tot:		ld a, (hl) 
4d2f			;		cp 0 
4d2f b7					or a 
4d30 ca f7 4d				jp z, .totdone 
4d33			 
4d33					if DEBUG_FORTH_WORDS 
4d33						DMARK "TC2" 
4d33 f5				push af  
4d34 3a 48 4d			ld a, (.dmark)  
4d37 32 9d fd			ld (debug_mark),a  
4d3a 3a 49 4d			ld a, (.dmark+1)  
4d3d 32 9e fd			ld (debug_mark+1),a  
4d40 3a 4a 4d			ld a, (.dmark+2)  
4d43 32 9f fd			ld (debug_mark+2),a  
4d46 18 03			jr .pastdmark  
4d48 ..			.dmark: db "TC2"  
4d4b f1			.pastdmark: pop af  
4d4c			endm  
# End of macro DMARK
4d4c						CALLMONITOR 
4d4c cd aa fd			call debug_vector  
4d4f				endm  
# End of macro CALLMONITOR
4d4f					endif 
4d4f					; check to see if current char is a space 
4d4f			 
4d4f fe 20				cp ' ' 
4d51 28 21				jr z, .totsp 
4d53 cd 1d 12				call to_lower 
4d56					if DEBUG_FORTH_WORDS 
4d56						DMARK "TC3" 
4d56 f5				push af  
4d57 3a 6b 4d			ld a, (.dmark)  
4d5a 32 9d fd			ld (debug_mark),a  
4d5d 3a 6c 4d			ld a, (.dmark+1)  
4d60 32 9e fd			ld (debug_mark+1),a  
4d63 3a 6d 4d			ld a, (.dmark+2)  
4d66 32 9f fd			ld (debug_mark+2),a  
4d69 18 03			jr .pastdmark  
4d6b ..			.dmark: db "TC3"  
4d6e f1			.pastdmark: pop af  
4d6f			endm  
# End of macro DMARK
4d6f						CALLMONITOR 
4d6f cd aa fd			call debug_vector  
4d72				endm  
# End of macro CALLMONITOR
4d72					endif 
4d72 18 62				jr .totnxt 
4d74			 
4d74			.totsp:         ; on a space, find next char which should be upper 
4d74			 
4d74					if DEBUG_FORTH_WORDS 
4d74						DMARK "TC4" 
4d74 f5				push af  
4d75 3a 89 4d			ld a, (.dmark)  
4d78 32 9d fd			ld (debug_mark),a  
4d7b 3a 8a 4d			ld a, (.dmark+1)  
4d7e 32 9e fd			ld (debug_mark+1),a  
4d81 3a 8b 4d			ld a, (.dmark+2)  
4d84 32 9f fd			ld (debug_mark+2),a  
4d87 18 03			jr .pastdmark  
4d89 ..			.dmark: db "TC4"  
4d8c f1			.pastdmark: pop af  
4d8d			endm  
# End of macro DMARK
4d8d						CALLMONITOR 
4d8d cd aa fd			call debug_vector  
4d90				endm  
# End of macro CALLMONITOR
4d90					endif 
4d90					;; 
4d90			 
4d90 fe 20				cp ' ' 
4d92 20 20				jr nz, .totsiptou 
4d94 23					inc hl 
4d95 7e					ld a, (hl) 
4d96					if DEBUG_FORTH_WORDS 
4d96						DMARK "TC5" 
4d96 f5				push af  
4d97 3a ab 4d			ld a, (.dmark)  
4d9a 32 9d fd			ld (debug_mark),a  
4d9d 3a ac 4d			ld a, (.dmark+1)  
4da0 32 9e fd			ld (debug_mark+1),a  
4da3 3a ad 4d			ld a, (.dmark+2)  
4da6 32 9f fd			ld (debug_mark+2),a  
4da9 18 03			jr .pastdmark  
4dab ..			.dmark: db "TC5"  
4dae f1			.pastdmark: pop af  
4daf			endm  
# End of macro DMARK
4daf						CALLMONITOR 
4daf cd aa fd			call debug_vector  
4db2				endm  
# End of macro CALLMONITOR
4db2					endif 
4db2 18 c0				jr .totsp 
4db4			.totsiptou:     
4db4					;cp 0 
4db4 b7					or a 
4db5 28 40				jr z, .totdone 
4db7					; not space and not zero term so upper case it 
4db7 cd 14 12				call to_upper 
4dba			 
4dba					if DEBUG_FORTH_WORDS 
4dba						DMARK "TC6" 
4dba f5				push af  
4dbb 3a cf 4d			ld a, (.dmark)  
4dbe 32 9d fd			ld (debug_mark),a  
4dc1 3a d0 4d			ld a, (.dmark+1)  
4dc4 32 9e fd			ld (debug_mark+1),a  
4dc7 3a d1 4d			ld a, (.dmark+2)  
4dca 32 9f fd			ld (debug_mark+2),a  
4dcd 18 03			jr .pastdmark  
4dcf ..			.dmark: db "TC6"  
4dd2 f1			.pastdmark: pop af  
4dd3			endm  
# End of macro DMARK
4dd3						CALLMONITOR 
4dd3 cd aa fd			call debug_vector  
4dd6				endm  
# End of macro CALLMONITOR
4dd6					endif 
4dd6			 
4dd6			 
4dd6			.totnxt: 
4dd6			 
4dd6 77					ld (hl), a 
4dd7 23					inc hl 
4dd8					if DEBUG_FORTH_WORDS 
4dd8						DMARK "TC7" 
4dd8 f5				push af  
4dd9 3a ed 4d			ld a, (.dmark)  
4ddc 32 9d fd			ld (debug_mark),a  
4ddf 3a ee 4d			ld a, (.dmark+1)  
4de2 32 9e fd			ld (debug_mark+1),a  
4de5 3a ef 4d			ld a, (.dmark+2)  
4de8 32 9f fd			ld (debug_mark+2),a  
4deb 18 03			jr .pastdmark  
4ded ..			.dmark: db "TC7"  
4df0 f1			.pastdmark: pop af  
4df1			endm  
# End of macro DMARK
4df1						CALLMONITOR 
4df1 cd aa fd			call debug_vector  
4df4				endm  
# End of macro CALLMONITOR
4df4					endif 
4df4 c3 2e 4d				jp .tot 
4df7			 
4df7					 
4df7			 
4df7			 
4df7			; for each char convert to low 
4df7					 
4df7			.totdone: 
4df7					if DEBUG_FORTH_WORDS 
4df7						DMARK "TCd" 
4df7 f5				push af  
4df8 3a 0c 4e			ld a, (.dmark)  
4dfb 32 9d fd			ld (debug_mark),a  
4dfe 3a 0d 4e			ld a, (.dmark+1)  
4e01 32 9e fd			ld (debug_mark+1),a  
4e04 3a 0e 4e			ld a, (.dmark+2)  
4e07 32 9f fd			ld (debug_mark+2),a  
4e0a 18 03			jr .pastdmark  
4e0c ..			.dmark: db "TCd"  
4e0f f1			.pastdmark: pop af  
4e10			endm  
# End of macro DMARK
4e10						CALLMONITOR 
4e10 cd aa fd			call debug_vector  
4e13				endm  
# End of macro CALLMONITOR
4e13					endif 
4e13					NEXTW 
4e13 cd a7 fd			call parse_vector 
4e16 c3 e2 23			jp macro_next 
4e19				endm 
# End of macro NEXTW
4e19			 
4e19			.SUBSTR: 
4e19				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
4e19 48				db WORD_SYS_CORE+52             
4e1a 79 4e			dw .LEFT            
4e1c 07				db 6 + 1 
4e1d .. 00			db "SUBSTR",0              
4e24				endm 
# End of macro CWHEAD
4e24			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
4e24			 
4e24					if DEBUG_FORTH_WORDS_KEY 
4e24						DMARK "SST" 
4e24 f5				push af  
4e25 3a 39 4e			ld a, (.dmark)  
4e28 32 9d fd			ld (debug_mark),a  
4e2b 3a 3a 4e			ld a, (.dmark+1)  
4e2e 32 9e fd			ld (debug_mark+1),a  
4e31 3a 3b 4e			ld a, (.dmark+2)  
4e34 32 9f fd			ld (debug_mark+2),a  
4e37 18 03			jr .pastdmark  
4e39 ..			.dmark: db "SST"  
4e3c f1			.pastdmark: pop af  
4e3d			endm  
# End of macro DMARK
4e3d						CALLMONITOR 
4e3d cd aa fd			call debug_vector  
4e40				endm  
# End of macro CALLMONITOR
4e40					endif 
4e40			; TODO check string type 
4e40					FORTH_DSP_VALUEHL 
4e40 cd fb 21			call macro_dsp_valuehl 
4e43				endm 
# End of macro FORTH_DSP_VALUEHL
4e43			 
4e43 e5					push hl      ; string length 
4e44			 
4e44					FORTH_DSP_POP 
4e44 cd b3 22			call macro_forth_dsp_pop 
4e47				endm 
# End of macro FORTH_DSP_POP
4e47			 
4e47					FORTH_DSP_VALUEHL 
4e47 cd fb 21			call macro_dsp_valuehl 
4e4a				endm 
# End of macro FORTH_DSP_VALUEHL
4e4a			 
4e4a e5					push hl     ; start char 
4e4b			 
4e4b					FORTH_DSP_POP 
4e4b cd b3 22			call macro_forth_dsp_pop 
4e4e				endm 
# End of macro FORTH_DSP_POP
4e4e			 
4e4e			 
4e4e					FORTH_DSP_VALUE 
4e4e cd e4 21			call macro_forth_dsp_value 
4e51				endm 
# End of macro FORTH_DSP_VALUE
4e51			 
4e51 d1					pop de    ; get start post offset 
4e52			 
4e52 19					add hl, de    ; starting offset 
4e53			 
4e53 c1					pop bc 
4e54 c5					push bc      ; grab size of string 
4e55			 
4e55 e5					push hl    ; save string start  
4e56			 
4e56 26 00				ld h, 0 
4e58 69					ld l, c 
4e59 23					inc hl 
4e5a 23					inc hl 
4e5b			 
4e5b cd 78 13				call malloc 
4e5e				if DEBUG_FORTH_MALLOC_GUARD 
4e5e cc fd 65				call z,malloc_error 
4e61				endif 
4e61			 
4e61 eb					ex de, hl      ; save malloc area for string copy 
4e62 e1					pop hl    ; get back source 
4e63 c1					pop bc    ; get length of string back 
4e64			 
4e64 d5					push de    ; save malloc area for after we push 
4e65 ed b0				ldir     ; copy substr 
4e67			 
4e67			 
4e67 eb					ex de, hl 
4e68			;		ld a, 0 
4e68 36 00				ld (hl), 0   ; term substr 
4e6a			 
4e6a					 
4e6a e1					pop hl    ; get malloc so we can push it 
4e6b e5					push hl   ; save so we can free it afterwards 
4e6c			 
4e6c cd 69 20				call forth_push_str 
4e6f			 
4e6f e1					pop hl 
4e70 cd 42 14				call free 
4e73			 
4e73					 
4e73					 
4e73			 
4e73			 
4e73					NEXTW 
4e73 cd a7 fd			call parse_vector 
4e76 c3 e2 23			jp macro_next 
4e79				endm 
# End of macro NEXTW
4e79			 
4e79			.LEFT: 
4e79				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
4e79 48				db WORD_SYS_CORE+52             
4e7a bd 4e			dw .RIGHT            
4e7c 05				db 4 + 1 
4e7d .. 00			db "LEFT",0              
4e82				endm 
# End of macro CWHEAD
4e82			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | DONE 
4e82					if DEBUG_FORTH_WORDS_KEY 
4e82						DMARK "LEF" 
4e82 f5				push af  
4e83 3a 97 4e			ld a, (.dmark)  
4e86 32 9d fd			ld (debug_mark),a  
4e89 3a 98 4e			ld a, (.dmark+1)  
4e8c 32 9e fd			ld (debug_mark+1),a  
4e8f 3a 99 4e			ld a, (.dmark+2)  
4e92 32 9f fd			ld (debug_mark+2),a  
4e95 18 03			jr .pastdmark  
4e97 ..			.dmark: db "LEF"  
4e9a f1			.pastdmark: pop af  
4e9b			endm  
# End of macro DMARK
4e9b						CALLMONITOR 
4e9b cd aa fd			call debug_vector  
4e9e				endm  
# End of macro CALLMONITOR
4e9e					endif 
4e9e			 
4e9e					 
4e9e			; TODO check string type 
4e9e					FORTH_DSP_VALUEHL 
4e9e cd fb 21			call macro_dsp_valuehl 
4ea1				endm 
# End of macro FORTH_DSP_VALUEHL
4ea1			 
4ea1 e5					push hl      ; string length 
4ea2			 
4ea2					FORTH_DSP_POP 
4ea2 cd b3 22			call macro_forth_dsp_pop 
4ea5				endm 
# End of macro FORTH_DSP_POP
4ea5			 
4ea5					FORTH_DSP_VALUEHL 
4ea5 cd fb 21			call macro_dsp_valuehl 
4ea8				endm 
# End of macro FORTH_DSP_VALUEHL
4ea8			 
4ea8 c1					pop bc 
4ea9			 
4ea9 11 f3 f0				ld de, scratch 
4eac ed b0				ldir 
4eae 3e 00				ld a, 0 
4eb0 12					ld (de), a 
4eb1					 
4eb1 21 f3 f0				ld hl, scratch 
4eb4 cd 69 20				call forth_push_str 
4eb7			 
4eb7					NEXTW 
4eb7 cd a7 fd			call parse_vector 
4eba c3 e2 23			jp macro_next 
4ebd				endm 
# End of macro NEXTW
4ebd			.RIGHT: 
4ebd				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4ebd 48				db WORD_SYS_CORE+52             
4ebe 7e 4f			dw .STR2NUM            
4ec0 06				db 5 + 1 
4ec1 .. 00			db "RIGHT",0              
4ec7				endm 
# End of macro CWHEAD
4ec7			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | DONE 
4ec7					if DEBUG_FORTH_WORDS_KEY 
4ec7						DMARK "RIG" 
4ec7 f5				push af  
4ec8 3a dc 4e			ld a, (.dmark)  
4ecb 32 9d fd			ld (debug_mark),a  
4ece 3a dd 4e			ld a, (.dmark+1)  
4ed1 32 9e fd			ld (debug_mark+1),a  
4ed4 3a de 4e			ld a, (.dmark+2)  
4ed7 32 9f fd			ld (debug_mark+2),a  
4eda 18 03			jr .pastdmark  
4edc ..			.dmark: db "RIG"  
4edf f1			.pastdmark: pop af  
4ee0			endm  
# End of macro DMARK
4ee0						CALLMONITOR 
4ee0 cd aa fd			call debug_vector  
4ee3				endm  
# End of macro CALLMONITOR
4ee3					endif 
4ee3			 
4ee3			; TODO check string type 
4ee3					FORTH_DSP_VALUEHL 
4ee3 cd fb 21			call macro_dsp_valuehl 
4ee6				endm 
# End of macro FORTH_DSP_VALUEHL
4ee6			 
4ee6 e5					push hl      ; string length 
4ee7			 
4ee7					FORTH_DSP_POP 
4ee7 cd b3 22			call macro_forth_dsp_pop 
4eea				endm 
# End of macro FORTH_DSP_POP
4eea			 
4eea					FORTH_DSP_VALUEHL 
4eea cd fb 21			call macro_dsp_valuehl 
4eed				endm 
# End of macro FORTH_DSP_VALUEHL
4eed			 
4eed					if DEBUG_FORTH_WORDS 
4eed						DMARK "RI1" 
4eed f5				push af  
4eee 3a 02 4f			ld a, (.dmark)  
4ef1 32 9d fd			ld (debug_mark),a  
4ef4 3a 03 4f			ld a, (.dmark+1)  
4ef7 32 9e fd			ld (debug_mark+1),a  
4efa 3a 04 4f			ld a, (.dmark+2)  
4efd 32 9f fd			ld (debug_mark+2),a  
4f00 18 03			jr .pastdmark  
4f02 ..			.dmark: db "RI1"  
4f05 f1			.pastdmark: pop af  
4f06			endm  
# End of macro DMARK
4f06						CALLMONITOR 
4f06 cd aa fd			call debug_vector  
4f09				endm  
# End of macro CALLMONITOR
4f09					endif 
4f09					; from the pointer to string get to the end of string 
4f09			 
4f09 01 ff 00				ld bc, 255 
4f0c 3e 00				ld a, 0 
4f0e ed b1				cpir 
4f10 2b					dec hl 
4f11			 
4f11					;  
4f11			 
4f11					if DEBUG_FORTH_WORDS 
4f11						DMARK "RI2" 
4f11 f5				push af  
4f12 3a 26 4f			ld a, (.dmark)  
4f15 32 9d fd			ld (debug_mark),a  
4f18 3a 27 4f			ld a, (.dmark+1)  
4f1b 32 9e fd			ld (debug_mark+1),a  
4f1e 3a 28 4f			ld a, (.dmark+2)  
4f21 32 9f fd			ld (debug_mark+2),a  
4f24 18 03			jr .pastdmark  
4f26 ..			.dmark: db "RI2"  
4f29 f1			.pastdmark: pop af  
4f2a			endm  
# End of macro DMARK
4f2a						CALLMONITOR 
4f2a cd aa fd			call debug_vector  
4f2d				endm  
# End of macro CALLMONITOR
4f2d					endif 
4f2d			 
4f2d c1					pop bc    ;  length of string to copy 
4f2e			 
4f2e 79					ld a, c 
4f2f eb					ex de, hl 
4f30 21 f3 f0				ld hl, scratch  
4f33 cd ac 0f				call addatohl 
4f36			 
4f36 eb					ex de, hl 
4f37			 
4f37					if DEBUG_FORTH_WORDS 
4f37						DMARK "RI3" 
4f37 f5				push af  
4f38 3a 4c 4f			ld a, (.dmark)  
4f3b 32 9d fd			ld (debug_mark),a  
4f3e 3a 4d 4f			ld a, (.dmark+1)  
4f41 32 9e fd			ld (debug_mark+1),a  
4f44 3a 4e 4f			ld a, (.dmark+2)  
4f47 32 9f fd			ld (debug_mark+2),a  
4f4a 18 03			jr .pastdmark  
4f4c ..			.dmark: db "RI3"  
4f4f f1			.pastdmark: pop af  
4f50			endm  
# End of macro DMARK
4f50						CALLMONITOR 
4f50 cd aa fd			call debug_vector  
4f53				endm  
# End of macro CALLMONITOR
4f53					endif 
4f53			 
4f53 03					inc bc 
4f54 ed b8				lddr 
4f56					 
4f56 21 f3 f0				ld hl, scratch 
4f59					if DEBUG_FORTH_WORDS 
4f59						DMARK "RI4" 
4f59 f5				push af  
4f5a 3a 6e 4f			ld a, (.dmark)  
4f5d 32 9d fd			ld (debug_mark),a  
4f60 3a 6f 4f			ld a, (.dmark+1)  
4f63 32 9e fd			ld (debug_mark+1),a  
4f66 3a 70 4f			ld a, (.dmark+2)  
4f69 32 9f fd			ld (debug_mark+2),a  
4f6c 18 03			jr .pastdmark  
4f6e ..			.dmark: db "RI4"  
4f71 f1			.pastdmark: pop af  
4f72			endm  
# End of macro DMARK
4f72						CALLMONITOR 
4f72 cd aa fd			call debug_vector  
4f75				endm  
# End of macro CALLMONITOR
4f75					endif 
4f75 cd 69 20				call forth_push_str 
4f78			 
4f78			 
4f78					NEXTW 
4f78 cd a7 fd			call parse_vector 
4f7b c3 e2 23			jp macro_next 
4f7e				endm 
# End of macro NEXTW
4f7e			 
4f7e			 
4f7e			.STR2NUM: 
4f7e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
4f7e 48				db WORD_SYS_CORE+52             
4f7f 0d 50			dw .NUM2STR            
4f81 08				db 7 + 1 
4f82 .. 00			db "STR2NUM",0              
4f8a				endm 
# End of macro CWHEAD
4f8a			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
4f8a			 
4f8a			 
4f8a			; TODO STR type check to do 
4f8a					if DEBUG_FORTH_WORDS_KEY 
4f8a						DMARK "S2N" 
4f8a f5				push af  
4f8b 3a 9f 4f			ld a, (.dmark)  
4f8e 32 9d fd			ld (debug_mark),a  
4f91 3a a0 4f			ld a, (.dmark+1)  
4f94 32 9e fd			ld (debug_mark+1),a  
4f97 3a a1 4f			ld a, (.dmark+2)  
4f9a 32 9f fd			ld (debug_mark+2),a  
4f9d 18 03			jr .pastdmark  
4f9f ..			.dmark: db "S2N"  
4fa2 f1			.pastdmark: pop af  
4fa3			endm  
# End of macro DMARK
4fa3						CALLMONITOR 
4fa3 cd aa fd			call debug_vector  
4fa6				endm  
# End of macro CALLMONITOR
4fa6					endif 
4fa6			 
4fa6					;FORTH_DSP 
4fa6					FORTH_DSP_VALUE 
4fa6 cd e4 21			call macro_forth_dsp_value 
4fa9				endm 
# End of macro FORTH_DSP_VALUE
4fa9					;inc hl 
4fa9			 
4fa9 eb					ex de, hl 
4faa					if DEBUG_FORTH_WORDS 
4faa						DMARK "S2a" 
4faa f5				push af  
4fab 3a bf 4f			ld a, (.dmark)  
4fae 32 9d fd			ld (debug_mark),a  
4fb1 3a c0 4f			ld a, (.dmark+1)  
4fb4 32 9e fd			ld (debug_mark+1),a  
4fb7 3a c1 4f			ld a, (.dmark+2)  
4fba 32 9f fd			ld (debug_mark+2),a  
4fbd 18 03			jr .pastdmark  
4fbf ..			.dmark: db "S2a"  
4fc2 f1			.pastdmark: pop af  
4fc3			endm  
# End of macro DMARK
4fc3						CALLMONITOR 
4fc3 cd aa fd			call debug_vector  
4fc6				endm  
# End of macro CALLMONITOR
4fc6					endif 
4fc6 cd 9b 12				call string_to_uint16 
4fc9			 
4fc9					if DEBUG_FORTH_WORDS 
4fc9						DMARK "S2b" 
4fc9 f5				push af  
4fca 3a de 4f			ld a, (.dmark)  
4fcd 32 9d fd			ld (debug_mark),a  
4fd0 3a df 4f			ld a, (.dmark+1)  
4fd3 32 9e fd			ld (debug_mark+1),a  
4fd6 3a e0 4f			ld a, (.dmark+2)  
4fd9 32 9f fd			ld (debug_mark+2),a  
4fdc 18 03			jr .pastdmark  
4fde ..			.dmark: db "S2b"  
4fe1 f1			.pastdmark: pop af  
4fe2			endm  
# End of macro DMARK
4fe2						CALLMONITOR 
4fe2 cd aa fd			call debug_vector  
4fe5				endm  
# End of macro CALLMONITOR
4fe5					endif 
4fe5			;		push hl 
4fe5					FORTH_DSP_POP 
4fe5 cd b3 22			call macro_forth_dsp_pop 
4fe8				endm 
# End of macro FORTH_DSP_POP
4fe8			;		pop hl 
4fe8					 
4fe8					if DEBUG_FORTH_WORDS 
4fe8						DMARK "S2b" 
4fe8 f5				push af  
4fe9 3a fd 4f			ld a, (.dmark)  
4fec 32 9d fd			ld (debug_mark),a  
4fef 3a fe 4f			ld a, (.dmark+1)  
4ff2 32 9e fd			ld (debug_mark+1),a  
4ff5 3a ff 4f			ld a, (.dmark+2)  
4ff8 32 9f fd			ld (debug_mark+2),a  
4ffb 18 03			jr .pastdmark  
4ffd ..			.dmark: db "S2b"  
5000 f1			.pastdmark: pop af  
5001			endm  
# End of macro DMARK
5001						CALLMONITOR 
5001 cd aa fd			call debug_vector  
5004				endm  
# End of macro CALLMONITOR
5004					endif 
5004 cd ff 1f				call forth_push_numhl	 
5007			 
5007				 
5007				       NEXTW 
5007 cd a7 fd			call parse_vector 
500a c3 e2 23			jp macro_next 
500d				endm 
# End of macro NEXTW
500d			.NUM2STR: 
500d				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
500d 48				db WORD_SYS_CORE+52             
500e a2 50			dw .CONCAT            
5010 08				db 7 + 1 
5011 .. 00			db "NUM2STR",0              
5019				endm 
# End of macro CWHEAD
5019			; | NUM2STR ( n -- s ) Convert a number on TOS to zero padded string | DONE 
5019			 
5019			;		; malloc a string to target 
5019			;		ld hl, 10     ; TODO max string size should be fine 
5019			;		call malloc 
5019			;		push hl    ; save malloc location 
5019			; 
5019			; 
5019			;; TODO check int type 
5019					if DEBUG_FORTH_WORDS_KEY 
5019						DMARK "N2S" 
5019 f5				push af  
501a 3a 2e 50			ld a, (.dmark)  
501d 32 9d fd			ld (debug_mark),a  
5020 3a 2f 50			ld a, (.dmark+1)  
5023 32 9e fd			ld (debug_mark+1),a  
5026 3a 30 50			ld a, (.dmark+2)  
5029 32 9f fd			ld (debug_mark+2),a  
502c 18 03			jr .pastdmark  
502e ..			.dmark: db "N2S"  
5031 f1			.pastdmark: pop af  
5032			endm  
# End of macro DMARK
5032						CALLMONITOR 
5032 cd aa fd			call debug_vector  
5035				endm  
# End of macro CALLMONITOR
5035					endif 
5035			 
5035					FORTH_DSP_VALUEHL 
5035 cd fb 21			call macro_dsp_valuehl 
5038				endm 
# End of macro FORTH_DSP_VALUEHL
5038			 
5038					if DEBUG_FORTH_WORDS 
5038						DMARK "NS1" 
5038 f5				push af  
5039 3a 4d 50			ld a, (.dmark)  
503c 32 9d fd			ld (debug_mark),a  
503f 3a 4e 50			ld a, (.dmark+1)  
5042 32 9e fd			ld (debug_mark+1),a  
5045 3a 4f 50			ld a, (.dmark+2)  
5048 32 9f fd			ld (debug_mark+2),a  
504b 18 03			jr .pastdmark  
504d ..			.dmark: db "NS1"  
5050 f1			.pastdmark: pop af  
5051			endm  
# End of macro DMARK
5051						CALLMONITOR 
5051 cd aa fd			call debug_vector  
5054				endm  
# End of macro CALLMONITOR
5054					endif 
5054					FORTH_DSP_POP 
5054 cd b3 22			call macro_forth_dsp_pop 
5057				endm 
# End of macro FORTH_DSP_POP
5057			 
5057 eb					ex de, hl 
5058 21 f3 f0				ld hl, scratch 
505b					if DEBUG_FORTH_WORDS 
505b						DMARK "NS2" 
505b f5				push af  
505c 3a 70 50			ld a, (.dmark)  
505f 32 9d fd			ld (debug_mark),a  
5062 3a 71 50			ld a, (.dmark+1)  
5065 32 9e fd			ld (debug_mark+1),a  
5068 3a 72 50			ld a, (.dmark+2)  
506b 32 9f fd			ld (debug_mark+2),a  
506e 18 03			jr .pastdmark  
5070 ..			.dmark: db "NS2"  
5073 f1			.pastdmark: pop af  
5074			endm  
# End of macro DMARK
5074						CALLMONITOR 
5074 cd aa fd			call debug_vector  
5077				endm  
# End of macro CALLMONITOR
5077					endif 
5077 cd b3 12				call uitoa_16 
507a 21 f3 f0				ld hl, scratch 
507d					if DEBUG_FORTH_WORDS 
507d						DMARK "NS3" 
507d f5				push af  
507e 3a 92 50			ld a, (.dmark)  
5081 32 9d fd			ld (debug_mark),a  
5084 3a 93 50			ld a, (.dmark+1)  
5087 32 9e fd			ld (debug_mark+1),a  
508a 3a 94 50			ld a, (.dmark+2)  
508d 32 9f fd			ld (debug_mark+2),a  
5090 18 03			jr .pastdmark  
5092 ..			.dmark: db "NS3"  
5095 f1			.pastdmark: pop af  
5096			endm  
# End of macro DMARK
5096						CALLMONITOR 
5096 cd aa fd			call debug_vector  
5099				endm  
# End of macro CALLMONITOR
5099					endif 
5099 cd 69 20				call forth_push_str 
509c			;		ld a, l 
509c			;		call DispAToASCII   
509c			;;TODO need to chage above call to dump into string 
509c			; 
509c			; 
509c			 
509c				       NEXTW 
509c cd a7 fd			call parse_vector 
509f c3 e2 23			jp macro_next 
50a2				endm 
# End of macro NEXTW
50a2			 
50a2			.CONCAT: 
50a2				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
50a2 48				db WORD_SYS_CORE+52             
50a3 58 51			dw .FIND            
50a5 07				db 6 + 1 
50a6 .. 00			db "CONCAT",0              
50ad				endm 
# End of macro CWHEAD
50ad			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
50ad			 
50ad			; TODO check string type 
50ad			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
50ad			 
50ad					if DEBUG_FORTH_WORDS_KEY 
50ad						DMARK "CON" 
50ad f5				push af  
50ae 3a c2 50			ld a, (.dmark)  
50b1 32 9d fd			ld (debug_mark),a  
50b4 3a c3 50			ld a, (.dmark+1)  
50b7 32 9e fd			ld (debug_mark+1),a  
50ba 3a c4 50			ld a, (.dmark+2)  
50bd 32 9f fd			ld (debug_mark+2),a  
50c0 18 03			jr .pastdmark  
50c2 ..			.dmark: db "CON"  
50c5 f1			.pastdmark: pop af  
50c6			endm  
# End of macro DMARK
50c6						CALLMONITOR 
50c6 cd aa fd			call debug_vector  
50c9				endm  
# End of macro CALLMONITOR
50c9					endif 
50c9			 
50c9			 
50c9					FORTH_DSP_VALUE 
50c9 cd e4 21			call macro_forth_dsp_value 
50cc				endm 
# End of macro FORTH_DSP_VALUE
50cc e5					push hl   ; s2 
50cd			 
50cd					FORTH_DSP_POP 
50cd cd b3 22			call macro_forth_dsp_pop 
50d0				endm 
# End of macro FORTH_DSP_POP
50d0			 
50d0					FORTH_DSP_VALUE 
50d0 cd e4 21			call macro_forth_dsp_value 
50d3				endm 
# End of macro FORTH_DSP_VALUE
50d3			 
50d3 e5					push hl   ; s1 
50d4			 
50d4					FORTH_DSP_POP 
50d4 cd b3 22			call macro_forth_dsp_pop 
50d7				endm 
# End of macro FORTH_DSP_POP
50d7					 
50d7			 
50d7					; copy s1 
50d7			 
50d7				 
50d7					; save ptr 
50d7 e1					pop hl  
50d8 e5					push hl 
50d9 3e 00				ld a, 0 
50db cd 0f 13				call strlent 
50de					;inc hl    ; zer0 
50de 06 00				ld b, 0 
50e0 4d					ld c, l 
50e1 e1					pop hl		 
50e2 11 f3 f0				ld de, scratch	 
50e5					if DEBUG_FORTH_WORDS 
50e5						DMARK "CO1" 
50e5 f5				push af  
50e6 3a fa 50			ld a, (.dmark)  
50e9 32 9d fd			ld (debug_mark),a  
50ec 3a fb 50			ld a, (.dmark+1)  
50ef 32 9e fd			ld (debug_mark+1),a  
50f2 3a fc 50			ld a, (.dmark+2)  
50f5 32 9f fd			ld (debug_mark+2),a  
50f8 18 03			jr .pastdmark  
50fa ..			.dmark: db "CO1"  
50fd f1			.pastdmark: pop af  
50fe			endm  
# End of macro DMARK
50fe						CALLMONITOR 
50fe cd aa fd			call debug_vector  
5101				endm  
# End of macro CALLMONITOR
5101					endif 
5101 ed b0				ldir 
5103			 
5103 e1					pop hl 
5104 e5					push hl 
5105 d5					push de 
5106			 
5106			 
5106 3e 00				ld a, 0 
5108 cd 0f 13				call strlent 
510b 23					inc hl    ; zer0 
510c 23					inc hl 
510d 06 00				ld b, 0 
510f 4d					ld c, l 
5110 d1					pop de 
5111 e1					pop hl		 
5112					if DEBUG_FORTH_WORDS 
5112						DMARK "CO2" 
5112 f5				push af  
5113 3a 27 51			ld a, (.dmark)  
5116 32 9d fd			ld (debug_mark),a  
5119 3a 28 51			ld a, (.dmark+1)  
511c 32 9e fd			ld (debug_mark+1),a  
511f 3a 29 51			ld a, (.dmark+2)  
5122 32 9f fd			ld (debug_mark+2),a  
5125 18 03			jr .pastdmark  
5127 ..			.dmark: db "CO2"  
512a f1			.pastdmark: pop af  
512b			endm  
# End of macro DMARK
512b						CALLMONITOR 
512b cd aa fd			call debug_vector  
512e				endm  
# End of macro CALLMONITOR
512e					endif 
512e ed b0				ldir 
5130			 
5130			 
5130			 
5130 21 f3 f0				ld hl, scratch 
5133					if DEBUG_FORTH_WORDS 
5133						DMARK "CO5" 
5133 f5				push af  
5134 3a 48 51			ld a, (.dmark)  
5137 32 9d fd			ld (debug_mark),a  
513a 3a 49 51			ld a, (.dmark+1)  
513d 32 9e fd			ld (debug_mark+1),a  
5140 3a 4a 51			ld a, (.dmark+2)  
5143 32 9f fd			ld (debug_mark+2),a  
5146 18 03			jr .pastdmark  
5148 ..			.dmark: db "CO5"  
514b f1			.pastdmark: pop af  
514c			endm  
# End of macro DMARK
514c						CALLMONITOR 
514c cd aa fd			call debug_vector  
514f				endm  
# End of macro CALLMONITOR
514f					endif 
514f			 
514f cd 69 20				call forth_push_str 
5152			 
5152			 
5152			 
5152			 
5152				       NEXTW 
5152 cd a7 fd			call parse_vector 
5155 c3 e2 23			jp macro_next 
5158				endm 
# End of macro NEXTW
5158			 
5158			 
5158			.FIND: 
5158				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
5158 4b				db WORD_SYS_CORE+55             
5159 18 52			dw .LEN            
515b 05				db 4 + 1 
515c .. 00			db "FIND",0              
5161				endm 
# End of macro CWHEAD
5161			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
5161			 
5161					if DEBUG_FORTH_WORDS_KEY 
5161						DMARK "FND" 
5161 f5				push af  
5162 3a 76 51			ld a, (.dmark)  
5165 32 9d fd			ld (debug_mark),a  
5168 3a 77 51			ld a, (.dmark+1)  
516b 32 9e fd			ld (debug_mark+1),a  
516e 3a 78 51			ld a, (.dmark+2)  
5171 32 9f fd			ld (debug_mark+2),a  
5174 18 03			jr .pastdmark  
5176 ..			.dmark: db "FND"  
5179 f1			.pastdmark: pop af  
517a			endm  
# End of macro DMARK
517a						CALLMONITOR 
517a cd aa fd			call debug_vector  
517d				endm  
# End of macro CALLMONITOR
517d					endif 
517d			 
517d			; TODO check string type 
517d					FORTH_DSP_VALUE 
517d cd e4 21			call macro_forth_dsp_value 
5180				endm 
# End of macro FORTH_DSP_VALUE
5180			 
5180 e5					push hl    
5181 7e					ld a,(hl)    ; char to find   
5182			; TODO change char to substr 
5182			 
5182 f5					push af 
5183					 
5183			 
5183			 
5183					if DEBUG_FORTH_WORDS 
5183						DMARK "FN1" 
5183 f5				push af  
5184 3a 98 51			ld a, (.dmark)  
5187 32 9d fd			ld (debug_mark),a  
518a 3a 99 51			ld a, (.dmark+1)  
518d 32 9e fd			ld (debug_mark+1),a  
5190 3a 9a 51			ld a, (.dmark+2)  
5193 32 9f fd			ld (debug_mark+2),a  
5196 18 03			jr .pastdmark  
5198 ..			.dmark: db "FN1"  
519b f1			.pastdmark: pop af  
519c			endm  
# End of macro DMARK
519c						CALLMONITOR 
519c cd aa fd			call debug_vector  
519f				endm  
# End of macro CALLMONITOR
519f					endif 
519f			 
519f					FORTH_DSP_POP 
519f cd b3 22			call macro_forth_dsp_pop 
51a2				endm 
# End of macro FORTH_DSP_POP
51a2			 
51a2					; string to search 
51a2			 
51a2					FORTH_DSP_VALUE 
51a2 cd e4 21			call macro_forth_dsp_value 
51a5				endm 
# End of macro FORTH_DSP_VALUE
51a5			 
51a5 d1					pop de  ; d is char to find  
51a6			 
51a6					if DEBUG_FORTH_WORDS 
51a6						DMARK "FN2" 
51a6 f5				push af  
51a7 3a bb 51			ld a, (.dmark)  
51aa 32 9d fd			ld (debug_mark),a  
51ad 3a bc 51			ld a, (.dmark+1)  
51b0 32 9e fd			ld (debug_mark+1),a  
51b3 3a bd 51			ld a, (.dmark+2)  
51b6 32 9f fd			ld (debug_mark+2),a  
51b9 18 03			jr .pastdmark  
51bb ..			.dmark: db "FN2"  
51be f1			.pastdmark: pop af  
51bf			endm  
# End of macro DMARK
51bf						CALLMONITOR 
51bf cd aa fd			call debug_vector  
51c2				endm  
# End of macro CALLMONITOR
51c2					endif 
51c2					 
51c2 01 00 00				ld bc, 0 
51c5 7e			.findchar:      ld a,(hl) 
51c6			;		cp 0   		 
51c6 b7					or a 
51c7 28 27				jr z, .finddone     
51c9 ba					cp d 
51ca 28 20				jr z, .foundchar 
51cc 03					inc bc 
51cd 23					inc hl 
51ce					if DEBUG_FORTH_WORDS 
51ce						DMARK "FN3" 
51ce f5				push af  
51cf 3a e3 51			ld a, (.dmark)  
51d2 32 9d fd			ld (debug_mark),a  
51d5 3a e4 51			ld a, (.dmark+1)  
51d8 32 9e fd			ld (debug_mark+1),a  
51db 3a e5 51			ld a, (.dmark+2)  
51de 32 9f fd			ld (debug_mark+2),a  
51e1 18 03			jr .pastdmark  
51e3 ..			.dmark: db "FN3"  
51e6 f1			.pastdmark: pop af  
51e7			endm  
# End of macro DMARK
51e7						CALLMONITOR 
51e7 cd aa fd			call debug_vector  
51ea				endm  
# End of macro CALLMONITOR
51ea					endif 
51ea 18 d9				jr .findchar 
51ec			 
51ec			 
51ec c5			.foundchar:	push bc 
51ed e1					pop hl 
51ee 18 03				jr .findexit 
51f0			 
51f0			 
51f0							 
51f0			 
51f0			.finddone:     ; got to end of string with no find 
51f0 21 00 00				ld hl, 0 
51f3			.findexit: 
51f3			 
51f3					if DEBUG_FORTH_WORDS 
51f3						DMARK "FNd" 
51f3 f5				push af  
51f4 3a 08 52			ld a, (.dmark)  
51f7 32 9d fd			ld (debug_mark),a  
51fa 3a 09 52			ld a, (.dmark+1)  
51fd 32 9e fd			ld (debug_mark+1),a  
5200 3a 0a 52			ld a, (.dmark+2)  
5203 32 9f fd			ld (debug_mark+2),a  
5206 18 03			jr .pastdmark  
5208 ..			.dmark: db "FNd"  
520b f1			.pastdmark: pop af  
520c			endm  
# End of macro DMARK
520c						CALLMONITOR 
520c cd aa fd			call debug_vector  
520f				endm  
# End of macro CALLMONITOR
520f					endif 
520f cd ff 1f			call forth_push_numhl 
5212			 
5212				       NEXTW 
5212 cd a7 fd			call parse_vector 
5215 c3 e2 23			jp macro_next 
5218				endm 
# End of macro NEXTW
5218			 
5218			.LEN: 
5218				CWHEAD .ASC 56 "COUNT" 5 WORD_FLAG_CODE 
5218 4c				db WORD_SYS_CORE+56             
5219 85 52			dw .ASC            
521b 06				db 5 + 1 
521c .. 00			db "COUNT",0              
5222				endm 
# End of macro CWHEAD
5222			; | COUNT (  str -- str u1 ) Push the length of the string str on TOS as u1 | DONE 
5222			 
5222					if DEBUG_FORTH_WORDS_KEY 
5222						DMARK "CNT" 
5222 f5				push af  
5223 3a 37 52			ld a, (.dmark)  
5226 32 9d fd			ld (debug_mark),a  
5229 3a 38 52			ld a, (.dmark+1)  
522c 32 9e fd			ld (debug_mark+1),a  
522f 3a 39 52			ld a, (.dmark+2)  
5232 32 9f fd			ld (debug_mark+2),a  
5235 18 03			jr .pastdmark  
5237 ..			.dmark: db "CNT"  
523a f1			.pastdmark: pop af  
523b			endm  
# End of macro DMARK
523b						CALLMONITOR 
523b cd aa fd			call debug_vector  
523e				endm  
# End of macro CALLMONITOR
523e					endif 
523e			; TODO check string type 
523e					FORTH_DSP_VALUE 
523e cd e4 21			call macro_forth_dsp_value 
5241				endm 
# End of macro FORTH_DSP_VALUE
5241			 
5241			 
5241					if DEBUG_FORTH_WORDS 
5241						DMARK "CN?" 
5241 f5				push af  
5242 3a 56 52			ld a, (.dmark)  
5245 32 9d fd			ld (debug_mark),a  
5248 3a 57 52			ld a, (.dmark+1)  
524b 32 9e fd			ld (debug_mark+1),a  
524e 3a 58 52			ld a, (.dmark+2)  
5251 32 9f fd			ld (debug_mark+2),a  
5254 18 03			jr .pastdmark  
5256 ..			.dmark: db "CN?"  
5259 f1			.pastdmark: pop af  
525a			endm  
# End of macro DMARK
525a						CALLMONITOR 
525a cd aa fd			call debug_vector  
525d				endm  
# End of macro CALLMONITOR
525d					endif 
525d cd 04 13				call strlenz 
5260					if DEBUG_FORTH_WORDS 
5260						DMARK "CNl" 
5260 f5				push af  
5261 3a 75 52			ld a, (.dmark)  
5264 32 9d fd			ld (debug_mark),a  
5267 3a 76 52			ld a, (.dmark+1)  
526a 32 9e fd			ld (debug_mark+1),a  
526d 3a 77 52			ld a, (.dmark+2)  
5270 32 9f fd			ld (debug_mark+2),a  
5273 18 03			jr .pastdmark  
5275 ..			.dmark: db "CNl"  
5278 f1			.pastdmark: pop af  
5279			endm  
# End of macro DMARK
5279						CALLMONITOR 
5279 cd aa fd			call debug_vector  
527c				endm  
# End of macro CALLMONITOR
527c					endif 
527c			 
527c cd ff 1f				call forth_push_numhl 
527f			 
527f			 
527f			 
527f				       NEXTW 
527f cd a7 fd			call parse_vector 
5282 c3 e2 23			jp macro_next 
5285				endm 
# End of macro NEXTW
5285			.ASC: 
5285				CWHEAD .CHR 57 "ASC" 3 WORD_FLAG_CODE 
5285 4d				db WORD_SYS_CORE+57             
5286 f6 52			dw .CHR            
5288 04				db 3 + 1 
5289 .. 00			db "ASC",0              
528d				endm 
# End of macro CWHEAD
528d			; | ASC ( u -- n ) Get the ASCII value of the first character of the string on TOS | DONE 
528d					if DEBUG_FORTH_WORDS_KEY 
528d						DMARK "ASC" 
528d f5				push af  
528e 3a a2 52			ld a, (.dmark)  
5291 32 9d fd			ld (debug_mark),a  
5294 3a a3 52			ld a, (.dmark+1)  
5297 32 9e fd			ld (debug_mark+1),a  
529a 3a a4 52			ld a, (.dmark+2)  
529d 32 9f fd			ld (debug_mark+2),a  
52a0 18 03			jr .pastdmark  
52a2 ..			.dmark: db "ASC"  
52a5 f1			.pastdmark: pop af  
52a6			endm  
# End of macro DMARK
52a6						CALLMONITOR 
52a6 cd aa fd			call debug_vector  
52a9				endm  
# End of macro CALLMONITOR
52a9					endif 
52a9					FORTH_DSP_VALUE 
52a9 cd e4 21			call macro_forth_dsp_value 
52ac				endm 
# End of macro FORTH_DSP_VALUE
52ac					;v5 FORTH_DSP_VALUE 
52ac			;		inc hl      ; now at start of numeric as string 
52ac			 
52ac e5					push hl 
52ad			 
52ad					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
52ad cd b3 22			call macro_forth_dsp_pop 
52b0				endm 
# End of macro FORTH_DSP_POP
52b0			 
52b0 e1					pop hl 
52b1			 
52b1					if DEBUG_FORTH_WORDS 
52b1						DMARK "AS1" 
52b1 f5				push af  
52b2 3a c6 52			ld a, (.dmark)  
52b5 32 9d fd			ld (debug_mark),a  
52b8 3a c7 52			ld a, (.dmark+1)  
52bb 32 9e fd			ld (debug_mark+1),a  
52be 3a c8 52			ld a, (.dmark+2)  
52c1 32 9f fd			ld (debug_mark+2),a  
52c4 18 03			jr .pastdmark  
52c6 ..			.dmark: db "AS1"  
52c9 f1			.pastdmark: pop af  
52ca			endm  
# End of macro DMARK
52ca						CALLMONITOR 
52ca cd aa fd			call debug_vector  
52cd				endm  
# End of macro CALLMONITOR
52cd					endif 
52cd					; push the content of a onto the stack as a value 
52cd			 
52cd 7e					ld a,(hl)   ; get char 
52ce 26 00				ld h,0 
52d0 6f					ld l,a 
52d1					if DEBUG_FORTH_WORDS 
52d1						DMARK "AS2" 
52d1 f5				push af  
52d2 3a e6 52			ld a, (.dmark)  
52d5 32 9d fd			ld (debug_mark),a  
52d8 3a e7 52			ld a, (.dmark+1)  
52db 32 9e fd			ld (debug_mark+1),a  
52de 3a e8 52			ld a, (.dmark+2)  
52e1 32 9f fd			ld (debug_mark+2),a  
52e4 18 03			jr .pastdmark  
52e6 ..			.dmark: db "AS2"  
52e9 f1			.pastdmark: pop af  
52ea			endm  
# End of macro DMARK
52ea						CALLMONITOR 
52ea cd aa fd			call debug_vector  
52ed				endm  
# End of macro CALLMONITOR
52ed					endif 
52ed cd ff 1f				call forth_push_numhl 
52f0			 
52f0				       NEXTW 
52f0 cd a7 fd			call parse_vector 
52f3 c3 e2 23			jp macro_next 
52f6				endm 
# End of macro NEXTW
52f6			 
52f6			.CHR: 
52f6				CWHEAD .ENDSTR 57 "CHR" 3 WORD_FLAG_CODE 
52f6 4d				db WORD_SYS_CORE+57             
52f7 35 53			dw .ENDSTR            
52f9 04				db 3 + 1 
52fa .. 00			db "CHR",0              
52fe				endm 
# End of macro CWHEAD
52fe			; | CHR ( u -- n ) The ASCII character value of u is turned into a string n on the stack | DONE 
52fe					if DEBUG_FORTH_WORDS_KEY 
52fe						DMARK "CHR" 
52fe f5				push af  
52ff 3a 13 53			ld a, (.dmark)  
5302 32 9d fd			ld (debug_mark),a  
5305 3a 14 53			ld a, (.dmark+1)  
5308 32 9e fd			ld (debug_mark+1),a  
530b 3a 15 53			ld a, (.dmark+2)  
530e 32 9f fd			ld (debug_mark+2),a  
5311 18 03			jr .pastdmark  
5313 ..			.dmark: db "CHR"  
5316 f1			.pastdmark: pop af  
5317			endm  
# End of macro DMARK
5317						CALLMONITOR 
5317 cd aa fd			call debug_vector  
531a				endm  
# End of macro CALLMONITOR
531a					endif 
531a					FORTH_DSP_VALUEHL 
531a cd fb 21			call macro_dsp_valuehl 
531d				endm 
# End of macro FORTH_DSP_VALUEHL
531d			 
531d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
531d cd b3 22			call macro_forth_dsp_pop 
5320				endm 
# End of macro FORTH_DSP_POP
5320			 
5320					; save asci byte as a zero term string and push string 
5320			 
5320 7d					ld a,l 
5321 32 f3 f0				ld (scratch), a 
5324			 
5324 3e 00				ld a, 0 
5326 32 f4 f0				ld (scratch+1), a 
5329			 
5329 21 f3 f0				ld hl, scratch 
532c cd 69 20				call forth_push_str 
532f			 
532f			 
532f				       NEXTW 
532f cd a7 fd			call parse_vector 
5332 c3 e2 23			jp macro_next 
5335				endm 
# End of macro NEXTW
5335			 
5335			 
5335			 
5335			 
5335			.ENDSTR: 
5335			; eof 
5335			 
# End of file forth_words_str.asm
5335			include "forth_words_key.asm" 
5335			 
5335			; | ## Keyboard Words 
5335			 
5335			.KEY: 
5335				CWHEAD .KEYDB 42 "KEY" 3 WORD_FLAG_CODE 
5335 3e				db WORD_SYS_CORE+42             
5336 68 53			dw .KEYDB            
5338 04				db 3 + 1 
5339 .. 00			db "KEY",0              
533d				endm 
# End of macro CWHEAD
533d			; | KEY ( -- u ) A non-blocking read of keypress | DONE 
533d			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
533d			; | | Can use something like this to process: 
533d			; | | > repeat active . key ?dup if emit then #1 until  
533d			 
533d					if DEBUG_FORTH_WORDS_KEY 
533d						DMARK "KEY" 
533d f5				push af  
533e 3a 52 53			ld a, (.dmark)  
5341 32 9d fd			ld (debug_mark),a  
5344 3a 53 53			ld a, (.dmark+1)  
5347 32 9e fd			ld (debug_mark+1),a  
534a 3a 54 53			ld a, (.dmark+2)  
534d 32 9f fd			ld (debug_mark+2),a  
5350 18 03			jr .pastdmark  
5352 ..			.dmark: db "KEY"  
5355 f1			.pastdmark: pop af  
5356			endm  
# End of macro DMARK
5356						CALLMONITOR 
5356 cd aa fd			call debug_vector  
5359				endm  
# End of macro CALLMONITOR
5359					endif 
5359			; TODO currently waits 
5359 cd 2a 7b				call cinndb 
535c					;call cin_wait 
535c 6f					ld l, a 
535d 26 00				ld h, 0 
535f cd ff 1f				call forth_push_numhl 
5362					NEXTW 
5362 cd a7 fd			call parse_vector 
5365 c3 e2 23			jp macro_next 
5368				endm 
# End of macro NEXTW
5368			.KEYDB: 
5368				CWHEAD .WAITK 42 "KEYDB" 5 WORD_FLAG_CODE 
5368 3e				db WORD_SYS_CORE+42             
5369 9d 53			dw .WAITK            
536b 06				db 5 + 1 
536c .. 00			db "KEYDB",0              
5372				endm 
# End of macro CWHEAD
5372			; | KEYDB ( -- u ) A non-blocking read of keypress with key release debounce | DONE 
5372			; | | The ASCII key (or key code) is pushed to stack. If no key is currently held down then push a 0 
5372			; | | Can use something like this to process: 
5372			; | | > repeat active . key ?dup if emit then #1 until  
5372			 
5372					if DEBUG_FORTH_WORDS_KEY 
5372						DMARK "KEB" 
5372 f5				push af  
5373 3a 87 53			ld a, (.dmark)  
5376 32 9d fd			ld (debug_mark),a  
5379 3a 88 53			ld a, (.dmark+1)  
537c 32 9e fd			ld (debug_mark+1),a  
537f 3a 89 53			ld a, (.dmark+2)  
5382 32 9f fd			ld (debug_mark+2),a  
5385 18 03			jr .pastdmark  
5387 ..			.dmark: db "KEB"  
538a f1			.pastdmark: pop af  
538b			endm  
# End of macro DMARK
538b						CALLMONITOR 
538b cd aa fd			call debug_vector  
538e				endm  
# End of macro CALLMONITOR
538e					endif 
538e			; TODO currently waits 
538e cd 17 7b				call cin 
5391					;call cin_wait 
5391 6f					ld l, a 
5392 26 00				ld h, 0 
5394 cd ff 1f				call forth_push_numhl 
5397					NEXTW 
5397 cd a7 fd			call parse_vector 
539a c3 e2 23			jp macro_next 
539d				endm 
# End of macro NEXTW
539d			.WAITK: 
539d				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
539d 3f				db WORD_SYS_CORE+43             
539e d2 53			dw .ACCEPT            
53a0 06				db 5 + 1 
53a1 .. 00			db "WAITK",0              
53a7				endm 
# End of macro CWHEAD
53a7			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
53a7					if DEBUG_FORTH_WORDS_KEY 
53a7						DMARK "WAI" 
53a7 f5				push af  
53a8 3a bc 53			ld a, (.dmark)  
53ab 32 9d fd			ld (debug_mark),a  
53ae 3a bd 53			ld a, (.dmark+1)  
53b1 32 9e fd			ld (debug_mark+1),a  
53b4 3a be 53			ld a, (.dmark+2)  
53b7 32 9f fd			ld (debug_mark+2),a  
53ba 18 03			jr .pastdmark  
53bc ..			.dmark: db "WAI"  
53bf f1			.pastdmark: pop af  
53c0			endm  
# End of macro DMARK
53c0						CALLMONITOR 
53c0 cd aa fd			call debug_vector  
53c3				endm  
# End of macro CALLMONITOR
53c3					endif 
53c3 cd 08 7b				call cin_wait 
53c6 6f					ld l, a 
53c7 26 00				ld h, 0 
53c9 cd ff 1f				call forth_push_numhl 
53cc					NEXTW 
53cc cd a7 fd			call parse_vector 
53cf c3 e2 23			jp macro_next 
53d2				endm 
# End of macro NEXTW
53d2			.ACCEPT: 
53d2				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
53d2 40				db WORD_SYS_CORE+44             
53d3 32 54			dw .EDIT            
53d5 07				db 6 + 1 
53d6 .. 00			db "ACCEPT",0              
53dd				endm 
# End of macro CWHEAD
53dd			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
53dd					; TODO crashes on push 
53dd					if DEBUG_FORTH_WORDS_KEY 
53dd						DMARK "ACC" 
53dd f5				push af  
53de 3a f2 53			ld a, (.dmark)  
53e1 32 9d fd			ld (debug_mark),a  
53e4 3a f3 53			ld a, (.dmark+1)  
53e7 32 9e fd			ld (debug_mark+1),a  
53ea 3a f4 53			ld a, (.dmark+2)  
53ed 32 9f fd			ld (debug_mark+2),a  
53f0 18 03			jr .pastdmark  
53f2 ..			.dmark: db "ACC"  
53f5 f1			.pastdmark: pop af  
53f6			endm  
# End of macro DMARK
53f6						CALLMONITOR 
53f6 cd aa fd			call debug_vector  
53f9				endm  
# End of macro CALLMONITOR
53f9					endif 
53f9 21 f1 f2				ld hl, os_input 
53fc			;		ld a, 0 
53fc 36 00				ld (hl),0 
53fe 3a 90 f9				ld a,(f_cursor_ptr) 
5401 16 64				ld d, 100 
5403 0e 00				ld c, 0 
5405 1e 28				ld e, 40 
5407 cd d9 0f				call input_str 
540a					; TODO perhaps do a type check and wrap in quotes if not a number 
540a 21 f1 f2				ld hl, os_input 
540d					if DEBUG_FORTH_WORDS 
540d						DMARK "AC1" 
540d f5				push af  
540e 3a 22 54			ld a, (.dmark)  
5411 32 9d fd			ld (debug_mark),a  
5414 3a 23 54			ld a, (.dmark+1)  
5417 32 9e fd			ld (debug_mark+1),a  
541a 3a 24 54			ld a, (.dmark+2)  
541d 32 9f fd			ld (debug_mark+2),a  
5420 18 03			jr .pastdmark  
5422 ..			.dmark: db "AC1"  
5425 f1			.pastdmark: pop af  
5426			endm  
# End of macro DMARK
5426						CALLMONITOR 
5426 cd aa fd			call debug_vector  
5429				endm  
# End of macro CALLMONITOR
5429					endif 
5429 cd 69 20				call forth_push_str 
542c					NEXTW 
542c cd a7 fd			call parse_vector 
542f c3 e2 23			jp macro_next 
5432				endm 
# End of macro NEXTW
5432			 
5432			.EDIT: 
5432				CWHEAD .DEDIT 44 "EDIT" 4 WORD_FLAG_CODE 
5432 40				db WORD_SYS_CORE+44             
5433 d7 54			dw .DEDIT            
5435 05				db 4 + 1 
5436 .. 00			db "EDIT",0              
543b				endm 
# End of macro CWHEAD
543b			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
543b			 
543b					; TODO does not copy from stack 
543b					if DEBUG_FORTH_WORDS_KEY 
543b						DMARK "EDT" 
543b f5				push af  
543c 3a 50 54			ld a, (.dmark)  
543f 32 9d fd			ld (debug_mark),a  
5442 3a 51 54			ld a, (.dmark+1)  
5445 32 9e fd			ld (debug_mark+1),a  
5448 3a 52 54			ld a, (.dmark+2)  
544b 32 9f fd			ld (debug_mark+2),a  
544e 18 03			jr .pastdmark  
5450 ..			.dmark: db "EDT"  
5453 f1			.pastdmark: pop af  
5454			endm  
# End of macro DMARK
5454						CALLMONITOR 
5454 cd aa fd			call debug_vector  
5457				endm  
# End of macro CALLMONITOR
5457					endif 
5457			 
5457					;FORTH_DSP 
5457					FORTH_DSP_VALUEHL 
5457 cd fb 21			call macro_dsp_valuehl 
545a				endm 
# End of macro FORTH_DSP_VALUEHL
545a			;		inc hl    ; TODO do type check 
545a			 
545a			;		call get_word_hl 
545a e5					push hl 
545b					if DEBUG_FORTH_WORDS 
545b						DMARK "EDp" 
545b f5				push af  
545c 3a 70 54			ld a, (.dmark)  
545f 32 9d fd			ld (debug_mark),a  
5462 3a 71 54			ld a, (.dmark+1)  
5465 32 9e fd			ld (debug_mark+1),a  
5468 3a 72 54			ld a, (.dmark+2)  
546b 32 9f fd			ld (debug_mark+2),a  
546e 18 03			jr .pastdmark  
5470 ..			.dmark: db "EDp"  
5473 f1			.pastdmark: pop af  
5474			endm  
# End of macro DMARK
5474						CALLMONITOR 
5474 cd aa fd			call debug_vector  
5477				endm  
# End of macro CALLMONITOR
5477					endif 
5477				;	ld a, 0 
5477 cd 04 13				call strlenz 
547a 23					inc hl 
547b			 
547b 06 00				ld b, 0 
547d 4d					ld c, l 
547e			 
547e e1					pop hl 
547f 11 f1 f2				ld de, os_input 
5482					if DEBUG_FORTH_WORDS_KEY 
5482						DMARK "EDc" 
5482 f5				push af  
5483 3a 97 54			ld a, (.dmark)  
5486 32 9d fd			ld (debug_mark),a  
5489 3a 98 54			ld a, (.dmark+1)  
548c 32 9e fd			ld (debug_mark+1),a  
548f 3a 99 54			ld a, (.dmark+2)  
5492 32 9f fd			ld (debug_mark+2),a  
5495 18 03			jr .pastdmark  
5497 ..			.dmark: db "EDc"  
549a f1			.pastdmark: pop af  
549b			endm  
# End of macro DMARK
549b						CALLMONITOR 
549b cd aa fd			call debug_vector  
549e				endm  
# End of macro CALLMONITOR
549e					endif 
549e ed b0				ldir 
54a0			 
54a0			 
54a0 21 f1 f2				ld hl, os_input 
54a3					;ld a, 0 
54a3					;ld (hl),a 
54a3 3a 90 f9				ld a,(f_cursor_ptr) 
54a6 16 64				ld d, 100 
54a8 0e 00				ld c, 0 
54aa 1e 28				ld e, 40 
54ac cd d9 0f				call input_str 
54af					; TODO perhaps do a type check and wrap in quotes if not a number 
54af 21 f1 f2				ld hl, os_input 
54b2					if DEBUG_FORTH_WORDS 
54b2						DMARK "ED1" 
54b2 f5				push af  
54b3 3a c7 54			ld a, (.dmark)  
54b6 32 9d fd			ld (debug_mark),a  
54b9 3a c8 54			ld a, (.dmark+1)  
54bc 32 9e fd			ld (debug_mark+1),a  
54bf 3a c9 54			ld a, (.dmark+2)  
54c2 32 9f fd			ld (debug_mark+2),a  
54c5 18 03			jr .pastdmark  
54c7 ..			.dmark: db "ED1"  
54ca f1			.pastdmark: pop af  
54cb			endm  
# End of macro DMARK
54cb						CALLMONITOR 
54cb cd aa fd			call debug_vector  
54ce				endm  
# End of macro CALLMONITOR
54ce					endif 
54ce cd 69 20				call forth_push_str 
54d1					NEXTW 
54d1 cd a7 fd			call parse_vector 
54d4 c3 e2 23			jp macro_next 
54d7				endm 
# End of macro NEXTW
54d7			 
54d7			.DEDIT: 
54d7				CWHEAD .ENDKEY 44 "DEDIT" 5 WORD_FLAG_CODE 
54d7 40				db WORD_SYS_CORE+44             
54d8 3c 55			dw .ENDKEY            
54da 06				db 5 + 1 
54db .. 00			db "DEDIT",0              
54e1				endm 
# End of macro CWHEAD
54e1			; | DEDIT ( ptr --  ) Takes an address for direct editing in memory. | DONE 
54e1			 
54e1					; TODO does not copy from stack 
54e1					if DEBUG_FORTH_WORDS_KEY 
54e1						DMARK "DED" 
54e1 f5				push af  
54e2 3a f6 54			ld a, (.dmark)  
54e5 32 9d fd			ld (debug_mark),a  
54e8 3a f7 54			ld a, (.dmark+1)  
54eb 32 9e fd			ld (debug_mark+1),a  
54ee 3a f8 54			ld a, (.dmark+2)  
54f1 32 9f fd			ld (debug_mark+2),a  
54f4 18 03			jr .pastdmark  
54f6 ..			.dmark: db "DED"  
54f9 f1			.pastdmark: pop af  
54fa			endm  
# End of macro DMARK
54fa						CALLMONITOR 
54fa cd aa fd			call debug_vector  
54fd				endm  
# End of macro CALLMONITOR
54fd					endif 
54fd			 
54fd					;FORTH_DSP 
54fd					FORTH_DSP_VALUEHL 
54fd cd fb 21			call macro_dsp_valuehl 
5500				endm 
# End of macro FORTH_DSP_VALUEHL
5500			;		inc hl    ; TODO do type check 
5500			 
5500			;		call get_word_hl 
5500 e5					push hl 
5501 e5					push hl 
5502					FORTH_DSP_POP 
5502 cd b3 22			call macro_forth_dsp_pop 
5505				endm 
# End of macro FORTH_DSP_POP
5505 e1					pop hl 
5506					if DEBUG_FORTH_WORDS 
5506						DMARK "EDp" 
5506 f5				push af  
5507 3a 1b 55			ld a, (.dmark)  
550a 32 9d fd			ld (debug_mark),a  
550d 3a 1c 55			ld a, (.dmark+1)  
5510 32 9e fd			ld (debug_mark+1),a  
5513 3a 1d 55			ld a, (.dmark+2)  
5516 32 9f fd			ld (debug_mark+2),a  
5519 18 03			jr .pastdmark  
551b ..			.dmark: db "EDp"  
551e f1			.pastdmark: pop af  
551f			endm  
# End of macro DMARK
551f						CALLMONITOR 
551f cd aa fd			call debug_vector  
5522				endm  
# End of macro CALLMONITOR
5522					endif 
5522				;	ld a, 0 
5522 cd 04 13				call strlenz 
5525 23					inc hl 
5526			 
5526 06 00				ld b, 0 
5528 4d					ld c, l 
5529			 
5529 e1					pop hl 
552a			 
552a					;ld a, 0 
552a					;ld (hl),a 
552a 3a 90 f9				ld a,(f_cursor_ptr) 
552d 16 64				ld d, 100 
552f 0e 00				ld c, 0 
5531 1e 28				ld e, 40 
5533 cd d9 0f				call input_str 
5536					; TODO perhaps do a type check and wrap in quotes if not a number 
5536					NEXTW 
5536 cd a7 fd			call parse_vector 
5539 c3 e2 23			jp macro_next 
553c				endm 
# End of macro NEXTW
553c			 
553c			 
553c			.ENDKEY: 
553c			; eof 
553c			 
# End of file forth_words_key.asm
553c			include "forth_words_const.asm" 
553c			 
553c			; | ## Constants (i.e. Useful memory addresses that can set or get features) 
553c			 
553c			 
553c			.SPITIME: 
553c				CWHEAD .VA 99 "SPITIME" 7 WORD_FLAG_CODE 
553c 77				db WORD_SYS_CORE+99             
553d 54 55			dw .VA            
553f 08				db 7 + 1 
5540 .. 00			db "SPITIME",0              
5548				endm 
# End of macro CWHEAD
5548			; | SPITIME ( -- u1 )   Pushes address of the SPI pulse counter/delay to stack | DONE 
5548			; 
5548			; | | If using BANK devices then leave as is. 
5548			; | | Only really useful for the CARTDEV where other devices may be far too slow. In particular 
5548			; | | the multiplexing of the PicoSPINet addon which might not be running fast enough for all of the nodes 
5548			 
5548 21 96 f9				ld hl, spi_clktime  
554b cd ff 1f				call forth_push_numhl 
554e			 
554e					NEXTW 
554e cd a7 fd			call parse_vector 
5551 c3 e2 23			jp macro_next 
5554				endm 
# End of macro NEXTW
5554			 
5554			 
5554			.VA: 
5554				CWHEAD .SYMBOL 99 "VA" 2 WORD_FLAG_CODE 
5554 77				db WORD_SYS_CORE+99             
5555 67 55			dw .SYMBOL            
5557 03				db 2 + 1 
5558 .. 00			db "VA",0              
555b				endm 
# End of macro CWHEAD
555b			; | VA ( -- u1 )   Pushes address of block of memory used for v1..5 | DONE 
555b 21 5a f9				ld hl, cli_var_array 
555e cd ff 1f				call forth_push_numhl 
5561			 
5561					NEXTW 
5561 cd a7 fd			call parse_vector 
5564 c3 e2 23			jp macro_next 
5567				endm 
# End of macro NEXTW
5567			 
5567			.SYMBOL: 
5567				CWHEAD .ENDCONST 99 "SYMBOL" 6 WORD_FLAG_CODE 
5567 77				db WORD_SYS_CORE+99             
5568 76 56			dw .ENDCONST            
556a 07				db 6 + 1 
556b .. 00			db "SYMBOL",0              
5572				endm 
# End of macro CWHEAD
5572			; | SYMBOL ( u1 -- )  Get the address of a system symbol from a look up table to TOS  | DONE 
5572			; | 
5572			; | | The value is the number reference and the final address is pushed to stack 
5572			 
5572			; | | ``` 
5572			; | | dw sym_table 
5572			; | | dw nmi_vector 
5572			; | | dw cli_autodisplay 
5572			; | | dw cli_data_sp 
5572			; | | dw cli_data_stack 
5572			; | | dw cli_loop_sp 
5572			; | | dw cli_loop_stack 
5572			; | | dw cli_var_array 
5572			; | | dw cursor_col 
5572			; | | dw cursor_ptr 
5572			; | | ; 10 
5572			; | | dw cursor_row 
5572			; | | dw debug_mark 
5572			; | | dw display_fb0 
5572			; | | dw display_fb1 
5572			; | | dw display_fb2 
5572			; | | dw display_fb3 
5572			; | | dw display_fb_active 
5572			; | | dw execscratch 
5572			; | | dw f_cursor_ptr 
5572			; | | dw hardware_word 
5572			; | | ;20 
5572			; | | dw input_at_cursor 
5572			; | | dw input_at_pos 
5572			; | | dw input_cur_flash 
5572			; | | dw input_cur_onoff 
5572			; | | dw input_cursor 
5572			; | | dw input_display_size 
5572			; | | dw input_len 
5572			; | | dw input_ptr 
5572			; | | dw input_size 
5572			; | | dw input_start 
5572			; | | ; 30 
5572			; | | dw input_str 
5572			; | | dw input_under_cursor 
5572			; | | dw os_cli_cmd 
5572			; | | dw os_cur_ptr 
5572			; | | dw os_current_i 
5572			; | | dw os_input 
5572			; | | dw os_last_cmd 
5572			; | | dw os_last_new_uword 
5572			; | | dw debug_vector 
5572			; | | dw os_view_hl 
5572			; | | ;40 
5572			; | | dw os_word_scratch 
5572			; | | dw portbctl 
5572			; | | dw portbdata 
5572			; | | dw spi_cartdev 
5572			; | | dw spi_cartdev2 
5572			; | | dw spi_clktime 
5572			; | | dw spi_device 
5572			; | | dw spi_device_id 
5572			; | | dw spi_portbyte 
5572			; | | dw stackstore 
5572			; | | ; 50 
5572			; | | if STORAGE_SE 
5572			; | | dw storage_actl 
5572			; | | dw storage_adata 
5572			; | | else 
5572			; | | dw 0 
5572			; | | dw 0 
5572			; | | endif 
5572			; | | dw storage_append 
5572			; | | if STORAGE_SE 
5572			; | | dw storage_bctl 
5572			; | | else 
5572			; | | dw 0 
5572			; | | endif 
5572			; | | dw store_bank_active 
5572			; | | dw store_filecache 
5572			; | | dw store_longread 
5572			; | | dw store_openaddr 
5572			; | | dw store_openext 
5572			; | | dw store_openmaxext 
5572			; | | ; 60 
5572			; | | dw store_page 
5572			; | | dw store_readbuf 
5572			; | | dw store_readcont 
5572			; | | dw store_readptr 
5572			; | | dw store_tmpext 
5572			; | | dw store_tmpid 
5572			; | | dw store_tmppageid 
5572			; | | dw malloc 
5572			; | | dw free 
5572			; | | dw cin 
5572			; | | ; 70 
5572			; | | dw cin_wait 
5572			; | | dw forth_push_numhl 
5572			; | | dw forth_push_str 
5572			; | | dw parse_vector 
5572			; | | ``` 
5572			 
5572					if DEBUG_FORTH_WORDS_KEY 
5572						DMARK "SYM" 
5572 f5				push af  
5573 3a 87 55			ld a, (.dmark)  
5576 32 9d fd			ld (debug_mark),a  
5579 3a 88 55			ld a, (.dmark+1)  
557c 32 9e fd			ld (debug_mark+1),a  
557f 3a 89 55			ld a, (.dmark+2)  
5582 32 9f fd			ld (debug_mark+2),a  
5585 18 03			jr .pastdmark  
5587 ..			.dmark: db "SYM"  
558a f1			.pastdmark: pop af  
558b			endm  
# End of macro DMARK
558b						CALLMONITOR 
558b cd aa fd			call debug_vector  
558e				endm  
# End of macro CALLMONITOR
558e					endif 
558e			 
558e					FORTH_DSP_VALUEHL 
558e cd fb 21			call macro_dsp_valuehl 
5591				endm 
# End of macro FORTH_DSP_VALUEHL
5591			 
5591 7d					ld a, l     
5592			 
5592			 
5592					if DEBUG_FORTH_WORDS 
5592						DMARK "SY1" 
5592 f5				push af  
5593 3a a7 55			ld a, (.dmark)  
5596 32 9d fd			ld (debug_mark),a  
5599 3a a8 55			ld a, (.dmark+1)  
559c 32 9e fd			ld (debug_mark+1),a  
559f 3a a9 55			ld a, (.dmark+2)  
55a2 32 9f fd			ld (debug_mark+2),a  
55a5 18 03			jr .pastdmark  
55a7 ..			.dmark: db "SY1"  
55aa f1			.pastdmark: pop af  
55ab			endm  
# End of macro DMARK
55ab						CALLMONITOR 
55ab cd aa fd			call debug_vector  
55ae				endm  
# End of macro CALLMONITOR
55ae					endif 
55ae					 
55ae f5					push af	 
55af					FORTH_DSP_POP 
55af cd b3 22			call macro_forth_dsp_pop 
55b2				endm 
# End of macro FORTH_DSP_POP
55b2 f1					pop af 
55b3			 
55b3 cb 27				sla a  
55b5				 
55b5					 
55b5					if DEBUG_FORTH_WORDS 
55b5						DMARK "SY" 
55b5 f5				push af  
55b6 3a ca 55			ld a, (.dmark)  
55b9 32 9d fd			ld (debug_mark),a  
55bc 3a cb 55			ld a, (.dmark+1)  
55bf 32 9e fd			ld (debug_mark+1),a  
55c2 3a cc 55			ld a, (.dmark+2)  
55c5 32 9f fd			ld (debug_mark+2),a  
55c8 18 02			jr .pastdmark  
55ca ..			.dmark: db "SY"  
55cc f1			.pastdmark: pop af  
55cd			endm  
# End of macro DMARK
55cd						CALLMONITOR 
55cd cd aa fd			call debug_vector  
55d0				endm  
# End of macro CALLMONITOR
55d0					endif 
55d0			 
55d0 21 e2 55				ld hl, sym_table 
55d3 cd ac 0f				call addatohl 
55d6 cd 68 23				call loadwordinhl 
55d9 cd ff 1f				call forth_push_numhl 
55dc			 
55dc			 
55dc				       NEXTW 
55dc cd a7 fd			call parse_vector 
55df c3 e2 23			jp macro_next 
55e2				endm 
# End of macro NEXTW
55e2			 
55e2			sym_table: 
55e2			 
55e2			; 0 
55e2 e2 55		dw sym_table 
55e4 ad fd		dw nmi_vector 
55e6 6e f9		dw cli_autodisplay 
55e8 20 f9		dw cli_data_sp 
55ea 5a f6		dw cli_data_stack 
55ec 22 f9		dw cli_loop_sp 
55ee 5c f8		dw cli_loop_stack 
55f0 5a f9		dw cli_var_array 
55f2 f7 fa		dw cursor_col 
55f4 f5 fa		dw cursor_ptr 
55f6			; 10 
55f6 f6 fa		dw cursor_row 
55f8 9d fd		dw debug_mark 
55fa e3 fc		dw display_fb0 
55fc 42 fc		dw display_fb1 
55fe 00 fb		dw display_fb2 
5600 a1 fb		dw display_fb3 
5602 fe fa		dw display_fb_active 
5604 f2 f1		dw execscratch 
5606 90 f9		dw f_cursor_ptr 
5608 b0 fd		dw hardware_word 
560a			;20 
560a 94 fd		dw input_at_cursor 
560c 96 fd		dw input_at_pos 
560e 92 fd		dw input_cur_flash 
5610 91 fd		dw input_cur_onoff 
5612 87 fd		dw input_cursor 
5614 97 fd		dw input_display_size 
5616 8c fd		dw input_len 
5618 9b fd		dw input_ptr 
561a 98 fd		dw input_size 
561c 99 fd		dw input_start 
561e			; 30 
561e d9 0f		dw input_str 
5620 95 fd		dw input_under_cursor 
5622 1a f4		dw os_cli_cmd 
5624 16 f4		dw os_cur_ptr 
5626 18 f4		dw os_current_i 
5628 f1 f2		dw os_input 
562a 19 f5		dw os_last_cmd 
562c f0 f3		dw os_last_new_uword 
562e aa fd		dw debug_vector 
5630 d5 f0		dw os_view_hl 
5632			;40 
5632 f8 f3		dw os_word_scratch 
5634 c3 00		dw portbctl 
5636 c1 00		dw portbdata 
5638 95 f9		dw spi_cartdev 
563a 94 f9		dw spi_cartdev2 
563c 96 f9		dw spi_clktime 
563e 92 f9		dw spi_device 
5640 91 f9		dw spi_device_id 
5642 93 f9		dw spi_portbyte 
5644 d9 fa		dw stackstore 
5646			; 50 
5646			if STORAGE_SE 
5646 82 00		dw storage_actl 
5648 80 00		dw storage_adata 
564a			else 
564a			dw 0 
564a			dw 0 
564a			endif 
564a 3b 0b		dw storage_append 
564c			if STORAGE_SE 
564c 83 00		dw storage_bctl 
564e			else 
564e			dw 0 
564e			endif 
564e c5 fa		dw store_bank_active 
5650 99 f9		dw store_filecache 
5652 a7 f9		dw store_longread 
5654 9d f9		dw store_openaddr 
5656 9c f9		dw store_openext 
5658 9b f9		dw store_openmaxext 
565a			; 60 
565a ac f9		dw store_page 
565c a8 f9		dw store_readbuf 
565e 9f f9		dw store_readcont 
5660 aa f9		dw store_readptr 
5662 9f f9		dw store_tmpext 
5664 a0 f9		dw store_tmpid 
5666 97 f9		dw store_tmppageid 
5668 78 13		dw malloc 
566a 42 14		dw free 
566c 17 7b		dw cin 
566e			; 70 
566e 08 7b		dw cin_wait 
5670 ff 1f		dw forth_push_numhl 
5672 69 20		dw forth_push_str 
5674 a7 fd		dw parse_vector 
5676			 
5676			.ENDCONST: 
5676			 
5676			; eof 
5676			 
5676			 
# End of file forth_words_const.asm
5676			 
5676			if STORAGE_SE 
5676			   	include "forth_words_storage.asm" 
5676			 
5676			; | ## Fixed Storage Words 
5676			 
5676			.RENAME: 
5676			  
5676				CWHEAD .RECORD 38 "RENAME" 6 WORD_FLAG_CODE 
5676 3a				db WORD_SYS_CORE+38             
5677 6f 57			dw .RECORD            
5679 07				db 6 + 1 
567a .. 00			db "RENAME",0              
5681				endm 
# End of macro CWHEAD
5681			; | RENAME ( s id -- ) With the current bank, rename the file id with the new label s  | DONE 
5681			; | | > [!NOTE] 
5681			; | | > Compatible with PicoSPINet  
5681					if DEBUG_FORTH_WORDS_KEY 
5681						DMARK "REN" 
5681 f5				push af  
5682 3a 96 56			ld a, (.dmark)  
5685 32 9d fd			ld (debug_mark),a  
5688 3a 97 56			ld a, (.dmark+1)  
568b 32 9e fd			ld (debug_mark+1),a  
568e 3a 98 56			ld a, (.dmark+2)  
5691 32 9f fd			ld (debug_mark+2),a  
5694 18 03			jr .pastdmark  
5696 ..			.dmark: db "REN"  
5699 f1			.pastdmark: pop af  
569a			endm  
# End of macro DMARK
569a						CALLMONITOR 
569a cd aa fd			call debug_vector  
569d				endm  
# End of macro CALLMONITOR
569d					endif 
569d			 
569d			 
569d					; preserve some internal vars used by other file handing routines 
569d			 
569d 2a 9d f9				ld hl, (store_openaddr) 
56a0 e5					push hl 
56a1 3a 9f f9				ld a, (store_readcont) 
56a4 f5					push af 
56a5			 
56a5					FORTH_DSP_VALUEHL 
56a5 cd fb 21			call macro_dsp_valuehl 
56a8				endm 
# End of macro FORTH_DSP_VALUEHL
56a8			 
56a8					; move ext and id around for the file header 
56a8			 
56a8 65					ld h, l 
56a9 2e 00				ld l, 0 
56ab			 
56ab e5					push hl    ; id 
56ac			 
56ac					FORTH_DSP_POP 
56ac cd b3 22			call macro_forth_dsp_pop 
56af				endm 
# End of macro FORTH_DSP_POP
56af			 
56af					; Locate the file header 
56af			 
56af e1					pop hl 
56b0 e5					push hl 
56b1 11 ac f9				ld de, store_page      ; get block zero of file 
56b4					if DEBUG_FORTH_WORDS 
56b4						DMARK "REr" 
56b4 f5				push af  
56b5 3a c9 56			ld a, (.dmark)  
56b8 32 9d fd			ld (debug_mark),a  
56bb 3a ca 56			ld a, (.dmark+1)  
56be 32 9e fd			ld (debug_mark+1),a  
56c1 3a cb 56			ld a, (.dmark+2)  
56c4 32 9f fd			ld (debug_mark+2),a  
56c7 18 03			jr .pastdmark  
56c9 ..			.dmark: db "REr"  
56cc f1			.pastdmark: pop af  
56cd			endm  
# End of macro DMARK
56cd						CALLMONITOR 
56cd cd aa fd			call debug_vector  
56d0				endm  
# End of macro CALLMONITOR
56d0					endif 
56d0 cd a7 09				call storage_read 
56d3			 
56d3 cd d5 0f			call ishlzero 
56d6 20 05			jr nz, .rnfound 
56d8			 
56d8				; file does not exist so indicate with 255 extents in use 
56d8			 
56d8 3e ff			ld a, 255 
56da e1				pop hl ; clear dup hl 
56db 18 7b			jr .skiprneof 
56dd			 
56dd			 
56dd			.rnfound: 
56dd					; file found so rename 
56dd			 
56dd					FORTH_DSP_VALUEHL 
56dd cd fb 21			call macro_dsp_valuehl 
56e0				endm 
# End of macro FORTH_DSP_VALUEHL
56e0			 
56e0 e5				push hl 
56e1 3e 00			ld a, 0 
56e3 cd 0f 13			call strlent 
56e6 23				inc hl   ; cover zero term 
56e7 06 00			ld b,0 
56e9 4d				ld c,l 
56ea e1				pop hl 
56eb 11 af f9				ld de, store_page + 3 
56ee ed b0				ldir 
56f0			 
56f0 11 ac f9				ld de, store_page 
56f3					if DEBUG_FORTH_WORDS 
56f3						DMARK "RER" 
56f3 f5				push af  
56f4 3a 08 57			ld a, (.dmark)  
56f7 32 9d fd			ld (debug_mark),a  
56fa 3a 09 57			ld a, (.dmark+1)  
56fd 32 9e fd			ld (debug_mark+1),a  
5700 3a 0a 57			ld a, (.dmark+2)  
5703 32 9f fd			ld (debug_mark+2),a  
5706 18 03			jr .pastdmark  
5708 ..			.dmark: db "RER"  
570b f1			.pastdmark: pop af  
570c			endm  
# End of macro DMARK
570c						CALLMONITOR 
570c cd aa fd			call debug_vector  
570f				endm  
# End of macro CALLMONITOR
570f					endif 
570f			 
570f e1					pop hl    ; get orig file id and mangle it for find id 
5710 55					ld d, l 
5711 5c					ld e, h 
5712			 
5712 21 00 00				ld hl, 0 
5715					if DEBUG_FORTH_WORDS 
5715						DMARK "REf" 
5715 f5				push af  
5716 3a 2a 57			ld a, (.dmark)  
5719 32 9d fd			ld (debug_mark),a  
571c 3a 2b 57			ld a, (.dmark+1)  
571f 32 9e fd			ld (debug_mark+1),a  
5722 3a 2c 57			ld a, (.dmark+2)  
5725 32 9f fd			ld (debug_mark+2),a  
5728 18 03			jr .pastdmark  
572a ..			.dmark: db "REf"  
572d f1			.pastdmark: pop af  
572e			endm  
# End of macro DMARK
572e						CALLMONITOR 
572e cd aa fd			call debug_vector  
5731				endm  
# End of macro CALLMONITOR
5731					endif 
5731 cd 83 07				call storage_findnextid 
5734 11 ac f9				ld de, store_page 
5737					if DEBUG_FORTH_WORDS 
5737						DMARK "REw" 
5737 f5				push af  
5738 3a 4c 57			ld a, (.dmark)  
573b 32 9d fd			ld (debug_mark),a  
573e 3a 4d 57			ld a, (.dmark+1)  
5741 32 9e fd			ld (debug_mark+1),a  
5744 3a 4e 57			ld a, (.dmark+2)  
5747 32 9f fd			ld (debug_mark+2),a  
574a 18 03			jr .pastdmark  
574c ..			.dmark: db "REw"  
574f f1			.pastdmark: pop af  
5750			endm  
# End of macro DMARK
5750						CALLMONITOR 
5750 cd aa fd			call debug_vector  
5753				endm  
# End of macro CALLMONITOR
5753					endif 
5753 cd bc 04				call storage_write_block 
5756			 
5756 3e 00				ld a, 0 
5758			.skiprneof: 
5758					; drop file name 
5758					FORTH_DSP_POP 
5758 cd b3 22			call macro_forth_dsp_pop 
575b				endm 
# End of macro FORTH_DSP_POP
575b			 
575b 6f					ld l, a 
575c 26 00				ld h, 0 
575e cd ff 1f				call forth_push_numhl 
5761			 
5761			 
5761 f1					pop af 
5762 32 9f f9				ld (store_readcont),a 
5765 e1					pop hl 
5766 22 9d f9				ld (store_openaddr), hl 
5769						 
5769				NEXTW 
5769 cd a7 fd			call parse_vector 
576c c3 e2 23			jp macro_next 
576f				endm 
# End of macro NEXTW
576f			.RECORD: 
576f			  
576f				CWHEAD .BREAD 38 "RECORD" 6 WORD_FLAG_CODE 
576f 3a				db WORD_SYS_CORE+38             
5770 19 58			dw .BREAD            
5772 07				db 6 + 1 
5773 .. 00			db "RECORD",0              
577a				endm 
# End of macro CWHEAD
577a			; | RECORD ( u id -- s ) With the current bank, read record number u from file id and push to stack  | DONE 
577a			; | | > [!NOTE] 
577a			; | | > Compatible with PicoSPINet  
577a			 
577a					if DEBUG_FORTH_WORDS_KEY 
577a						DMARK "REC" 
577a f5				push af  
577b 3a 8f 57			ld a, (.dmark)  
577e 32 9d fd			ld (debug_mark),a  
5781 3a 90 57			ld a, (.dmark+1)  
5784 32 9e fd			ld (debug_mark+1),a  
5787 3a 91 57			ld a, (.dmark+2)  
578a 32 9f fd			ld (debug_mark+2),a  
578d 18 03			jr .pastdmark  
578f ..			.dmark: db "REC"  
5792 f1			.pastdmark: pop af  
5793			endm  
# End of macro DMARK
5793						CALLMONITOR 
5793 cd aa fd			call debug_vector  
5796				endm  
# End of macro CALLMONITOR
5796					endif 
5796			 
5796					FORTH_DSP_VALUEHL 
5796 cd fb 21			call macro_dsp_valuehl 
5799				endm 
# End of macro FORTH_DSP_VALUEHL
5799			 
5799 e5					push hl    ; id 
579a			 
579a					FORTH_DSP_POP 
579a cd b3 22			call macro_forth_dsp_pop 
579d				endm 
# End of macro FORTH_DSP_POP
579d			 
579d					FORTH_DSP_VALUEHL 
579d cd fb 21			call macro_dsp_valuehl 
57a0				endm 
# End of macro FORTH_DSP_VALUEHL
57a0			 
57a0					FORTH_DSP_POP 
57a0 cd b3 22			call macro_forth_dsp_pop 
57a3				endm 
# End of macro FORTH_DSP_POP
57a3			 
57a3 d1					pop de     ; get file id 
57a4			 
57a4					; e = file id 
57a4					; l = file extent 
57a4			 
57a4			 
57a4					; construct request to access file extent 
57a4			 
57a4			;		ld a, e 
57a4 63					ld h, e 
57a5					 
57a5					 
57a5					 
57a5			 
57a5					; e has id 
57a5			 
57a5 11 ac f9			ld de, store_page 
57a8					if DEBUG_FORTH_WORDS 
57a8						DMARK "REr" 
57a8 f5				push af  
57a9 3a bd 57			ld a, (.dmark)  
57ac 32 9d fd			ld (debug_mark),a  
57af 3a be 57			ld a, (.dmark+1)  
57b2 32 9e fd			ld (debug_mark+1),a  
57b5 3a bf 57			ld a, (.dmark+2)  
57b8 32 9f fd			ld (debug_mark+2),a  
57bb 18 03			jr .pastdmark  
57bd ..			.dmark: db "REr"  
57c0 f1			.pastdmark: pop af  
57c1			endm  
# End of macro DMARK
57c1						CALLMONITOR 
57c1 cd aa fd			call debug_vector  
57c4				endm  
# End of macro CALLMONITOR
57c4					endif 
57c4 cd a7 09				call storage_read 
57c7 cd d5 0f			call ishlzero 
57ca 28 25			jr z, .recnotfound 
57cc			 
57cc			 
57cc					if DEBUG_FORTH_WORDS 
57cc						DMARK "REe" 
57cc f5				push af  
57cd 3a e1 57			ld a, (.dmark)  
57d0 32 9d fd			ld (debug_mark),a  
57d3 3a e2 57			ld a, (.dmark+1)  
57d6 32 9e fd			ld (debug_mark+1),a  
57d9 3a e3 57			ld a, (.dmark+2)  
57dc 32 9f fd			ld (debug_mark+2),a  
57df 18 03			jr .pastdmark  
57e1 ..			.dmark: db "REe"  
57e4 f1			.pastdmark: pop af  
57e5			endm  
# End of macro DMARK
57e5						CALLMONITOR 
57e5 cd aa fd			call debug_vector  
57e8				endm  
# End of macro CALLMONITOR
57e8					endif 
57e8 cd 69 20			call forth_push_str 
57eb			 
57eb					NEXTW 
57eb cd a7 fd			call parse_vector 
57ee c3 e2 23			jp macro_next 
57f1				endm 
# End of macro NEXTW
57f1			 
57f1			.recnotfound: 
57f1					if DEBUG_FORTH_WORDS 
57f1						DMARK "REf" 
57f1 f5				push af  
57f2 3a 06 58			ld a, (.dmark)  
57f5 32 9d fd			ld (debug_mark),a  
57f8 3a 07 58			ld a, (.dmark+1)  
57fb 32 9e fd			ld (debug_mark+1),a  
57fe 3a 08 58			ld a, (.dmark+2)  
5801 32 9f fd			ld (debug_mark+2),a  
5804 18 03			jr .pastdmark  
5806 ..			.dmark: db "REf"  
5809 f1			.pastdmark: pop af  
580a			endm  
# End of macro DMARK
580a						CALLMONITOR 
580a cd aa fd			call debug_vector  
580d				endm  
# End of macro CALLMONITOR
580d					endif 
580d 21 ff 00			ld hl, 255 
5810 cd ff 1f			call forth_push_numhl 
5813				NEXTW 
5813 cd a7 fd			call parse_vector 
5816 c3 e2 23			jp macro_next 
5819				endm 
# End of macro NEXTW
5819			 
5819			 
5819			.BREAD: 
5819			  
5819				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
5819 3a				db WORD_SYS_CORE+38             
581a 9f 58			dw .BWRITE            
581c 06				db 5 + 1 
581d .. 00			db "BREAD",0              
5823				endm 
# End of macro CWHEAD
5823			; | BREAD ( u -- u ) Lowlevel storage word. With the current bank, read a block from page id u (1-512) and push to stack  | DONE 
5823			; | | > [!NOTE] 
5823			; | | > Compatible with PicoSPINet  
5823				 
5823					if DEBUG_FORTH_WORDS_KEY 
5823						DMARK "BRD" 
5823 f5				push af  
5824 3a 38 58			ld a, (.dmark)  
5827 32 9d fd			ld (debug_mark),a  
582a 3a 39 58			ld a, (.dmark+1)  
582d 32 9e fd			ld (debug_mark+1),a  
5830 3a 3a 58			ld a, (.dmark+2)  
5833 32 9f fd			ld (debug_mark+2),a  
5836 18 03			jr .pastdmark  
5838 ..			.dmark: db "BRD"  
583b f1			.pastdmark: pop af  
583c			endm  
# End of macro DMARK
583c						CALLMONITOR 
583c cd aa fd			call debug_vector  
583f				endm  
# End of macro CALLMONITOR
583f					endif 
583f			 
583f				FORTH_DSP_VALUEHL 
583f cd fb 21			call macro_dsp_valuehl 
5842				endm 
# End of macro FORTH_DSP_VALUEHL
5842			 
5842				FORTH_DSP_POP 
5842 cd b3 22			call macro_forth_dsp_pop 
5845				endm 
# End of macro FORTH_DSP_POP
5845			 
5845				; calc block address 
5845			 
5845 eb				ex de, hl 
5846 3e 40			ld a, STORE_BLOCK_PHY 
5848 cd 2f 0f			call Mult16 
584b			 
584b			 
584b 11 ac f9			ld de, store_page 
584e			 
584e					if DEBUG_FORTH_WORDS 
584e						DMARK "BR1" 
584e f5				push af  
584f 3a 63 58			ld a, (.dmark)  
5852 32 9d fd			ld (debug_mark),a  
5855 3a 64 58			ld a, (.dmark+1)  
5858 32 9e fd			ld (debug_mark+1),a  
585b 3a 65 58			ld a, (.dmark+2)  
585e 32 9f fd			ld (debug_mark+2),a  
5861 18 03			jr .pastdmark  
5863 ..			.dmark: db "BR1"  
5866 f1			.pastdmark: pop af  
5867			endm  
# End of macro DMARK
5867						CALLMONITOR 
5867 cd aa fd			call debug_vector  
586a				endm  
# End of macro CALLMONITOR
586a					endif 
586a			 
586a cd 57 04			call storage_read_block 
586d			 
586d cd d5 0f			call ishlzero 
5870 20 05			jr nz, .brfound 
5872			 
5872 cd ff 1f			call forth_push_numhl 
5875 18 22			jr .brdone 
5877			 
5877			 
5877			.brfound: 
5877 21 ae f9		        ld hl, store_page+2 
587a			 
587a					if DEBUG_FORTH_WORDS 
587a						DMARK "BR2" 
587a f5				push af  
587b 3a 8f 58			ld a, (.dmark)  
587e 32 9d fd			ld (debug_mark),a  
5881 3a 90 58			ld a, (.dmark+1)  
5884 32 9e fd			ld (debug_mark+1),a  
5887 3a 91 58			ld a, (.dmark+2)  
588a 32 9f fd			ld (debug_mark+2),a  
588d 18 03			jr .pastdmark  
588f ..			.dmark: db "BR2"  
5892 f1			.pastdmark: pop af  
5893			endm  
# End of macro DMARK
5893						CALLMONITOR 
5893 cd aa fd			call debug_vector  
5896				endm  
# End of macro CALLMONITOR
5896					endif 
5896			 
5896 cd 69 20			call forth_push_str 
5899			 
5899			 
5899			.brdone: 
5899			 
5899					NEXTW 
5899 cd a7 fd			call parse_vector 
589c c3 e2 23			jp macro_next 
589f				endm 
# End of macro NEXTW
589f			.BWRITE: 
589f				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
589f 3a				db WORD_SYS_CORE+38             
58a0 37 59			dw .BUPD            
58a2 07				db 6 + 1 
58a3 .. 00			db "BWRITE",0              
58aa				endm 
# End of macro CWHEAD
58aa			; | BWRITE ( s u -- ) Lowlevel storage word. With the current bank, write the string s to page id u | DONE 
58aa			; | | > [!NOTE] 
58aa			; | | > Compatible with PicoSPINet  
58aa			 
58aa					if DEBUG_FORTH_WORDS_KEY 
58aa						DMARK "BWR" 
58aa f5				push af  
58ab 3a bf 58			ld a, (.dmark)  
58ae 32 9d fd			ld (debug_mark),a  
58b1 3a c0 58			ld a, (.dmark+1)  
58b4 32 9e fd			ld (debug_mark+1),a  
58b7 3a c1 58			ld a, (.dmark+2)  
58ba 32 9f fd			ld (debug_mark+2),a  
58bd 18 03			jr .pastdmark  
58bf ..			.dmark: db "BWR"  
58c2 f1			.pastdmark: pop af  
58c3			endm  
# End of macro DMARK
58c3						CALLMONITOR 
58c3 cd aa fd			call debug_vector  
58c6				endm  
# End of macro CALLMONITOR
58c6					endif 
58c6			 
58c6				FORTH_DSP_VALUEHL 
58c6 cd fb 21			call macro_dsp_valuehl 
58c9				endm 
# End of macro FORTH_DSP_VALUEHL
58c9			 
58c9				; calc block address 
58c9			 
58c9 eb				ex de, hl 
58ca 3e 40			ld a, STORE_BLOCK_PHY 
58cc cd 2f 0f			call Mult16 
58cf			 
58cf e5				push hl         ; address 
58d0			 
58d0				FORTH_DSP_POP 
58d0 cd b3 22			call macro_forth_dsp_pop 
58d3				endm 
# End of macro FORTH_DSP_POP
58d3			 
58d3				FORTH_DSP_VALUEHL 
58d3 cd fb 21			call macro_dsp_valuehl 
58d6				endm 
# End of macro FORTH_DSP_VALUEHL
58d6			 
58d6				FORTH_DSP_POP 
58d6 cd b3 22			call macro_forth_dsp_pop 
58d9				endm 
# End of macro FORTH_DSP_POP
58d9			 
58d9 cd 84 0c			call storage_clear_page 
58dc			 
58dc				; copy string to store page 
58dc			 
58dc e5				push hl     ; save string address 
58dd			 
58dd 3e 00			ld a, 0 
58df cd 0f 13			call strlent 
58e2			 
58e2 23				inc hl 
58e3			 
58e3 4d				ld c, l 
58e4 06 00			ld b, 0 
58e6			 
58e6 e1				pop hl 
58e7 11 ae f9			ld de, store_page + 2 
58ea					if DEBUG_FORTH_WORDS 
58ea						DMARK "BW1" 
58ea f5				push af  
58eb 3a ff 58			ld a, (.dmark)  
58ee 32 9d fd			ld (debug_mark),a  
58f1 3a 00 59			ld a, (.dmark+1)  
58f4 32 9e fd			ld (debug_mark+1),a  
58f7 3a 01 59			ld a, (.dmark+2)  
58fa 32 9f fd			ld (debug_mark+2),a  
58fd 18 03			jr .pastdmark  
58ff ..			.dmark: db "BW1"  
5902 f1			.pastdmark: pop af  
5903			endm  
# End of macro DMARK
5903						CALLMONITOR 
5903 cd aa fd			call debug_vector  
5906				endm  
# End of macro CALLMONITOR
5906					endif 
5906 ed b0			ldir 
5908			 
5908			 
5908				; poke the start of the block with flags to prevent high level file ops hitting the block 
5908			 
5908 21 ff ff			ld hl, $ffff 
590b			 
590b 22 ac f9			ld (store_page), hl	 
590e				 
590e e1				pop hl    ; get address 
590f 11 ac f9			ld de, store_page 
5912			 
5912					if DEBUG_FORTH_WORDS 
5912						DMARK "BW2" 
5912 f5				push af  
5913 3a 27 59			ld a, (.dmark)  
5916 32 9d fd			ld (debug_mark),a  
5919 3a 28 59			ld a, (.dmark+1)  
591c 32 9e fd			ld (debug_mark+1),a  
591f 3a 29 59			ld a, (.dmark+2)  
5922 32 9f fd			ld (debug_mark+2),a  
5925 18 03			jr .pastdmark  
5927 ..			.dmark: db "BW2"  
592a f1			.pastdmark: pop af  
592b			endm  
# End of macro DMARK
592b						CALLMONITOR 
592b cd aa fd			call debug_vector  
592e				endm  
# End of macro CALLMONITOR
592e					endif 
592e			 
592e cd bc 04			call storage_write_block 
5931			 
5931					NEXTW 
5931 cd a7 fd			call parse_vector 
5934 c3 e2 23			jp macro_next 
5937				endm 
# End of macro NEXTW
5937			 
5937			.BUPD: 
5937				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
5937 3a				db WORD_SYS_CORE+38             
5938 90 59			dw .BYID            
593a 05				db 4 + 1 
593b .. 00			db "BUPD",0              
5940				endm 
# End of macro CWHEAD
5940			; | BUPD ( u -- ) Lowlevel storage word. Write the contents of the current file system storage buffer directly to page id u | DONE 
5940			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
5940			; | | or completely different file system structure. 
5940			; | | > [!NOTE] 
5940			; | | > Compatible with PicoSPINet  
5940			 
5940					if DEBUG_FORTH_WORDS_KEY 
5940						DMARK "BUD" 
5940 f5				push af  
5941 3a 55 59			ld a, (.dmark)  
5944 32 9d fd			ld (debug_mark),a  
5947 3a 56 59			ld a, (.dmark+1)  
594a 32 9e fd			ld (debug_mark+1),a  
594d 3a 57 59			ld a, (.dmark+2)  
5950 32 9f fd			ld (debug_mark+2),a  
5953 18 03			jr .pastdmark  
5955 ..			.dmark: db "BUD"  
5958 f1			.pastdmark: pop af  
5959			endm  
# End of macro DMARK
5959						CALLMONITOR 
5959 cd aa fd			call debug_vector  
595c				endm  
# End of macro CALLMONITOR
595c					endif 
595c			 
595c				FORTH_DSP_VALUEHL 
595c cd fb 21			call macro_dsp_valuehl 
595f				endm 
# End of macro FORTH_DSP_VALUEHL
595f			 
595f				; calc block address 
595f			 
595f eb				ex de, hl 
5960 3e 40			ld a, STORE_BLOCK_PHY 
5962 cd 2f 0f			call Mult16 
5965			 
5965				FORTH_DSP_POP 
5965 cd b3 22			call macro_forth_dsp_pop 
5968				endm 
# End of macro FORTH_DSP_POP
5968			 
5968			 
5968 11 ac f9			ld de, store_page 
596b			 
596b					if DEBUG_FORTH_WORDS 
596b						DMARK "BUe" 
596b f5				push af  
596c 3a 80 59			ld a, (.dmark)  
596f 32 9d fd			ld (debug_mark),a  
5972 3a 81 59			ld a, (.dmark+1)  
5975 32 9e fd			ld (debug_mark+1),a  
5978 3a 82 59			ld a, (.dmark+2)  
597b 32 9f fd			ld (debug_mark+2),a  
597e 18 03			jr .pastdmark  
5980 ..			.dmark: db "BUe"  
5983 f1			.pastdmark: pop af  
5984			endm  
# End of macro DMARK
5984						CALLMONITOR 
5984 cd aa fd			call debug_vector  
5987				endm  
# End of macro CALLMONITOR
5987					endif 
5987			 
5987 cd bc 04			call storage_write_block 
598a			 
598a					NEXTW 
598a cd a7 fd			call parse_vector 
598d c3 e2 23			jp macro_next 
5990				endm 
# End of macro NEXTW
5990			 
5990			.BYID: 
5990			;	CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
5990			;; > BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u > TODO 
5990			; 
5990			;		 
5990			;		if DEBUG_FORTH_WORDS_KEY 
5990			;			DMARK "BYID" 
5990			;			CALLMONITOR 
5990			;		endif 
5990			; 
5990			;		; get direct address 
5990			; 
5990			;		FORTH_DSP_VALUEHL 
5990			; 
5990			;		FORTH_DSP_POP 
5990			; 
5990			;	; calc block address 
5990			; 
5990			;	ex de, hl 
5990			;	ld a, STORE_BLOCK_PHY 
5990			;	call Mult16 
5990			;	;	do BREAD with number as param 
5990			;	; push the file name	 
5990			;	ld de, store_page 
5990			;	call storage_read_block 
5990			 ;       ld hl, store_page+2 
5990			; 
5990			; 
5990			;		NEXTW 
5990			;.BYNAME: 
5990				CWHEAD .DIR 38 "GETID" 5 WORD_FLAG_CODE 
5990 3a				db WORD_SYS_CORE+38             
5991 ac 59			dw .DIR            
5993 06				db 5 + 1 
5994 .. 00			db "GETID",0              
599a				endm 
# End of macro CWHEAD
599a			; | GETID ( s -- u ) Get the file ID in the current BANK of the file named s | DONE 
599a			; | | > [!NOTE] 
599a			; | | > Compatible with PicoSPINet  
599a			 
599a					; get pointer to file name to seek 
599a			 
599a					FORTH_DSP_VALUEHL 
599a cd fb 21			call macro_dsp_valuehl 
599d				endm 
# End of macro FORTH_DSP_VALUEHL
599d			 
599d			 
599d cd 7e 03				call storage_getid  
59a0			 
59a0					FORTH_DSP_POP 
59a0 cd b3 22			call macro_forth_dsp_pop 
59a3				endm 
# End of macro FORTH_DSP_POP
59a3			 
59a3 cd ff 1f				call forth_push_numhl 
59a6			 
59a6					NEXTW 
59a6 cd a7 fd			call parse_vector 
59a9 c3 e2 23			jp macro_next 
59ac				endm 
# End of macro NEXTW
59ac			; 
59ac			.DIR: 
59ac				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
59ac 3a				db WORD_SYS_CORE+38             
59ad b3 5a			dw .SAVE            
59af 04				db 3 + 1 
59b0 .. 00			db "DIR",0              
59b4				endm 
# End of macro CWHEAD
59b4			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
59b4			; | | > [!NOTE] 
59b4			; | | > Compatible with PicoSPINet  
59b4			 
59b4					if DEBUG_FORTH_WORDS_KEY 
59b4						DMARK "DIR" 
59b4 f5				push af  
59b5 3a c9 59			ld a, (.dmark)  
59b8 32 9d fd			ld (debug_mark),a  
59bb 3a ca 59			ld a, (.dmark+1)  
59be 32 9e fd			ld (debug_mark+1),a  
59c1 3a cb 59			ld a, (.dmark+2)  
59c4 32 9f fd			ld (debug_mark+2),a  
59c7 18 03			jr .pastdmark  
59c9 ..			.dmark: db "DIR"  
59cc f1			.pastdmark: pop af  
59cd			endm  
# End of macro DMARK
59cd						CALLMONITOR 
59cd cd aa fd			call debug_vector  
59d0				endm  
# End of macro CALLMONITOR
59d0					endif 
59d0 cd 05 05			call storage_get_block_0 
59d3			 
59d3 21 ac f9			ld hl, store_page     ; get current id count 
59d6 46				ld b, (hl) 
59d7 0e 00			ld c, 0    ; count of files   
59d9					if DEBUG_FORTH_WORDS 
59d9						DMARK "DI1" 
59d9 f5				push af  
59da 3a ee 59			ld a, (.dmark)  
59dd 32 9d fd			ld (debug_mark),a  
59e0 3a ef 59			ld a, (.dmark+1)  
59e3 32 9e fd			ld (debug_mark+1),a  
59e6 3a f0 59			ld a, (.dmark+2)  
59e9 32 9f fd			ld (debug_mark+2),a  
59ec 18 03			jr .pastdmark  
59ee ..			.dmark: db "DI1"  
59f1 f1			.pastdmark: pop af  
59f2			endm  
# End of macro DMARK
59f2						CALLMONITOR 
59f2 cd aa fd			call debug_vector  
59f5				endm  
# End of macro CALLMONITOR
59f5					endif 
59f5			 
59f5				; check for empty drive 
59f5			 
59f5 3e 00			ld a, 0 
59f7 b8				cp b 
59f8 ca 66 5a			jp z, .dirdone 
59fb			 
59fb				; for each of the current ids do a search for them and if found push to stack 
59fb			 
59fb c5			.diritem:	push bc 
59fc 21 40 00				ld hl, STORE_BLOCK_PHY 
59ff 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
5a01 58					ld e,b 
5a02			 
5a02			;		if DEBUG_FORTH_WORDS 
5a02			;			DMARK "DI2" 
5a02			;			CALLMONITOR 
5a02			;		endif 
5a02			 
5a02 cd 83 07				call storage_findnextid 
5a05			 
5a05			;		if DEBUG_FORTH_WORDS 
5a05			;			DMARK "DI3" 
5a05			;			CALLMONITOR 
5a05			;		endif 
5a05			 
5a05					; if found hl will be non zero 
5a05			 
5a05 cd d5 0f				call ishlzero 
5a08			;		ld a, l 
5a08			;		add h 
5a08			; 
5a08			;		cp 0 
5a08 28 59				jr z, .dirnotfound 
5a0a			 
5a0a					; increase count 
5a0a			 
5a0a c1					pop bc	 
5a0b 0c					inc c 
5a0c c5					push bc 
5a0d					 
5a0d			 
5a0d					; get file header and push the file name 
5a0d			 
5a0d 11 ac f9				ld de, store_page 
5a10 cd 57 04				call storage_read_block 
5a13			 
5a13					; push file id to stack 
5a13				 
5a13 3a ac f9				ld a, (store_page) 
5a16 26 00				ld h, 0 
5a18 6f					ld l, a 
5a19 cd ff 1f				call forth_push_numhl 
5a1c			 
5a1c					; push extent count to stack  
5a1c				 
5a1c 3a ae f9				ld a, (store_page+2) 
5a1f 26 00				ld h, 0 
5a21 6f					ld l, a 
5a22 cd ff 1f				call forth_push_numhl 
5a25			 
5a25					; push file name 
5a25			 
5a25 21 af f9				ld hl, store_page+3 
5a28					if DEBUG_FORTH_WORDS 
5a28						DMARK "DI5" 
5a28 f5				push af  
5a29 3a 3d 5a			ld a, (.dmark)  
5a2c 32 9d fd			ld (debug_mark),a  
5a2f 3a 3e 5a			ld a, (.dmark+1)  
5a32 32 9e fd			ld (debug_mark+1),a  
5a35 3a 3f 5a			ld a, (.dmark+2)  
5a38 32 9f fd			ld (debug_mark+2),a  
5a3b 18 03			jr .pastdmark  
5a3d ..			.dmark: db "DI5"  
5a40 f1			.pastdmark: pop af  
5a41			endm  
# End of macro DMARK
5a41						CALLMONITOR 
5a41 cd aa fd			call debug_vector  
5a44				endm  
# End of macro CALLMONITOR
5a44					endif 
5a44 cd 69 20				call forth_push_str 
5a47					if DEBUG_FORTH_WORDS 
5a47						DMARK "DI6" 
5a47 f5				push af  
5a48 3a 5c 5a			ld a, (.dmark)  
5a4b 32 9d fd			ld (debug_mark),a  
5a4e 3a 5d 5a			ld a, (.dmark+1)  
5a51 32 9e fd			ld (debug_mark+1),a  
5a54 3a 5e 5a			ld a, (.dmark+2)  
5a57 32 9f fd			ld (debug_mark+2),a  
5a5a 18 03			jr .pastdmark  
5a5c ..			.dmark: db "DI6"  
5a5f f1			.pastdmark: pop af  
5a60			endm  
# End of macro DMARK
5a60						CALLMONITOR 
5a60 cd aa fd			call debug_vector  
5a63				endm  
# End of macro CALLMONITOR
5a63					endif 
5a63			.dirnotfound: 
5a63 c1					pop bc     
5a64 10 95				djnz .diritem 
5a66				 
5a66			.dirdone:	 
5a66					if DEBUG_FORTH_WORDS 
5a66						DMARK "DI7" 
5a66 f5				push af  
5a67 3a 7b 5a			ld a, (.dmark)  
5a6a 32 9d fd			ld (debug_mark),a  
5a6d 3a 7c 5a			ld a, (.dmark+1)  
5a70 32 9e fd			ld (debug_mark+1),a  
5a73 3a 7d 5a			ld a, (.dmark+2)  
5a76 32 9f fd			ld (debug_mark+2),a  
5a79 18 03			jr .pastdmark  
5a7b ..			.dmark: db "DI7"  
5a7e f1			.pastdmark: pop af  
5a7f			endm  
# End of macro DMARK
5a7f						CALLMONITOR 
5a7f cd aa fd			call debug_vector  
5a82				endm  
# End of macro CALLMONITOR
5a82					endif 
5a82			 
5a82					; push a count of the dir items found 
5a82			 
5a82 26 00				ld h, 0 
5a84 69					ld l, c 
5a85 cd ff 1f				call forth_push_numhl 
5a88			 
5a88					; push the bank label 
5a88			 
5a88 cd 05 05				call storage_get_block_0 
5a8b			 
5a8b				 
5a8b 21 af f9		 		ld hl, store_page+3 
5a8e			 
5a8e					if DEBUG_FORTH_WORDS 
5a8e						DMARK "DI8" 
5a8e f5				push af  
5a8f 3a a3 5a			ld a, (.dmark)  
5a92 32 9d fd			ld (debug_mark),a  
5a95 3a a4 5a			ld a, (.dmark+1)  
5a98 32 9e fd			ld (debug_mark+1),a  
5a9b 3a a5 5a			ld a, (.dmark+2)  
5a9e 32 9f fd			ld (debug_mark+2),a  
5aa1 18 03			jr .pastdmark  
5aa3 ..			.dmark: db "DI8"  
5aa6 f1			.pastdmark: pop af  
5aa7			endm  
# End of macro DMARK
5aa7						CALLMONITOR 
5aa7 cd aa fd			call debug_vector  
5aaa				endm  
# End of macro CALLMONITOR
5aaa					endif 
5aaa cd 69 20				call forth_push_str 
5aad			 
5aad			 
5aad				 
5aad					NEXTW 
5aad cd a7 fd			call parse_vector 
5ab0 c3 e2 23			jp macro_next 
5ab3				endm 
# End of macro NEXTW
5ab3			.SAVE: 
5ab3			;	CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
5ab3			;; > SAVE  ( w u -- )    Save user word memory to file name w on bank u > TODO 
5ab3			;		NEXTW 
5ab3			;.LOAD: 
5ab3			;	CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
5ab3			;; > LOAD ( u -- )    Load user word memory from file id on current bank > TODO 
5ab3			;; > > The indivdual records being loaded can be both uword word difintions or interactive commands. 
5ab3			;; > > The LOAD command can not be used in any user words or compound lines. 
5ab3			; 
5ab3			;		; store_openext use it. If zero it is EOF 
5ab3			; 
5ab3			;		; read block from current stream id 
5ab3			;		; if the block does not contain zero term keep reading blocks until zero found 
5ab3			;		; push the block to stack 
5ab3			;		; save the block id to stream 
5ab3			; 
5ab3			; 
5ab3			;		FORTH_DSP_VALUEHL 
5ab3			; 
5ab3			;;		push hl 
5ab3			; 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LOA" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			;		FORTH_DSP_POP 
5ab3			; 
5ab3			;;		pop hl 
5ab3			; 
5ab3			;		ld h, l 
5ab3			;		ld l, 0 
5ab3			; 
5ab3			;		push hl     ; stack holds current file id and extent to work with 
5ab3			; 
5ab3			; 
5ab3			;		ld de, store_page      ; get block zero of file 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LO0" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			;		call storage_read 
5ab3			; 
5ab3			;		ld a, (store_page+2)    ; max extents for this file 
5ab3			;		ld  (store_openmaxext),a   ; get our limit 
5ab3			; 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LOE" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			; 
5ab3			;; TODO dont know why max extents are not present 
5ab3			;;		cp 0 
5ab3			;;		jp z, .loadeof     ; dont read past eof 
5ab3			; 
5ab3			;;		ld a, 1   ; start from the head of the file 
5ab3			; 
5ab3			;.loadline:	pop hl 
5ab3			;		inc hl 
5ab3			;		ld  a, (store_openmaxext)   ; get our limit 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LOx" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			;		inc a 
5ab3			;		cp l 
5ab3			;		jp z, .loadeof 
5ab3			;		push hl    ; save current extent 
5ab3			; 
5ab3			;		ld de, store_page 
5ab3			; 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LO1" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			;		call storage_read 
5ab3			; 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LO2" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			;	call ishlzero 
5ab3			;	ld a, l 
5ab3			;	add h 
5ab3			;	cp 0 
5ab3			;	jr z, .loadeof 
5ab3			; 
5ab3			;	; not eof so hl should point to data to exec 
5ab3			; 
5ab3			;	; will need to add the FORTH_END_BUFFER flag 
5ab3			 ; 
5ab3			;	ld hl, store_page+2 
5ab3			;	ld bc, 255 
5ab3			;	ld a, 0 
5ab3			;	cpir 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LOt" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			;	dec hl 
5ab3			;	ld a, ' ' 
5ab3			;	ld (hl), a 
5ab3			;	inc hl 
5ab3			;	ld (hl), a 
5ab3			;	inc hl 
5ab3			;	ld (hl), a 
5ab3			;	inc hl 
5ab3			;	ld a, FORTH_END_BUFFER 
5ab3			;	ld (hl), a 
5ab3			; 
5ab3			;	; TODO handle more than a single block read 
5ab3			; 
5ab3			; 
5ab3			;	ld hl, store_page+2 
5ab3			; 
5ab3			;	ld (os_tok_ptr), hl 
5ab3			; 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LO3" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			; 
5ab3			;	call forthparse 
5ab3			;	call forthexec 
5ab3			;	call forthexec_cleanup 
5ab3			; 
5ab3			;	; go to next extent 
5ab3			; 
5ab3			;	; get next block  or mark as eof 
5ab3			;	jp .loadline 
5ab3			; 
5ab3			; 
5ab3			; 
5ab3			;	       NEXTW 
5ab3			;.loadeof:	ld a, 0 
5ab3			;		ld (store_openext), a 
5ab3			; 
5ab3			;	if DEBUG_STORESE 
5ab3			;		DMARK "LOF" 
5ab3			;		CALLMONITOR 
5ab3			;	endif 
5ab3			;		ret 
5ab3			;		;NEXTW 
5ab3			;.BSAVE:   
5ab3			; 
5ab3			;	CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
5ab3			;; > BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes > TODO 
5ab3			;		NEXTW 
5ab3			;.BLOAD: 
5ab3			;	CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
5ab3			;; > BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u > TODO 
5ab3			;		NEXTW 
5ab3			;;;; counter gap 
5ab3			 
5ab3			 
5ab3			.SEO: 
5ab3				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
5ab3 64				db WORD_SYS_CORE+80             
5ab4 d5 5a			dw .SEI            
5ab6 04				db 3 + 1 
5ab7 .. 00			db "SEO",0              
5abb				endm 
# End of macro CWHEAD
5abb			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
5abb			 
5abb					; get port 
5abb			 
5abb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5abb cd fb 21			call macro_dsp_valuehl 
5abe				endm 
# End of macro FORTH_DSP_VALUEHL
5abe			 
5abe e5					push hl    ; u2 - byte 
5abf			 
5abf					; destroy value TOS 
5abf			 
5abf					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5abf cd b3 22			call macro_forth_dsp_pop 
5ac2				endm 
# End of macro FORTH_DSP_POP
5ac2			 
5ac2					; get byte to send 
5ac2			 
5ac2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5ac2 cd fb 21			call macro_dsp_valuehl 
5ac5				endm 
# End of macro FORTH_DSP_VALUEHL
5ac5			 
5ac5 e5					push hl    ; u1 - addr 
5ac6			 
5ac6					; destroy value TOS 
5ac6			 
5ac6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ac6 cd b3 22			call macro_forth_dsp_pop 
5ac9				endm 
# End of macro FORTH_DSP_POP
5ac9			 
5ac9					; one value on hl get other one back 
5ac9			 
5ac9 d1					pop de   ; u1 - byte 
5aca			 
5aca e1					pop hl   ; u2 - addr 
5acb			 
5acb					; TODO Send SPI byte 
5acb			 
5acb			 
5acb 7b					ld a, e 
5acc cd 65 02				call se_writebyte 
5acf			 
5acf					 
5acf			 
5acf					NEXTW 
5acf cd a7 fd			call parse_vector 
5ad2 c3 e2 23			jp macro_next 
5ad5				endm 
# End of macro NEXTW
5ad5			 
5ad5			.SEI: 
5ad5				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
5ad5 65				db WORD_SYS_CORE+81             
5ad6 f2 5a			dw .SFREE            
5ad8 04				db 3 + 1 
5ad9 .. 00			db "SEI",0              
5add				endm 
# End of macro CWHEAD
5add			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
5add			 
5add					; get port 
5add			 
5add					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
5add cd fb 21			call macro_dsp_valuehl 
5ae0				endm 
# End of macro FORTH_DSP_VALUEHL
5ae0			 
5ae0			;		push hl 
5ae0			 
5ae0					; destroy value TOS 
5ae0			 
5ae0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
5ae0 cd b3 22			call macro_forth_dsp_pop 
5ae3				endm 
# End of macro FORTH_DSP_POP
5ae3			 
5ae3					; one value on hl get other one back 
5ae3			 
5ae3			;		pop hl 
5ae3			 
5ae3			 
5ae3					; TODO Get SPI byte 
5ae3			 
5ae3 cd ff 02				call se_readbyte 
5ae6			 
5ae6 26 00				ld h, 0 
5ae8 6f					ld l, a 
5ae9 cd ff 1f				call forth_push_numhl 
5aec			 
5aec					NEXTW 
5aec cd a7 fd			call parse_vector 
5aef c3 e2 23			jp macro_next 
5af2				endm 
# End of macro NEXTW
5af2			 
5af2			.SFREE: 
5af2				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
5af2 67				db WORD_SYS_CORE+83             
5af3 24 5b			dw .SIZE            
5af5 06				db 5 + 1 
5af6 .. 00			db "FFREE",0              
5afc				endm 
# End of macro CWHEAD
5afc			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
5afc			; | | > [!NOTE] 
5afc			; | | > Compatible with PicoSPINet  
5afc					if DEBUG_FORTH_WORDS_KEY 
5afc						DMARK "FFR" 
5afc f5				push af  
5afd 3a 11 5b			ld a, (.dmark)  
5b00 32 9d fd			ld (debug_mark),a  
5b03 3a 12 5b			ld a, (.dmark+1)  
5b06 32 9e fd			ld (debug_mark+1),a  
5b09 3a 13 5b			ld a, (.dmark+2)  
5b0c 32 9f fd			ld (debug_mark+2),a  
5b0f 18 03			jr .pastdmark  
5b11 ..			.dmark: db "FFR"  
5b14 f1			.pastdmark: pop af  
5b15			endm  
# End of macro DMARK
5b15						CALLMONITOR 
5b15 cd aa fd			call debug_vector  
5b18				endm  
# End of macro CALLMONITOR
5b18					endif 
5b18			 
5b18 cd 1d 08				call storage_freeblocks 
5b1b			 
5b1b cd ff 1f				call forth_push_numhl 
5b1e			 
5b1e				       NEXTW 
5b1e cd a7 fd			call parse_vector 
5b21 c3 e2 23			jp macro_next 
5b24				endm 
# End of macro NEXTW
5b24			.SIZE: 
5b24				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
5b24 67				db WORD_SYS_CORE+83             
5b25 5b 5b			dw .CREATE            
5b27 05				db 4 + 1 
5b28 .. 00			db "SIZE",0              
5b2d				endm 
# End of macro CWHEAD
5b2d			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
5b2d			; | | > [!NOTE] 
5b2d			; | | > Compatible with PicoSPINet  
5b2d					if DEBUG_FORTH_WORDS_KEY 
5b2d						DMARK "SIZ" 
5b2d f5				push af  
5b2e 3a 42 5b			ld a, (.dmark)  
5b31 32 9d fd			ld (debug_mark),a  
5b34 3a 43 5b			ld a, (.dmark+1)  
5b37 32 9e fd			ld (debug_mark+1),a  
5b3a 3a 44 5b			ld a, (.dmark+2)  
5b3d 32 9f fd			ld (debug_mark+2),a  
5b40 18 03			jr .pastdmark  
5b42 ..			.dmark: db "SIZ"  
5b45 f1			.pastdmark: pop af  
5b46			endm  
# End of macro DMARK
5b46						CALLMONITOR 
5b46 cd aa fd			call debug_vector  
5b49				endm  
# End of macro CALLMONITOR
5b49					endif 
5b49			 
5b49					FORTH_DSP_VALUEHL 
5b49 cd fb 21			call macro_dsp_valuehl 
5b4c				endm 
# End of macro FORTH_DSP_VALUEHL
5b4c			;		push hl 
5b4c					FORTH_DSP_POP 
5b4c cd b3 22			call macro_forth_dsp_pop 
5b4f				endm 
# End of macro FORTH_DSP_POP
5b4f			;		pop hl 
5b4f cd 86 04				call storage_file_size 
5b52			 
5b52 cd ff 1f				call forth_push_numhl 
5b55			  
5b55			 
5b55				       NEXTW 
5b55 cd a7 fd			call parse_vector 
5b58 c3 e2 23			jp macro_next 
5b5b				endm 
# End of macro NEXTW
5b5b			 
5b5b			.CREATE: 
5b5b				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
5b5b 68				db WORD_SYS_CORE+84             
5b5c cc 5b			dw .APPEND            
5b5e 07				db 6 + 1 
5b5f .. 00			db "CREATE",0              
5b66				endm 
# End of macro CWHEAD
5b66			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | DONE 
5b66			; | | e.g.  
5b66			; | | TestProgram CREATE 
5b66			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
5b66			; | |  
5b66			; | | Max file IDs are 255. 
5b66			; | |  
5b66			; | | > [!NOTE] 
5b66			; | | > Compatible with PicoSPINet  
5b66					 
5b66					if DEBUG_FORTH_WORDS_KEY 
5b66						DMARK "CRT" 
5b66 f5				push af  
5b67 3a 7b 5b			ld a, (.dmark)  
5b6a 32 9d fd			ld (debug_mark),a  
5b6d 3a 7c 5b			ld a, (.dmark+1)  
5b70 32 9e fd			ld (debug_mark+1),a  
5b73 3a 7d 5b			ld a, (.dmark+2)  
5b76 32 9f fd			ld (debug_mark+2),a  
5b79 18 03			jr .pastdmark  
5b7b ..			.dmark: db "CRT"  
5b7e f1			.pastdmark: pop af  
5b7f			endm  
# End of macro DMARK
5b7f						CALLMONITOR 
5b7f cd aa fd			call debug_vector  
5b82				endm  
# End of macro CALLMONITOR
5b82					endif 
5b82			;		call storage_get_block_0 
5b82			 
5b82					; TODO pop hl 
5b82			 
5b82					;v5 FORTH_DSP_VALUE 
5b82					FORTH_DSP_VALUE 
5b82 cd e4 21			call macro_forth_dsp_value 
5b85				endm 
# End of macro FORTH_DSP_VALUE
5b85			 
5b85				if DEBUG_STORESE 
5b85					DMARK "CR1" 
5b85 f5				push af  
5b86 3a 9a 5b			ld a, (.dmark)  
5b89 32 9d fd			ld (debug_mark),a  
5b8c 3a 9b 5b			ld a, (.dmark+1)  
5b8f 32 9e fd			ld (debug_mark+1),a  
5b92 3a 9c 5b			ld a, (.dmark+2)  
5b95 32 9f fd			ld (debug_mark+2),a  
5b98 18 03			jr .pastdmark  
5b9a ..			.dmark: db "CR1"  
5b9d f1			.pastdmark: pop af  
5b9e			endm  
# End of macro DMARK
5b9e					CALLMONITOR 
5b9e cd aa fd			call debug_vector  
5ba1				endm  
# End of macro CALLMONITOR
5ba1				endif 
5ba1			;		push hl 
5ba1			;		FORTH_DSP_POP 
5ba1			;		pop hl 
5ba1			 
5ba1			;		inc hl   ; move past the type marker 
5ba1			 
5ba1 cd 51 08				call storage_create 
5ba4			 
5ba4				if DEBUG_STORESE 
5ba4					DMARK "CT1" 
5ba4 f5				push af  
5ba5 3a b9 5b			ld a, (.dmark)  
5ba8 32 9d fd			ld (debug_mark),a  
5bab 3a ba 5b			ld a, (.dmark+1)  
5bae 32 9e fd			ld (debug_mark+1),a  
5bb1 3a bb 5b			ld a, (.dmark+2)  
5bb4 32 9f fd			ld (debug_mark+2),a  
5bb7 18 03			jr .pastdmark  
5bb9 ..			.dmark: db "CT1"  
5bbc f1			.pastdmark: pop af  
5bbd			endm  
# End of macro DMARK
5bbd					CALLMONITOR 
5bbd cd aa fd			call debug_vector  
5bc0				endm  
# End of macro CALLMONITOR
5bc0				endif 
5bc0			;		push hl 
5bc0					FORTH_DSP_POP 
5bc0 cd b3 22			call macro_forth_dsp_pop 
5bc3				endm 
# End of macro FORTH_DSP_POP
5bc3			;		pop hl 
5bc3					; push file id to stack 
5bc3 cd ff 1f				call forth_push_numhl 
5bc6			 
5bc6			 
5bc6			 
5bc6				       NEXTW 
5bc6 cd a7 fd			call parse_vector 
5bc9 c3 e2 23			jp macro_next 
5bcc				endm 
# End of macro NEXTW
5bcc			 
5bcc			.APPEND: 
5bcc				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
5bcc 69				db WORD_SYS_CORE+85             
5bcd 60 5c			dw .SDEL            
5bcf 07				db 6 + 1 
5bd0 .. 00			db "APPEND",0              
5bd7				endm 
# End of macro CWHEAD
5bd7			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | DONE 
5bd7			; | | e.g. 
5bd7			; | | Test CREATE      -> $01 
5bd7			; | | "A string to add to file" $01 APPEND 
5bd7			; | |  
5bd7			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
5bd7			; | | > [!NOTE] 
5bd7			; | | > Compatible with PicoSPINet  
5bd7					if DEBUG_FORTH_WORDS_KEY 
5bd7						DMARK "APP" 
5bd7 f5				push af  
5bd8 3a ec 5b			ld a, (.dmark)  
5bdb 32 9d fd			ld (debug_mark),a  
5bde 3a ed 5b			ld a, (.dmark+1)  
5be1 32 9e fd			ld (debug_mark+1),a  
5be4 3a ee 5b			ld a, (.dmark+2)  
5be7 32 9f fd			ld (debug_mark+2),a  
5bea 18 03			jr .pastdmark  
5bec ..			.dmark: db "APP"  
5bef f1			.pastdmark: pop af  
5bf0			endm  
# End of macro DMARK
5bf0						CALLMONITOR 
5bf0 cd aa fd			call debug_vector  
5bf3				endm  
# End of macro CALLMONITOR
5bf3					endif 
5bf3			 
5bf3					FORTH_DSP_VALUEHL 
5bf3 cd fb 21			call macro_dsp_valuehl 
5bf6				endm 
# End of macro FORTH_DSP_VALUEHL
5bf6 e5					push hl 	; save file id 
5bf7			 
5bf7				if DEBUG_STORESE 
5bf7					DMARK "AP1" 
5bf7 f5				push af  
5bf8 3a 0c 5c			ld a, (.dmark)  
5bfb 32 9d fd			ld (debug_mark),a  
5bfe 3a 0d 5c			ld a, (.dmark+1)  
5c01 32 9e fd			ld (debug_mark+1),a  
5c04 3a 0e 5c			ld a, (.dmark+2)  
5c07 32 9f fd			ld (debug_mark+2),a  
5c0a 18 03			jr .pastdmark  
5c0c ..			.dmark: db "AP1"  
5c0f f1			.pastdmark: pop af  
5c10			endm  
# End of macro DMARK
5c10					CALLMONITOR 
5c10 cd aa fd			call debug_vector  
5c13				endm  
# End of macro CALLMONITOR
5c13				endif 
5c13					FORTH_DSP_POP 
5c13 cd b3 22			call macro_forth_dsp_pop 
5c16				endm 
# End of macro FORTH_DSP_POP
5c16			 
5c16					FORTH_DSP_VALUEHL 
5c16 cd fb 21			call macro_dsp_valuehl 
5c19				endm 
# End of macro FORTH_DSP_VALUEHL
5c19					;v5 FORTH_DSP_VALUE 
5c19 e5					push hl 	; save ptr to string to save 
5c1a			 
5c1a				if DEBUG_STORESE 
5c1a					DMARK "AP1" 
5c1a f5				push af  
5c1b 3a 2f 5c			ld a, (.dmark)  
5c1e 32 9d fd			ld (debug_mark),a  
5c21 3a 30 5c			ld a, (.dmark+1)  
5c24 32 9e fd			ld (debug_mark+1),a  
5c27 3a 31 5c			ld a, (.dmark+2)  
5c2a 32 9f fd			ld (debug_mark+2),a  
5c2d 18 03			jr .pastdmark  
5c2f ..			.dmark: db "AP1"  
5c32 f1			.pastdmark: pop af  
5c33			endm  
# End of macro DMARK
5c33					CALLMONITOR 
5c33 cd aa fd			call debug_vector  
5c36				endm  
# End of macro CALLMONITOR
5c36				endif 
5c36					FORTH_DSP_POP 
5c36 cd b3 22			call macro_forth_dsp_pop 
5c39				endm 
# End of macro FORTH_DSP_POP
5c39			 
5c39 d1					pop de 
5c3a e1					pop hl 
5c3b				if DEBUG_STORESE 
5c3b					DMARK "AP2" 
5c3b f5				push af  
5c3c 3a 50 5c			ld a, (.dmark)  
5c3f 32 9d fd			ld (debug_mark),a  
5c42 3a 51 5c			ld a, (.dmark+1)  
5c45 32 9e fd			ld (debug_mark+1),a  
5c48 3a 52 5c			ld a, (.dmark+2)  
5c4b 32 9f fd			ld (debug_mark+2),a  
5c4e 18 03			jr .pastdmark  
5c50 ..			.dmark: db "AP2"  
5c53 f1			.pastdmark: pop af  
5c54			endm  
# End of macro DMARK
5c54					CALLMONITOR 
5c54 cd aa fd			call debug_vector  
5c57				endm  
# End of macro CALLMONITOR
5c57				endif 
5c57					;inc de ; skip var type indicator 
5c57			 
5c57					; TODO how to append numerics???? 
5c57			 
5c57 cd 3b 0b				call storage_append		 
5c5a			 
5c5a				       NEXTW 
5c5a cd a7 fd			call parse_vector 
5c5d c3 e2 23			jp macro_next 
5c60				endm 
# End of macro NEXTW
5c60			.SDEL: 
5c60				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
5c60 6a				db WORD_SYS_CORE+86             
5c61 af 5c			dw .OPEN            
5c63 05				db 4 + 1 
5c64 .. 00			db "ERA",0              
5c68				endm 
# End of macro CWHEAD
5c68			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
5c68			; | | > [!NOTE] 
5c68			; | | > Compatible with PicoSPINet  
5c68					FORTH_DSP_VALUEHL 
5c68 cd fb 21			call macro_dsp_valuehl 
5c6b				endm 
# End of macro FORTH_DSP_VALUEHL
5c6b			;		push hl 	; save file id 
5c6b			 
5c6b					if DEBUG_FORTH_WORDS_KEY 
5c6b						DMARK "ERA" 
5c6b f5				push af  
5c6c 3a 80 5c			ld a, (.dmark)  
5c6f 32 9d fd			ld (debug_mark),a  
5c72 3a 81 5c			ld a, (.dmark+1)  
5c75 32 9e fd			ld (debug_mark+1),a  
5c78 3a 82 5c			ld a, (.dmark+2)  
5c7b 32 9f fd			ld (debug_mark+2),a  
5c7e 18 03			jr .pastdmark  
5c80 ..			.dmark: db "ERA"  
5c83 f1			.pastdmark: pop af  
5c84			endm  
# End of macro DMARK
5c84						CALLMONITOR 
5c84 cd aa fd			call debug_vector  
5c87				endm  
# End of macro CALLMONITOR
5c87					endif 
5c87				if DEBUG_STORESE 
5c87					DMARK "ER1" 
5c87 f5				push af  
5c88 3a 9c 5c			ld a, (.dmark)  
5c8b 32 9d fd			ld (debug_mark),a  
5c8e 3a 9d 5c			ld a, (.dmark+1)  
5c91 32 9e fd			ld (debug_mark+1),a  
5c94 3a 9e 5c			ld a, (.dmark+2)  
5c97 32 9f fd			ld (debug_mark+2),a  
5c9a 18 03			jr .pastdmark  
5c9c ..			.dmark: db "ER1"  
5c9f f1			.pastdmark: pop af  
5ca0			endm  
# End of macro DMARK
5ca0					CALLMONITOR 
5ca0 cd aa fd			call debug_vector  
5ca3				endm  
# End of macro CALLMONITOR
5ca3				endif 
5ca3					FORTH_DSP_POP 
5ca3 cd b3 22			call macro_forth_dsp_pop 
5ca6				endm 
# End of macro FORTH_DSP_POP
5ca6			 
5ca6			;		pop hl 
5ca6			 
5ca6 cd 92 06				call storage_erase 
5ca9				       NEXTW 
5ca9 cd a7 fd			call parse_vector 
5cac c3 e2 23			jp macro_next 
5caf				endm 
# End of macro NEXTW
5caf			 
5caf			.OPEN: 
5caf				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
5caf 6b				db WORD_SYS_CORE+87             
5cb0 45 5d			dw .READ            
5cb2 05				db 4 + 1 
5cb3 .. 00			db "OPEN",0              
5cb8				endm 
# End of macro CWHEAD
5cb8			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
5cb8			; | | e.g. 
5cb8			; | | $01 OPEN $01 DO $01 READ . LOOP 
5cb8			; | | 
5cb8			; | | Will return with 255 blocks if the file does not exist 
5cb8			; | | > [!NOTE] 
5cb8			; | | > Compatible with PicoSPINet  
5cb8			 
5cb8					if DEBUG_FORTH_WORDS_KEY 
5cb8						DMARK "OPN" 
5cb8 f5				push af  
5cb9 3a cd 5c			ld a, (.dmark)  
5cbc 32 9d fd			ld (debug_mark),a  
5cbf 3a ce 5c			ld a, (.dmark+1)  
5cc2 32 9e fd			ld (debug_mark+1),a  
5cc5 3a cf 5c			ld a, (.dmark+2)  
5cc8 32 9f fd			ld (debug_mark+2),a  
5ccb 18 03			jr .pastdmark  
5ccd ..			.dmark: db "OPN"  
5cd0 f1			.pastdmark: pop af  
5cd1			endm  
# End of macro DMARK
5cd1						CALLMONITOR 
5cd1 cd aa fd			call debug_vector  
5cd4				endm  
# End of macro CALLMONITOR
5cd4					endif 
5cd4					; TODO handle multiple file opens 
5cd4			 
5cd4 3e 01			       	ld a, 1 
5cd6 32 9c f9				ld (store_openext), a 
5cd9			 
5cd9					; get max extents for this file 
5cd9				 
5cd9								 
5cd9					FORTH_DSP_VALUEHL 
5cd9 cd fb 21			call macro_dsp_valuehl 
5cdc				endm 
# End of macro FORTH_DSP_VALUEHL
5cdc			 
5cdc 65					ld h, l 
5cdd 2e 00				ld l, 0 
5cdf			 
5cdf					; store file id 
5cdf			 
5cdf 7c					ld a, h 
5ce0 32 99 f9				ld (store_filecache), a 
5ce3			 
5ce3				if DEBUG_STORESE 
5ce3					DMARK "OPN" 
5ce3 f5				push af  
5ce4 3a f8 5c			ld a, (.dmark)  
5ce7 32 9d fd			ld (debug_mark),a  
5cea 3a f9 5c			ld a, (.dmark+1)  
5ced 32 9e fd			ld (debug_mark+1),a  
5cf0 3a fa 5c			ld a, (.dmark+2)  
5cf3 32 9f fd			ld (debug_mark+2),a  
5cf6 18 03			jr .pastdmark  
5cf8 ..			.dmark: db "OPN"  
5cfb f1			.pastdmark: pop af  
5cfc			endm  
# End of macro DMARK
5cfc					CALLMONITOR 
5cfc cd aa fd			call debug_vector  
5cff				endm  
# End of macro CALLMONITOR
5cff				endif 
5cff			;		push hl 
5cff					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
5cff cd b3 22			call macro_forth_dsp_pop 
5d02				endm 
# End of macro FORTH_DSP_POP
5d02			;		pop hl 
5d02						 
5d02 11 ac f9				ld de, store_page      ; get block zero of file 
5d05 cd a7 09				call storage_read 
5d08 cd d5 0f			call ishlzero 
5d0b 20 04			jr nz, .opfound 
5d0d			 
5d0d				; file does not exist so indicate with 255 extents in use 
5d0d			 
5d0d 3e ff			ld a, 255 
5d0f 18 28			jr .skipopeneof 
5d11			 
5d11			 
5d11			.opfound: 
5d11			 
5d11			 
5d11 3a ae f9				ld a, (store_page+2)    ; max extents for this file 
5d14 32 9b f9				ld  (store_openmaxext), a   ; get our limit and push 
5d17					 
5d17				if DEBUG_STORESE 
5d17					DMARK "OPx" 
5d17 f5				push af  
5d18 3a 2c 5d			ld a, (.dmark)  
5d1b 32 9d fd			ld (debug_mark),a  
5d1e 3a 2d 5d			ld a, (.dmark+1)  
5d21 32 9e fd			ld (debug_mark+1),a  
5d24 3a 2e 5d			ld a, (.dmark+2)  
5d27 32 9f fd			ld (debug_mark+2),a  
5d2a 18 03			jr .pastdmark  
5d2c ..			.dmark: db "OPx"  
5d2f f1			.pastdmark: pop af  
5d30			endm  
# End of macro DMARK
5d30					CALLMONITOR 
5d30 cd aa fd			call debug_vector  
5d33				endm  
# End of macro CALLMONITOR
5d33				endif 
5d33			;		cp 0 
5d33 b7					or a 
5d34 20 03				jr nz, .skipopeneof 
5d36					; have opened an empty file 
5d36					 
5d36 32 9c f9				ld (store_openext), a 
5d39			 
5d39			.skipopeneof: 
5d39			 
5d39 6f					ld l, a 
5d3a 26 00				ld h, 0 
5d3c cd ff 1f				call forth_push_numhl 
5d3f			 
5d3f			 
5d3f				       NEXTW 
5d3f cd a7 fd			call parse_vector 
5d42 c3 e2 23			jp macro_next 
5d45				endm 
# End of macro NEXTW
5d45			.READ: 
5d45				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
5d45 6c				db WORD_SYS_CORE+88             
5d46 74 5e			dw .EOF            
5d48 05				db 4 + 1 
5d49 .. 00			db "READ",0              
5d4e				endm 
# End of macro CWHEAD
5d4e			; | READ ( -- n  )  Reads next page of current file id and push to stack | DONE 
5d4e			; | | e.g. 
5d4e			; | | $01 OPEN $01 DO READ . LOOP 
5d4e			; | | 
5d4e			; | | As this word only reads one 64 byte block in at a time, if the APPEND word has created extra blocks for the excess, this READ 
5d4e			; | | word is unaware so the long string needs to be joined if the string is a full. A single block read might be what you want, 
5d4e			; | | but if not then writing a word to join blocks will be required. The upshot is a full string will be 62 bytes as the first 
5d4e			; | | two bytes contain the file id and extent. 
5d4e			; | |  
5d4e			; | | Note: There is a flag that enables/disables long block reads called 'store_longread' and a poke of a non-zero value will 
5d4e			; | | enable the code to automatically read futher blocks if full. It is BUGGY so don't use for now. 
5d4e			; | | > [!NOTE] 
5d4e			; | | > Compatible with PicoSPINet  
5d4e			 
5d4e					if DEBUG_FORTH_WORDS_KEY 
5d4e						DMARK "REA" 
5d4e f5				push af  
5d4f 3a 63 5d			ld a, (.dmark)  
5d52 32 9d fd			ld (debug_mark),a  
5d55 3a 64 5d			ld a, (.dmark+1)  
5d58 32 9e fd			ld (debug_mark+1),a  
5d5b 3a 65 5d			ld a, (.dmark+2)  
5d5e 32 9f fd			ld (debug_mark+2),a  
5d61 18 03			jr .pastdmark  
5d63 ..			.dmark: db "REA"  
5d66 f1			.pastdmark: pop af  
5d67			endm  
# End of macro DMARK
5d67						CALLMONITOR 
5d67 cd aa fd			call debug_vector  
5d6a				endm  
# End of macro CALLMONITOR
5d6a					endif 
5d6a					; store_openext use it. If zero it is EOF 
5d6a			 
5d6a					; read block from current stream id 
5d6a					; if the block does not contain zero term keep reading blocks until zero found 
5d6a					; push the block to stack 
5d6a					; save the block id to stream 
5d6a			 
5d6a			 
5d6a cd a4 5e				call .testeof 
5d6d 3e 01				ld a, 1 
5d6f bd					cp l 
5d70 ca 4d 5e				jp z, .ateof 
5d73			 
5d73			 
5d73			;		FORTH_DSP_VALUEHL 
5d73			 
5d73			;		push hl 
5d73			 
5d73			;	if DEBUG_STORESE 
5d73			;		DMARK "REA" 
5d73			;		CALLMONITOR 
5d73			;	endif 
5d73			;		FORTH_DSP_POP 
5d73			 
5d73			;		pop hl 
5d73				 
5d73 3a 99 f9				ld a, (store_filecache) 
5d76 67					ld h,a 
5d77			 
5d77 3a 9c f9				ld a, (store_openext) 
5d7a 6f					ld l, a 
5d7b					 
5d7b			;		cp 0 
5d7b b7					or a 
5d7c ca 4d 5e				jp z, .ateof     ; dont read past eof 
5d7f			 
5d7f cd 84 0c				call storage_clear_page 
5d82			 
5d82 11 ac f9				ld de, store_page 
5d85				if DEBUG_STORESE 
5d85					DMARK "RE1" 
5d85 f5				push af  
5d86 3a 9a 5d			ld a, (.dmark)  
5d89 32 9d fd			ld (debug_mark),a  
5d8c 3a 9b 5d			ld a, (.dmark+1)  
5d8f 32 9e fd			ld (debug_mark+1),a  
5d92 3a 9c 5d			ld a, (.dmark+2)  
5d95 32 9f fd			ld (debug_mark+2),a  
5d98 18 03			jr .pastdmark  
5d9a ..			.dmark: db "RE1"  
5d9d f1			.pastdmark: pop af  
5d9e			endm  
# End of macro DMARK
5d9e					CALLMONITOR 
5d9e cd aa fd			call debug_vector  
5da1				endm  
# End of macro CALLMONITOR
5da1				endif 
5da1 cd a7 09				call storage_read 
5da4			 
5da4				if DEBUG_STORESE 
5da4					DMARK "RE2" 
5da4 f5				push af  
5da5 3a b9 5d			ld a, (.dmark)  
5da8 32 9d fd			ld (debug_mark),a  
5dab 3a ba 5d			ld a, (.dmark+1)  
5dae 32 9e fd			ld (debug_mark+1),a  
5db1 3a bb 5d			ld a, (.dmark+2)  
5db4 32 9f fd			ld (debug_mark+2),a  
5db7 18 03			jr .pastdmark  
5db9 ..			.dmark: db "RE2"  
5dbc f1			.pastdmark: pop af  
5dbd			endm  
# End of macro DMARK
5dbd					CALLMONITOR 
5dbd cd aa fd			call debug_vector  
5dc0				endm  
# End of macro CALLMONITOR
5dc0				endif 
5dc0 cd d5 0f			call ishlzero 
5dc3			;	ld a, l 
5dc3			;	add h 
5dc3			;	cp 0 
5dc3 ca 4d 5e			jp z, .readeof 
5dc6			 
5dc6				; not eof so hl should point to data to push to stack 
5dc6			 
5dc6				if DEBUG_STORESE 
5dc6					DMARK "RE3" 
5dc6 f5				push af  
5dc7 3a db 5d			ld a, (.dmark)  
5dca 32 9d fd			ld (debug_mark),a  
5dcd 3a dc 5d			ld a, (.dmark+1)  
5dd0 32 9e fd			ld (debug_mark+1),a  
5dd3 3a dd 5d			ld a, (.dmark+2)  
5dd6 32 9f fd			ld (debug_mark+2),a  
5dd9 18 03			jr .pastdmark  
5ddb ..			.dmark: db "RE3"  
5dde f1			.pastdmark: pop af  
5ddf			endm  
# End of macro DMARK
5ddf					CALLMONITOR 
5ddf cd aa fd			call debug_vector  
5de2				endm  
# End of macro CALLMONITOR
5de2				endif 
5de2 cd 69 20			call forth_push_str 
5de5			 
5de5				if DEBUG_STORESE 
5de5					DMARK "RE4" 
5de5 f5				push af  
5de6 3a fa 5d			ld a, (.dmark)  
5de9 32 9d fd			ld (debug_mark),a  
5dec 3a fb 5d			ld a, (.dmark+1)  
5def 32 9e fd			ld (debug_mark+1),a  
5df2 3a fc 5d			ld a, (.dmark+2)  
5df5 32 9f fd			ld (debug_mark+2),a  
5df8 18 03			jr .pastdmark  
5dfa ..			.dmark: db "RE4"  
5dfd f1			.pastdmark: pop af  
5dfe			endm  
# End of macro DMARK
5dfe					CALLMONITOR 
5dfe cd aa fd			call debug_vector  
5e01				endm  
# End of macro CALLMONITOR
5e01				endif 
5e01				; get next block  or mark as eof 
5e01			 
5e01 3a 9b f9			ld a, (store_openmaxext)   ; get our limit 
5e04 4f				ld c, a	 
5e05 3a 9c f9			ld a, (store_openext) 
5e08			 
5e08				if DEBUG_STORESE 
5e08					DMARK "RE5" 
5e08 f5				push af  
5e09 3a 1d 5e			ld a, (.dmark)  
5e0c 32 9d fd			ld (debug_mark),a  
5e0f 3a 1e 5e			ld a, (.dmark+1)  
5e12 32 9e fd			ld (debug_mark+1),a  
5e15 3a 1f 5e			ld a, (.dmark+2)  
5e18 32 9f fd			ld (debug_mark+2),a  
5e1b 18 03			jr .pastdmark  
5e1d ..			.dmark: db "RE5"  
5e20 f1			.pastdmark: pop af  
5e21			endm  
# End of macro DMARK
5e21					CALLMONITOR 
5e21 cd aa fd			call debug_vector  
5e24				endm  
# End of macro CALLMONITOR
5e24				endif 
5e24 b9				cp c 
5e25 28 26			jr z, .readeof     ; at last extent 
5e27			 
5e27 3c					inc a 
5e28 32 9c f9				ld (store_openext), a 
5e2b			 
5e2b				if DEBUG_STORESE 
5e2b					DMARK "RE6" 
5e2b f5				push af  
5e2c 3a 40 5e			ld a, (.dmark)  
5e2f 32 9d fd			ld (debug_mark),a  
5e32 3a 41 5e			ld a, (.dmark+1)  
5e35 32 9e fd			ld (debug_mark+1),a  
5e38 3a 42 5e			ld a, (.dmark+2)  
5e3b 32 9f fd			ld (debug_mark+2),a  
5e3e 18 03			jr .pastdmark  
5e40 ..			.dmark: db "RE6"  
5e43 f1			.pastdmark: pop af  
5e44			endm  
# End of macro DMARK
5e44					CALLMONITOR 
5e44 cd aa fd			call debug_vector  
5e47				endm  
# End of macro CALLMONITOR
5e47				endif 
5e47			 
5e47			 
5e47				       NEXTW 
5e47 cd a7 fd			call parse_vector 
5e4a c3 e2 23			jp macro_next 
5e4d				endm 
# End of macro NEXTW
5e4d			.ateof: 
5e4d				;	ld hl, .showeof 
5e4d				;	call forth_push_str 
5e4d 3e 00		.readeof:	ld a, 0 
5e4f 32 9c f9				ld (store_openext), a 
5e52			 
5e52					 
5e52				if DEBUG_STORESE 
5e52					DMARK "REF" 
5e52 f5				push af  
5e53 3a 67 5e			ld a, (.dmark)  
5e56 32 9d fd			ld (debug_mark),a  
5e59 3a 68 5e			ld a, (.dmark+1)  
5e5c 32 9e fd			ld (debug_mark+1),a  
5e5f 3a 69 5e			ld a, (.dmark+2)  
5e62 32 9f fd			ld (debug_mark+2),a  
5e65 18 03			jr .pastdmark  
5e67 ..			.dmark: db "REF"  
5e6a f1			.pastdmark: pop af  
5e6b			endm  
# End of macro DMARK
5e6b					CALLMONITOR 
5e6b cd aa fd			call debug_vector  
5e6e				endm  
# End of macro CALLMONITOR
5e6e				endif 
5e6e				       NEXTW 
5e6e cd a7 fd			call parse_vector 
5e71 c3 e2 23			jp macro_next 
5e74				endm 
# End of macro NEXTW
5e74			 
5e74			;.showeof:   db "eof", 0 
5e74			 
5e74			 
5e74			.EOF: 
5e74				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
5e74 6d				db WORD_SYS_CORE+89             
5e75 b7 5e			dw .FORMAT            
5e77 04				db 3 + 1 
5e78 .. 00			db "EOF",0              
5e7c				endm 
# End of macro CWHEAD
5e7c			; | EOF ( -- u )  Returns EOF logical state of current open file id | DONE 
5e7c			; | | e.g. 
5e7c			; | | $01 OPEN REPEAT READ EOF $00 IF LOOP 
5e7c			; | | > [!NOTE] 
5e7c			; | | > Compatible with PicoSPINet  
5e7c					; TODO if current block id for stream is zero then push true else false 
5e7c			 
5e7c					if DEBUG_FORTH_WORDS_KEY 
5e7c						DMARK "EOF" 
5e7c f5				push af  
5e7d 3a 91 5e			ld a, (.dmark)  
5e80 32 9d fd			ld (debug_mark),a  
5e83 3a 92 5e			ld a, (.dmark+1)  
5e86 32 9e fd			ld (debug_mark+1),a  
5e89 3a 93 5e			ld a, (.dmark+2)  
5e8c 32 9f fd			ld (debug_mark+2),a  
5e8f 18 03			jr .pastdmark  
5e91 ..			.dmark: db "EOF"  
5e94 f1			.pastdmark: pop af  
5e95			endm  
# End of macro DMARK
5e95						CALLMONITOR 
5e95 cd aa fd			call debug_vector  
5e98				endm  
# End of macro CALLMONITOR
5e98					endif 
5e98			 
5e98					; TODO handlue multiple file streams 
5e98			 
5e98			;		FORTH_iDSP_POP     ; for now just get rid of stream id 
5e98 cd a4 5e				call .testeof 
5e9b cd ff 1f				call forth_push_numhl 
5e9e			 
5e9e			 
5e9e				       NEXTW 
5e9e cd a7 fd			call parse_vector 
5ea1 c3 e2 23			jp macro_next 
5ea4				endm 
# End of macro NEXTW
5ea4			 
5ea4			.testeof: 
5ea4 2e 01				ld l, 1 
5ea6 3a 9b f9				ld a, (store_openmaxext) 
5ea9			;		cp 0 
5ea9 b7					or a 
5eaa 28 08				jr  z, .eofdone   ; empty file 
5eac 3a 9c f9				ld a, (store_openext) 
5eaf			;		cp 0 
5eaf b7					or a 
5eb0 28 02				jr  z, .eofdone 
5eb2 2e 00				ld l, 0 
5eb4 26 00		.eofdone:	ld h, 0 
5eb6 c9					ret 
5eb7			 
5eb7			 
5eb7			 
5eb7			 
5eb7			.FORMAT: 
5eb7				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
5eb7 6d				db WORD_SYS_CORE+89             
5eb8 0b 5f			dw .LABEL            
5eba 07				db 6 + 1 
5ebb .. 00			db "FORMAT",0              
5ec2				endm 
# End of macro CWHEAD
5ec2			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
5ec2			; | | > [!NOTE] 
5ec2			; | | > Compatible with PicoSPINet  
5ec2					; TODO if current block id for stream is zero then push true else false 
5ec2				 
5ec2				if DEBUG_STORESE 
5ec2					DMARK "FOR" 
5ec2 f5				push af  
5ec3 3a d7 5e			ld a, (.dmark)  
5ec6 32 9d fd			ld (debug_mark),a  
5ec9 3a d8 5e			ld a, (.dmark+1)  
5ecc 32 9e fd			ld (debug_mark+1),a  
5ecf 3a d9 5e			ld a, (.dmark+2)  
5ed2 32 9f fd			ld (debug_mark+2),a  
5ed5 18 03			jr .pastdmark  
5ed7 ..			.dmark: db "FOR"  
5eda f1			.pastdmark: pop af  
5edb			endm  
# End of macro DMARK
5edb					CALLMONITOR 
5edb cd aa fd			call debug_vector  
5ede				endm  
# End of macro CALLMONITOR
5ede				endif 
5ede					; Wipes the bank check flags to cause a reformat on next block 0 read 
5ede			 
5ede 21 01 00				ld hl, 1 
5ee1 3e 00				ld a, 0 
5ee3 cd 65 02				call se_writebyte 
5ee6			 
5ee6				if DEBUG_STORESE 
5ee6					DMARK "FO0" 
5ee6 f5				push af  
5ee7 3a fb 5e			ld a, (.dmark)  
5eea 32 9d fd			ld (debug_mark),a  
5eed 3a fc 5e			ld a, (.dmark+1)  
5ef0 32 9e fd			ld (debug_mark+1),a  
5ef3 3a fd 5e			ld a, (.dmark+2)  
5ef6 32 9f fd			ld (debug_mark+2),a  
5ef9 18 03			jr .pastdmark  
5efb ..			.dmark: db "FO0"  
5efe f1			.pastdmark: pop af  
5eff			endm  
# End of macro DMARK
5eff					CALLMONITOR 
5eff cd aa fd			call debug_vector  
5f02				endm  
# End of macro CALLMONITOR
5f02				endif 
5f02					; force bank init 
5f02			 
5f02 cd 05 05				call storage_get_block_0 
5f05					 
5f05				       NEXTW 
5f05 cd a7 fd			call parse_vector 
5f08 c3 e2 23			jp macro_next 
5f0b				endm 
# End of macro NEXTW
5f0b			.LABEL: 
5f0b				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
5f0b 6d				db WORD_SYS_CORE+89             
5f0c 5c 5f			dw .STOREPAGE            
5f0e 06				db 5 + 1 
5f0f .. 00			db "LABEL",0              
5f15				endm 
# End of macro CWHEAD
5f15			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
5f15			; | | > [!NOTE] 
5f15			; | | > Compatible with PicoSPINet  
5f15					; TODO test to see if bank is selected 
5f15				 
5f15					if DEBUG_FORTH_WORDS_KEY 
5f15						DMARK "LBL" 
5f15 f5				push af  
5f16 3a 2a 5f			ld a, (.dmark)  
5f19 32 9d fd			ld (debug_mark),a  
5f1c 3a 2b 5f			ld a, (.dmark+1)  
5f1f 32 9e fd			ld (debug_mark+1),a  
5f22 3a 2c 5f			ld a, (.dmark+2)  
5f25 32 9f fd			ld (debug_mark+2),a  
5f28 18 03			jr .pastdmark  
5f2a ..			.dmark: db "LBL"  
5f2d f1			.pastdmark: pop af  
5f2e			endm  
# End of macro DMARK
5f2e						CALLMONITOR 
5f2e cd aa fd			call debug_vector  
5f31				endm  
# End of macro CALLMONITOR
5f31					endif 
5f31			;	if DEBUG_STORESE 
5f31			;		DMARK "LBL" 
5f31			;		CALLMONITOR 
5f31			;	endif 
5f31					FORTH_DSP_VALUEHL 
5f31 cd fb 21			call macro_dsp_valuehl 
5f34				endm 
# End of macro FORTH_DSP_VALUEHL
5f34					;v5FORTH_DSP_VALUE 
5f34					 
5f34			;		push hl 
5f34					FORTH_DSP_POP 
5f34 cd b3 22			call macro_forth_dsp_pop 
5f37				endm 
# End of macro FORTH_DSP_POP
5f37			;		pop hl 
5f37			 
5f37			;v5		inc hl   ; move past the type marker 
5f37			 
5f37				if DEBUG_STORESE 
5f37					DMARK "LBl" 
5f37 f5				push af  
5f38 3a 4c 5f			ld a, (.dmark)  
5f3b 32 9d fd			ld (debug_mark),a  
5f3e 3a 4d 5f			ld a, (.dmark+1)  
5f41 32 9e fd			ld (debug_mark+1),a  
5f44 3a 4e 5f			ld a, (.dmark+2)  
5f47 32 9f fd			ld (debug_mark+2),a  
5f4a 18 03			jr .pastdmark  
5f4c ..			.dmark: db "LBl"  
5f4f f1			.pastdmark: pop af  
5f50			endm  
# End of macro DMARK
5f50					CALLMONITOR 
5f50 cd aa fd			call debug_vector  
5f53				endm  
# End of macro CALLMONITOR
5f53				endif 
5f53 cd 25 06				call storage_label 
5f56			 
5f56				       NEXTW 
5f56 cd a7 fd			call parse_vector 
5f59 c3 e2 23			jp macro_next 
5f5c				endm 
# End of macro NEXTW
5f5c			.STOREPAGE: 
5f5c				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
5f5c 6d				db WORD_SYS_CORE+89             
5f5d 92 5f			dw .LABELS            
5f5f 0a				db 9 + 1 
5f60 .. 00			db "STOREPAGE",0              
5f6a				endm 
# End of macro CWHEAD
5f6a			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
5f6a			; | | > [!NOTE] 
5f6a			; | | > Compatible with PicoSPINet  
5f6a					; TODO test to see if bank is selected 
5f6a				 
5f6a					if DEBUG_FORTH_WORDS_KEY 
5f6a						DMARK "STP" 
5f6a f5				push af  
5f6b 3a 7f 5f			ld a, (.dmark)  
5f6e 32 9d fd			ld (debug_mark),a  
5f71 3a 80 5f			ld a, (.dmark+1)  
5f74 32 9e fd			ld (debug_mark+1),a  
5f77 3a 81 5f			ld a, (.dmark+2)  
5f7a 32 9f fd			ld (debug_mark+2),a  
5f7d 18 03			jr .pastdmark  
5f7f ..			.dmark: db "STP"  
5f82 f1			.pastdmark: pop af  
5f83			endm  
# End of macro DMARK
5f83						CALLMONITOR 
5f83 cd aa fd			call debug_vector  
5f86				endm  
# End of macro CALLMONITOR
5f86					endif 
5f86			;	if DEBUG_STORESE 
5f86			;		DMARK "STP" 
5f86			;		CALLMONITOR 
5f86			;	endif 
5f86			 
5f86 21 ac f9			ld hl, store_page 
5f89 cd ff 1f			call forth_push_numhl 
5f8c			 
5f8c			 
5f8c				       NEXTW 
5f8c cd a7 fd			call parse_vector 
5f8f c3 e2 23			jp macro_next 
5f92				endm 
# End of macro NEXTW
5f92			.LABELS: 
5f92				CWHEAD .SCONST1 89 "LABELS" 6 WORD_FLAG_CODE 
5f92 6d				db WORD_SYS_CORE+89             
5f93 1f 60			dw .SCONST1            
5f95 07				db 6 + 1 
5f96 .. 00			db "LABELS",0              
5f9d				endm 
# End of macro CWHEAD
5f9d			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | DONE 
5f9d			; | | > [!CAUTION] 
5f9d			; | | > *NOT* Compatible with PicoSPINet  
5f9d					;  
5f9d			 
5f9d					; save the current device selected to restore afterwards 
5f9d				 
5f9d 3a 92 f9				ld a, (spi_device) 
5fa0 f5					push af 
5fa1			 
5fa1			 
5fa1					; run through each of the banks 
5fa1			 
5fa1 21 01 00				ld hl, 1 
5fa4 cd ff 1f				call forth_push_numhl 
5fa7 3e ff				ld a, SPI_CE_HIGH 
5fa9 cb 87				res SPI_CE0, a 
5fab 32 92 f9				ld (spi_device), a 
5fae cd 05 05				call storage_get_block_0 
5fb1 21 af f9				ld hl, store_page+3 
5fb4 cd 69 20				call forth_push_str 
5fb7			 
5fb7					 
5fb7 21 02 00				ld hl, 2 
5fba cd ff 1f				call forth_push_numhl 
5fbd 3e ff				ld a, SPI_CE_HIGH 
5fbf cb 8f				res SPI_CE1, a 
5fc1 32 92 f9				ld (spi_device), a 
5fc4 cd 05 05				call storage_get_block_0 
5fc7 21 af f9				ld hl, store_page+3 
5fca cd 69 20				call forth_push_str 
5fcd			 
5fcd					 
5fcd 21 03 00				ld hl, 3 
5fd0 cd ff 1f				call forth_push_numhl 
5fd3 3e ff				ld a, SPI_CE_HIGH 
5fd5 cb 97				res SPI_CE2, a 
5fd7 32 92 f9				ld (spi_device), a 
5fda cd 05 05				call storage_get_block_0 
5fdd 21 af f9				ld hl, store_page+3 
5fe0 cd 69 20				call forth_push_str 
5fe3			 
5fe3			 
5fe3 21 04 00				ld hl, 4 
5fe6 cd ff 1f				call forth_push_numhl 
5fe9 3e ff				ld a, SPI_CE_HIGH 
5feb cb 9f				res SPI_CE3, a 
5fed 32 92 f9				ld (spi_device), a 
5ff0 cd 05 05				call storage_get_block_0 
5ff3 21 af f9				ld hl, store_page+3 
5ff6 cd 69 20				call forth_push_str 
5ff9			 
5ff9					 
5ff9			 
5ff9 21 05 00				ld hl, 5 
5ffc cd ff 1f				call forth_push_numhl 
5fff 3e ff				ld a, SPI_CE_HIGH 
6001 cb a7				res SPI_CE4, a 
6003 32 92 f9				ld (spi_device), a 
6006 cd 05 05				call storage_get_block_0 
6009 21 af f9				ld hl, store_page+3 
600c cd 69 20				call forth_push_str 
600f			 
600f					 
600f					; push fixed count of storage devices (on board) for now 
600f			 
600f 21 05 00				ld hl, 5 
6012 cd ff 1f				call forth_push_numhl 
6015			 
6015					; restore selected device  
6015				 
6015 f1					pop af 
6016 32 92 f9				ld (spi_device), a 
6019			 
6019				       NEXTW 
6019 cd a7 fd			call parse_vector 
601c c3 e2 23			jp macro_next 
601f				endm 
# End of macro NEXTW
601f			 
601f			.SCONST1: 
601f				CWHEAD .SCONST2 89 "FILEID" 6 WORD_FLAG_CODE 
601f 6d				db WORD_SYS_CORE+89             
6020 39 60			dw .SCONST2            
6022 07				db 6 + 1 
6023 .. 00			db "FILEID",0              
602a				endm 
# End of macro CWHEAD
602a			; | FILEID (  -- u1  )  Pushes currently open file ID to stack | DONE 
602a			; | | > [!NOTE] 
602a			; | | > Compatible with PicoSPINet  
602a 3a 99 f9				ld a, (store_filecache) 
602d 26 00				ld h, 0 
602f 6f					ld l, a 
6030 cd ff 1f				call forth_push_numhl 
6033					NEXTW 
6033 cd a7 fd			call parse_vector 
6036 c3 e2 23			jp macro_next 
6039				endm 
# End of macro NEXTW
6039			.SCONST2: 
6039				CWHEAD .SCONST3 89 "FILEEXT" 7 WORD_FLAG_CODE 
6039 6d				db WORD_SYS_CORE+89             
603a 54 60			dw .SCONST3            
603c 08				db 7 + 1 
603d .. 00			db "FILEEXT",0              
6045				endm 
# End of macro CWHEAD
6045			; | FILEEXT (  -- u1  )  Pushes the currently read file extent of the file to stack | DONE 
6045			; | | > [!NOTE] 
6045			; | | > Compatible with PicoSPINet  
6045 3a 9c f9				ld a, (store_openext) 
6048 26 00				ld h, 0 
604a 6f					ld l, a 
604b cd ff 1f				call forth_push_numhl 
604e					NEXTW 
604e cd a7 fd			call parse_vector 
6051 c3 e2 23			jp macro_next 
6054				endm 
# End of macro NEXTW
6054			.SCONST3: 
6054				CWHEAD .SCONST4 89 "FILEMAX" 7 WORD_FLAG_CODE 
6054 6d				db WORD_SYS_CORE+89             
6055 6f 60			dw .SCONST4            
6057 08				db 7 + 1 
6058 .. 00			db "FILEMAX",0              
6060				endm 
# End of macro CWHEAD
6060			; | FILEMAXEXT (  -- u1  )  Pushes the maximum file extent of the currenlty open file to stack | DONE 
6060			; | | > [!NOTE] 
6060			; | | > Compatible with PicoSPINet  
6060 3a 9b f9				ld a, (store_openmaxext) 
6063 26 00				ld h, 0 
6065 6f					ld l, a 
6066 cd ff 1f				call forth_push_numhl 
6069					NEXTW 
6069 cd a7 fd			call parse_vector 
606c c3 e2 23			jp macro_next 
606f				endm 
# End of macro NEXTW
606f			.SCONST4: 
606f				CWHEAD .SCONST5 89 "FILEADDR" 8 WORD_FLAG_CODE 
606f 6d				db WORD_SYS_CORE+89             
6070 88 60			dw .SCONST5            
6072 09				db 8 + 1 
6073 .. 00			db "FILEADDR",0              
607c				endm 
# End of macro CWHEAD
607c			; | FILEADDR (  -- u1  )  Pushes the address of the block accessed for the currently open file to stack | DONE 
607c			; | | > [!NOTE] 
607c			; | | > Compatible with PicoSPINet  
607c 2a 9d f9				ld hl, (store_openaddr) 
607f cd ff 1f				call forth_push_numhl 
6082					NEXTW 
6082 cd a7 fd			call parse_vector 
6085 c3 e2 23			jp macro_next 
6088				endm 
# End of macro NEXTW
6088			.SCONST5: 
6088				CWHEAD .SCONST6 89 "FILEPAGE" 8 WORD_FLAG_CODE 
6088 6d				db WORD_SYS_CORE+89             
6089 ac 60			dw .SCONST6            
608b 09				db 8 + 1 
608c .. 00			db "FILEPAGE",0              
6095				endm 
# End of macro CWHEAD
6095			; | FILEPAGE (  -- u1  )  Pushes the page id block accessed for the currenlty open file to stack | DONE 
6095			; | | > [!NOTE] 
6095			; | | > Compatible with PicoSPINet  
6095 2a 9d f9				ld hl, (store_openaddr) 
6098 e5					push hl 
6099 c1					pop bc 
609a 16 00				ld d, 0 
609c 1e 40				ld e, STORE_BLOCK_PHY 
609e cd 09 0f				call Div16 
60a1 c5					push bc 
60a2 e1					pop hl 
60a3 cd ff 1f				call forth_push_numhl 
60a6					NEXTW 
60a6 cd a7 fd			call parse_vector 
60a9 c3 e2 23			jp macro_next 
60ac				endm 
# End of macro NEXTW
60ac			.SCONST6: 
60ac				CWHEAD .ENDSTORAGE 89 "READCONT" 8 WORD_FLAG_CODE 
60ac 6d				db WORD_SYS_CORE+89             
60ad c8 60			dw .ENDSTORAGE            
60af 09				db 8 + 1 
60b0 .. 00			db "READCONT",0              
60b9				endm 
# End of macro CWHEAD
60b9			; | READCONT (  -- u1  )  Pushes the READ continuation flag to stack | DONE 
60b9			; | | If the most recent READ results in a full buffer load then this flag is set and will indicate that 
60b9			; | | a further read should, if applicable, be CONCAT to the previous read. 
60b9			; | | > [!NOTE] 
60b9			; | | > Compatible with PicoSPINet  
60b9 3a 9f f9				ld a, (store_readcont) 
60bc 26 00				ld h, 0 
60be 6f					ld l, a 
60bf cd ff 1f				call forth_push_numhl 
60c2					NEXTW 
60c2 cd a7 fd			call parse_vector 
60c5 c3 e2 23			jp macro_next 
60c8				endm 
# End of macro NEXTW
60c8			.ENDSTORAGE: 
60c8			; eof 
# End of file forth_words_storage.asm
60c8			endif 
60c8				include "forth_words_device.asm" 
60c8			; Device related words 
60c8			 
60c8			; | ## Device Words 
60c8			 
60c8			;if SOUND_ENABLE 
60c8			;.NOTE: 
60c8			;	CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
60c8			;; NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds  TODO 
60c8			;		if DEBUG_FORTH_WORDS_KEY 
60c8			;			DMARK "NTE" 
60c8			;			CALLMONITOR 
60c8			;		endif 
60c8			; 
60c8			;	 
60c8			; 
60c8			;		NEXTW 
60c8			;.AFTERSOUND: 
60c8			;endif 
60c8			 
60c8			 
60c8			USE_GPIO: equ 0 
60c8			 
60c8			if USE_GPIO 
60c8			.GP1: 
60c8				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
60c8			;  IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result   
60c8					NEXTW 
60c8			.GP2: 
60c8				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
60c8			;  IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2   
60c8			 
60c8					NEXTW 
60c8			 
60c8			.GP3: 
60c8				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
60c8			;  IOBYTE ( u1 --  )    Perform a GPIO write of byte u1   
60c8			 
60c8					NEXTW 
60c8			 
60c8			.GP4: 
60c8				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
60c8			;  IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin   
60c8			 
60c8					NEXTW 
60c8			.SIN: 
60c8			 
60c8			 
60c8			endif 
60c8			 
60c8			 
60c8				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
60c8 33				db WORD_SYS_CORE+31             
60c9 00 61			dw .SOUT            
60cb 03				db 2 + 1 
60cc .. 00			db "IN",0              
60cf				endm 
# End of macro CWHEAD
60cf			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
60cf					if DEBUG_FORTH_WORDS_KEY 
60cf						DMARK "IN." 
60cf f5				push af  
60d0 3a e4 60			ld a, (.dmark)  
60d3 32 9d fd			ld (debug_mark),a  
60d6 3a e5 60			ld a, (.dmark+1)  
60d9 32 9e fd			ld (debug_mark+1),a  
60dc 3a e6 60			ld a, (.dmark+2)  
60df 32 9f fd			ld (debug_mark+2),a  
60e2 18 03			jr .pastdmark  
60e4 ..			.dmark: db "IN."  
60e7 f1			.pastdmark: pop af  
60e8			endm  
# End of macro DMARK
60e8						CALLMONITOR 
60e8 cd aa fd			call debug_vector  
60eb				endm  
# End of macro CALLMONITOR
60eb					endif 
60eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
60eb cd fb 21			call macro_dsp_valuehl 
60ee				endm 
# End of macro FORTH_DSP_VALUEHL
60ee			 
60ee e5					push hl 
60ef			 
60ef					; destroy value TOS 
60ef			 
60ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
60ef cd b3 22			call macro_forth_dsp_pop 
60f2				endm 
# End of macro FORTH_DSP_POP
60f2			 
60f2					; one value on hl get other one back 
60f2			 
60f2 c1					pop bc 
60f3			 
60f3					; do the sub 
60f3			;		ex de, hl 
60f3			 
60f3 ed 68				in l,(c) 
60f5			 
60f5					; save it 
60f5			 
60f5 26 00				ld h,0 
60f7			 
60f7					; TODO push value back onto stack for another op etc 
60f7			 
60f7 cd ff 1f				call forth_push_numhl 
60fa					NEXTW 
60fa cd a7 fd			call parse_vector 
60fd c3 e2 23			jp macro_next 
6100				endm 
# End of macro NEXTW
6100			.SOUT: 
6100				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
6100 34				db WORD_SYS_CORE+32             
6101 56 61			dw .SPIO            
6103 04				db 3 + 1 
6104 .. 00			db "OUT",0              
6108				endm 
# End of macro CWHEAD
6108			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
6108					if DEBUG_FORTH_WORDS_KEY 
6108						DMARK "OUT" 
6108 f5				push af  
6109 3a 1d 61			ld a, (.dmark)  
610c 32 9d fd			ld (debug_mark),a  
610f 3a 1e 61			ld a, (.dmark+1)  
6112 32 9e fd			ld (debug_mark+1),a  
6115 3a 1f 61			ld a, (.dmark+2)  
6118 32 9f fd			ld (debug_mark+2),a  
611b 18 03			jr .pastdmark  
611d ..			.dmark: db "OUT"  
6120 f1			.pastdmark: pop af  
6121			endm  
# End of macro DMARK
6121						CALLMONITOR 
6121 cd aa fd			call debug_vector  
6124				endm  
# End of macro CALLMONITOR
6124					endif 
6124			 
6124					; get port 
6124			 
6124					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6124 cd fb 21			call macro_dsp_valuehl 
6127				endm 
# End of macro FORTH_DSP_VALUEHL
6127			 
6127 e5					push hl 
6128			 
6128					; destroy value TOS 
6128			 
6128					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6128 cd b3 22			call macro_forth_dsp_pop 
612b				endm 
# End of macro FORTH_DSP_POP
612b			 
612b					; get byte to send 
612b			 
612b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
612b cd fb 21			call macro_dsp_valuehl 
612e				endm 
# End of macro FORTH_DSP_VALUEHL
612e			 
612e			;		push hl 
612e			 
612e					; destroy value TOS 
612e			 
612e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
612e cd b3 22			call macro_forth_dsp_pop 
6131				endm 
# End of macro FORTH_DSP_POP
6131			 
6131					; one value on hl get other one back 
6131			 
6131			;		pop hl 
6131			 
6131 c1					pop bc 
6132			 
6132					if DEBUG_FORTH_WORDS 
6132						DMARK "OUT" 
6132 f5				push af  
6133 3a 47 61			ld a, (.dmark)  
6136 32 9d fd			ld (debug_mark),a  
6139 3a 48 61			ld a, (.dmark+1)  
613c 32 9e fd			ld (debug_mark+1),a  
613f 3a 49 61			ld a, (.dmark+2)  
6142 32 9f fd			ld (debug_mark+2),a  
6145 18 03			jr .pastdmark  
6147 ..			.dmark: db "OUT"  
614a f1			.pastdmark: pop af  
614b			endm  
# End of macro DMARK
614b						CALLMONITOR 
614b cd aa fd			call debug_vector  
614e				endm  
# End of macro CALLMONITOR
614e					endif 
614e			 
614e ed 69				out (c), l 
6150			 
6150					NEXTW 
6150 cd a7 fd			call parse_vector 
6153 c3 e2 23			jp macro_next 
6156				endm 
# End of macro NEXTW
6156			 
6156			 
6156			.SPIO: 
6156			 
6156			if STORAGE_SE 
6156				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
6156 51				db WORD_SYS_CORE+61             
6157 6a 61			dw .SPICEH            
6159 07				db 6 + 1 
615a .. 00			db "SPICEL",0              
6161				endm 
# End of macro CWHEAD
6161			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
6161			 
6161 cd 0e 02				call spi_ce_low 
6164			    NEXTW 
6164 cd a7 fd			call parse_vector 
6167 c3 e2 23			jp macro_next 
616a				endm 
# End of macro NEXTW
616a			 
616a			.SPICEH: 
616a				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
616a 51				db WORD_SYS_CORE+61             
616b 7e 61			dw .SPIOb            
616d 07				db 6 + 1 
616e .. 00			db "SPICEH",0              
6175				endm 
# End of macro CWHEAD
6175			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
6175			 
6175 cd fd 01				call spi_ce_high 
6178			    NEXTW 
6178 cd a7 fd			call parse_vector 
617b c3 e2 23			jp macro_next 
617e				endm 
# End of macro NEXTW
617e			 
617e			 
617e			.SPIOb: 
617e			 
617e				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
617e 51				db WORD_SYS_CORE+61             
617f b3 61			dw .SPII            
6181 05				db 4 + 1 
6182 .. 00			db "SPIO",0              
6187				endm 
# End of macro CWHEAD
6187			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
6187			 
6187					if DEBUG_FORTH_WORDS_KEY 
6187						DMARK "SPo" 
6187 f5				push af  
6188 3a 9c 61			ld a, (.dmark)  
618b 32 9d fd			ld (debug_mark),a  
618e 3a 9d 61			ld a, (.dmark+1)  
6191 32 9e fd			ld (debug_mark+1),a  
6194 3a 9e 61			ld a, (.dmark+2)  
6197 32 9f fd			ld (debug_mark+2),a  
619a 18 03			jr .pastdmark  
619c ..			.dmark: db "SPo"  
619f f1			.pastdmark: pop af  
61a0			endm  
# End of macro DMARK
61a0						CALLMONITOR 
61a0 cd aa fd			call debug_vector  
61a3				endm  
# End of macro CALLMONITOR
61a3					endif 
61a3					; get port 
61a3			 
61a3			 
61a3					; get byte to send 
61a3			 
61a3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
61a3 cd fb 21			call macro_dsp_valuehl 
61a6				endm 
# End of macro FORTH_DSP_VALUEHL
61a6			 
61a6			;		push hl    ; u1  
61a6			 
61a6					; destroy value TOS 
61a6			 
61a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
61a6 cd b3 22			call macro_forth_dsp_pop 
61a9				endm 
# End of macro FORTH_DSP_POP
61a9			 
61a9					; one value on hl get other one back 
61a9			 
61a9			;		pop hl   ; u2 - addr 
61a9			 
61a9					; TODO Send SPI byte 
61a9			 
61a9			;		push hl 
61a9			;		call spi_ce_low 
61a9			;		pop hl 
61a9 7d					ld a, l 
61aa cd 0f 01				call spi_send_byte 
61ad			;		call spi_ce_high 
61ad			 
61ad					NEXTW 
61ad cd a7 fd			call parse_vector 
61b0 c3 e2 23			jp macro_next 
61b3				endm 
# End of macro NEXTW
61b3			 
61b3			.SPII: 
61b3				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
61b3 52				db WORD_SYS_CORE+62             
61b4 1f 62			dw .SESEL            
61b6 06				db 5 + 1 
61b7 .. 00			db "SPII",0              
61bc				endm 
# End of macro CWHEAD
61bc			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
61bc					if DEBUG_FORTH_WORDS_KEY 
61bc						DMARK "SPi" 
61bc f5				push af  
61bd 3a d1 61			ld a, (.dmark)  
61c0 32 9d fd			ld (debug_mark),a  
61c3 3a d2 61			ld a, (.dmark+1)  
61c6 32 9e fd			ld (debug_mark+1),a  
61c9 3a d3 61			ld a, (.dmark+2)  
61cc 32 9f fd			ld (debug_mark+2),a  
61cf 18 03			jr .pastdmark  
61d1 ..			.dmark: db "SPi"  
61d4 f1			.pastdmark: pop af  
61d5			endm  
# End of macro DMARK
61d5						CALLMONITOR 
61d5 cd aa fd			call debug_vector  
61d8				endm  
# End of macro CALLMONITOR
61d8					endif 
61d8			 
61d8					; TODO Get SPI byte 
61d8			 
61d8 cd 33 01				call spi_read_byte 
61db			 
61db					if DEBUG_FORTH_WORDS 
61db						DMARK "Si2" 
61db f5				push af  
61dc 3a f0 61			ld a, (.dmark)  
61df 32 9d fd			ld (debug_mark),a  
61e2 3a f1 61			ld a, (.dmark+1)  
61e5 32 9e fd			ld (debug_mark+1),a  
61e8 3a f2 61			ld a, (.dmark+2)  
61eb 32 9f fd			ld (debug_mark+2),a  
61ee 18 03			jr .pastdmark  
61f0 ..			.dmark: db "Si2"  
61f3 f1			.pastdmark: pop af  
61f4			endm  
# End of macro DMARK
61f4						CALLMONITOR 
61f4 cd aa fd			call debug_vector  
61f7				endm  
# End of macro CALLMONITOR
61f7					endif 
61f7 26 00				ld h, 0 
61f9 6f					ld l, a 
61fa					if DEBUG_FORTH_WORDS 
61fa						DMARK "Si3" 
61fa f5				push af  
61fb 3a 0f 62			ld a, (.dmark)  
61fe 32 9d fd			ld (debug_mark),a  
6201 3a 10 62			ld a, (.dmark+1)  
6204 32 9e fd			ld (debug_mark+1),a  
6207 3a 11 62			ld a, (.dmark+2)  
620a 32 9f fd			ld (debug_mark+2),a  
620d 18 03			jr .pastdmark  
620f ..			.dmark: db "Si3"  
6212 f1			.pastdmark: pop af  
6213			endm  
# End of macro DMARK
6213						CALLMONITOR 
6213 cd aa fd			call debug_vector  
6216				endm  
# End of macro CALLMONITOR
6216					endif 
6216 cd ff 1f				call forth_push_numhl 
6219			 
6219					NEXTW 
6219 cd a7 fd			call parse_vector 
621c c3 e2 23			jp macro_next 
621f				endm 
# End of macro NEXTW
621f			 
621f			 
621f			 
621f			.SESEL: 
621f				CWHEAD .SESELS 82 "BANK?" 5 WORD_FLAG_CODE 
621f 66				db WORD_SYS_CORE+82             
6220 56 62			dw .SESELS            
6222 06				db 5 + 1 
6223 .. 00			db "BANK?",0              
6229				endm 
# End of macro CWHEAD
6229			; | BANK? ( -- u ) Reports on the serial EEPROM Bank Device at bank address u1 1-5.  | DONE 
6229			; | | Zero is disabled storage. 
6229					if DEBUG_FORTH_WORDS_KEY 
6229						DMARK "BN?" 
6229 f5				push af  
622a 3a 3e 62			ld a, (.dmark)  
622d 32 9d fd			ld (debug_mark),a  
6230 3a 3f 62			ld a, (.dmark+1)  
6233 32 9e fd			ld (debug_mark+1),a  
6236 3a 40 62			ld a, (.dmark+2)  
6239 32 9f fd			ld (debug_mark+2),a  
623c 18 03			jr .pastdmark  
623e ..			.dmark: db "BN?"  
6241 f1			.pastdmark: pop af  
6242			endm  
# End of macro DMARK
6242						CALLMONITOR 
6242 cd aa fd			call debug_vector  
6245				endm  
# End of macro CALLMONITOR
6245					endif 
6245 3a 91 f9				ld a, (spi_device_id) 
6248 d6 30				sub '0' 
624a 26 00				ld h, 0 
624c 6f					ld l, a 
624d cd ff 1f				call forth_push_numhl 
6250					NEXTW 
6250 cd a7 fd			call parse_vector 
6253 c3 e2 23			jp macro_next 
6256				endm 
# End of macro NEXTW
6256			.SESELS: 
6256				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
6256 66				db WORD_SYS_CORE+82             
6257 01 63			dw .CARTDEV            
6259 05				db 4 + 1 
625a .. 00			db "BANK",0              
625f				endm 
# End of macro CWHEAD
625f			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV).  | DONE 
625f			; | | Set to zero to disable storage. 
625f					if DEBUG_FORTH_WORDS_KEY 
625f						DMARK "BNK" 
625f f5				push af  
6260 3a 74 62			ld a, (.dmark)  
6263 32 9d fd			ld (debug_mark),a  
6266 3a 75 62			ld a, (.dmark+1)  
6269 32 9e fd			ld (debug_mark+1),a  
626c 3a 76 62			ld a, (.dmark+2)  
626f 32 9f fd			ld (debug_mark+2),a  
6272 18 03			jr .pastdmark  
6274 ..			.dmark: db "BNK"  
6277 f1			.pastdmark: pop af  
6278			endm  
# End of macro DMARK
6278						CALLMONITOR 
6278 cd aa fd			call debug_vector  
627b				endm  
# End of macro CALLMONITOR
627b					endif 
627b			 
627b 3e ff				ld a, 255 
627d 32 95 f9				ld (spi_cartdev), a 
6280			 
6280					; get bank 
6280			 
6280					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
6280 cd fb 21			call macro_dsp_valuehl 
6283				endm 
# End of macro FORTH_DSP_VALUEHL
6283			 
6283			;		push hl 
6283			 
6283					; destroy value TOS 
6283			 
6283					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6283 cd b3 22			call macro_forth_dsp_pop 
6286				endm 
# End of macro FORTH_DSP_POP
6286			 
6286					; one value on hl get other one back 
6286			 
6286			;		pop hl 
6286			 
6286			 
6286 0e ff				ld c, SPI_CE_HIGH 
6288 06 30				ld b, '0'    ; human readable bank number 
628a			 
628a 7d					ld a, l 
628b			 
628b					if DEBUG_FORTH_WORDS 
628b						DMARK "BNK" 
628b f5				push af  
628c 3a a0 62			ld a, (.dmark)  
628f 32 9d fd			ld (debug_mark),a  
6292 3a a1 62			ld a, (.dmark+1)  
6295 32 9e fd			ld (debug_mark+1),a  
6298 3a a2 62			ld a, (.dmark+2)  
629b 32 9f fd			ld (debug_mark+2),a  
629e 18 03			jr .pastdmark  
62a0 ..			.dmark: db "BNK"  
62a3 f1			.pastdmark: pop af  
62a4			endm  
# End of macro DMARK
62a4						CALLMONITOR 
62a4 cd aa fd			call debug_vector  
62a7				endm  
# End of macro CALLMONITOR
62a7					endif 
62a7			 
62a7					; active low 
62a7			 
62a7			;		cp 0 
62a7 b7					or a 
62a8 28 28				jr z, .bset 
62aa fe 01				cp 1 
62ac 20 04				jr nz, .b2 
62ae cb 81				res 0, c 
62b0 06 31				ld b, '1'    ; human readable bank number 
62b2 fe 02		.b2:		cp 2 
62b4 20 04				jr nz, .b3 
62b6 cb 89				res 1, c 
62b8 06 32				ld b, '2'    ; human readable bank number 
62ba fe 03		.b3:		cp 3 
62bc 20 04				jr nz, .b4 
62be cb 91				res 2, c 
62c0 06 33				ld b, '3'    ; human readable bank number 
62c2 fe 04		.b4:		cp 4 
62c4 20 04				jr nz, .b5 
62c6 cb 99				res 3, c 
62c8 06 34				ld b, '4'    ; human readable bank number 
62ca fe 05		.b5:		cp 5 
62cc 20 04				jr nz, .bset 
62ce cb a1				res 4, c 
62d0 06 35				ld b, '5'    ; human readable bank number 
62d2			 
62d2			.bset: 
62d2 79					ld a, c 
62d3 32 92 f9				ld (spi_device),a 
62d6 78					ld a, b 
62d7 32 91 f9				ld (spi_device_id),a 
62da					if DEBUG_FORTH_WORDS 
62da						DMARK "BN2" 
62da f5				push af  
62db 3a ef 62			ld a, (.dmark)  
62de 32 9d fd			ld (debug_mark),a  
62e1 3a f0 62			ld a, (.dmark+1)  
62e4 32 9e fd			ld (debug_mark+1),a  
62e7 3a f1 62			ld a, (.dmark+2)  
62ea 32 9f fd			ld (debug_mark+2),a  
62ed 18 03			jr .pastdmark  
62ef ..			.dmark: db "BN2"  
62f2 f1			.pastdmark: pop af  
62f3			endm  
# End of macro DMARK
62f3						CALLMONITOR 
62f3 cd aa fd			call debug_vector  
62f6				endm  
# End of macro CALLMONITOR
62f6					endif 
62f6			 
62f6					; set default SPI clk pulse time as disabled for BANK use 
62f6			 
62f6 3e 00				ld a, 0 
62f8 32 96 f9				ld (spi_clktime), a 
62fb			 
62fb					NEXTW 
62fb cd a7 fd			call parse_vector 
62fe c3 e2 23			jp macro_next 
6301				endm 
# End of macro NEXTW
6301			 
6301			.CARTDEV: 
6301				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
6301 66				db WORD_SYS_CORE+82             
6302 b1 63			dw .ENDDEVICE            
6304 08				db 7 + 1 
6305 .. 00			db "CARTDEV",0              
630d				endm 
# End of macro CWHEAD
630d			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). | DONE 
630d			; | | Set to zero to disable devices. 
630d					if DEBUG_FORTH_WORDS_KEY 
630d						DMARK "CDV" 
630d f5				push af  
630e 3a 22 63			ld a, (.dmark)  
6311 32 9d fd			ld (debug_mark),a  
6314 3a 23 63			ld a, (.dmark+1)  
6317 32 9e fd			ld (debug_mark+1),a  
631a 3a 24 63			ld a, (.dmark+2)  
631d 32 9f fd			ld (debug_mark+2),a  
6320 18 03			jr .pastdmark  
6322 ..			.dmark: db "CDV"  
6325 f1			.pastdmark: pop af  
6326			endm  
# End of macro DMARK
6326						CALLMONITOR 
6326 cd aa fd			call debug_vector  
6329				endm  
# End of macro CALLMONITOR
6329					endif 
6329			 
6329					; disable se storage bank selection 
6329			 
6329 3e ff				ld a, SPI_CE_HIGH		; ce high 
632b 32 92 f9				ld (spi_device), a 
632e			 
632e					; get bank 
632e			 
632e					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
632e cd fb 21			call macro_dsp_valuehl 
6331				endm 
# End of macro FORTH_DSP_VALUEHL
6331			 
6331			;		push hl 
6331			 
6331					; destroy value TOS 
6331			 
6331					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6331 cd b3 22			call macro_forth_dsp_pop 
6334				endm 
# End of macro FORTH_DSP_POP
6334			 
6334					; one value on hl get other one back 
6334			 
6334			;		pop hl 
6334			 
6334					; active low 
6334			 
6334 0e ff				ld c, 255 
6336			 
6336 7d					ld a, l 
6337					if DEBUG_FORTH_WORDS 
6337						DMARK "CDV" 
6337 f5				push af  
6338 3a 4c 63			ld a, (.dmark)  
633b 32 9d fd			ld (debug_mark),a  
633e 3a 4d 63			ld a, (.dmark+1)  
6341 32 9e fd			ld (debug_mark+1),a  
6344 3a 4e 63			ld a, (.dmark+2)  
6347 32 9f fd			ld (debug_mark+2),a  
634a 18 03			jr .pastdmark  
634c ..			.dmark: db "CDV"  
634f f1			.pastdmark: pop af  
6350			endm  
# End of macro DMARK
6350						CALLMONITOR 
6350 cd aa fd			call debug_vector  
6353				endm  
# End of macro CALLMONITOR
6353					endif 
6353			;		cp 0 
6353 b7					or a 
6354 28 30				jr z, .cset 
6356 fe 01				cp 1 
6358 20 02				jr nz, .c2 
635a cb 81				res 0, c 
635c fe 02		.c2:		cp 2 
635e 20 02				jr nz, .c3 
6360 cb 89				res 1, c 
6362 fe 03		.c3:		cp 3 
6364 20 02				jr nz, .c4 
6366 cb 91				res 2, c 
6368 fe 04		.c4:		cp 4 
636a 20 02				jr nz, .c5 
636c cb 99				res 3, c 
636e fe 05		.c5:		cp 5 
6370 20 02				jr nz, .c6 
6372 cb a1				res 4, c 
6374 fe 06		.c6:		cp 6 
6376 20 02				jr nz, .c7 
6378 cb a9				res 5, c 
637a fe 07		.c7:		cp 7 
637c 20 02				jr nz, .c8 
637e cb b1				res 6, c 
6380 fe 08		.c8:		cp 8 
6382 20 02				jr nz, .cset 
6384 cb b9				res 7, c 
6386 79			.cset:		ld a, c 
6387 32 95 f9				ld (spi_cartdev),a 
638a			 
638a					if DEBUG_FORTH_WORDS 
638a						DMARK "CD2" 
638a f5				push af  
638b 3a 9f 63			ld a, (.dmark)  
638e 32 9d fd			ld (debug_mark),a  
6391 3a a0 63			ld a, (.dmark+1)  
6394 32 9e fd			ld (debug_mark+1),a  
6397 3a a1 63			ld a, (.dmark+2)  
639a 32 9f fd			ld (debug_mark+2),a  
639d 18 03			jr .pastdmark  
639f ..			.dmark: db "CD2"  
63a2 f1			.pastdmark: pop af  
63a3			endm  
# End of macro DMARK
63a3						CALLMONITOR 
63a3 cd aa fd			call debug_vector  
63a6				endm  
# End of macro CALLMONITOR
63a6					endif 
63a6			 
63a6					; set default SPI clk pulse time as 10ms for CARTDEV use 
63a6			 
63a6 3e 0a				ld a, $0a 
63a8 32 96 f9				ld (spi_clktime), a 
63ab					NEXTW 
63ab cd a7 fd			call parse_vector 
63ae c3 e2 23			jp macro_next 
63b1				endm 
# End of macro NEXTW
63b1			endif 
63b1			 
63b1			.ENDDEVICE: 
63b1			; eof 
63b1			 
# End of file forth_words_device.asm
63b1			 
63b1			; var handler 
63b1			 
63b1			 
63b1			.VARS: 
63b1				CWHEAD .V0 99 "VAR" 3 WORD_FLAG_CODE 
63b1 77				db WORD_SYS_CORE+99             
63b2 65 64			dw .V0            
63b4 04				db 3 + 1 
63b5 .. 00			db "VAR",0              
63b9				endm 
# End of macro CWHEAD
63b9			; | VAR ( u1 -- )  Get the address of the (word) variable referenced on TOS  | DONE 
63b9			; | 
63b9			; | | The variable name should consist of a single letter (a-z). e.g. "a" 
63b9			; | |  
63b9			; | | e.g. 
63b9			; | |         #30 a var ! 
63b9			; | |         a var @ . 
63b9			; | |   
63b9			; | |     Displays the number 30 
63b9			; | | 
63b9			; | | Each variable pointer is a word so can use for any words that use that:  
63b9			; | |  
63b9			; | | e.g. 
63b9			; | |  
63b9			; | |         #30 a var 2! 
63b9			; | |         a var 2@ . 
63b9			; | |   
63b9			; | |     Displays the number 30 
63b9			; | |  
63b9			; | | > [!NOTE]  
63b9			; ! | > If a full string is passed then only the first char is looked at 
63b9			; | | > Any other char could exceed bounds checks!  
63b9			; | | > 
63b9			; | | > Each variable location follows the previous. Watch you don't clobber any others. 
63b9			 
63b9					if DEBUG_FORTH_WORDS_KEY 
63b9						DMARK "VAR" 
63b9 f5				push af  
63ba 3a ce 63			ld a, (.dmark)  
63bd 32 9d fd			ld (debug_mark),a  
63c0 3a cf 63			ld a, (.dmark+1)  
63c3 32 9e fd			ld (debug_mark+1),a  
63c6 3a d0 63			ld a, (.dmark+2)  
63c9 32 9f fd			ld (debug_mark+2),a  
63cc 18 03			jr .pastdmark  
63ce ..			.dmark: db "VAR"  
63d1 f1			.pastdmark: pop af  
63d2			endm  
# End of macro DMARK
63d2						CALLMONITOR 
63d2 cd aa fd			call debug_vector  
63d5				endm  
# End of macro CALLMONITOR
63d5					endif 
63d5			 
63d5					FORTH_DSP_VALUEHL 
63d5 cd fb 21			call macro_dsp_valuehl 
63d8				endm 
# End of macro FORTH_DSP_VALUEHL
63d8			 
63d8 7e					ld a, (hl)    ; get first char on of the string 
63d9			 
63d9			 
63d9					if DEBUG_FORTH_WORDS 
63d9						DMARK "VR1" 
63d9 f5				push af  
63da 3a ee 63			ld a, (.dmark)  
63dd 32 9d fd			ld (debug_mark),a  
63e0 3a ef 63			ld a, (.dmark+1)  
63e3 32 9e fd			ld (debug_mark+1),a  
63e6 3a f0 63			ld a, (.dmark+2)  
63e9 32 9f fd			ld (debug_mark+2),a  
63ec 18 03			jr .pastdmark  
63ee ..			.dmark: db "VR1"  
63f1 f1			.pastdmark: pop af  
63f2			endm  
# End of macro DMARK
63f2						CALLMONITOR 
63f2 cd aa fd			call debug_vector  
63f5				endm  
# End of macro CALLMONITOR
63f5					endif 
63f5					 
63f5 f5					push af	 
63f6					FORTH_DSP_POP 
63f6 cd b3 22			call macro_forth_dsp_pop 
63f9				endm 
# End of macro FORTH_DSP_POP
63f9 f1					pop af 
63fa			 
63fa					; convert to upper 
63fa			 
63fa cd 14 12				call to_upper 
63fd					if DEBUG_FORTH_WORDS 
63fd						DMARK "Vaa" 
63fd f5				push af  
63fe 3a 12 64			ld a, (.dmark)  
6401 32 9d fd			ld (debug_mark),a  
6404 3a 13 64			ld a, (.dmark+1)  
6407 32 9e fd			ld (debug_mark+1),a  
640a 3a 14 64			ld a, (.dmark+2)  
640d 32 9f fd			ld (debug_mark+2),a  
6410 18 03			jr .pastdmark  
6412 ..			.dmark: db "Vaa"  
6415 f1			.pastdmark: pop af  
6416			endm  
# End of macro DMARK
6416						CALLMONITOR 
6416 cd aa fd			call debug_vector  
6419				endm  
# End of macro CALLMONITOR
6419					endif 
6419 06 41				ld b, 'A' 
641b 90					sub b			; set offset 
641c					if DEBUG_FORTH_WORDS 
641c						DMARK "Vbb" 
641c f5				push af  
641d 3a 31 64			ld a, (.dmark)  
6420 32 9d fd			ld (debug_mark),a  
6423 3a 32 64			ld a, (.dmark+1)  
6426 32 9e fd			ld (debug_mark+1),a  
6429 3a 33 64			ld a, (.dmark+2)  
642c 32 9f fd			ld (debug_mark+2),a  
642f 18 03			jr .pastdmark  
6431 ..			.dmark: db "Vbb"  
6434 f1			.pastdmark: pop af  
6435			endm  
# End of macro DMARK
6435						CALLMONITOR 
6435 cd aa fd			call debug_vector  
6438				endm  
# End of macro CALLMONITOR
6438					endif 
6438 cb 27				sla a  
643a				 
643a					 
643a					if DEBUG_FORTH_WORDS 
643a						DMARK "VR2" 
643a f5				push af  
643b 3a 4f 64			ld a, (.dmark)  
643e 32 9d fd			ld (debug_mark),a  
6441 3a 50 64			ld a, (.dmark+1)  
6444 32 9e fd			ld (debug_mark+1),a  
6447 3a 51 64			ld a, (.dmark+2)  
644a 32 9f fd			ld (debug_mark+2),a  
644d 18 03			jr .pastdmark  
644f ..			.dmark: db "VR2"  
6452 f1			.pastdmark: pop af  
6453			endm  
# End of macro DMARK
6453						CALLMONITOR 
6453 cd aa fd			call debug_vector  
6456				endm  
# End of macro CALLMONITOR
6456					endif 
6456			 
6456 21 26 f9				ld hl, cli_var_array2 
6459 cd ac 0f				call addatohl 
645c cd ff 1f				call forth_push_numhl 
645f			 
645f			 
645f				       NEXTW 
645f cd a7 fd			call parse_vector 
6462 c3 e2 23			jp macro_next 
6465				endm 
# End of macro NEXTW
6465			.V0: 
6465				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
6465 78				db WORD_SYS_CORE+100             
6466 80 64			dw .V0Q            
6468 04				db 3 + 1 
6469 .. 00			db "V0!",0              
646d				endm 
# End of macro CWHEAD
646d			;| V0! ( u1 -- )  Store value to v0  | DONE 
646d			 
646d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
646d cd fb 21			call macro_dsp_valuehl 
6470				endm 
# End of macro FORTH_DSP_VALUEHL
6470			 
6470 11 5a f9				ld de, cli_var_array 
6473			 
6473 eb					ex de, hl 
6474 73					ld (hl), e 
6475 23					inc hl 
6476 72					ld (hl), d 
6477			 
6477					; destroy value TOS 
6477			 
6477					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6477 cd b3 22			call macro_forth_dsp_pop 
647a				endm 
# End of macro FORTH_DSP_POP
647a			 
647a				       NEXTW 
647a cd a7 fd			call parse_vector 
647d c3 e2 23			jp macro_next 
6480				endm 
# End of macro NEXTW
6480			.V0Q: 
6480				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
6480 79				db WORD_SYS_CORE+101             
6481 94 64			dw .V1S            
6483 04				db 3 + 1 
6484 .. 00			db "V0@",0              
6488				endm 
# End of macro CWHEAD
6488			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
6488 2a 5a f9				ld hl, (cli_var_array) 
648b cd ff 1f				call forth_push_numhl 
648e			 
648e				       NEXTW 
648e cd a7 fd			call parse_vector 
6491 c3 e2 23			jp macro_next 
6494				endm 
# End of macro NEXTW
6494			.V1S: 
6494				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
6494 7a				db WORD_SYS_CORE+102             
6495 af 64			dw .V1Q            
6497 04				db 3 + 1 
6498 .. 00			db "V1!",0              
649c				endm 
# End of macro CWHEAD
649c			;| V1! ( u1 -- )  Store value to v1 | DONE 
649c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
649c cd fb 21			call macro_dsp_valuehl 
649f				endm 
# End of macro FORTH_DSP_VALUEHL
649f			 
649f 11 5c f9				ld de, cli_var_array+2 
64a2				 
64a2 eb					ex de, hl 
64a3 73					ld (hl), e 
64a4 23					inc hl 
64a5 72					ld (hl), d 
64a6			 
64a6					; destroy value TOS 
64a6			 
64a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
64a6 cd b3 22			call macro_forth_dsp_pop 
64a9				endm 
# End of macro FORTH_DSP_POP
64a9				       NEXTW 
64a9 cd a7 fd			call parse_vector 
64ac c3 e2 23			jp macro_next 
64af				endm 
# End of macro NEXTW
64af			.V1Q: 
64af				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
64af 7b				db WORD_SYS_CORE+103             
64b0 c3 64			dw .V2S            
64b2 04				db 3 + 1 
64b3 .. 00			db "V1@",0              
64b7				endm 
# End of macro CWHEAD
64b7			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
64b7 2a 5c f9				ld hl, (cli_var_array+2) 
64ba cd ff 1f				call forth_push_numhl 
64bd				       NEXTW 
64bd cd a7 fd			call parse_vector 
64c0 c3 e2 23			jp macro_next 
64c3				endm 
# End of macro NEXTW
64c3			.V2S: 
64c3				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
64c3 7c				db WORD_SYS_CORE+104             
64c4 de 64			dw .V2Q            
64c6 04				db 3 + 1 
64c7 .. 00			db "V2!",0              
64cb				endm 
# End of macro CWHEAD
64cb			;| V2! ( u1 -- )  Store value to v2 | DONE 
64cb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
64cb cd fb 21			call macro_dsp_valuehl 
64ce				endm 
# End of macro FORTH_DSP_VALUEHL
64ce			 
64ce 11 5e f9				ld de, cli_var_array+4 
64d1				 
64d1 eb					ex de, hl 
64d2 73					ld (hl), e 
64d3 23					inc hl 
64d4 72					ld (hl), d 
64d5			 
64d5					; destroy value TOS 
64d5			 
64d5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
64d5 cd b3 22			call macro_forth_dsp_pop 
64d8				endm 
# End of macro FORTH_DSP_POP
64d8				       NEXTW 
64d8 cd a7 fd			call parse_vector 
64db c3 e2 23			jp macro_next 
64de				endm 
# End of macro NEXTW
64de			.V2Q: 
64de				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
64de 7d				db WORD_SYS_CORE+105             
64df f2 64			dw .V3S            
64e1 04				db 3 + 1 
64e2 .. 00			db "V2@",0              
64e6				endm 
# End of macro CWHEAD
64e6			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
64e6 2a 5e f9				ld hl, (cli_var_array+4) 
64e9 cd ff 1f				call forth_push_numhl 
64ec				       NEXTW 
64ec cd a7 fd			call parse_vector 
64ef c3 e2 23			jp macro_next 
64f2				endm 
# End of macro NEXTW
64f2			.V3S: 
64f2				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
64f2 7c				db WORD_SYS_CORE+104             
64f3 0d 65			dw .V3Q            
64f5 04				db 3 + 1 
64f6 .. 00			db "V3!",0              
64fa				endm 
# End of macro CWHEAD
64fa			;| V3! ( u1 -- )  Store value to v3 | DONE 
64fa					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
64fa cd fb 21			call macro_dsp_valuehl 
64fd				endm 
# End of macro FORTH_DSP_VALUEHL
64fd			 
64fd 11 60 f9				ld de, cli_var_array+6 
6500				 
6500 eb					ex de, hl 
6501 73					ld (hl), e 
6502 23					inc hl 
6503 72					ld (hl), d 
6504			 
6504					; destroy value TOS 
6504			 
6504					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
6504 cd b3 22			call macro_forth_dsp_pop 
6507				endm 
# End of macro FORTH_DSP_POP
6507				       NEXTW 
6507 cd a7 fd			call parse_vector 
650a c3 e2 23			jp macro_next 
650d				endm 
# End of macro NEXTW
650d			.V3Q: 
650d				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
650d 7d				db WORD_SYS_CORE+105             
650e 21 65			dw .END            
6510 04				db 3 + 1 
6511 .. 00			db "V3@",0              
6515				endm 
# End of macro CWHEAD
6515			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
6515 2a 60 f9				ld hl, (cli_var_array+6) 
6518 cd ff 1f				call forth_push_numhl 
651b				       NEXTW 
651b cd a7 fd			call parse_vector 
651e c3 e2 23			jp macro_next 
6521				endm 
# End of macro NEXTW
6521			 
6521			 
6521			 
6521			 
6521			 
6521			; end of dict marker 
6521			 
6521 00			.END:    db WORD_SYS_END 
6522 00 00			dw 0 
6524 00				db 0 
6525			 
6525			; use to jp here for user dict words to save on macro expansion  
6525			 
6525			user_dict_next: 
6525				NEXTW 
6525 cd a7 fd			call parse_vector 
6528 c3 e2 23			jp macro_next 
652b				endm 
# End of macro NEXTW
652b			 
652b			 
652b			user_exec: 
652b				;    ld hl, <word code> 
652b				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
652b				;    call forthexec 
652b				;    jp user_dict_next   (NEXT) 
652b			        ;    <word code bytes> 
652b eb				ex de, hl 
652c 2a f4 f3			ld hl,(os_tok_ptr) 
652f				 
652f				FORTH_RSP_NEXT 
652f cd a6 1f			call macro_forth_rsp_next 
6532				endm 
# End of macro FORTH_RSP_NEXT
6532			 
6532			if DEBUG_FORTH_UWORD 
6532						DMARK "UEX" 
6532 f5				push af  
6533 3a 47 65			ld a, (.dmark)  
6536 32 9d fd			ld (debug_mark),a  
6539 3a 48 65			ld a, (.dmark+1)  
653c 32 9e fd			ld (debug_mark+1),a  
653f 3a 49 65			ld a, (.dmark+2)  
6542 32 9f fd			ld (debug_mark+2),a  
6545 18 03			jr .pastdmark  
6547 ..			.dmark: db "UEX"  
654a f1			.pastdmark: pop af  
654b			endm  
# End of macro DMARK
654b				CALLMONITOR 
654b cd aa fd			call debug_vector  
654e				endm  
# End of macro CALLMONITOR
654e			endif 
654e			 
654e			 
654e			 
654e eb				ex de, hl 
654f 22 f4 f3			ld (os_tok_ptr), hl 
6552				 
6552				; Don't use next - Skips the first word in uword. 
6552			 
6552 c3 63 24			jp exec1 
6555			;	NEXT 
6555			 
6555			 
6555			; eof 
# End of file forth_wordsv4.asm
6555			endif 
6555			;;;;;;;;;;;;;; Debug code 
6555			 
6555			 
6555			;if DEBUG_FORTH_PARSE 
6555 .. 00		.nowordfound: db "No match",0 
655e .. 00		.compword:	db "Comparing word ",0 
656e .. 00		.nextwordat:	db "Next word at",0 
657b .. 00		.charmatch:	db "Char match",0 
6586			;endif 
6586			if DEBUG_FORTH_JP 
6586			.foundword:	db "Word match. Exec..",0 
6586			endif 
6586			;if DEBUG_FORTH_PUSH 
6586 .. 00		.enddict:	db "Dict end. Push.",0 
6596 .. 00		.push_str:	db "Pushing string",0 
65a5 .. 00		.push_num:	db "Pushing number",0 
65b4 .. 00		.data_sp:	db "SP:",0 
65b8 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
65ca .. 00		.wordinde:	db "Word in DE (3/0):",0 
65dc .. 00		.wordinbc:	db "Word in BC (4/0):",0 
65ee			;endif 
65ee			;if DEBUG_FORTH_MALLOC 
65ee .. 00		.push_malloc:	db "Malloc address",0 
65fd			;endif 
65fd			 
65fd			 
65fd			 
65fd			; display malloc address and current data stack pointer  
65fd			 
65fd			malloc_error: 
65fd d5				push de 
65fe f5				push af 
65ff e5				push hl 
6600 cd 7c 0d			call clear_display 
6603 11 23 66			ld de, .mallocerr 
6606 3e 00			ld a,0 
6608			;	ld de,os_word_scratch 
6608 cd 8e 0d			call str_at_display 
660b 3e 11			ld a, display_row_1+17 
660d 11 9d fd			ld de, debug_mark 
6610 cd 8e 0d			call str_at_display 
6613 cd 9e 0d			call update_display 
6616				;call break_point_state 
6616 cd 08 7b			call cin_wait 
6619			 
6619			;	ld a, ' ' 
6619			;	ld (os_view_disable), a 
6619 cd ce 18			call bp_on 
661c e1				pop hl 
661d f1				pop af 
661e d1				pop de	 
661f				CALLMONITOR 
661f cd aa fd			call debug_vector  
6622				endm  
# End of macro CALLMONITOR
6622 c9				ret 
6623			 
6623 .. 00		.mallocerr: 	db "Malloc Error",0 
6630			;if DEBUG_FORTH_PUSH 
6630			display_data_sp: 
6630 f5				push af 
6631			 
6631				; see if disabled 
6631			 
6631			 
6631 3a aa fd			ld a, (debug_vector) 
6634 fe c9			cp $C9  ; RET 
6636				;ld a, (os_view_disable) 
6636				;cp '*' 
6636 28 65			jr z, .skipdsp 
6638			 
6638 e5				push hl 
6639 e5				push hl 
663a e5			push hl 
663b cd 7c 0d			call clear_display 
663e e1			pop hl 
663f 7c				ld a,h 
6640 21 f8 f3			ld hl, os_word_scratch 
6643 cd a8 11			call hexout 
6646 e1				pop hl 
6647 7d				ld a,l 
6648 21 fa f3			ld hl, os_word_scratch+2 
664b cd a8 11			call hexout 
664e 21 fc f3			ld hl, os_word_scratch+4 
6651			;	ld a,0 
6651 36 00			ld (hl),0 
6653 11 f8 f3			ld de,os_word_scratch 
6656 3e 28				ld a, display_row_2 
6658 cd 8e 0d				call str_at_display 
665b 11 b8 65			ld de, .wordinhl 
665e 3e 00			ld a, display_row_1 
6660			 
6660 cd 8e 0d				call str_at_display 
6663 11 9d fd			ld de, debug_mark 
6666 3e 11			ld a, display_row_1+17 
6668			 
6668 cd 8e 0d				call str_at_display 
666b			 
666b				; display current data stack pointer 
666b 11 b4 65			ld de,.data_sp 
666e 3e 30				ld a, display_row_2 + 8 
6670 cd 8e 0d				call str_at_display 
6673			 
6673 2a 20 f9			ld hl,(cli_data_sp) 
6676 e5				push hl 
6677 7c				ld a,h 
6678 21 f8 f3			ld hl, os_word_scratch 
667b cd a8 11			call hexout 
667e e1				pop hl 
667f 7d				ld a,l 
6680 21 fa f3			ld hl, os_word_scratch+2 
6683 cd a8 11			call hexout 
6686 21 fc f3			ld hl, os_word_scratch+4 
6689			;	ld a,0 
6689 36 00			ld (hl),0 
668b 11 f8 f3			ld de,os_word_scratch 
668e 3e 33				ld a, display_row_2 + 11 
6690 cd 8e 0d				call str_at_display 
6693			 
6693			 
6693 cd 9e 0d			call update_display 
6696 cd c0 0c			call delay1s 
6699 cd c0 0c			call delay1s 
669c e1				pop hl 
669d			.skipdsp: 
669d f1				pop af 
669e c9				ret 
669f			 
669f			display_data_malloc: 
669f			 
669f f5				push af 
66a0 e5				push hl 
66a1 e5				push hl 
66a2 e5			push hl 
66a3 cd 7c 0d			call clear_display 
66a6 e1			pop hl 
66a7 7c				ld a,h 
66a8 21 f8 f3			ld hl, os_word_scratch 
66ab cd a8 11			call hexout 
66ae e1				pop hl 
66af 7d				ld a,l 
66b0 21 fa f3			ld hl, os_word_scratch+2 
66b3 cd a8 11			call hexout 
66b6 21 fc f3			ld hl, os_word_scratch+4 
66b9			;	ld a,0 
66b9 36 00			ld (hl),0 
66bb 11 f8 f3			ld de,os_word_scratch 
66be 3e 28				ld a, display_row_2 
66c0 cd 8e 0d				call str_at_display 
66c3 11 ee 65			ld de, .push_malloc 
66c6 3e 00			ld a, display_row_1 
66c8			 
66c8 cd 8e 0d				call str_at_display 
66cb			 
66cb				; display current data stack pointer 
66cb 11 b4 65			ld de,.data_sp 
66ce 3e 30				ld a, display_row_2 + 8 
66d0 cd 8e 0d				call str_at_display 
66d3			 
66d3 2a 20 f9			ld hl,(cli_data_sp) 
66d6 e5				push hl 
66d7 7c				ld a,h 
66d8 21 f8 f3			ld hl, os_word_scratch 
66db cd a8 11			call hexout 
66de e1				pop hl 
66df 7d				ld a,l 
66e0 21 fa f3			ld hl, os_word_scratch+2 
66e3 cd a8 11			call hexout 
66e6 21 fc f3			ld hl, os_word_scratch+4 
66e9			;	ld a,0 
66e9 36 00			ld (hl),0 
66eb 11 f8 f3			ld de,os_word_scratch 
66ee 3e 33				ld a, display_row_2 + 11 
66f0 cd 8e 0d				call str_at_display 
66f3			 
66f3 cd 9e 0d			call update_display 
66f6 cd c0 0c			call delay1s 
66f9 cd c0 0c			call delay1s 
66fc e1				pop hl 
66fd f1				pop af 
66fe c9				ret 
66ff			;endif 
66ff			 
66ff			include "forth_autostart.asm" 
66ff			; list of commands to perform at system start up 
66ff			 
66ff			startcmds: 
66ff			;	dw test11 
66ff			;	dw test12 
66ff			;	dw test13 
66ff			;	dw test14 
66ff			;	dw test15 
66ff			;	dw test16 
66ff			;	dw test17 
66ff			;	dw ifthtest1 
66ff			;	dw ifthtest2 
66ff			;	dw ifthtest3 
66ff			;	dw mmtest1 
66ff			;	dw mmtest2 
66ff			;	dw mmtest3 
66ff			;	dw mmtest4 
66ff			;	dw mmtest5 
66ff			;	dw mmtest6 
66ff			;	dw iftest1 
66ff			;	dw iftest2 
66ff			;	dw iftest3 
66ff			;	dw looptest1 
66ff			;	dw looptest2 
66ff			;	dw test1 
66ff			;	dw test2 
66ff			;	dw test3 
66ff			;	dw test4 
66ff			;	dw game2r 
66ff			;	dw game2b1 
66ff			;	dw game2b2 
66ff			 
66ff				; start up words that are actually useful 
66ff			 
66ff			;    dw spi1 
66ff			;    dw spi2 
66ff			;    dw spi3 
66ff			;    dw spi4 
66ff			;    dw spi5 
66ff			;    dw spi6 
66ff			;    dw spi7 
66ff			; 
66ff			;    dw spi8 
66ff			;    dw spi9 
66ff			;    dw spi10 
66ff			 
66ff			; file editor 
66ff			;	dw edit1 
66ff			;	dw edit2 
66ff			;	dw edit3 
66ff			 
66ff			;	dw longread 
66ff 21 6b			dw clrstack 
6701 55 6b			dw type 
6703			;	dw stest 
6703 7a 6b			dw strncpy 
6705 ea 6c			dw list 
6707 db 6b			dw start1 
6709 eb 6b			dw start2 
670b			;	dw start3 
670b			;	dw start3b 
670b			;	dw start3c 
670b			 
670b				; (unit) testing words 
670b			 
670b			;	dw mtesta 
670b			;	dw mtestb 
670b			;	dw mtestc 
670b			;	dw mtestd 
670b			;	dw mteste 
670b			 
670b				; demo/game words 
670b			 
670b			;        dw game3w 
670b			;        dw game3p 
670b			;        dw game3sc 
670b			;        dw game3vsi 
670b			;        dw game3vs 
670b				 
670b			;	dw game2b 
670b			;	dw game2bf 
670b			;	dw game2mba 
670b			;	dw game2mbas 
670b			;	dw game2mb 
670b			 
670b 1b 6f			dw game1 
670d 2c 6f			dw game1a 
670f 8e 6f			dw game1b 
6711 c3 6f			dw game1c 
6713 f9 6f			dw game1d 
6715 2a 70			dw game1s 
6717 3e 70			dw game1t 
6719 53 70			dw game1f 
671b 87 70			dw game1z 
671d cb 70			dw game1zz 
671f			 
671f 54 6d			dw test5 
6721 8c 6d			dw test6 
6723 c4 6d			dw test7 
6725 d8 6d			dw test8 
6727 04 6e			dw test9 
6729 1a 6e			dw test10 
672b				 
672b a2 71		        dw ssv5 
672d 86 71		        dw ssv4 
672f 6a 71		        dw ssv3 
6731 34 71		        dw ssv2 
6733 bb 71		        dw ssv1 
6735 03 72		        dw ssv1cpm 
6737			;	dw keyup 
6737			;	dw keydown 
6737			;	dw keyleft 
6737			;	dw keyright 
6737			;	dw 	keyf1 
6737			;	dw keyf2 
6737			;	dw keyf3 
6737			;	dw keyf4 
6737			;	dw keyf5 
6737			;	dw keyf6 
6737			;	dw keyf7 
6737			;	dw keyf8 
6737			;	dw keyf9 
6737			;	dw keyf10 
6737			;	dw keyf11 
6737			;	dw keyf12 
6737			;	dw keytab 
6737			;	dw keycr 
6737			;	dw keyhome 
6737			;	dw keyend 
6737			;	dw keybs 
6737 00 00			db 0, 0	 
6739			 
6739			 
6739			; File Editor 
6739			 
6739			; ( id - ) use 'e' to edit the displayed line 
6739 .. 00		edit1: db ": edc waitk $65 = if ede then ; ", 0 
675a .. 00		edit2: db ": ede storepage ptr $02 + cls dedit filepage bupd ; ", 0 
678f			;edit2: db ": ede v1@ v0@ record drop storepage ptr $02 + cls dedit filepage bupd ; ", 0 
678f .. 00		edit3: db ": ed dup v0! open $01 do i v0@ record cls . edc loop ; ",0 
67c7			;edit3: db ": ed dup v0! open $01 do i v0@ record cls . i v1! edc loop ; ",0 
67c7			 
67c7			; SPI Net support words 
67c7			 
67c7			; v0! = node to send to 
67c7			; ( str count - ) 
67c7 .. 00		spi1:       db ": spitype spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ",0 
6820			 
6820			; spiputc ( char node - ) 
6820 .. 00		spi2:       db ": spiputc spicel $10 spio spio ptr @ spio spiceh ; ",0 
6854			; spiputc ( u node - ) 
6854 .. 00		spi2b:       db ": spiputb spicel $10 spio spio spio spiceh ; ",0 
6882			 
6882			; spigetc ( - n ) 
6882 .. 00		spi4:       db ": spigetc spicel $11 spio spii spiceh ; ", 0 
68ab			 
68ab			; getnode ( - n ) 
68ab .. 00		spi5:       db ": getnode spicel $18 spio spii nop spiceh ; ", 0 
68d8			 
68d8			; ( str node - )  
68d8 .. 00		spi3:       db ": sendnode v0! count spiceh $00 do dup i + @ v0@ spicel $10 spio spio spio spiceh $01 pause loop ; ; ",0 
693e			; store string ( str i - ) 
693e			 
693e			;spi3:       db ": storestrold spicel $03 spio spio ptr count clkstro spiceh ; ", 0 
693e .. 00		spi6:       db ": storestr spicel $12 spio spio count $00 do dup i + @ spio $01 pause loop spiceh ; ", 0 
6993			 
6993			; get string ( addr i -  )    TO FIX 
6993			 
6993 .. 00		spi7:       db ": getstorestr spicel $13 spio spio \" \" repeat spii dup concat $00 = not until spiceh ; ", 0 
69eb			 
69eb			 
69eb			; NETCHAT (TODO) 
69eb			; Program to allow two nodes to chat with eachother 
69eb			; 
69eb			; v0 - target node 
69eb			;  
69eb			; accept input at 0,0 
69eb			; if input is string send spitype to target node 
69eb			; starting at row 2,0 , while spigetchr is not zero ->  
69eb			; 
69eb			; 
69eb			; TODO add paging of get request 
69eb			 
69eb			; ( node - ) 
69eb .. 00		spi8:		db ": netchatp $00 $00 at accept ;", 0 
6a0a .. 00		spi9: 		db ": netchatr repeat spigetchr dup dup $00 = not if emit then $00 = not until $02 pause ; ",0 
6a62 .. 00		spi10:		db ": netchat v0! repeat netchatp count dup $00 > if spitype $01 pause then cls $00 $03 at \">\" . netchatr true until nop ; ", 0 
6ada			 
6ada			 
6ada			; Long read of currently open file 
6ada .. 00		longread:   db ": lread read repeat readcont if read concat then readcont until nop ; ", 0 
6b21			 
6b21			; clear stack  
6b21			 
6b21 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ; ", 0 
6b55			 
6b55			; type ( addr count - ) 
6b55 .. 00		type:     db ": type $00 do dup i + @ emit loop ; ", 0 
6b7a			 
6b7a			; some direct memory words 
6b7a			; strncpy ( len t f -- t ) 
6b7a			 
6b7a .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
6bdb			 
6bdb .. 00		start1:     	db ": bpon $00 bp ;",0 
6beb .. 00		start2:     	db ": bpoff $01 bp ;",0 
6bfc .. 00		start3b:         db ": ls dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
6c77 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
6cd7			 
6cd7 .. 00		tuck:         db ": tuck swap over ;", 0 
6cea			 
6cea			; a handy word to list items on the stack 
6cea			 
6cea .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
6d54			 
6d54			 
6d54			; test stack  
6d54			; rnd8 stest 
6d54			 
6d54			;stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
6d54			 
6d54			; random malloc and free cycles 
6d54			 
6d54			;mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6d54			 
6d54			; fixed malloc and free cycles 
6d54			 
6d54			;mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
6d54			 
6d54			; fixed double string push and drop cycle  
6d54			 
6d54			;mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
6d54			 
6d54			; consistent fixed string push and drop cycle  
6d54			 
6d54			;mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6d54			 
6d54			;mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
6d54			 
6d54			;test1:		db ": aa 1 2 3 ;", 0 
6d54			;test2:     	db "111 aa 888 999",0 
6d54			;test3:     	db ": bb 77 ;",0 
6d54			;test4:     	db "$02 $01 do i . loop bb",0 
6d54			 
6d54 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
6d8c .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
6dc4 .. 00		test7:     	db ": box hline vline ;",0 
6dd8 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
6e04 .. 00		test9:     	db ": sw $01 adsp world ;",0 
6e1a .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
6e3f			;test11:     	db "hello create .",0 
6e3f			;test12:     	db "hello2 create .",0 
6e3f			 
6e3f			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
6e3f			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
6e3f			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
6e3f			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
6e3f			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
6e3f			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
6e3f			 
6e3f			;iftest1:     	db "$0001 IF cls .",0 
6e3f			;iftest2:     	db "$0000 IF cls .",0 
6e3f			;iftest3:     	db "$0002 $0003 - IF cls .",0 
6e3f			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
6e3f			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
6e3f			 
6e3f			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6e3f			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6e3f			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
6e3f			 
6e3f			 
6e3f .. 00		sound1: db ": note spicel spio spiceh spicel ; ",0 
6e63 .. 00		sound2: db ": slient $9f note $bf note $df note $ff note ; ", 0 
6e93 .. 00		sound3: db ": sound $01 cartdev $00 spitime ! ; ",0 
6eb8 .. 00		sound4: db ": cha $00 ; ",0 
6ec5 .. 00		sound5: db ": chb $20 ; ",0 
6ed2 .. 00		sound6: db ": chc $40 ; ",0 
6edf .. 00		sound7: db ": chd $60 ; ",0 
6eec .. 00		sound8: db ": cnote $80 + + note ; ", 0 
6f04 .. 00		sound9: db ": cvol $90 + + note ; ", 0 
6f1b			 
6f1b			 
6f1b			 
6f1b			 
6f1b			; a small guess the number game 
6f1b			 
6f1b .. 00		game1:          db ": gsn rnd8 v1! ;",0 
6f2c .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
6f8e			 
6f8e .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
6fc3 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
6ff9 .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
702a .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
703e .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
7053 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
7087 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
70cb			 
70cb			; Using 'ga' save a high score across multiple runs using external storage 
70cb			 
70cb .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
7134			 
7134			 
7134			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
7134			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
7134			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
7134			 
7134			; simple screen saver to test code memory reuse to destruction 
7134			 
7134 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
716a .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
7186 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
71a2 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
71bb .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
7203 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
725a			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
725a			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
725a			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
725a			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
725a			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
725a			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
725a			 
725a			 
725a			 
725a			; minesweeper/battleship finding game 
725a			; draws a game board of random ship/mine positions 
725a			; user enters coords to see if it hits on 
725a			; game ends when all are hit 
725a			; when hit or miss says how many may be in the area 
725a			 
725a			; setup the game board and then hide it 
725a			;game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
725a			;game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
725a			;; prompt for where to target 
725a			;game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
725a			;game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
725a			;; TODO see if the entered coords hits or misses pushes char hit of miss 
725a			;game2mbht:      db ": mbckht nop ;",0 
725a			;game2mbms:      db ": mbcms nop ;",0 
725a			; TODO how many might be near by 
725a			;game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
725a			 
725a			; Game 3 
725a			 
725a			; Vert scroller ski game - avoid the trees! 
725a			 
725a			; v0 score (ie turns) 
725a			; v1 player pos 
725a			; v2 left wall 
725a			; v3 right wall 
725a			 
725a			; Draw side walls randomly 
725a			 
725a			;game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
725a			 
725a			; Draw player 
725a			;game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
725a			 
725a			; TODO Get Key 
725a			 
725a			; TODO Move left right 
725a			 
725a			; scroll and move walls a bit 
725a			 
725a			;game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
725a			 
725a			; main game loop 
725a			 
725a			;game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
725a			;game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
725a			 
725a			; key board defs 
725a			 
725a .. 00		keyup:       db ": keyup $05 ;",0 
7268 .. 00		keydown:       db ": keydown $0a ;",0 
7278 .. 00		keyleft:       db ": keyleft $0b ;",0 
7288 .. 00		keyright:       db ": keyright $0c ;",0 
7299 .. 00		keyf1:       db ": keyf1 $10 ;",0 
72a7 .. 00		keyf2:       db ": keyf2 $11 ;",0 
72b5 .. 00		keyf3:       db ": keyf3 $12 ;",0 
72c3 .. 00		keyf4:       db ": keyf4 $13 ;",0 
72d1 .. 00		keyf5:       db ": keyf5 $14 ;",0 
72df .. 00		keyf6:       db ": keyf6 $15 ;",0 
72ed .. 00		keyf7:       db ": keyf7 $16 ;",0 
72fb .. 00		keyf8:       db ": keyf8 $17 ;",0 
7309 .. 00		keyf9:       db ": keyf9 $18 ;",0 
7317 .. 00		keyf10:       db ": keyf10 $19 ;",0 
7326 .. 00		keyf11:       db ": keyf11 $1a ;",0 
7335 .. 00		keyf12:       db ": keyf12 $1b ;",0 
7344			 
7344 .. 00		keytab:       db ": keytab $09 ;",0 
7353 .. 00		keycr:       db ": keycr $0d ;",0 
7361 .. 00		keyhome:       db ": keyhome $0e ;",0 
7371 .. 00		keyend:       db ": keyend $0f ;",0 
7380 .. 00		keybs:       db ": keybs $08 ;",0 
738e			 
738e			   
738e			 
738e			 
738e			 
738e			; eof 
# End of file forth_autostart.asm
738e			 
738e			 
738e			 
738e			; stack over and underflow checks 
738e			 
738e			; init the words to detect the under/overflow 
738e			 
738e			chk_stk_init: 
738e				; a vague random number to check so we dont get any "lucky" hits 
738e 3e 2d			ld a, 45 
7390 6f				ld l, a 
7391 00				nop 
7392 3e 17			ld a, 23 
7394 67				ld h, a 
7395			 
7395 22 cf f0			ld (chk_word), hl     ; the word we need to check against 
7398			 
7398			;	ld (chk_stund), hl	; stack points.... 
7398 22 3b fe			ld (chk_stovr), hl 
739b 22 1e f9			ld (chk_ret_und), hl 
739e 22 dc f8			ld (chk_ret_ovr), hl 
73a1 22 5a f8			ld (chk_loop_ovr), hl 
73a4 22 58 f6			ld (chk_data_ovr), hl 
73a7 c9				ret 
73a8				 
73a8			check_stacks: 
73a8				; check all stack words 
73a8			 
73a8 e5				push hl 
73a9 d5				push de 
73aa			 
73aa			;	ld de,(chk_word) 
73aa			;	ld hl, (chk_stund)	; stack points.... 
73aa			;	if DEBUG_STK_FAULT 
73aa			;		DMARK "FAa" 
73aa			;		CALLMONITOR 
73aa			;	endif 
73aa			;	call cmp16 
73aa			;	jp z, .chk_faulta 
73aa			; 
73aa			;	ld de, sfaultsu 
73aa			;	jp .chk_fault 
73aa			 
73aa 2a 3b fe		.chk_faulta: ld hl, (chk_stovr) 
73ad ed 5b cf f0		ld de,(chk_word) 
73b1				if DEBUG_STK_FAULT 
73b1					DMARK "FAb" 
73b1					CALLMONITOR 
73b1				endif 
73b1 cd ca 0f			call cmp16 
73b4 28 06			jr z, .chk_fault1 
73b6 11 5a 74			ld de, sfaultso 
73b9 c3 0b 74			jp .chk_fault 
73bc			.chk_fault1:  
73bc 2a 1e f9			ld hl, (chk_ret_und) 
73bf ed 5b cf f0		ld de,(chk_word) 
73c3				if DEBUG_STK_FAULT 
73c3					DMARK "FAU" 
73c3					CALLMONITOR 
73c3				endif 
73c3 cd ca 0f			call cmp16 
73c6 ca cf 73			jp z, .chk_fault2 
73c9 11 6a 74			ld de, sfaultru 
73cc c3 0b 74			jp .chk_fault 
73cf			.chk_fault2:  
73cf 2a dc f8			ld hl, (chk_ret_ovr) 
73d2 ed 5b cf f0		ld de,(chk_word) 
73d6				if DEBUG_STK_FAULT 
73d6					DMARK "FA1" 
73d6					CALLMONITOR 
73d6				endif 
73d6 cd ca 0f			call cmp16 
73d9 ca e2 73			jp z, .chk_fault3 
73dc 11 78 74			ld de, sfaultro 
73df c3 0b 74			jp .chk_fault 
73e2			.chk_fault3:  
73e2 2a 5a f8			ld hl, (chk_loop_ovr) 
73e5 ed 5b cf f0		ld de,(chk_word) 
73e9				if DEBUG_STK_FAULT 
73e9					DMARK "FA2" 
73e9					CALLMONITOR 
73e9				endif 
73e9 cd ca 0f			call cmp16 
73ec ca f5 73			jp z, .chk_fault4 
73ef 11 92 74			ld de, sfaultlo 
73f2 c3 0b 74			jp .chk_fault 
73f5			.chk_fault4:  
73f5 2a 58 f6			ld hl, (chk_data_ovr) 
73f8 ed 5b cf f0		ld de,(chk_word) 
73fc				if DEBUG_STK_FAULT 
73fc					DMARK "FA3" 
73fc					CALLMONITOR 
73fc				endif 
73fc cd ca 0f			call cmp16 
73ff ca 08 74			jp z, .chk_fault5 
7402 11 ac 74			ld de, sfaultdo 
7405 c3 0b 74			jp .chk_fault 
7408			 
7408			 
7408			.chk_fault5:  
7408 d1				pop de 
7409 e1				pop hl 
740a			 
740a c9				ret 
740b			 
740b cd 7c 0d		.chk_fault: 	call clear_display 
740e 3e 28				ld a, display_row_2 
7410 cd 8e 0d				call str_at_display 
7413 11 3c 74				   ld de, .stackfault 
7416 3e 00				ld a, display_row_1 
7418 cd 8e 0d				call str_at_display 
741b 11 9d fd				    ld de, debug_mark 
741e 3e 11				ld a, display_row_1+17 
7420 cd 8e 0d				call str_at_display 
7423 cd 9e 0d				call update_display 
7426			 
7426				; prompt before entering montior for investigating issue 
7426			 
7426 3e 78			ld a, display_row_4 
7428 11 e1 1c			ld de, endprog 
742b			 
742b cd 9e 0d			call update_display		 
742e			 
742e cd 77 1f			call next_page_prompt 
7431			 
7431 d1				pop de 
7432 e1				pop hl 
7433 cd 35 1d				call monitor 
7436 cd 88 23				call forth_warmstart 
7439 c3 33 1c				jp warmstart_afterauto 
743c					;jp 0 
743c					;halt 
743c			 
743c			 
743c			 
743c .. 00		.stackfault: 	db "Stack fault:",0 
7449			 
7449 .. 00		sfaultsu: 	db	"Stack under flow",0 
745a .. 00		sfaultso: 	db	"Stack over flow",0 
746a .. 00		sfaultru:	db "RTS underflow",0 
7478 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
7492 .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
74ac .. 00		sfaultdo:	db "DTS overflow", 0 
74b9			 
74b9			 
74b9			fault_dsp_under: 
74b9 11 cb 74			ld de, .dsp_under 
74bc c3 81 75			jp .show_fault 
74bf			 
74bf			fault_rsp_under: 
74bf 11 d9 74			ld de, .rsp_under 
74c2 c3 81 75			jp .show_fault 
74c5			fault_loop_under: 
74c5 11 e7 74			ld de, .loop_under 
74c8 c3 81 75			jp .show_fault 
74cb			 
74cb .. 00		.dsp_under: db "DSP Underflow",0 
74d9 .. 00		.rsp_under: db "RSP Underflow",0 
74e7 .. 00		.loop_under: db "LOOP Underflow",0 
74f6			 
74f6			 
74f6 d5			type_faultn: 	push de 
74f7 e5					push hl 
74f8 cd 7c 0d				call clear_display 
74fb 11 25 75				   ld de, .typefaultn 
74fe 3e 00				ld a, display_row_1 
7500 cd 8e 0d				call str_at_display 
7503 11 9d fd				    ld de, debug_mark 
7506 3e 11				ld a, display_row_1+17 
7508 cd 8e 0d				call str_at_display 
750b cd 9e 0d				call update_display 
750e			 
750e				; prompt before entering montior for investigating issue 
750e			 
750e 3e 78			ld a, display_row_4 
7510 11 e1 1c			ld de, endprog 
7513			 
7513 cd 9e 0d			call update_display		 
7516			 
7516 cd 77 1f			call next_page_prompt 
7519			 
7519 e5					push hl 
751a d5					push de 
751b cd 35 1d				call monitor 
751e cd 88 23				call forth_warmstart 
7521 c3 33 1c				jp warmstart_afterauto 
7524 76					halt 
7525			 
7525			 
7525 .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
753c			 
753c d5			type_faults: 	push de 
753d e5					push hl 
753e cd 7c 0d				call clear_display 
7541 11 6a 75				   ld de, .typefaults 
7544 3e 00				ld a, display_row_1 
7546 cd 8e 0d				call str_at_display 
7549 11 9d fd				    ld de, debug_mark 
754c 3e 11				ld a, display_row_1+17 
754e cd 8e 0d				call str_at_display 
7551 cd 9e 0d				call update_display 
7554			 
7554				; prompt before entering montior for investigating issue 
7554			 
7554 3e 78			ld a, display_row_4 
7556 11 e1 1c			ld de, endprog 
7559			 
7559 cd 9e 0d			call update_display		 
755c			 
755c cd 77 1f			call next_page_prompt 
755f			 
755f e1					pop hl 
7560 d1					pop de 
7561 cd 35 1d				call monitor 
7564 cd 88 23				call forth_warmstart 
7567 c3 33 1c				jp warmstart_afterauto 
756a			 
756a			 
756a .. 00		.typefaults: db "STR Type Expected TOS!",0 
7581			 
7581			.show_fault: 	 
7581 d5					push de 
7582 cd 7c 0d				call clear_display 
7585 d1					pop de 
7586 3e 00				ld a, display_row_1 
7588 cd 8e 0d				call str_at_display 
758b 11 9d fd				    ld de, debug_mark 
758e 3e 11				ld a, display_row_1+17 
7590 cd 8e 0d				call str_at_display 
7593 cd 9e 0d				call update_display 
7596			 
7596				; prompt before entering montior for investigating issue 
7596			 
7596 3e 78			ld a, display_row_4 
7598 11 e1 1c			ld de, endprog 
759b			 
759b cd 9e 0d			call update_display		 
759e			 
759e cd 77 1f			call next_page_prompt 
75a1			 
75a1 e1					pop hl 
75a2 d1					pop de 
75a3 cd 35 1d				call monitor 
75a6			; do a dump to cli and not warmstart so we preserve all of the uwords.  
75a6			; TODO Make optional fault restart to cli or warm boot? 
75a6					;jp warmstart 
75a6 c3 76 1c				jp cli 
75a9 76					halt 
75aa			 
75aa			 
75aa			; handle the auto run of code from files in storage 
75aa			 
75aa			 
75aa			include "forth_startup.asm" 
75aa			; Which startup method to use? 
75aa			; 
75aa			; version 1 - allows for a single stored file to be selected to run at start up (if se storage is enabled) 
75aa			; followed by loading of a list of scripts in eeprom 
75aa			 
75aa			; version 2 - if se storage is enabled then auto load all files which begin with a '*' else use loading 
75aa			; from eeprom 
75aa			 
75aa			; Select with define in main stubs 
75aa			 
75aa			if STARTUP_V1 
75aa				include "forth_startupv1.asm" 
75aa			endif 
75aa			if STARTUP_V2 
75aa				include "forth_startupv2.asm" 
75aa			; Version 2 of the startup  
75aa			;  
75aa			; Auto load any files in bank 1 that start with a '*' 
75aa			; If no se storage then revert to using eprom 
75aa			 
75aa			 
75aa			if STORAGE_SE = 0 
75aa			 
75aa			sprompt1: db "Startup load...",0 
75aa			sprompt2: db "Run? 1=No *=End #=All",0 
75aa			 
75aa			 
75aa			 
75aa			 
75aa			forth_startup: 
75aa				ld hl, startcmds 
75aa				ld a, 0 
75aa				ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
75aa			 
75aa			.start1:	push hl 
75aa				call clear_display 
75aa				ld de, sprompt1 
75aa			        ld a, display_row_1 
75aa				call str_at_display 
75aa				ld de, sprompt2 
75aa			        ld a, display_row_2 
75aa				call str_at_display 
75aa				pop hl 
75aa				push hl 
75aa				ld e,(hl) 
75aa				inc hl 
75aa				ld d,(hl) 
75aa			        ld a, display_row_3 
75aa				call str_at_display 
75aa				call update_display 
75aa			 
75aa			 
75aa				ld a, (os_last_cmd) 
75aa			;	cp 0 
75aa				or a 
75aa				jr z, .startprompt 
75aa				call delay250ms 
75aa				jr .startdo 
75aa				 
75aa				 
75aa			 
75aa			.startprompt: 
75aa			 
75aa				ld a,display_row_4 + display_cols - 1 
75aa			        ld de, endprg 
75aa				call str_at_display 
75aa				call update_display 
75aa				call delay1s 
75aa				call cin_wait 
75aa						 
75aa				cp '*' 
75aa				jr z, .startupend1 
75aa				cp '#' 
75aa				jr nz, .startno 
75aa				ld a, 1 
75aa				ld (os_last_cmd),a 
75aa				jr .startdo 
75aa			.startno:	cp '1' 
75aa				jr z,.startnxt  
75aa			 
75aa				; exec startup line 
75aa			.startdo:	 
75aa				pop hl 
75aa				push hl 
75aa				 
75aa				ld e,(hl) 
75aa				inc hl 
75aa				ld d,(hl) 
75aa				ex de,hl 
75aa			 
75aa				push hl 
75aa			 
75aa				ld a, 0 
75aa				;ld a, FORTH_END_BUFFER 
75aa				call strlent 
75aa				inc hl   ; include zero term to copy 
75aa				ld b,0 
75aa				ld c,l 
75aa				pop hl 
75aa				ld de, scratch 
75aa				ldir 
75aa			 
75aa			 
75aa				ld hl, scratch 
75aa				call forthparse 
75aa				call forthexec 
75aa				call forthexec_cleanup 
75aa			 
75aa				ld a, display_row_4 
75aa				ld de, endprog 
75aa			 
75aa				call update_display		 
75aa			 
75aa				ld a, (os_last_cmd) 
75aa			;	cp 0 
75aa				or a 
75aa				jr nz, .startnxt 
75aa				call next_page_prompt 
75aa			        call clear_display 
75aa				call update_display		 
75aa			 
75aa				; move onto next startup line? 
75aa			.startnxt: 
75aa			 
75aa				call delay250ms 
75aa				pop hl 
75aa			 
75aa				inc hl 
75aa				inc hl 
75aa			 
75aa				push hl 
75aa				ld e, (hl) 
75aa				inc hl 
75aa				ld d, (hl) 
75aa				pop hl 
75aa				; TODO replace 0 test 
75aa			 
75aa				ex de, hl 
75aa				call ishlzero 
75aa			;	ld a,e 
75aa			;	add d 
75aa			;	cp 0    ; any left to do? 
75aa				ex de, hl 
75aa				jp nz, .start1 
75aa				jr .startupend 
75aa			 
75aa			.startupend1: pop hl 
75aa			.startupend: 
75aa			 
75aa				call clear_display 
75aa				call update_display 
75aa				ret 
75aa			endif 
75aa			 
75aa			 
75aa			if STORAGE_SE 
75aa			 
75aa			;sprompt3: db "Loading from start-up file:",0 
75aa .. 00		sprompt3: db "  Searching...",0 
75b9			;sprompt4: db "(Any key to stop)",0 
75b9			 
75b9			 
75b9			forth_autoload: 
75b9			 
75b9				; load block 0 of store 1 
75b9				 
75b9 3e fe			ld a, $fe      ; bit 0 clear 
75bb 32 92 f9			ld (spi_device), a 
75be			 
75be cd 05 05			call storage_get_block_0 
75c1			 
75c1 3a cd f9			ld a, (store_page+STORE_0_AUTOFILE) 
75c4			 
75c4			;	cp 0 
75c4 b7				or a 
75c5 c8				ret z     ; auto start not enabled 
75c6			 
75c6 cd 7c 0d			call clear_display 
75c9			 
75c9				; set bank 
75c9			 
75c9 3a cf f9				ld a, (store_page+STORE_0_BANKRUN) 
75cc 32 92 f9				ld (spi_device), a 
75cf 3a d1 f9				ld a, (store_page+STORE_0_BANKRUNN) 
75d2 32 91 f9				ld (spi_device_id), a 
75d5			 
75d5			 
75d5				; generate a directory of bank 1 and search for flagged files 
75d5			 
75d5					if DEBUG_FORTH_WORDS_KEY 
75d5						DMARK "DIR" 
75d5 f5				push af  
75d6 3a ea 75			ld a, (.dmark)  
75d9 32 9d fd			ld (debug_mark),a  
75dc 3a eb 75			ld a, (.dmark+1)  
75df 32 9e fd			ld (debug_mark+1),a  
75e2 3a ec 75			ld a, (.dmark+2)  
75e5 32 9f fd			ld (debug_mark+2),a  
75e8 18 03			jr .pastdmark  
75ea ..			.dmark: db "DIR"  
75ed f1			.pastdmark: pop af  
75ee			endm  
# End of macro DMARK
75ee						CALLMONITOR 
75ee cd aa fd			call debug_vector  
75f1				endm  
# End of macro CALLMONITOR
75f1					endif 
75f1			 
75f1 cd 05 05			call storage_get_block_0 
75f4			 
75f4 21 ac f9			ld hl, store_page     ; get current id count 
75f7 46				ld b, (hl) 
75f8 0e 00			ld c, 0    ; count of files   
75fa					if DEBUG_FORTH_WORDS 
75fa						DMARK "DI1" 
75fa f5				push af  
75fb 3a 0f 76			ld a, (.dmark)  
75fe 32 9d fd			ld (debug_mark),a  
7601 3a 10 76			ld a, (.dmark+1)  
7604 32 9e fd			ld (debug_mark+1),a  
7607 3a 11 76			ld a, (.dmark+2)  
760a 32 9f fd			ld (debug_mark+2),a  
760d 18 03			jr .pastdmark  
760f ..			.dmark: db "DI1"  
7612 f1			.pastdmark: pop af  
7613			endm  
# End of macro DMARK
7613						CALLMONITOR 
7613 cd aa fd			call debug_vector  
7616				endm  
# End of macro CALLMONITOR
7616					endif 
7616			 
7616				; check for empty drive 
7616			 
7616 3e 00			ld a, 0 
7618 b8				cp b 
7619 ca 66 76			jp z, .dirdone 
761c			 
761c				; for each of the current ids do a search for them and if found push to stack 
761c			 
761c c5			.diritem:	push bc 
761d 21 40 00				ld hl, STORE_BLOCK_PHY 
7620 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
7622 58					ld e,b 
7623			 
7623 d5					push de 
7624 e5					push hl 
7625 cd 7c 0d			call clear_display 
7628 3e 32			ld a, display_row_2 + 10 
762a 11 aa 75			ld de, sprompt3 
762d cd 8e 0d			call str_at_display 
7630 cd d4 0c			call active 
7633 eb				ex de, hl 
7634 3e 2f			ld a, display_row_2 + 7 
7636 cd 8e 0d			call str_at_display 
7639 cd 9e 0d			call update_display 
763c e1				pop hl 
763d d1				pop de 
763e			 
763e			;		if DEBUG_FORTH_WORDS 
763e			;			DMARK "DI2" 
763e			;			CALLMONITOR 
763e			;		endif 
763e			 
763e cd 83 07				call storage_findnextid 
7641			 
7641			;		if DEBUG_FORTH_WORDS 
7641			;			DMARK "DI3" 
7641			;			CALLMONITOR 
7641			;		endif 
7641			 
7641					; if found hl will be non zero 
7641			 
7641 cd d5 0f				call ishlzero 
7644			;		ld a, l 
7644			;		add h 
7644			; 
7644			;		cp 0 
7644 28 1d				jr z, .dirnotfound 
7646			 
7646					; increase count 
7646			 
7646 c1					pop bc	 
7647 0c					inc c 
7648 c5					push bc 
7649					 
7649			 
7649					; get file header and push the file name 
7649			 
7649 11 ac f9				ld de, store_page 
764c cd 57 04				call storage_read_block 
764f			 
764f					; push file id to stack 
764f				 
764f			 
764f					; is this a file we want to run? 
764f			 
764f 21 af f9				ld hl, store_page+3 
7652 7e					ld a,(hl) 
7653 fe 2a				cp '*' 
7655 20 0c				jr nz,  .dirnotfound 
7657					 
7657			 
7657			 
7657 3a ac f9				ld a, (store_page) 
765a d5					push de 
765b e5					push hl 
765c c5					push bc 
765d cd 89 76				call .autorunf 
7660 c1					pop bc 
7661 e1					pop hl 
7662 d1					pop de 
7663			 
7663			 
7663			 
7663				; save this extent 
7663			 
7663					; push file name 
7663			;display file name to run 
7663			 
7663			;		ld hl, store_page+3 
7663			;		if DEBUG_FORTH_WORDS 
7663			;			DMARK "DI5" 
7663			;			CALLMONITOR 
7663			;		endif 
7663			; 
7663			;		 
7663			; 
7663			;		call forth_push_str 
7663			;		if DEBUG_FORTH_WORDS 
7663			;			DMARK "DI6" 
7663			;			CALLMONITOR 
7663			;		endif 
7663			.dirnotfound: 
7663 c1					pop bc     
7664 10 b6				djnz .diritem 
7666				 
7666			.dirdone:	 
7666					if DEBUG_FORTH_WORDS 
7666						DMARK "DI7" 
7666 f5				push af  
7667 3a 7b 76			ld a, (.dmark)  
766a 32 9d fd			ld (debug_mark),a  
766d 3a 7c 76			ld a, (.dmark+1)  
7670 32 9e fd			ld (debug_mark+1),a  
7673 3a 7d 76			ld a, (.dmark+2)  
7676 32 9f fd			ld (debug_mark+2),a  
7679 18 03			jr .pastdmark  
767b ..			.dmark: db "DI7"  
767e f1			.pastdmark: pop af  
767f			endm  
# End of macro DMARK
767f						CALLMONITOR 
767f cd aa fd			call debug_vector  
7682				endm  
# End of macro CALLMONITOR
7682					endif 
7682			 
7682 cd 7c 0d				call clear_display 
7685 cd 9e 0d				call update_display 
7688			 
7688 c9					ret 
7689			 
7689			 
7689			 
7689			 
7689			 
7689			.autorunf: 
7689			 
7689			 
7689				; get file id to load from and get the file name to display 
7689			 
7689			;		ld a, (store_page+STORE_0_FILERUN) 
7689			 
7689 2e 00				ld l, 0 
768b 67					ld h, a 
768c 11 ac f9				ld de, store_page 
768f			 
768f					if DEBUG_FORTH_WORDS 
768f						DMARK "ASp" 
768f f5				push af  
7690 3a a4 76			ld a, (.dmark)  
7693 32 9d fd			ld (debug_mark),a  
7696 3a a5 76			ld a, (.dmark+1)  
7699 32 9e fd			ld (debug_mark+1),a  
769c 3a a6 76			ld a, (.dmark+2)  
769f 32 9f fd			ld (debug_mark+2),a  
76a2 18 03			jr .pastdmark  
76a4 ..			.dmark: db "ASp"  
76a7 f1			.pastdmark: pop af  
76a8			endm  
# End of macro DMARK
76a8						CALLMONITOR 
76a8 cd aa fd			call debug_vector  
76ab				endm  
# End of macro CALLMONITOR
76ab					endif 
76ab cd a7 09				call storage_read 
76ae			 
76ae					if DEBUG_FORTH_WORDS 
76ae						DMARK "ASr" 
76ae f5				push af  
76af 3a c3 76			ld a, (.dmark)  
76b2 32 9d fd			ld (debug_mark),a  
76b5 3a c4 76			ld a, (.dmark+1)  
76b8 32 9e fd			ld (debug_mark+1),a  
76bb 3a c5 76			ld a, (.dmark+2)  
76be 32 9f fd			ld (debug_mark+2),a  
76c1 18 03			jr .pastdmark  
76c3 ..			.dmark: db "ASr"  
76c6 f1			.pastdmark: pop af  
76c7			endm  
# End of macro DMARK
76c7						CALLMONITOR 
76c7 cd aa fd			call debug_vector  
76ca				endm  
# End of macro CALLMONITOR
76ca					endif 
76ca			 
76ca cd d5 0f				call ishlzero 
76cd c8					ret z             ; file not found 
76ce			 
76ce					; display file name we are loading 
76ce			 
76ce cd 7c 0d				call clear_display 
76d1			 
76d1 3e 32				ld a, display_row_2 + 10 
76d3 11 af f9				ld de, store_page+3 
76d6 cd 8e 0d				call str_at_display 
76d9				 
76d9			; 
76d9			 
76d9			;	ld a, display_row_1+5 
76d9			;	ld de, sprompt3 
76d9			;	call str_at_display 
76d9			;	ld a, display_row_2+7 
76d9			;	call active 
76d9			;	ex de, hl 
76d9			;;	ld de, sprompt4 
76d9			;	call str_at_display 
76d9			; 
76d9 cd 9e 0d			call update_display 
76dc			 
76dc			;	call cin_wait 
76dc			;	cp 'n' 
76dc			;	ret z 
76dc			;	cp 'N' 
76dc			;	ret z 
76dc			 
76dc			;	call delay1s 
76dc			 
76dc 3a ae f9			ld a, (store_page+2) 
76df 32 9b f9			ld (store_openmaxext), a    ; save count of ext 
76e2 3e 01			ld a, 1  
76e4 32 9c f9			ld (store_openext), a    ; save count of ext 
76e7			 
76e7			.autof: 
76e7				; begin to read a line from file 
76e7			 
76e7 21 1a f4			ld hl, os_cli_cmd 
76ea 22 18 f6			ld (os_var_array), hl     ; somewhere to hold the line construction pointer 
76ed			  
76ed			.readext: 
76ed 3a 9c f9			ld a, (store_openext) 
76f0 6f				ld l , a 
76f1				 
76f1 3a ac f9			ld a, (store_page) 
76f4 67				ld h, a	 
76f5 11 ac f9			ld de, store_page 
76f8					if DEBUG_FORTH_WORDS 
76f8						DMARK "ASl" 
76f8 f5				push af  
76f9 3a 0d 77			ld a, (.dmark)  
76fc 32 9d fd			ld (debug_mark),a  
76ff 3a 0e 77			ld a, (.dmark+1)  
7702 32 9e fd			ld (debug_mark+1),a  
7705 3a 0f 77			ld a, (.dmark+2)  
7708 32 9f fd			ld (debug_mark+2),a  
770b 18 03			jr .pastdmark  
770d ..			.dmark: db "ASl"  
7710 f1			.pastdmark: pop af  
7711			endm  
# End of macro DMARK
7711						CALLMONITOR 
7711 cd aa fd			call debug_vector  
7714				endm  
# End of macro CALLMONITOR
7714					endif 
7714 cd a7 09				call storage_read 
7717 cd d5 0f			call ishlzero 
771a c8				ret z 
771b			 
771b			; TODO copy to exec buffer 
771b			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
771b			 
771b				; copy the record buffer to the cli buffer 
771b			 
771b ed 5b 18 f6		ld de, (os_var_array) 
771f 21 ae f9			ld hl, store_page+2 
7722			;	ex de, hl 
7722 01 3e 00			ld bc, STORE_BLOCK_PHY-2   ; two for the file ids 
7725 ed b0			ldir 
7727 ed 53 18 f6		ld (os_var_array), de 
772b				 
772b 3a 9c f9			ld a, (store_openext) 
772e 3c				inc a 
772f 32 9c f9			ld (store_openext), a    ; save count of ext 
7732			 
7732			 
7732			; check (store_readcont) if 0 then exec, if not then load on the end of the exec buffer until 0 
7732				 
7732 3a 9f f9			ld a, (store_readcont) 
7735			;	cp 0 
7735 b7				or a 
7736 20 b5			jr nz, .readext 
7738			 
7738			;	jr z, .autoend 
7738			 
7738					if DEBUG_FORTH_WORDS 
7738						DMARK "ASc" 
7738 f5				push af  
7739 3a 4d 77			ld a, (.dmark)  
773c 32 9d fd			ld (debug_mark),a  
773f 3a 4e 77			ld a, (.dmark+1)  
7742 32 9e fd			ld (debug_mark+1),a  
7745 3a 4f 77			ld a, (.dmark+2)  
7748 32 9f fd			ld (debug_mark+2),a  
774b 18 03			jr .pastdmark  
774d ..			.dmark: db "ASc"  
7750 f1			.pastdmark: pop af  
7751			endm  
# End of macro DMARK
7751						CALLMONITOR 
7751 cd aa fd			call debug_vector  
7754				endm  
# End of macro CALLMONITOR
7754					endif 
7754 e5				push hl	 
7755 d5				push de 
7756 cd d4 0c			call active 
7759 eb				ex de, hl 
775a 3e 2f			ld a, display_row_2 + 7 
775c cd 8e 0d			call str_at_display 
775f			 
775f cd 9e 0d			call update_display 
7762 d1				pop de  
7763 e1				pop hl 
7764			;	call delay250ms 
7764			 
7764			 
7764			 
7764			 
7764			.autoexec: 
7764			 
7764			 
7764 21 1a f4			ld hl, os_cli_cmd 
7767					if DEBUG_FORTH_WORDS 
7767						DMARK "ASx" 
7767 f5				push af  
7768 3a 7c 77			ld a, (.dmark)  
776b 32 9d fd			ld (debug_mark),a  
776e 3a 7d 77			ld a, (.dmark+1)  
7771 32 9e fd			ld (debug_mark+1),a  
7774 3a 7e 77			ld a, (.dmark+2)  
7777 32 9f fd			ld (debug_mark+2),a  
777a 18 03			jr .pastdmark  
777c ..			.dmark: db "ASx"  
777f f1			.pastdmark: pop af  
7780			endm  
# End of macro DMARK
7780						CALLMONITOR 
7780 cd aa fd			call debug_vector  
7783				endm  
# End of macro CALLMONITOR
7783					endif 
7783 cd 28 24			call forthparse 
7786 cd 60 24			call forthexec 
7789 cd 82 23			call forthexec_cleanup 
778c			 
778c			 
778c			 
778c c3 e7 76			jp .autof 
778f			;.autofdone: 
778f			; 
778f			;		if DEBUG_FORTH_WORDS 
778f			;			DMARK "ASx" 
778f			;			CALLMONITOR 
778f			;		endif 
778f			;;	call clear_display 
778f			;	ret 
778f			 
778f			 
778f			 
778f			endif 
# End of file forth_startupv2.asm
778f			endif 
778f			 
# End of file forth_startup.asm
778f			 
778f			; eof 
# End of file forth_kernel.asm
778f			;include "nascombasic.asm" 
778f			;include "basicZ80.asm" 
778f			 
778f			 
778f			 
778f			; find out where the code ends if loaded into RAM (for SC114) 
778f			;endofcode:  
778f			;	nop 
778f			 
778f			 
778f			; jump to nmi vector 
778f			 
778f			init_nmi: 
778f 3e c9			ld a, $c9   ; RET 
7791 32 ad fd			ld (nmi_vector), a 
7794 c9				ret 
7795			nmi: 
7795 e5				push hl 
7796 d5				push de 
7797 c5				push bc 
7798 f5				push af 
7799 cd ad fd			call nmi_vector 
779c f5				push af 
779d c5				push bc 
779e d5				push de 
779f e5				push hl 
77a0 ed 4d			reti 
77a2			 
77a2			 
77a2			; eof 
77a2			 
# End of file main.asm
77a2			include "firmware_lcd_4x40.asm" 
77a2			; **********************************************************************  
77a2			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
77a2			; **********************************************************************  
77a2			;  
77a2			; **  Written as a Small Computer Monitor App  
77a2			; **  www.scc.me.uk  
77a2			;  
77a2			; History  
77a2			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
77a2			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
77a2			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
77a2			;  
77a2			; **********************************************************************  
77a2			;  
77a2			; This program is an example of one of the methods of interfacing an   
77a2			; alphanumeric LCD module.   
77a2			;  
77a2			; In this example the display is connected to either a Z80 PIO or a   
77a2			; simple 8-bit output port.   
77a2			;  
77a2			; This interfacing method uses 4-bit data mode and uses time delays  
77a2			; rather than polling the display's ready status. As a result the   
77a2			; interface only requires 6 simple output lines:  
77a2			;   Output bit 0 = not used  
77a2			;   Output bit 1 = not used  
77a2			;   Output bit 2 = RS         High = data, Low = instruction  
77a2			;   Output bit 3 = E          Active high  
77a2			;   Output bit 4 = DB4  
77a2			;   Output bit 5 = DB5  
77a2			;   Output bit 6 = DB6  
77a2			;   Output bit 7 = DB7  
77a2			; Display's R/W is connected to 0v so it is always in write mode  
77a2			;  
77a2			; This set up should work with any system supporting the RC2014 bus  
77a2			  
77a2			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
77a2			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
77a2			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
77a2			;  
77a2			; **********************************************************************  
77a2			  
77a2			; Additonal for 4x40. E1 and E2 instead of just E   
77a2			; TODO swipe vidout signal on port a to activate E2  
77a2			  
77a2			; **********************************************************************  
77a2			; **  Constants  
77a2			; **********************************************************************  
77a2			; LCD constants required by LCD support module  
77a2			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
77a2			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
77a2			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
77a2			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
77a2			; TODO Decide which E is being set  
77a2			kLCDWidth:  EQU display_cols             ;Width in characters  
77a2			  
77a2			; **********************************************************************  
77a2			; **  Code library usage  
77a2			; **********************************************************************  
77a2			  
77a2			; send character to current cursor position  
77a2			; wraps and/or scrolls screen automatically  
77a2			  
77a2			  
77a2			  
77a2			lcd_init:  
77a2			  
77a2			; SCMonAPI functions used  
77a2			  
77a2			; Alphanumeric LCD functions used  
77a2			; no need to specify specific functions for this module  
77a2			  
77a2 3e cf		            LD   A, 11001111b  
77a4 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
77a6 3e 00		            LD   A, 00000000b  
77a8 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
77aa			  
77aa			; Initialise alphanumeric LCD module  
77aa 3e 00				ld a, 0  
77ac 32 fd fa				ld (display_lcde1e2), a  
77af cd 30 78		            CALL fLCD_Init      ;Initialise LCD module  
77b2 3e 01				ld a, 1  
77b4 32 fd fa				ld (display_lcde1e2), a  
77b7 cd 30 78		            CALL fLCD_Init      ;Initialise LCD module  
77ba			  
77ba c9				ret  
77bb			  
77bb			;  
77bb			;;  
77bb			; lcd functions  
77bb			;  
77bb			;  
77bb			  
77bb			; what is at cursor position   
77bb			  
77bb			;get_cursor:	ld de, (cursor_row)   ;  row + col  
77bb			;		call curptr  
77bb			;		ret  
77bb			  
77bb			  
77bb			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
77bb			  
77bb			curptr:  
77bb c5				push bc  
77bc 21 e3 fc			ld hl, display_fb0  
77bf			cpr:	  
77bf				; loop for cursor whole row  
77bf 0e 28			ld c, display_cols  
77c1 23			cpr1:	inc hl  
77c2 0d				dec c  
77c3 20 fc			jr nz, cpr1  
77c5 05				dec b  
77c6 20 f7			jr nz, cpr  
77c8			  
77c8				; add col	  
77c8			  
77c8 23			cpr2:	inc hl  
77c9 1d				dec e  
77ca 20 fc			jr nz, cpr2  
77cc			  
77cc c1				pop bc  
77cd c9				ret  
77ce				  
77ce			  
77ce			  
77ce			  
77ce			  
77ce			; write the frame buffer given in hl to hardware   
77ce 22 fb fa		write_display: ld (display_write_tmp), hl 	   
77d1 3e 00			ld a, kLCD_Line1  
77d3 cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
77d6 06 28			ld b, display_cols  
77d8 ed 5b fb fa		ld de, (display_write_tmp)  
77dc cd 28 78			call write_len_string  
77df				  
77df				  
77df 2a fb fa			ld hl, (display_write_tmp)  
77e2 11 28 00			ld de, display_cols  
77e5 19				add hl,de  
77e6 22 fb fa			ld (display_write_tmp),hl  
77e9			  
77e9				  
77e9 3e 28			ld a, kLCD_Line2  
77eb cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
77ee 06 28			ld b, display_cols  
77f0 ed 5b fb fa		ld de, (display_write_tmp)  
77f4 cd 28 78			call write_len_string  
77f7				  
77f7 2a fb fa			ld hl, (display_write_tmp)  
77fa 11 28 00			ld de, display_cols  
77fd 19				add hl,de  
77fe 22 fb fa			ld (display_write_tmp),hl  
7801			  
7801				  
7801 3e 50			ld a, kLCD_Line3  
7803 cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7806 06 28			ld b, display_cols  
7808 ed 5b fb fa		ld de, (display_write_tmp)  
780c cd 28 78			call write_len_string  
780f				  
780f 2a fb fa			ld hl, (display_write_tmp)  
7812 11 28 00			ld de, display_cols  
7815 19				add hl,de  
7816 22 fb fa			ld (display_write_tmp),hl  
7819			  
7819				  
7819 3e 78			ld a, kLCD_Line4  
781b cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
781e 06 28			ld b, display_cols  
7820 ed 5b fb fa		ld de, (display_write_tmp)  
7824 cd 28 78			call write_len_string  
7827 c9					ret  
7828				  
7828				; write out a fixed length string given in b from de  
7828			  
7828 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
7829 cd 95 78		            CALL fLCD_Data      ;Write character to display  
782c 13				inc de  
782d 10 f9			djnz write_len_string  
782f c9				ret  
7830			  
7830			; Some other things to do  
7830			;            LD   A, kLCD_Clear ;Display clear  
7830			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
7830			;            LD   A, kLCD_Under ;Display on with underscore cursor  
7830			;            LD   A, kLCD_On     ;Display on with no cursor  
7830			;            ;LD   A, kLCD_Off   ;Display off  
7830			;            CALL fLCD_Inst      ;Send instruction to display  
7830			;  
7830			;  
7830			;            halt  
7830			;  
7830			;  
7830			;MsgHello:   DB  "Hello World!",0  
7830			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
7830			  
7830			; Custom characters 5 pixels wide by 8 pixels high  
7830			; Up to 8 custom characters can be defined  
7830			;BitMaps:      
7830			;; Character 0x00 = Battery icon  
7830			;            DB  01110b  
7830			;            DB  11011b  
7830			;            DB  10001b  
7830			;            DB  10001b  
7830			;            DB  11111b  
7830			;            DB  11111b  
7830			;            DB  11111b  
7830			;            DB  11111b  
7830			;; Character 0x01 = Bluetooth icon  
7830			;            DB  01100b  
7830			;            DB  01010b  
7830			;            DB  11100b  
7830			;            DB  01000b  
7830			;            DB  11100b  
7830			;            DB  01010b  
7830			;            DB  01100b  
7830			;            DB  00000b  
7830			;  
7830			  
7830			  
7830			; **********************************************************************  
7830			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
7830			; **********************************************************************  
7830			;  
7830			; **  Written as a Small Computer Monitor App   
7830			; **  Version 0.1 SCC 2018-05-16  
7830			; **  www.scc.me.uk  
7830			;  
7830			; **********************************************************************  
7830			;  
7830			; This module provides support for alphanumeric LCD modules using with  
7830			; *  HD44780 (or compatible) controller  
7830			; *  5 x 7 pixel fonts  
7830			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
7830			; *  Interface via six digital outputs to the display (see below)  
7830			;  
7830			; LCD module pinout:  
7830			;   1  Vss   0v supply  
7830			;   2  Vdd   5v supply  
7830			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
7830			;   4  RS    High = data, Low = instruction  
7830			;   5  R/W   High = Read, Low = Write  
7830			;   6  E     Enable signal (active high)  
7830			;   7  DB0   Data bit 0  
7830			;   8  DB1   Data bit 1  
7830			;   9  DB2   Data bit 2  
7830			;  10  DB3   Data bit 3  
7830			;  11  DB4   Data bit 4  
7830			;  12  DB5   Data bit 5  
7830			;  13  DB6   Data bit 6  
7830			;  14  DB7   Data bit 7  
7830			;  15  A     Backlight anode (+)  
7830			;  16  K     Backlight cathode (-)  
7830			;  
7830			; This interfacing method uses 4-bit data mode and uses time delays  
7830			; rather than polling the display's ready status. As a result the   
7830			; interface only requires 6 simple output lines:  
7830			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
7830			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
7830			;   LCD DB4 = Microcomputer output port bit 4  
7830			;   LCD DB5 = Microcomputer output port bit 5  
7830			;   LCD DB6 = Microcomputer output port bit 6  
7830			;   LCD DB7 = Microcomputer output port bit 7  
7830			; Display's R/W is connected to 0v so it is always in write mode  
7830			; All 6 connections must be on the same port address <kLCDPrt>  
7830			; This method also allows a decent length of cable from micro to LCD  
7830			;  
7830			; **********************************************************************  
7830			;  
7830			; To include the code for any given function provided by this module,   
7830			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
7830			; the parent source file.  
7830			; For example:  #REQUIRES   uHexPrefix  
7830			;  
7830			; Also #INCLUDE this file at some point after the #REQUIRES statements  
7830			; in the parent source file.  
7830			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
7830			;  
7830			; These are the function names provided by this module:  
7830			; fLCD_Init                     ;Initialise LCD  
7830			; fLCD_Inst                     ;Send instruction to LCD  
7830			; fLCD_Data                     ;Send data byte to LCD  
7830			; fLCD_Pos                      ;Position cursor  
7830			; fLCD_Str                      ;Display string  
7830			; fLCD_Def                      ;Define custom character  
7830			;  
7830			; **********************************************************************  
7830			;  
7830			; Requires SCMonAPI.asm to also be included in the project  
7830			;  
7830			  
7830			  
7830			; **********************************************************************  
7830			; **  Constants  
7830			; **********************************************************************  
7830			  
7830			; Constants that must be defined externally  
7830			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
7830			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
7830			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
7830			;kLCDWidth: EQU 20             ;Width in characters  
7830			  
7830			; general line offsets in any frame buffer  
7830			  
7830			  
7830			display_row_1: equ 0  
7830			display_row_2: equ display_row_1+display_cols  
7830			display_row_3: equ display_row_2 + display_cols  
7830			display_row_4: equ display_row_3 + display_cols  
7830			;display_row_4_eol:   
7830			  
7830			  
7830			; Cursor position values for the start of each line  
7830			  
7830			; E  
7830			kLCD_Line1: EQU 0x00   
7830			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
7830			; E1  
7830			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
7830			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
7830			  
7830			; Instructions to send as A register to fLCD_Inst  
7830			kLCD_Clear: EQU 00000001b     ;LCD clear  
7830			kLCD_Off:   EQU 00001000b     ;LCD off  
7830			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
7830			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
7830			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
7830			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
7830			  
7830			; Constants used by this code module  
7830			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
7830			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
7830			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
7830			  
7830			  
7830			  
7830			; **********************************************************************  
7830			; **  LCD support functions  
7830			; **********************************************************************  
7830			  
7830			; Initialise alphanumeric LCD module  
7830			; LCD control register codes:  
7830			;   DL   0 = 4-bit mode        1 = 8-bit mode  
7830			;   N    0 = 1-line mode       1 = 2-line mode  
7830			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
7830			;   D    0 = Display off       1 = Display on  
7830			;   C    0 = Cursor off        1 = Cursor on  
7830			;   B    0 = Blinking off      1 = Blinking on  
7830			;   ID   0 = Decrement mode    1 = Increment mode  
7830			;   SH   0 = Entire shift off  1 = Entire shift on  
7830 3e 28		fLCD_Init:  LD   A, 40  
7832 cd 57 79		            CALL LCDDelay       ;Delay 40ms after power up  
7835			; For reliable reset set 8-bit mode - 3 times  
7835 cd 27 79		            CALL WrFn8bit       ;Function = 8-bit mode  
7838 cd 27 79		            CALL WrFn8bit       ;Function = 8-bit mode  
783b cd 27 79		            CALL WrFn8bit       ;Function = 8-bit mode  
783e			; Set 4-bit mode  
783e cd 23 79		            CALL WrFn4bit       ;Function = 4-bit mode  
7841 cd 55 79		            CALL LCDDelay1      ;Delay 37 us or more  
7844			; Function set  
7844 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
7846 cd 59 78		            CALL fLCD_Inst      ;2 line, display on  
7849			; Display On/Off control  
7849 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
784b cd 59 78		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
784e			; Display Clear  
784e 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
7850 cd 59 78		            CALL fLCD_Inst      ;Clear display  
7853			; Entry mode  
7853 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
7855 cd 59 78		            CALL fLCD_Inst      ;Increment mode, shift off  
7858			; Display module now initialised  
7858 c9			            RET  
7859			; ok to here  
7859			  
7859			; Write instruction to LCD  
7859			;   On entry: A = Instruction byte to be written  
7859			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7859 f5			fLCD_Inst:  PUSH AF  
785a f5			            PUSH AF  
785b cd 6d 78		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
785e f1			            POP  AF  
785f 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
7860 17			            RLA  
7861 17			            RLA  
7862 17			            RLA  
7863 cd 6d 78		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
7866 3e 02		            LD   A, 2  
7868 cd 57 79		            CALL LCDDelay       ;Delay 2 ms to complete   
786b f1			            POP  AF  
786c c9			            RET  
786d			Wr4bits:   
786d f5					push af  
786e 3a fd fa				ld a, (display_lcde1e2)  
7871 fe 00				cp 0     ; e  
7873 20 10				jr nz, .wea2	  
7875 f1					pop af  
7876 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7878 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
787a cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
787c cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
787e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7880 cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
7882 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7884 c9			            RET  
7885 f1			.wea2:		pop af  
7886 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
7888 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
788a cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
788c cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
788e d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
7890 cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
7892 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7894 c9			            RET  
7895			  
7895			  
7895			; Write data to LCD  
7895			;   On entry: A = Data byte to be written  
7895			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7895 f5			fLCD_Data:  PUSH AF  
7896 f5			            PUSH AF  
7897 cd a9 78		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
789a f1			            POP  AF  
789b 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
789c 17			            RLA  
789d 17			            RLA  
789e 17			            RLA  
789f cd a9 78		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
78a2 3e 96		            LD   A, 150  
78a4 3d			Wait:      DEC  A              ;Wait a while to allow data   
78a5 20 fd		            JR   NZ, Wait      ;  write to complete  
78a7 f1			            POP  AF  
78a8 c9			            RET  
78a9			Wr4bitsa:     
78a9 f5					push af  
78aa 3a fd fa				ld a, (display_lcde1e2)  
78ad fe 00				cp 0     ; e1  
78af 20 16				jr nz, .we2	  
78b1 f1					pop af  
78b2 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
78b4 cb d7		            SET  kLCDBitRS, A  
78b6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
78b8 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
78ba cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
78bc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
78be cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
78c0 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
78c2 cb 97		            RES  kLCDBitRS, A  
78c4 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
78c6 c9			            RET  
78c7 f1			.we2:		pop af  
78c8 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
78ca cb d7		            SET  kLCDBitRS, A  
78cc d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
78ce cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
78d0 cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
78d2 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
78d4 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
78d6 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
78d8 cb 97		            RES  kLCDBitRS, A  
78da d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
78dc c9			            RET  
78dd			  
78dd			  
78dd			; Position cursor to specified location  
78dd			;   On entry: A = Cursor position  
78dd			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
78dd f5			fLCD_Pos:   PUSH AF  
78de					; at this point set the E1 or E2 flag depending on position  
78de			  
78de c5					push bc  
78df			;		push af  
78df 06 00				ld b, 0  
78e1 4f					ld c, a  
78e2 3e 4f				ld a, kLCD_Line3-1  
78e4 b7			 		or a      ;clear carry flag  
78e5 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
78e6 38 04				jr c, .pe1  
78e8			  
78e8					; E selection  
78e8 cb 80				res 0, b         ; bit 0 unset e  
78ea			;		pop af    ; before line 3 so recover orig pos  
78ea			;		ld c, a    ; save for poking back  
78ea 18 06				jr .peset	          
78ec			.pe1:          	; E2 selection  
78ec cb c0				set 0, b         ; bit 0 set e1  
78ee 79					ld a, c  
78ef de 4f				sbc a, kLCD_Line3-1  
78f1 4f					ld c, a	         ; save caculated offset  
78f2			;		pop af     ; bin this original value now we have calculated form  
78f2			  
78f2			.peset:		; set bit  
78f2 78					ld a, b  
78f3 32 fd fa				ld (display_lcde1e2), a 	  
78f6 79					ld a, c  
78f7 c1					pop bc  
78f8			  
78f8 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
78fa cd 59 78		            CALL fLCD_Inst      ;Write instruction to LCD  
78fd f1			            POP  AF  
78fe c9			            RET  
78ff			  
78ff			  
78ff			; Output text string to LCD  
78ff			;   On entry: DE = Pointer to null terminated text string  
78ff			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
78ff 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
7900 b7			            OR   A              ;Null terminator?  
7901 c8			            RET  Z              ;Yes, so finished  
7902 cd 95 78		            CALL fLCD_Data      ;Write character to display  
7905 13			            INC  DE             ;Point to next character  
7906 18 f7		            JR   fLCD_Str       ;Repeat  
7908 c9					ret  
7909			  
7909			; Define custom character  
7909			;   On entry: A = Character number (0 to 7)  
7909			;             DE = Pointer to character bitmap data  
7909			;   On exit:  A = Next character number  
7909			;             DE = Next location following bitmap  
7909			;             BC HL IX IY I AF' BC' DE' HL' preserved  
7909			; Character is   
7909 c5			fLCD_Def:   PUSH BC  
790a f5			            PUSH AF  
790b 07			            RLCA                ;Calculate location  
790c 07			            RLCA                ;  for bitmap data  
790d 07			            RLCA                ;  = 8 x CharacterNumber  
790e f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
7910 cd 59 78		            CALL fLCD_Inst      ;Write instruction to LCD  
7913 06 00		            LD   B, 0  
7915 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
7916 cd 95 78		            CALL fLCD_Data      ;Write byte to display  
7919 13			            INC  DE             ;Point to next byte  
791a 04			            INC  B              ;Count bytes  
791b cb 58		            BIT  3, B           ;Finish all 8 bytes?  
791d 28 f6		            JR   Z, Loop       ;No, so repeat  
791f f1			            POP  AF  
7920 3c			            INC  A              ;Increment character number  
7921 c1			            POP  BC  
7922 c9			            RET  
7923			  
7923			  
7923			; **********************************************************************  
7923			; **  Private functions  
7923			; **********************************************************************  
7923			  
7923			; Write function to LCD  
7923			;   On entry: A = Function byte to be written  
7923			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7923 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
7925 18 02		            JR   WrFunc  
7927 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
7929 f5			WrFunc:     PUSH AF  
792a f5					push af  
792b 3a fd fa				ld a, (display_lcde1e2)  
792e fe 00				cp 0     ; e1  
7930 20 0f				jr nz, .wfea2	  
7932 f1					pop af  
7933 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7935 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
7937 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
7939 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
793b cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
793d d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
793f 18 0d			jr .wfskip  
7941 f1			.wfea2:		pop af  
7942 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
7944 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
7946 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
7948 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
794a cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
794c d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
794e 3e 05		.wfskip:            LD  A, 5  
7950 cd 57 79		            CALL LCDDelay       ;Delay 5 ms to complete  
7953 f1			            POP  AF  
7954 c9			            RET  
7955			  
7955			  
7955			; Delay in milliseconds  
7955			;   On entry: A = Number of milliseconds delay  
7955			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
7955 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
7957 d5			LCDDelay:   PUSH DE  
7958 5f			            LD   E, A           ;Delay by 'A' ms  
7959 16 00		            LD   D, 0  
795b cd a5 0c		            CALL aDelayInMS  
795e d1			            POP  DE  
795f c9			            RET  
7960			  
7960			  
7960			testlcd:  
7960 3e 00			ld a, kLCD_Line1  
7962 cd dd 78			call fLCD_Pos  
7965 06 28			ld b, 40  
7967 11 95 79			ld de, .ttext1  
796a cd 28 78			call write_len_string  
796d			  
796d 3e 28			ld a, kLCD_Line2  
796f cd dd 78			call fLCD_Pos  
7972 06 28			ld b, 40  
7974 11 be 79			ld de, .ttext2  
7977 cd 28 78			call write_len_string  
797a 3e 50			ld a, kLCD_Line3  
797c cd dd 78			call fLCD_Pos  
797f 06 28			ld b, 40  
7981 11 e7 79			ld de, .ttext3  
7984 cd 28 78			call write_len_string  
7987 3e 78			ld a, kLCD_Line4  
7989 cd dd 78			call fLCD_Pos  
798c 06 28			ld b, 40  
798e 11 10 7a			ld de, .ttext4  
7991 cd 28 78			call write_len_string  
7994			  
7994 76				halt  
7995			  
7995			  
7995 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
79be .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
79e7 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
7a10 .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
7a39			   
7a39			  
7a39			  
7a39			; eof  
7a39			  
# End of file firmware_lcd_4x40.asm
7a39			;include "firmware_lcd_4x20.asm" 
7a39			include "firmware_key_5x10.asm" 
7a39			; 5 x 10 decade counter scanner  
7a39			  
7a39			  
7a39			; TODO do cursor shape change for shift keys  
7a39			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
7a39			  
7a39			  
7a39			; bit mask for each scan column and row for teing the matrix  
7a39			  
7a39			  
7a39			key_init:  
7a39			  
7a39			; SCMonAPI functions used  
7a39			  
7a39			; Alphanumeric LCD functions used  
7a39			; no need to specify specific functions for this module  
7a39			  
7a39			  
7a39 3e cf		            LD   A, 11001111b  
7a3b d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
7a3d			;            LD   A, 00000000b  
7a3d 3e 1f		            LD   A, 00011111b  
7a3f d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
7a41			  
7a41			  
7a41				; TODO Configure cursor shapes  
7a41			  
7a41				; Load cursor shapes   
7a41 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
7a43 11 53 7a		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
7a46 06 02		            LD   B, 2           ;Number of characters to define  
7a48 cd 09 79		.DefLoop:   CALL fLCD_Def       ;Define custom character  
7a4b 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
7a4d			  
7a4d 3e 01				ld a, 1  
7a4f 32 f3 fa			ld (cursor_shape),a  
7a52 c9				ret  
7a53			  
7a53			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
7a53			; Up to 8 custom characters can be defined  
7a53			.cursor_shapes:      
7a53			;; Character 0x00 = Normal  
7a53 1f			            DB  11111b  
7a54 1f			            DB  11111b  
7a55 1f			            DB  11111b  
7a56 1f			            DB  11111b  
7a57 1f			            DB  11111b  
7a58 1f			            DB  11111b  
7a59 1f			            DB  11111b  
7a5a 1f			            DB  11111b  
7a5b			;; Character 0x01 = Modifier  
7a5b 1f			            DB  11111b  
7a5c 1b			            DB  11011b  
7a5d 1b			            DB  11011b  
7a5e 1b			            DB  11011b  
7a5f 1b			            DB  11011b  
7a60 1f			            DB  11111b  
7a61 1b			            DB  11011b  
7a62 1f			            DB  11111b  
7a63			  
7a63			  
7a63			  
7a63			  
7a63			; Display custom character 0  
7a63			;            LD   A, kLCD_Line1+14  
7a63			;            CALL fLCD_Pos       ;Position cursor to location in A  
7a63			;            LD   A, 0  
7a63			;            CALL fLCD_Data      ;Write character in A at cursor  
7a63			  
7a63			; Display custom character 1  
7a63			;            LD   A, kLCD_Line2+14  
7a63			;            CALL fLCD_Pos      ;Position cursor to location in A  
7a63			;            LD   A, 1  
7a63			;            CALL fLCD_Data     ;Write character in A at cursor  
7a63			  
7a63			; keyboard scanning   
7a63			  
7a63			; character in from keyboard  
7a63			  
7a63			; mapping for the pcb layout  
7a63			  
7a63			.matrix_to_char:  
7a63 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
7a6e .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
7a79 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
7a84 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
7a8f .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
7a9a			.matrix_to_shift:  
7a9a			  
7a9a .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
7aa5 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
7ab0 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
7abb 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
7ac6 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
7ad1			  
7ad1			.matrix_to_symbolshift:  
7ad1			  
7ad1 fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
7adc .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
7ae7 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
7af2			;		db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
7af2 7e .. 5c 7e 00	    	 	db KEY_SHIFT,"<>,.:;'",92, KEY_SHIFT,0  
7afd .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
7b08			  
7b08			  
7b08			  
7b08			; mapping for a simple straight through breadboard layout  
7b08			  
7b08			;.matrix_to_char:  
7b08			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7b08			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
7b08			;		db "asdfghjkl",KEY_CR,0  
7b08			;		db "qwertyuiop",0  
7b08			;		 db "1234567890",0  
7b08			;.matrix_to_shift:  
7b08			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
7b08			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
7b08			;		db "ASDFGHJKL",KEY_CR,0  
7b08			;		db "QWERTYUIOP",0  
7b08			;		 db "!",'"',"#$%^&*()",0  
7b08			;.matrix_to_symbolshift:  
7b08			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
7b08			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
7b08			;		db "_?*fghjk=",KEY_CR,0  
7b08			;		db "-/+*[]{}@#",0  
7b08			;		 db "1234567890",0  
7b08			  
7b08			;.matrix_to_char: db "D#0*C987B654A321"  
7b08			  
7b08			  
7b08				  
7b08			  
7b08			; add cin and cin_wait  
7b08			  
7b08 cd 17 7b		cin_wait: 	call cin  
7b0b						if DEBUG_KEYCINWAIT  
7b0b							push af  
7b0b							  
7b0b							ld hl,key_repeat_ct  
7b0b							ld (hl),a  
7b0b							inc hl  
7b0b							call hexout  
7b0b							ld hl,key_repeat_ct+3  
7b0b			;				ld a,0  
7b0b							ld (hl),0  
7b0b			  
7b0b							    LD   A, kLCD_Line1+11  
7b0b							    CALL fLCD_Pos       ;Position cursor to location in A  
7b0b							    LD   DE, key_repeat_ct  
7b0b							    ;LD   DE, MsgHello  
7b0b							    CALL fLCD_Str       ;Display string pointed to by DE  
7b0b			  
7b0b			  
7b0b			  
7b0b							pop af  
7b0b						endif  
7b0b			;	cp 0  
7b0b b7				or a  
7b0c 28 fa			jr z, cin_wait   ; block until key press  
7b0e			  
7b0e							if DEBUG_KEYCINWAIT  
7b0e								push af  
7b0e			  
7b0e			;					ld a, 'A'	  
7b0e								ld hl,key_repeat_ct  
7b0e								ld (hl),'A'  
7b0e								inc hl  
7b0e			;					ld a,0  
7b0e								ld (hl),0  
7b0e			  
7b0e								    LD   A, kLCD_Line2+11  
7b0e								    CALL fLCD_Pos       ;Position cursor to location in A  
7b0e								    LD   DE, key_repeat_ct  
7b0e								    ;LD   DE, MsgHello  
7b0e								    CALL fLCD_Str       ;Display string pointed to by DE  
7b0e			  
7b0e							call delay500ms  
7b0e			  
7b0e								pop af  
7b0e							endif  
7b0e f5				push af   ; save key pressed  
7b0f			  
7b0f			.cin_wait1:	  
7b0f							if DEBUG_KEYCINWAIT  
7b0f								push af  
7b0f			  
7b0f			;					ld a, 'b'	  
7b0f								ld hl,key_repeat_ct  
7b0f								ld (hl),'b'  
7b0f								inc hl  
7b0f			;					ld a,0  
7b0f								ld (hl),0  
7b0f			  
7b0f								    LD   A, kLCD_Line2+11  
7b0f								    CALL fLCD_Pos       ;Position cursor to location in A  
7b0f								    LD   DE, key_repeat_ct  
7b0f								    ;LD   DE, MsgHello  
7b0f								    CALL fLCD_Str       ;Display string pointed to by DE  
7b0f			  
7b0f			  
7b0f							call delay500ms  
7b0f			  
7b0f								pop af  
7b0f							endif  
7b0f			  
7b0f cd 17 7b		call cin  
7b12			;	cp 0  
7b12 b7				or a  
7b13 20 fa			jr nz, .cin_wait1  	; wait for key release  
7b15			if DEBUG_KEYCINWAIT  
7b15				push af  
7b15			  
7b15			;	ld a, '3'	  
7b15				ld hl,key_repeat_ct  
7b15				ld (hl),'3'  
7b15				inc hl  
7b15			;	ld a,0  
7b15				ld (hl),0  
7b15			  
7b15			            LD   A, kLCD_Line2+11  
7b15			            CALL fLCD_Pos       ;Position cursor to location in A  
7b15			            LD   DE, key_repeat_ct  
7b15			            ;LD   DE, MsgHello  
7b15			            CALL fLCD_Str       ;Display string pointed to by DE  
7b15			  
7b15			  
7b15			call delay500ms  
7b15			  
7b15				pop af  
7b15			endif  
7b15			  
7b15 f1				pop af   ; get key  
7b16 c9				ret  
7b17			  
7b17			  
7b17			; cin - key non-blocking except for keybounce release  
7b17			  
7b17 cd 33 7b		cin: 	call .mtoc  
7b1a			  
7b1a			if DEBUG_KEYCIN  
7b1a				push af  
7b1a				  
7b1a				ld hl,key_repeat_ct  
7b1a				ld (hl),a  
7b1a				inc hl  
7b1a				call hexout  
7b1a				ld hl,key_repeat_ct+3  
7b1a			;	ld a,0  
7b1a				ld (hl),0  
7b1a			  
7b1a			            LD   A, kLCD_Line3+15  
7b1a			            CALL fLCD_Pos       ;Position cursor to location in A  
7b1a			            LD   DE, key_repeat_ct  
7b1a			            ;LD   DE, MsgHello  
7b1a			            CALL fLCD_Str       ;Display string pointed to by DE  
7b1a			  
7b1a			  
7b1a			call delay500ms  
7b1a			  
7b1a				pop af  
7b1a			endif  
7b1a			  
7b1a			  
7b1a				; no key held  
7b1a			;	cp 0  
7b1a b7				or a  
7b1b c8				ret z  
7b1c			  
7b1c			if DEBUG_KEYCIN  
7b1c				push af  
7b1c			  
7b1c			;	ld a, '1'	  
7b1c				ld hl,key_repeat_ct  
7b1c				ld (hl),'1'  
7b1c				inc hl  
7b1c			;	ld a,0  
7b1c				ld (hl),0  
7b1c			  
7b1c			            LD   A, kLCD_Line4+15  
7b1c			            CALL fLCD_Pos       ;Position cursor to location in A  
7b1c			            LD   DE, key_repeat_ct  
7b1c			            ;LD   DE, MsgHello  
7b1c			            CALL fLCD_Str       ;Display string pointed to by DE  
7b1c			  
7b1c			  
7b1c			call delay500ms  
7b1c			  
7b1c				pop af  
7b1c			endif  
7b1c			  
7b1c				; stop key bounce  
7b1c			  
7b1c 32 c6 fd			ld (key_held),a		 ; save it  
7b1f 47				ld b, a  
7b20			  
7b20 c5			.cina1:	push bc  
7b21			if DEBUG_KEYCIN  
7b21				push af  
7b21			  
7b21				ld hl,key_repeat_ct  
7b21				inc hl  
7b21				call hexout  
7b21				ld hl,key_repeat_ct+3  
7b21			;	ld a,0  
7b21				ld (hl),0  
7b21				ld hl,key_repeat_ct  
7b21			;	ld a, '2'	  
7b21				ld (hl),'2'  
7b21			  
7b21			            LD   A, kLCD_Line4+15  
7b21			            CALL fLCD_Pos       ;Position cursor to location in A  
7b21			            LD   DE, key_repeat_ct  
7b21			            ;LD   DE, MsgHello  
7b21			            CALL fLCD_Str       ;Display string pointed to by DE  
7b21			  
7b21				pop af  
7b21			endif  
7b21 cd 33 7b			call .mtoc  
7b24 c1				pop bc  
7b25 b8				cp b  
7b26 28 f8			jr z, .cina1  
7b28 78				ld a,b		  
7b29			if DEBUG_KEYCIN  
7b29				push af  
7b29			  
7b29				ld hl,key_repeat_ct  
7b29				inc hl  
7b29				call hexout  
7b29				ld hl,key_repeat_ct+3  
7b29			;	ld a,0  
7b29				ld (hl),0  
7b29				ld hl,key_repeat_ct  
7b29			;	ld a, '3'	  
7b29				ld (hl),'3'  
7b29			  
7b29			            LD   A, kLCD_Line4+15  
7b29			            CALL fLCD_Pos       ;Position cursor to location in A  
7b29			            LD   DE, key_repeat_ct  
7b29			            ;LD   DE, MsgHello  
7b29			            CALL fLCD_Str       ;Display string pointed to by DE  
7b29			  
7b29				pop af  
7b29			endif  
7b29 c9				ret  
7b2a			  
7b2a			; cinndb - key non-blocking without keybounce release  
7b2a			  
7b2a cd 33 7b		cinndb: 	call .mtoc  
7b2d			  
7b2d			if DEBUG_KEYCIN  
7b2d				push af  
7b2d				  
7b2d				ld hl,key_repeat_ct  
7b2d				ld (hl),a  
7b2d				inc hl  
7b2d				call hexout  
7b2d				ld hl,key_repeat_ct+3  
7b2d			;	ld a,0  
7b2d				ld (hl),0  
7b2d			  
7b2d			            LD   A, kLCD_Line3+15  
7b2d			            CALL fLCD_Pos       ;Position cursor to location in A  
7b2d			            LD   DE, key_repeat_ct  
7b2d			            ;LD   DE, MsgHello  
7b2d			            CALL fLCD_Str       ;Display string pointed to by DE  
7b2d			  
7b2d			  
7b2d			call delay500ms  
7b2d			  
7b2d				pop af  
7b2d			endif  
7b2d			  
7b2d			  
7b2d				; no key held  
7b2d			;	cp 0  
7b2d b7				or a  
7b2e c8				ret z  
7b2f			  
7b2f			if DEBUG_KEYCIN  
7b2f				push af  
7b2f			  
7b2f			;	ld a, '1'	  
7b2f				ld hl,key_repeat_ct  
7b2f				ld (hl),'1'  
7b2f				inc hl  
7b2f			;	ld a,0  
7b2f				ld (hl),0  
7b2f			  
7b2f			            LD   A, kLCD_Line4+15  
7b2f			            CALL fLCD_Pos       ;Position cursor to location in A  
7b2f			            LD   DE, key_repeat_ct  
7b2f			            ;LD   DE, MsgHello  
7b2f			            CALL fLCD_Str       ;Display string pointed to by DE  
7b2f			  
7b2f			  
7b2f			call delay500ms  
7b2f			  
7b2f				pop af  
7b2f			endif  
7b2f			  
7b2f 32 c6 fd			ld (key_held),a		 ; save it  
7b32			  
7b32			if DEBUG_KEYCIN  
7b32				push af  
7b32			  
7b32				ld hl,key_repeat_ct  
7b32				inc hl  
7b32				call hexout  
7b32				ld hl,key_repeat_ct+3  
7b32			;	ld a,0  
7b32				ld (hl),0  
7b32				ld hl,key_repeat_ct  
7b32			;	ld a, '3'	  
7b32				ld (hl),'3'  
7b32			  
7b32			            LD   A, kLCD_Line4+15  
7b32			            CALL fLCD_Pos       ;Position cursor to location in A  
7b32			            LD   DE, key_repeat_ct  
7b32			            ;LD   DE, MsgHello  
7b32			            CALL fLCD_Str       ;Display string pointed to by DE  
7b32			  
7b32				pop af  
7b32			endif  
7b32 c9				ret  
7b33			; detect keyboard modifier key press and apply new overlay to the face key held  
7b33			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
7b33			  
7b33			;.cin_map_modifier:   
7b33			;	ld a, (hl)  
7b33			;	and 255  
7b33			;	ret NZ		; modifier key not flagged  
7b33			;  
7b33			;	; get key face  
7b33			;  
7b33			;	ld b,(key_face_held)  
7b33			;  
7b33			;	ld b, key_cols * key_rows  
7b33			;  
7b33			;	push de  
7b33			;	pop hl  
7b33			;  
7b33			;.mmod1: ld a,(hl)   ; get map test  
7b33			;	cp b  
7b33			;	jr z, .mmod2  
7b33			;  
7b33			;  
7b33			;  
7b33			;.mmod2: inc hl    ;   
7b33			;  
7b33			;	  
7b33			;  
7b33			;	  
7b33			;  
7b33			;	ld hl,key_actual_pressed  
7b33			;	ld (hl),a,  
7b33			;	ret  
7b33			  
7b33			; map matrix key held to char on face of key  
7b33			  
7b33			.mtoc:  
7b33			  
7b33			; test decade counter strobes  
7b33			  
7b33			;.decadetest1:  
7b33			  
7b33			; reset counter  
7b33			;ld a, 128  
7b33			;out (portbdata),a  
7b33			  
7b33			  
7b33			;ld b, 5  
7b33			;.dec1:  
7b33			;ld a, 0  
7b33			;out (portbdata),a  
7b33			;call delay1s  
7b33			  
7b33			;ld a, 32  
7b33			;out (portbdata),a  
7b33			;call delay1s  
7b33			;call delay1s  
7b33			;call delay1s  
7b33			;  
7b33			;ld a, 64+32  
7b33			;out (portbdata),a  
7b33			;call delay1s  
7b33			;;djnz .dec1  
7b33			;  
7b33			;jp .decadetest1  
7b33			  
7b33			  
7b33			  
7b33			  
7b33			  
7b33			  
7b33			  
7b33			  
7b33			  
7b33			  
7b33				; scan keyboard matrix and generate raw scan map  
7b33 cd c4 7b			call matrix  
7b36			  
7b36				; reuse c bit 0 left modifer button - ie shift  
7b36			        ; reuse c bit 1 for right modifer button - ie symbol shift  
7b36				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
7b36			  
7b36 0e 00			ld c, 0  
7b38			  
7b38				; TODO set flags for modifer key presses   
7b38				; TODO do a search for modifer key...  
7b38			  
7b38				;ld hl,keyscan_table_row4  
7b38 21 25 fe			ld hl,keyscan_table_row2  
7b3b			  
7b3b 7e				ld a, (hl)  
7b3c fe 23			cp '#'  
7b3e 20 07			jr nz, .nextmodcheck  
7b40 cb c1			set 0, c  
7b42 21 9a 7a			ld hl, .matrix_to_shift  
7b45 18 21			jr .dokeymap  
7b47				; TODO for now igonre  
7b47			.nextmodcheck:  
7b47 21 1a fe			ld hl,keyscan_table_row3  
7b4a			  
7b4a 7e				ld a, (hl)  
7b4b fe 23			cp '#'  
7b4d 20 07			jr nz, .nextmodcheck2  
7b4f cb c9			set 1, c   
7b51 21 d1 7a			ld hl, .matrix_to_symbolshift  
7b54 18 12			jr .dokeymap  
7b56			.nextmodcheck2:  
7b56 21 2e fe			ld hl,keyscan_table_row2+9    ; right shift  
7b59			  
7b59 7e				ld a, (hl)  
7b5a fe 23			cp '#'  
7b5c 20 07			jr nz, .donemodcheck  
7b5e cb c9			set 1, c   
7b60 21 9a 7a			ld hl, .matrix_to_shift  
7b63 18 03			jr .dokeymap  
7b65			  
7b65				; no modifer found so just map to normal keys  
7b65				; get mtoc map matrix to respective keys  
7b65			;	ld hl, .matrix_to_char  
7b65			;	ld hl, .matrix_to_char  
7b65			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7b65			;	ld a, KEY_SHIFT  
7b65			;	call findchar  
7b65			;  
7b65			;	; got offset to key modifer in b  
7b65			;  
7b65			;	ld hl,keyscan_table_row5  
7b65			;  
7b65			;	ld a,b  
7b65			;	call addatohl  
7b65			;	ld a,(hl)  
7b65			;  
7b65			;	cp '#'  
7b65			;	jr nz, .nextmodcheck  
7b65			;	set 0, c  
7b65			;	ld hl, .matrix_to_char  
7b65			;	jr .dokeymap  
7b65			;	; TODO for now igonre  
7b65			;.nextmodcheck:  
7b65			;	ld hl, .matrix_to_symbolshift  
7b65			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
7b65			;	ld a, KEY_SYMBOLSHIFT  
7b65			;	call findchar  
7b65			;  
7b65			;  
7b65			;	; got offset to key modifer in b  
7b65			;  
7b65			;	ld hl,keyscan_table_row5  
7b65			;  
7b65			;	ld a,b  
7b65			;	call addatohl  
7b65			;	ld a,(hl)  
7b65			;  
7b65			;	cp '#'  
7b65			;	jr nz, .donemodcheck  
7b65			;	set 1, c   
7b65			;	ld hl, .matrix_to_symbolshift  
7b65			;	jr .dokeymap  
7b65			  
7b65			  
7b65			  
7b65			.donemodcheck:  
7b65				; no modifer found so just map to normal keys  
7b65				; get mtoc map matrix to respective keys  
7b65 21 63 7a			ld hl, .matrix_to_char  
7b68			  
7b68			.dokeymap:  
7b68				;ld (key_fa), c   
7b68 cd 80 7b			call .mapkeys  
7b6b			  
7b6b			  
7b6b			if DEBUG_KEY  
7b6b			  
7b6b			; Display text on first line  
7b6b			            LD   A, kLCD_Line1  
7b6b			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6b			            LD   DE, keyscan_table_row1  
7b6b			            ;LD   DE, MsgHello  
7b6b			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6b			  
7b6b			; Display text on second line  
7b6b			            LD   A, kLCD_Line2  
7b6b			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6b			            LD   DE, keyscan_table_row2  
7b6b			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6b			            LD   A, kLCD_Line3  
7b6b			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6b			            LD   DE, keyscan_table_row3  
7b6b			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6b			            LD   A, kLCD_Line4  
7b6b			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6b			            LD   DE, keyscan_table_row4  
7b6b			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6b			            LD   A, kLCD_Line1+10  
7b6b			            CALL fLCD_Pos       ;Position cursor to location in A  
7b6b			            LD   DE, keyscan_table_row5  
7b6b			            CALL fLCD_Str       ;Display string pointed to by DE  
7b6b			  
7b6b				;call delay250ms  
7b6b			endif  
7b6b			;	jp testkey  
7b6b			  
7b6b			; get first char reported  
7b6b			  
7b6b 21 04 fe			ld hl,keyscan_table_row5  
7b6e			  
7b6e				;ld b, 46   ; 30 keys to remap + 8 nulls   
7b6e 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7b70			.findkey:  
7b70 7e				ld a,(hl)  
7b71			;	cp 0  
7b71 b7				or a  
7b72 28 04			jr z, .nextkey  
7b74 fe 7e			cp KEY_MATRIX_NO_PRESS  
7b76 20 06			jr nz, .foundkey  
7b78			.nextkey:  
7b78 23				inc hl  
7b79 10 f5			djnz .findkey  
7b7b 3e 00			ld a,0  
7b7d c9				ret  
7b7e			.foundkey:  
7b7e 7e				ld a,(hl)  
7b7f c9				ret  
7b80				  
7b80			  
7b80			; convert the raw key map given hl for destination key  
7b80			.mapkeys:  
7b80 11 04 fe			ld de,keyscan_table_row5  
7b83			  
7b83 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
7b85			.remap:  
7b85 1a				ld a,(de)  
7b86 fe 23			cp '#'  
7b88 20 02			jr nz, .remapnext  
7b8a				;CALLMONITOR  
7b8a 7e				ld a,(hl)  
7b8b 12				ld (de),a  
7b8c			  
7b8c			  
7b8c			  
7b8c			.remapnext:  
7b8c 23				inc hl  
7b8d 13				inc de  
7b8e 10 f5			djnz .remap  
7b90				  
7b90 c9				ret  
7b91			  
7b91			  
7b91			  
7b91			.mtocold2:  
7b91			  
7b91			;	; flag if key D is held down and remove from reporting  
7b91			;	ld bc, .key_map_fd    
7b91			;	ld hl, keyscan_table  
7b91			;	ld de, key_fd  
7b91			;	call .key_shift_hold  
7b91			;	cp 255  
7b91			;	jr z, .cinmap  
7b91			;	; flag if key C is held down and remove from reporting  
7b91			;	ld bc, .key_map_fc    
7b91			;	ld hl, keyscan_table+key_cols  
7b91			;	ld de, key_fc  
7b91			;	call .key_shift_hold  
7b91			;	cp 255  
7b91			;	jr z, .cinmap  
7b91			;	; flag if key B is held down and remove from reporting  
7b91			;	ld bc, .key_map_fb    
7b91			;	ld hl, keyscan_table+(key_cols*2)  
7b91			;	ld de, key_fb  
7b91			;	call .key_shift_hold  
7b91			;	cp 255  
7b91			;	jr z, .cinmap  
7b91			;	; flag if key A is held down and remove from reporting  
7b91			;	ld bc, .key_map_fa    
7b91			;	ld hl, keyscan_table+(key_cols*3)  
7b91			;	ld de, key_fa  
7b91			;	call .key_shift_hold  
7b91			;	cp 255  
7b91			;	jr z, .cinmap  
7b91			  
7b91 11 63 7a			ld de, .matrix_to_char  
7b94			  
7b94			  
7b94			.cinmap1:   
7b94				if DEBUG_KEY  
7b94			            LD   A, kLCD_Line4  
7b94			            CALL fLCD_Pos       ;Position cursor to location in A  
7b94					push de  
7b94			            LD   DE, keyscan_table  
7b94			            CALL fLCD_Str       ;Display string pointed to by DE  
7b94					pop de  
7b94				endif  
7b94			  
7b94				; scan key matrix table for any held key  
7b94			  
7b94				; de holds either the default matrix or one selected above  
7b94			  
7b94 21 d1 fd			ld hl, keyscan_table  
7b97 06 32			ld b,key_cols*key_rows  
7b99			  
7b99 7e			.cin11:	ld a,(hl)  
7b9a fe 23			cp '#'  
7b9c 28 08			jr z, .cinhit1  
7b9e 23				inc hl  
7b9f 13				inc de  
7ba0 05				dec b  
7ba1 20 f6			jr nz, .cin11  
7ba3				; no key found held  
7ba3 3e 00			ld a,0  
7ba5 c9				ret  
7ba6 d5			.cinhit1: push de  
7ba7 e1				pop hl  
7ba8 7e				ld a,(hl)  
7ba9 c9				ret  
7baa			  
7baa			; flag a control key is held   
7baa			; hl is key pin, de is flag indicator  
7baa			  
7baa			.key_shift_hold1:  
7baa c5				push bc  
7bab 3e 01			ld a, 1  
7bad 32 f3 fa			ld (cursor_shape),a  
7bb0 06 00			ld b, 0  
7bb2 7e				ld a, (hl)  
7bb3 fe 2e			cp '.'  
7bb5 28 09			jr z, .key_shift11  
7bb7 06 ff			ld b, 255  
7bb9			;	ld a, '+'    ; hide key from later scans  
7bb9 36 2b			ld (hl),'+'  
7bbb 3e 02			ld a, 2  
7bbd 32 f3 fa			ld (cursor_shape), a  
7bc0			.key_shift11:  
7bc0				; write flag indicator  
7bc0 78				ld a,b  
7bc1 12				ld (de),a  
7bc2			  
7bc2 d1				pop de    ; de now holds the key map ptr  
7bc3 c9				ret  
7bc4			  
7bc4				  
7bc4			  
7bc4			; scans keyboard matrix and flags key press in memory array	  
7bc4				  
7bc4			matrix:  
7bc4				;call matrix  
7bc4				; TODO optimise the code....  
7bc4			  
7bc4			  
7bc4			;ld hl, keyscan_table_row1  
7bc4			;ld de, keyscan_table_row1+1  
7bc4			;ld bc,46  
7bc4			;ld a,KEY_MATRIX_NO_PRESS  
7bc4			;ldir  
7bc4			  
7bc4			  
7bc4			  
7bc4			; reset counter  
7bc4 3e 80		ld a, 128  
7bc6 d3 c1		out (portbdata),a  
7bc8			  
7bc8 06 0a		ld b, 10  
7bca 0e 00		ld c, 0       ; current clock toggle  
7bcc			  
7bcc			.colscan:  
7bcc			  
7bcc			; set current column  
7bcc			; disable clock enable and set clock low  
7bcc			  
7bcc			;ld a, 0  
7bcc			;out (portbdata),a  
7bcc			  
7bcc			; For each column scan for switches  
7bcc			  
7bcc c5			push bc  
7bcd 21 c7 fd		ld hl, keyscan_scancol  
7bd0 cd d4 7c		call .rowscan  
7bd3 c1			pop bc  
7bd4			  
7bd4			  
7bd4			; get back current column  
7bd4			  
7bd4			; translate the row scan  
7bd4			  
7bd4			;   
7bd4			; row 1  
7bd4			  
7bd4 78			ld a,b  
7bd5			  
7bd5 21 3a fe		LD   hl, keyscan_table_row1+10  
7bd8			  
7bd8 cd be 0f		call subafromhl  
7bdb			;call addatohl  
7bdb			  
7bdb 11 c7 fd		ld de, keyscan_scancol  
7bde			  
7bde 1a			ld a,(de)  
7bdf 77			ld (hl),a  
7be0			  
7be0			  
7be0			  
7be0			  
7be0			; row 2  
7be0			  
7be0 78			ld a,b  
7be1			  
7be1 21 2f fe		LD   hl, keyscan_table_row2+10  
7be4			  
7be4			;call addatohl  
7be4 cd be 0f		call subafromhl  
7be7			  
7be7			  
7be7 11 c8 fd		ld de, keyscan_scancol+1  
7bea			  
7bea 1a			ld a,(de)  
7beb 77			ld (hl),a  
7bec			  
7bec			  
7bec			; row 3  
7bec			  
7bec 78			ld a,b  
7bed			  
7bed 21 24 fe		LD   hl, keyscan_table_row3+10  
7bf0			  
7bf0			;call addatohl  
7bf0 cd be 0f		call subafromhl  
7bf3			  
7bf3 11 c9 fd		ld de, keyscan_scancol+2  
7bf6			  
7bf6 1a			ld a,(de)  
7bf7 77			ld (hl),a  
7bf8			  
7bf8			  
7bf8			  
7bf8			; row 4  
7bf8			  
7bf8 78			ld a,b  
7bf9			  
7bf9 21 19 fe		LD   hl, keyscan_table_row4+10  
7bfc			  
7bfc			;call addatohl  
7bfc cd be 0f		call subafromhl  
7bff			  
7bff 11 ca fd		ld de, keyscan_scancol+3  
7c02			  
7c02 1a			ld a,(de)  
7c03 77			ld (hl),a  
7c04			  
7c04			; row 5  
7c04			  
7c04 78			ld a,b  
7c05			  
7c05 21 0e fe		LD   hl, keyscan_table_row5+10  
7c08			  
7c08			;call addatohl  
7c08 cd be 0f		call subafromhl  
7c0b			  
7c0b 11 cb fd		ld de, keyscan_scancol+4  
7c0e			  
7c0e 1a			ld a,(de)  
7c0f 77			ld (hl),a  
7c10			  
7c10			; handshake next column  
7c10			  
7c10			  
7c10 3e 40		ld a, 64  
7c12 d3 c1		out (portbdata),a  
7c14			  
7c14 3e 00		ld a, 0  
7c16 d3 c1		out (portbdata),a  
7c18			  
7c18			; toggle clk and move to next column  
7c18			;ld a, 64  
7c18			;cp c  
7c18			;  
7c18			;jr z, .coltoglow  
7c18			;ld c, a  
7c18			;jr .coltog  
7c18			;.coltoglow:  
7c18			;ld c, 0  
7c18			;.coltog:  
7c18			;ld a, c  
7c18			;out (portbdata),a  
7c18			  
7c18 10 b2		djnz .colscan  
7c1a			  
7c1a 3e 0a		ld a,10  
7c1c 21 30 fe		LD   hl, keyscan_table_row1  
7c1f cd ac 0f		call addatohl  
7c22			;ld a, 0  
7c22 36 00		ld (hl), 0  
7c24			  
7c24			  
7c24 3e 0a		ld a,10  
7c26 21 25 fe		LD   hl, keyscan_table_row2  
7c29 cd ac 0f		call addatohl  
7c2c			;ld a, 0  
7c2c 36 00		ld (hl), 0  
7c2e			  
7c2e 3e 0a		ld a,10  
7c30 21 1a fe		LD   hl, keyscan_table_row3  
7c33 cd ac 0f		call addatohl  
7c36			;ld a, 0  
7c36 36 00		ld (hl), 0  
7c38			  
7c38 3e 0a		ld a,10  
7c3a 21 0f fe		LD   hl, keyscan_table_row4  
7c3d cd ac 0f		call addatohl  
7c40			;ld a, 0  
7c40 36 00		ld (hl), 0  
7c42			  
7c42 3e 0a		ld a,10  
7c44 21 04 fe		LD   hl, keyscan_table_row5  
7c47 cd ac 0f		call addatohl  
7c4a			;ld a, 0  
7c4a 36 00		ld (hl), 0  
7c4c			  
7c4c			if DEBUG_KEY_MATRIX  
7c4c			  
7c4c			; Display text on first line  
7c4c			            LD   A, kLCD_Line1  
7c4c			            CALL fLCD_Pos       ;Position cursor to location in A  
7c4c			            LD   DE, keyscan_table_row1  
7c4c			            ;LD   DE, MsgHello  
7c4c			            CALL fLCD_Str       ;Display string pointed to by DE  
7c4c			  
7c4c			; Display text on second line  
7c4c			            LD   A, kLCD_Line2  
7c4c			            CALL fLCD_Pos       ;Position cursor to location in A  
7c4c			            LD   DE, keyscan_table_row2  
7c4c			            CALL fLCD_Str       ;Display string pointed to by DE  
7c4c			            LD   A, kLCD_Line3  
7c4c			            CALL fLCD_Pos       ;Position cursor to location in A  
7c4c			            LD   DE, keyscan_table_row3  
7c4c			            CALL fLCD_Str       ;Display string pointed to by DE  
7c4c			            LD   A, kLCD_Line4  
7c4c			            CALL fLCD_Pos       ;Position cursor to location in A  
7c4c			            LD   DE, keyscan_table_row4  
7c4c			            CALL fLCD_Str       ;Display string pointed to by DE  
7c4c			            LD   A, kLCD_Line4+10  
7c4c			            CALL fLCD_Pos       ;Position cursor to location in A  
7c4c			            LD   DE, keyscan_table_row5  
7c4c			            CALL fLCD_Str       ;Display string pointed to by DE  
7c4c			  
7c4c			;call delay250ms  
7c4c				jp matrix  
7c4c			endif  
7c4c c9			ret  
7c4d			  
7c4d			; using decade counter....  
7c4d			  
7c4d			  
7c4d			; TODO reset decade counter to start of scan  
7c4d			  
7c4d			; reset 15  
7c4d			; clock 14  
7c4d			; ce 13  
7c4d			  
7c4d			; 1 - q5  
7c4d			; 2 - q1  
7c4d			; 3 - q0  
7c4d			; 4 - q2  
7c4d			; 5 - q6  
7c4d			; 6 - q7  
7c4d			; 7 - q3  
7c4d			; 8 - vss  
7c4d			; 9 - q8  
7c4d			; 10 - q4  
7c4d			; 11 - q9  
7c4d			; 12 - cout  
7c4d			; 16 - vdd  
7c4d			  
7c4d			; clock      ce       reset     output  
7c4d			; 0          x        0         n  
7c4d			; x          1        0         n  
7c4d			; x          x        1         q0  
7c4d			; rising     0        0         n+1  
7c4d			; falling    x        0         n  
7c4d			; x          rising   0         n  
7c4d			; 1          falling  0         x+1  
7c4d			;  
7c4d			; x = dont care, if n < 5 carry = 1 otherwise 0  
7c4d			  
7c4d			;   
7c4d			; reset   
7c4d			; 13=0, 14=0, 15=1 .. 15=0  
7c4d			;  
7c4d			; handshake line  
7c4d			; 14=1.... read line 14=0  
7c4d			  
7c4d			  
7c4d			  
7c4d			  
7c4d			  
7c4d			; TODO hand shake clock for next column scan  
7c4d			; TODO detect each row  
7c4d			  
7c4d			  
7c4d			  
7c4d			  
7c4d			; reset 128  
7c4d			; clock 64  
7c4d			; ce 32  
7c4d			  
7c4d			  
7c4d			.cyclestart:  
7c4d			  
7c4d			; reset counter  
7c4d 3e 80		ld a, 128  
7c4f d3 c1		out (portbdata),a  
7c51			  
7c51			; loop leds  
7c51 06 0a		ld b,10  
7c53			  
7c53			.cycle1:  
7c53 c5			push bc  
7c54 3e 00		ld a, 0  
7c56 d3 c1		out (portbdata),a  
7c58 cd b4 0c		call delay250ms  
7c5b			  
7c5b 3e 40		ld a, 64  
7c5d d3 c1		out (portbdata),a  
7c5f cd b4 0c		call delay250ms  
7c62			  
7c62 3e 00		ld a, 0  
7c64 d3 c1		out (portbdata),a  
7c66 cd b4 0c		call delay250ms  
7c69			  
7c69 c1			pop bc  
7c6a 10 e7		djnz .cycle1  
7c6c			  
7c6c			  
7c6c 18 df		jr .cyclestart  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			; map matrix key held to char on face of key  
7c6e			  
7c6e			;.mtocold:  
7c6e			;  
7c6e			;  
7c6e			;; reset counter  
7c6e			;ld a, 128  
7c6e			;out (portbdata),a  
7c6e			;  
7c6e			;  
7c6e			;; scan keyboard row 1  
7c6e			;ld a, 0  
7c6e			;out (portbdata),a  
7c6e			;;ld a, 64  
7c6e			;;out (portbdata),a  
7c6e			;  
7c6e			;  
7c6e			;	ld a, 128  
7c6e			;	ld hl, keyscan_table  
7c6e			;	call .rowscan  
7c6e			;  
7c6e			;;ld a, 0  
7c6e			;;out (portbdata),a  
7c6e			;ld a, 64  
7c6e			;out (portbdata),a  
7c6e			;  
7c6e			;	ld a, 64  
7c6e			;	ld hl, keyscan_table+key_cols  
7c6e			;	call .rowscan  
7c6e			;  
7c6e			;ld a, 0  
7c6e			;out (portbdata),a  
7c6e			;;ld a, 64  
7c6e			;;out (portbdata),a  
7c6e			;	ld a, 32  
7c6e			;	ld hl, keyscan_table+(key_cols*2)  
7c6e			;	call .rowscan  
7c6e			;  
7c6e			;  
7c6e			;;ld a, 0  
7c6e			;;out (portbdata),a  
7c6e			;ld a, 64  
7c6e			;out (portbdata),a  
7c6e			;  
7c6e			;	ld a, 16  
7c6e			;	ld hl, keyscan_table+(key_cols*3)  
7c6e			;	call .rowscan  
7c6e			;  
7c6e			;  
7c6e			;	; flag if key D is held down and remove from reporting  
7c6e			;	ld bc, .key_map_fd    
7c6e			;	ld hl, keyscan_table  
7c6e			;	ld de, key_fd  
7c6e			;	call .key_shift_hold  
7c6e			;	cp 255  
7c6e			;	jr z, .cinmap  
7c6e			;	; flag if key C is held down and remove from reporting  
7c6e			;	ld bc, .key_map_fc    
7c6e			;	ld hl, keyscan_table+key_cols  
7c6e			;	ld de, key_fc  
7c6e			;	call .key_shift_hold  
7c6e			;	cp 255  
7c6e			;	jr z, .cinmap  
7c6e			;	; flag if key B is held down and remove from reporting  
7c6e			;	ld bc, .key_map_fb    
7c6e			;	ld hl, keyscan_table+(key_cols*2)  
7c6e			;	ld de, key_fb  
7c6e			;	call .key_shift_hold  
7c6e			;	cp 255  
7c6e			;	jr z, .cinmap  
7c6e			;	; flag if key A is held down and remove from reporting  
7c6e			;	ld bc, .key_map_fa    
7c6e			;	ld hl, keyscan_table+(key_cols*3)  
7c6e			;	ld de, key_fa  
7c6e			;	call .key_shift_hold  
7c6e			;	cp 255  
7c6e			;	jr z, .cinmap  
7c6e			;  
7c6e			;	ld de, .matrix_to_char  
7c6e			;  
7c6e			;  
7c6e			;.cinmap:   
7c6e			;	if DEBUG_KEY  
7c6e			;            LD   A, kLCD_Line4  
7c6e			;            CALL fLCD_Pos       ;Position cursor to location in A  
7c6e			;		push de  
7c6e			;            LD   DE, keyscan_table  
7c6e			;            CALL fLCD_Str       ;Display string pointed to by DE  
7c6e			;		pop de  
7c6e			;	endif  
7c6e			  
7c6e				; scan key matrix table for any held key  
7c6e			  
7c6e				; de holds either the default matrix or one selected above  
7c6e			  
7c6e			;	ld hl, keyscan_table  
7c6e			;	ld b,key_cols*key_rows  
7c6e			;  
7c6e			;.cin1:	ld a,(hl)  
7c6e			;	cp '#'  
7c6e			;	jr z, .cinhit  
7c6e			;	inc hl  
7c6e			;	inc de  
7c6e			;	dec b  
7c6e			;	jr nz, .cin1  
7c6e			;	; no key found held  
7c6e			;	ld a,0  
7c6e			;	ret  
7c6e			;.cinhit: push de  
7c6e			;	pop hl  
7c6e			;	ld a,(hl)  
7c6e			;	ret  
7c6e			  
7c6e			; flag a control key is held   
7c6e			; hl is key pin, de is flag indicator  
7c6e			  
7c6e			;.key_shift_hold:  
7c6e			;	push bc  
7c6e			;	ld a, 1  
7c6e			;	ld (cursor_shape),a  
7c6e			;	ld b, 0  
7c6e			;	ld a, (hl)  
7c6e			;	cp '.'  
7c6e			;	jr z, .key_shift1  
7c6e			;	ld b, 255  
7c6e			;	ld a, '+'    ; hide key from later scans  
7c6e			;	ld (hl),a  
7c6e			;	ld a, 2  
7c6e			;	ld (cursor_shape),a  
7c6e			;.key_shift1:  
7c6e			;	; write flag indicator  
7c6e			;	ld a,b  
7c6e			;	ld (de),a  
7c6e			;  
7c6e			;	pop de    ; de now holds the key map ptr  
7c6e			;	ret  
7c6e			  
7c6e				  
7c6e				  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			;	push hl  
7c6e			;	push de  
7c6e			;	push bc  
7c6e			;	call keyscan  
7c6e			;	; map key matrix to ascii value of key face  
7c6e			;  
7c6e			;	ld hl, key_face_map  
7c6e			;	ld de, keyscan_table  
7c6e			;  
7c6e			;	; get how many keys to look at  
7c6e			;	ld b, keyscan_table_len  
7c6e			;	  
7c6e			;  
7c6e			;	; at this stage fall out on first key hit  
7c6e			;	; TODO handle multiple key press  
7c6e			;  
7c6e			;map1:	ld a,(hl)  
7c6e			;	cp '#'  
7c6e			;	jr z, keyhit  
7c6e			;	inc hl  
7c6e			;	inc de  
7c6e			;	dec b  
7c6e			;	jr nz, map1  
7c6e			;nohit:	ld a, 0  
7c6e			;	jr keydone  
7c6e			;keyhit: push de  
7c6e			;	pop hl  
7c6e			;	ld a,(hl)  
7c6e			;keydone:  
7c6e			;	push bc  
7c6e			;	push de  
7c6e			; 	push hl  
7c6e			;	ret   
7c6e			;  
7c6e			  
7c6e			  
7c6e			  
7c6e			  
7c6e			; scan physical key matrix  
7c6e			  
7c6e			  
7c6e			;keyscan:  
7c6e			;  
7c6e			;; for each key_row use keyscanr bit mask for out  
7c6e			;; then read in for keyscanc bitmask  
7c6e			;; save result of row scan to keyscantable  
7c6e			;  
7c6e			;; scan keyboard row 1  
7c6e			;  
7c6e			;	ld b, key_rows  
7c6e			;	ld hl, key_scanr  
7c6e			;	ld de, keyscan_table  
7c6e			;  
7c6e			;rowloop:  
7c6e			;  
7c6e			;	ld a,(hl)		; out bit mask to energise keyboard row  
7c6e			;	call rowscan  
7c6e			;	inc hl  
7c6e			;	dec b  
7c6e			;	jr nz, rowloop  
7c6e			;  
7c6e			;	ret  
7c6e			;  
7c6e			;  
7c6e			;; pass a out bitmask, b row number  
7c6e			;arowscan:   
7c6e			;	push bc  
7c6e			;  
7c6e			;	ld d, b  
7c6e			;  
7c6e			;	; calculate buffer location for this row  
7c6e			;  
7c6e			;	ld hl, keyscan_table	  
7c6e			;kbufr:  ld e, key_cols  
7c6e			;kbufc:	inc hl  
7c6e			;	dec e  
7c6e			;	jr nz, kbufc  
7c6e			;	dec d  
7c6e			;	jr nz, kbufr  
7c6e			;  
7c6e			;	; energise row and read columns  
7c6e			;  
7c6e			;	out (portbdata),a  
7c6e			;	in a,(portbdata)  
7c6e			;	ld c,a  
7c6e			;  
7c6e			;  
7c6e			;	; save buffer loc  
7c6e			;  
7c6e			;	ld (keybufptr), hl  
7c6e			;  
7c6e			;	ld hl, key_scanc  
7c6e			;	ld d, key_cols  
7c6e			;  
7c6e			;	; for each column check each bit mask  
7c6e			;  
7c6e			;colloop:  
7c6e			;	  
7c6e			;  
7c6e			;	; reset flags for the row   
7c6e			;  
7c6e			;	ld b,'.'  
7c6e			;	and (hl)  
7c6e			;	jr z, maskskip  
7c6e			;	ld b,'#'  
7c6e			;maskskip:  
7c6e			;	; save  key state  
7c6e			;	push hl  
7c6e			;	ld hl, (keybufptr)  
7c6e			;	ld (hl), b  
7c6e			;	inc hl  
7c6e			;	ld (keybufptr), hl  
7c6e			;  
7c6e			;	; move to next bit mask  
7c6e			;	pop hl  
7c6e			;	inc hl  
7c6e			;  
7c6e			;	dec d  
7c6e			;	jr nz, colloop  
7c6e			;  
7c6e			;	ret  
7c6e			;  
7c6e			;  
7c6e			;;  
7c6e			; lcd functions  
7c6e			;  
7c6e			;  
7c6e			  
7c6e			;if DEBUG_KEY_MATRIX  
7c6e			  
7c6e			; test function to display hardware view of matrix state  
7c6e			  
7c6e			matrixold:  
7c6e			  
7c6e			  
7c6e			  
7c6e			; reset counter  
7c6e 3e 80		ld a, 128  
7c70 d3 c1		out (portbdata),a  
7c72			; scan keyboard row 1  
7c72 3e 00		ld a, 0  
7c74 d3 c1		out (portbdata),a  
7c76			;ld a, 64  
7c76			;out (portbdata),a  
7c76 3e 80			ld a, 128  
7c78 21 30 fe			ld hl, keyscan_table_row1  
7c7b cd d4 7c			call .rowscan  
7c7e			  
7c7e			;ld a, 0  
7c7e			;out (portbdata),a  
7c7e 3e 40		ld a, 64  
7c80 d3 c1		out (portbdata),a  
7c82 3e 40			ld a, 64  
7c84 21 25 fe			ld hl, keyscan_table_row2  
7c87 cd d4 7c			call .rowscan  
7c8a			  
7c8a 3e 00		ld a, 0  
7c8c d3 c1		out (portbdata),a  
7c8e			;ld a, 64  
7c8e			;out (portbdata),a  
7c8e 3e 20			ld a, 32  
7c90 21 1a fe			ld hl, keyscan_table_row3  
7c93 cd d4 7c			call .rowscan  
7c96			  
7c96			;ld a, 0  
7c96			;out (portbdata),a  
7c96 3e 40		ld a, 64  
7c98 d3 c1		out (portbdata),a  
7c9a 3e 10			ld a, 16  
7c9c 21 0f fe			ld hl, keyscan_table_row4  
7c9f cd d4 7c			call .rowscan  
7ca2			  
7ca2			; Display text on first line  
7ca2 3e 00		            LD   A, kLCD_Line1  
7ca4 cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7ca7 11 30 fe		            LD   DE, keyscan_table_row1  
7caa			            ;LD   DE, MsgHello  
7caa cd ff 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7cad			  
7cad			; Display text on second line  
7cad 3e 28		            LD   A, kLCD_Line2  
7caf cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7cb2 11 25 fe		            LD   DE, keyscan_table_row2  
7cb5 cd ff 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7cb8 3e 50		            LD   A, kLCD_Line3  
7cba cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7cbd 11 1a fe		            LD   DE, keyscan_table_row3  
7cc0 cd ff 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7cc3 3e 78		            LD   A, kLCD_Line4  
7cc5 cd dd 78		            CALL fLCD_Pos       ;Position cursor to location in A  
7cc8 11 0f fe		            LD   DE, keyscan_table_row4  
7ccb cd ff 78		            CALL fLCD_Str       ;Display string pointed to by DE  
7cce			  
7cce cd b4 0c			call delay250ms  
7cd1 c3 c4 7b			jp matrix  
7cd4			  
7cd4			; pass de as row display flags  
7cd4			.rowscan:   
7cd4			;	out (portbdata),a  
7cd4 db c1			in a,(portbdata)  
7cd6 4f				ld c,a  
7cd7				; reset flags for the row   
7cd7 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7cd9 e6 01			and 1  
7cdb 28 02			jr z, .p1on  
7cdd 06 23			ld b,'#'  
7cdf			.p1on:  
7cdf 70				ld (hl), b  
7ce0 23				inc hl  
7ce1			  
7ce1 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7ce3 79				ld a,c  
7ce4 e6 02			and 2  
7ce6			;	bit 0,a  
7ce6 28 02			jr z, .p2on  
7ce8 06 23			ld b,'#'  
7cea			.p2on:  
7cea 70				ld (hl), b  
7ceb 23				inc hl  
7cec			;  
7cec 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7cee 79				ld a,c  
7cef e6 04			and 4  
7cf1			;;	bit 0,a  
7cf1 28 02			jr z, .p3on  
7cf3 06 23			ld b,'#'  
7cf5			.p3on:  
7cf5 70				ld (hl), b  
7cf6 23				inc hl  
7cf7			;;  
7cf7 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7cf9			;;	bit 0,a  
7cf9 79				ld a,c  
7cfa e6 08			and 8  
7cfc 28 02			jr z, .p4on  
7cfe 06 23			ld b,'#'  
7d00			.p4on:  
7d00 70				ld (hl), b  
7d01 23				inc hl  
7d02			  
7d02 06 7e			ld b,KEY_MATRIX_NO_PRESS  
7d04			;;	bit 0,a  
7d04 79				ld a,c  
7d05 e6 10			and 16  
7d07 28 02			jr z, .p5on  
7d09 06 23			ld b,'#'  
7d0b			.p5on:  
7d0b 70				ld (hl), b  
7d0c 23				inc hl  
7d0d			; zero term  
7d0d			;	ld b,0  
7d0d 36 00			ld (hl), 0  
7d0f			  
7d0f c9			.rscandone: ret  
7d10			  
7d10			;addatohl:  
7d10			;  
7d10			 ;add   a, l    ; A = A+L  
7d10			  ;  ld    l, a    ; L = A+L  
7d10			   ; adc   a, h    ; A = A+L+H+carry  
7d10			   ; sub   l       ; A = H+carry  
7d10			   ; ld    h, a    ; H = H+carry  
7d10			  
7d10			;ret  
7d10			; eof  
# End of file firmware_key_5x10.asm
7d10			;include "firmware_key_4x10.asm" 
7d10			 
7d10			heap_size:    equ heap_end - heap_start 
7d10			;eof 
# End of file os_mega.asm
7d10
