# File os_mega.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 1 
0000			BASE_CPM: equ 0 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0fffdh 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 1 
0000			SOUND_ENABLE: equ 1 
0000			 
0000			; Number of bytes available in heap   TODO make all of user ram 
0000			baseram: equ 08000h 
0000			endofcode: equ 08000h 
0000			heap_start: equ 0800eh  ; Starting address of heap 
0000			free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes) 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0000			endif 
0000 c3 d6 15			jp coldstart     ; rst 0 - cold boot 
0003			 
0003			;        nop  
0003			;        nop 
0003			;;	org 05h		; null out bdos call 
0003			; 
0003			;        nop  
0003			;        nop  
0003			;        nop 
0003			;;	org 08h 
0003			;;; 
0003			;;	jp cin		; rst 8 - char in 
0003			;;; 
0003			; 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;        nop 
0003			;	org 010h 
0003			;; 
0003			;	jp cout		; rest 010h  - char out 
0003			;; 
0003			;	org 01bh   
0003			; 
0003			;	;jp  		; rst 01bh   - write string to display 
0003			;	jp str_at_display 
0003			; 
0003			; 
0003			;	org 020h 
0003			; 
0003			;	; jp		 ; rst 020h - read char at screen location 
0003			; 
0003			;	org 028h 
0003			 
0003				; jp		 ; rst 028h  - storage i/o 
0003			 
0003			; 	org 030h 
0003			;	jp break_point_state 
0003			  
0003			; $30  
0003			; org 038h 
0003			; $38 
0003			 
0003			; TODO any more important entry points to add to jump table for easier coding use? 
0003			 
0003			 
0003			include "firmware.asm" 
0003			  
0003			; main constants (used here and in firmware)  
0003			  
0003			; TODO have page 0 of storage as bios  
0003			  
0003			Device_A: equ 0h  
0003			Device_B: equ 040h          ; Sound  
0003			  
0003			if BASE_KEV  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_SC114  
0003			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			; TODO fixup for CPM  
0003			Device_C: equ 080h          ; Storage and ext cart devices  
0003			endif  
0003			  
0003			Device_D: equ 0c0h             ; Keyboard and LCD  
0003			  
0003			; Odd specific debug points for testing hardware dev  
0003			  
0003			DEBUG_SOUND: equ 1  
0003			DEBUG_STK_FAULT: equ 0  
0003			DEBUG_INPUT: equ 0     ; Debug input entry code  
0003			DEBUG_KEYCINWAIT: equ 0  
0003			DEBUG_KEYCIN: equ 0  
0003			DEBUG_KEY: equ 0  
0003			DEBUG_KEY_MATRIX: equ 0  
0003			DEBUG_STORECF: equ 0  
0003			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0003			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0003			DEBUG_SPI: equ 0    ; low level spi tests  
0003			  
0003			; Enable many break points  
0003			  
0003			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0003			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0003			DEBUG_FORTH_JP: equ 0    ; 4  
0003			DEBUG_FORTH_MALLOC: equ 0  
0003			DEBUG_FORTH_MALLOC_INT: equ 0  
0003			DEBUG_FORTH_DOT: equ 0  
0003			DEBUG_FORTH_DOT_WAIT: equ 0  
0003			DEBUG_FORTH_MATHS: equ 0  
0003			DEBUG_FORTH_TOK: equ 0    ; 4  
0003			DEBUG_FORTH_PARSE: equ 0    ; 3  
0003			DEBUG_FORTH: equ 0  ;2  
0003			DEBUG_FORTH_WORDS: equ 1   ; 1  
0003			DEBUG_FORTH_PUSH: equ 0   ; 1  
0003			DEBUG_FORTH_UWORD: equ 1   ; 1  
0003			  
0003			; Enable key point breakpoints  
0003			  
0003			DEBUG_FORTH_DOT_KEY: equ 0  
0003			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0003			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0003			  
0003			; Debug stack imbalances  
0003			  
0003			ON: equ 1  
0003			OFF: equ 0  
0003			  
0003			DEBUG_STACK_IMB: equ 0  
0003			STACK_IMB_STORE: equ 20  
0003			  
0003			; House keeping and protections  
0003			  
0003			DEBUG_FORTH_STACK_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0003			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0003			FORTH_ENABLE_FREE: equ 0  
0003			FORTH_ENABLE_MALLOCFREE: equ 1  
0003			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0003			FORTH_ENABLE_FLOATMATH: equ 0  
0003			  
0003			  
0003			CALLMONITOR: macro  
0003				call break_point_state  
0003				endm  
0003			  
0003			MALLOC_1: equ 1        ; from dk88   
0003			MALLOC_2: equ 0           ; broke  
0003			MALLOC_3: equ 0           ; really broke  
0003			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0003			  
0003			if BASE_KEV   
0003			stacksize: equ 512*2  
0003			  
0003			STACK_RET_SIZE: equ 128  
0003			STACK_LOOP_SIZE: equ 512  
0003			STACK_DATA_SIZE: equ 512  
0003			endif  
0003			if BASE_SC114  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			if BASE_CPM  
0003			;tos:	equ 0f000h  
0003			stacksize: equ 256  
0003			STACK_RET_SIZE: equ 64  
0003			STACK_LOOP_SIZE: equ 256  
0003			STACK_DATA_SIZE: equ 256  
0003			endif  
0003			  
0003			;if STORAGE_SE == 0  
0003			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0003			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0003			;endif  
0003			  
0003			; Blocks where directory table is held  
0003			  
0003			; Reducing the number of entries increases the max file size  
0003			  
0003			;STORE_DIR_START: equ 1  
0003			;STORE_DIR_END: equ 33  
0003			  
0003			; Blocks from where file data is stored  
0003			  
0003			;STORE_DATA_START: equ STORE_DIR_END + 1  
0003			  
0003			; Block indicators (<32 are data files)  
0003			  
0003			;STORE_BLOCK_CFG: equ $8f       ; config block  
0003			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0003			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0003			;STORE_BLOCK_FREE: equ $85       ; data block free  
0003			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0003			  
0003			  
0003			  
0003			; Directory entry flags  
0003			  
0003			;STORE_DIR_FREE: equ 0  
0003			;STORE_DIR_FILE:  equ 1  
0003			  
0003			; Structure offsets to directory entries  
0003			;STORE_DE_FLAG: equ 0  
0003			;STORE_DE_MAXEXT: equ 1  
0003			;STORE_DE_FILENAME: equ 2  
0003			  
0003			; Structure offsets to block 0  
0003			  
0003			;STORE_BK0_ISFOR: equ 1  
0003			;STORE_BK0_LABEL: equ 3  
0003			  
0003			; memory allocation   
0003			  
0003			chk_stund: equ tos+2           ; underflow check word  
0003			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0003			  
0003			; keyscan table needs rows x cols buffer  
0003			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0003			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0003			  
0003			keyscan_table_row1: equ chk_stovr -key_cols-1  
0003			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0003			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0003			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0003			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0003			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0003			keyscan_scancol: equ keyscan_table-key_cols  
0003			;keyscan_table_len: equ key_rows*key_cols  
0003			;keybufptr: equ keyscan_table - 2  
0003			;keysymbol: equ keybufptr - 1  
0003			key_held: equ keyscan_scancol-1	; currently held  
0003			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0003			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0003			key_fa: equ key_repeat_ct -1 ;  
0003			key_fb: equ key_fa -1 ;  
0003			key_fc: equ key_fb -1 ;  
0003			key_fd: equ key_fc -1 ;  
0003			key_face_held: equ key_fd - 1   
0003			  
0003			; flag for enabling/disabling various hardware diags   
0003			  
0003			hardware_diag: equ key_face_held - 1  
0003			  
0003			; hardware config switches  
0003			; TODO add bitmasks on includes for hardware  
0003			; high byte for expansion ids  
0003			;     0000 0000  no card inserted  
0003			;     0000 0001  storage card inserted  
0003			;     0000 0010  spi sd card active  
0003			  
0003			;       
0003			; low byte:  
0003			;     0000 0001   4x4 keypad  
0003			;     0000 0010   full keyboard  
0003			;     0000 0011   spi/ext keyboard  
0003			;     0000 0100   20x4 lcd  
0003			;     0000 1000   40x4 lcd  
0003			;     0000 1100   spi/ext display  
0003			;     0001 0000   ide interface available  
0003			  
0003			hardware_word: equ hardware_diag - 2  
0003			  
0003			; debug marker - optional display of debug point on the debug screens  
0003			  
0003			debug_mark: equ hardware_word - 4  
0003			  
0003			; input_str vars  
0003			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0003			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0003			input_size: equ input_start -1  ; number of chars  
0003			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0003			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0003			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0003			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0003			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0003			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0003			input_len: equ input_cur_onoff - 5 ; length of current input  
0003			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0003			  
0003			CUR_BLINK_RATE: equ 15  
0003			  
0003			key_actual_pressed: equ input_cursor - 1   
0003			key_symbol: equ key_actual_pressed - 1   
0003			key_shift: equ key_symbol - 1   
0003			  
0003			; Display allocation  
0003			  
0003			;display_rows: equ 4     ; move out to mini and mega files  
0003			;display_cols: equ 20  
0003			  
0003			display_fb_len: equ display_rows*display_cols  
0003			  
0003			; primary frame buffer     
0003			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0003			; working frame buffers  
0003			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0003			display_fb3: equ  display_fb1-display_fb_len - 1  
0003			display_fb2: equ  display_fb3-display_fb_len - 1  
0003			;  
0003			; pointer to active frame buffer  
0003			display_fb_active: equ display_fb2 - 2  
0003			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0003			display_write_tmp: equ display_lcde1e2 - 2  
0003			  
0003			  
0003			;  
0003			  
0003			;; can load into de directory  
0003			cursor_col: equ display_write_tmp-1  
0003			cursor_row: equ cursor_col-1  
0003			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0003			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0003			  
0003			; maths vars  
0003			  
0003			LFSRSeed: equ cursor_shape -20   
0003			randData: equ LFSRSeed - 2  
0003			xrandc: equ randData - 2  
0003			stackstore: equ xrandc - 2  
0003			seed1: equ  stackstore -2   
0003			seed2: equ seed1 - 2  
0003			  
0003			; cf storage vars  
0003			  
0003			iErrorNum:  equ seed2-1         ;Error number  
0003			iErrorReg:  equ iErrorNum -1              ;Error register  
0003			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0003			  
0003			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0003			  
0003			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0003			  
0003			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0003			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0003			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0003			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0003			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0003			store_tmpid: equ store_tmp3 - 1		; page temp id  
0003			store_tmpext: equ store_tmpid - 1		; file extent temp  
0003			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0003			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0003			store_filecache: equ store_openmaxext+(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0003			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0003			;  
0003			; spi vars  
0003			  
0003			  
0003			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0003			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0003			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0003			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0003			  
0003			;;;;; forth cli params  
0003			  
0003			; TODO use a different frame buffer for forth???  
0003			  
0003			f_cursor_ptr:  equ spi_device - 1  ; offset into frame buffer for any . or EMIT output  
0003			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0003			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0003			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0003			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0003			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0003			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0003			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0003			  
0003			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0003			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0003			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0003			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0003			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0003			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0003			  
0003			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0003			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0003			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0003			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0003			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0003			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0003			  
0003			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0003			  
0003			; os/forth token vars  
0003			  
0003			os_last_cmd: equ os_var_array-255  
0003			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0003			os_current_i: equ os_cli_cmd-2  
0003			os_cur_ptr: equ os_current_i-2  
0003			os_word_scratch: equ os_cur_ptr-30  
0003			os_tok_len: equ os_word_scratch - 2  
0003			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0003			os_tok_malloc: equ os_tok_ptr - 2  
0003			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0003			os_input: equ os_last_new_uword-255  
0003			execscratch: equ os_input-255        ; exec cmd eval buffer  
0003			scratch: equ execscratch-255  
0003			  
0003			  
0003			; temp locations for new word processing to save on adding more   
0003			  
0003			os_new_malloc: equ os_input  
0003			os_new_parse_len: equ os_new_malloc + 2  
0003			os_new_word_len: equ os_new_parse_len + 2  
0003			os_new_work_ptr: equ os_new_word_len + 2  
0003			os_new_src_ptr: equ os_new_work_ptr + 2  
0003			os_new_exec: equ os_new_src_ptr + 2  
0003			os_new_exec_ptr: equ os_new_exec + 2  
0003			  
0003			; resume memory alloocations....  
0003			  
0003			os_view_disable: equ scratch - 1  
0003			os_view_af: equ os_view_disable - 2  
0003			os_view_hl: equ os_view_af -2  
0003			os_view_de: equ os_view_hl - 2  
0003			os_view_bc: equ os_view_de - 2  
0003			  
0003			; stack checksum word  
0003			if DEBUG_STACK_IMB  
0003				curframe: equ  os_view_de - 5  
0003				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0003				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			else  
0003				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0003			endif  
0003			  
0003			; with data stack could see memory filled with junk. need some memory management   
0003			; malloc and free entry points added  
0003			  
0003			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0003			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			;heap_end: equ free_list-1  ; Starting address of heap  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			  
0003			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0003			heap_end: equ chk_word-1  ; Starting address of heap  
0003			  
0003			  
0003			;if BASE_KEV   
0003			;heap_start: equ 0800eh  ; Starting address of heap  
0003			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;heap_start: equ baseram+15  ; Starting address of heap  
0003			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0003			;endif  
0003			  
0003			  
0003			;;;;  
0003			  
0003			  
0003			; change below to point to last memory alloc above  
0003			topusermem:  equ   heap_start  
0003			  
0003			;if BASE_KEV   
0003			;baseusermem: equ 08000h  
0003			;endif  
0003			  
0003			;if BASE_SC114  
0003			;;aseusermem:     equ    12  
0003			;baseusermem:     equ    prompt  
0003			;;baseusermem:     equ    endofcode  
0003			;endif  
0003			  
0003			  
0003			; **********************************************************************  
0003			; **  Constants  
0003			; **********************************************************************  
0003			  
0003			; Constants used by this code module  
0003			kDataReg:   EQU Device_D           ;PIO port A data register  
0003			kContReg:   EQU Device_D+2           ;PIO port A control register  
0003			  
0003			  
0003			portbdata:  equ Device_D+1    ; port b data  
0003			portbctl:   equ Device_D+3    ; port b control  
0003			  
0003			  
0003			;KEY_SHIFT:   equ 5  
0003			;KEY_SYMBOLSHIFT:  equ 6  
0003			  
0003			KEY_SHIFTLOCK: equ 4  
0003			  
0003			  
0003			KEY_UP: equ 5  
0003			KEY_NEXTWORD: equ 6  
0003			KEY_PREVWORD: equ 7  
0003			KEY_BS: equ 8  
0003			KEY_TAB:  equ 9  
0003			KEY_DOWN: equ 10  
0003			KEY_LEFT: equ 11  
0003			KEY_RIGHT: equ 12  
0003			KEY_CR:   equ 13  
0003			KEY_HOME: equ 14  
0003			KEY_END: equ 15  
0003			  
0003			KEY_F1: equ 16  
0003			KEY_F2: equ 17  
0003			KEY_F3: equ 18  
0003			KEY_F4: equ 19  
0003			  
0003			KEY_F5: equ 20  
0003			KEY_F6: equ 21  
0003			KEY_F7: equ 22  
0003			KEY_F8: equ 23  
0003			  
0003			KEY_F9: equ 24  
0003			KEY_F10: equ 25  
0003			KEY_F11: equ 26  
0003			KEY_F12: equ 27  
0003			  
0003			;if DEBUG_KEY  
0003			;	KEY_MATRIX_NO_PRESS: equ '.'  
0003			;	KEY_SHIFT:   equ '.'  
0003			;	KEY_SYMBOLSHIFT:  equ '.'  
0003			;else  
0003				KEY_SHIFT:   equ '~'  
0003				KEY_SYMBOLSHIFT:  equ '~'  
0003				KEY_MATRIX_NO_PRESS: equ '~'  
0003			;endi  
0003			  
0003			  
0003			  
0003			  
0003			; Macro to make adding debug marks easier  
0003			  
0003			DMARK: macro str  
0003				push af  
0003				ld a, (.dmark)  
0003				ld (debug_mark),a  
0003				ld a, (.dmark+1)  
0003				ld (debug_mark+1),a  
0003				ld a, (.dmark+2)  
0003				ld (debug_mark+2),a  
0003				jr .pastdmark  
0003			.dmark: db str  
0003			.pastdmark: pop af  
0003			  
0003			endm  
0003			  
0003			  
0003			; macro to detect for stack imbalances  
0003			  
0003			include "stackimbal.asm"  
0003			; Macro and code to detect stock imbalances 
0003			 
0003			SPPUSH: equ 0 
0003			 
0003			; Add a stack frame which can be checked before return 
0003			 
0003			STACKFRAME: macro onoff frame1 frame2 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003						exx 
0003			 
0003						ld de, frame1 
0003						ld a, d 
0003						ld hl, curframe 
0003						call hexout 
0003						ld a, e 
0003						ld hl, curframe+2 
0003						call hexout 
0003			  
0003						ld hl, frame1 
0003						push hl 
0003						ld hl, frame2 
0003						push hl 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			endm 
0003			 
0003			STACKFRAMECHK: macro onoff frame1 frame2 
0003			 
0003					 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						exx 
0003						; check stack frame SP 
0003			 
0003						ld hl, frame2 
0003						pop de   ; frame2 
0003			 
0003						call cmp16 
0003						jr nz, .spnosame 
0003						 
0003			 
0003						ld hl, frame1 
0003						pop de   ; frame1 
0003			 
0003						call cmp16 
0003						jr z, .spfrsame 
0003			 
0003						.spnosame: call showsperror 
0003			 
0003						.spfrsame: nop 
0003			 
0003						exx 
0003					endif 
0003					 
0003				endif 
0003			 
0003			 
0003			endm 
0003			 
0003			 
0003			; for a sub routine, wrap SP collection and comparisons 
0003			 
0003			; Usage: 
0003			; 
0003			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0003			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0003			 
0003			SAVESP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003						; save current SP 
0003			 
0003						ld (store_sp+(storeword*4)), sp 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			CHECKSP: macro onoff storeword 
0003			 
0003				if DEBUG_STACK_IMB 
0003					if onoff 
0003			 
0003						; save SP after last save 
0003				 
0003						ld (store_sp+(storeword*4)+2), sp 
0003			 
0003						push hl 
0003						ld hl, store_sp+(storeword*4) 
0003						call check_stack_sp  
0003						pop hl 
0003			 
0003			 
0003					endif 
0003					 
0003				endif 
0003			 
0003			endm 
0003			 
0003			if DEBUG_STACK_IMB 
0003			 
0003			check_stack_sp: 
0003					push de 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					push de 
0003			 
0003			 
0003					ld e, (hl) 
0003					inc hl 
0003					ld d, (hl) 
0003					inc hl 
0003			 
0003					pop hl 
0003			 
0003			 
0003					; check to see if the same 
0003			 
0003					call cmp16 
0003					jr z, .spsame 
0003			 
0003					; not same 
0003			 
0003					call showsperror 
0003			.spsame: 
0003			 
0003					pop de 
0003			 
0003					ret 
0003			 
0003			.sperr:  db "Stack imbalance",0 
0003			 
0003			 
0003			showsperror: 
0003			 
0003			 
0003				push hl 
0003				push af 
0003				push de 
0003				call clear_display 
0003				ld de, .sperr 
0003				ld a,0 
0003			;	ld de,os_word_scratch 
0003				call str_at_display 
0003				ld a, display_row_1+17 
0003				ld de, debug_mark 
0003				call str_at_display 
0003				ld a, 0 
0003				ld (curframe+4),a 
0003				ld hl, curframe 
0003				ld de, os_word_scratch 
0003				ld a, display_row_4 
0003				call str_at_display 
0003				call update_display 
0003				;call break_point_state 
0003				call cin_wait 
0003			 
0003				ld a, ' ' 
0003				ld (os_view_disable), a 
0003				pop de	 
0003				pop af 
0003				pop hl 
0003				CALLMONITOR 
0003				ret 
0003			 
0003			endif 
0003			 
0003			 
0003			 
0003			; eof 
# End of file stackimbal.asm
0003			  
0003			;TODO macro to calc col and row offset into screen  
0003			  
0003			  
0003			  
0003			hardware_init:  
0003			  
0003 3e 00				ld a, 0  
0005 32 7d fb				ld (hardware_diag), a  
0008			  
0008					; clear all the buffers  
0008			  
0008 21 1c fa				ld hl, display_fb1  
000b 22 d8 f8				ld (display_fb_active), hl  
000e			  
000e cd b9 0a				call clear_display  
0011			  
0011 21 da f8				ld hl, display_fb2  
0014 22 d8 f8				ld (display_fb_active), hl  
0017			  
0017 cd b9 0a				call clear_display  
001a			  
001a					; init primary frame buffer area  
001a 21 bd fa				ld hl, display_fb0  
001d 22 d8 f8				ld (display_fb_active), hl  
0020			  
0020 cd b9 0a				call clear_display  
0023			  
0023			  
0023 cd 8f 61				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0026			  
0026 cd 26 64			call key_init  
0029 cd cc 01			call storage_init  
002c			  
002c				; setup malloc functions  
002c			  
002c				if MALLOC_1  
002c cd b5 10				call  heap_init  
002f				endif  
002f				if MALLOC_4  
002f					call  heap_init  
002f				endif  
002f			  
002f				; init sound hardware if present  
002f			  
002f				if SOUND_ENABLE  
002f cd 72 12				call sound_init  
0032				endif  
0032			  
0032				; lcd test sequence  
0032					  
0032 cd dc 0a			call update_display  
0035 cd 3d 0a			call delay1s  
0038 3e 2b			ld a,'+'  
003a cd be 0a			call fill_display  
003d cd dc 0a			call update_display  
0040 cd 3d 0a			call delay1s  
0043 3e 2a			ld a,'*'  
0045 cd be 0a			call fill_display  
0048 cd dc 0a			call update_display  
004b cd 3d 0a			call delay1s  
004e 3e 2d			ld a,'-'  
0050 cd be 0a			call fill_display  
0053 cd dc 0a			call update_display  
0056 cd 3d 0a			call delay1s  
0059			  
0059			; boot splash screen  
0059			if display_cols == 20	  
0059			        ld a, display_row_1    
0059			else  
0059 3e 0a		        ld a, display_row_1 +10   
005b			endif  
005b 11 8c 00			ld de, bootmsg  
005e cd cc 0a			call str_at_display  
0061 cd dc 0a			call update_display  
0064			  
0064			  
0064 cd 3d 0a			call delay1s  
0067 cd 3d 0a			call delay1s  
006a			if display_cols == 20	  
006a			            LD   A, display_row_3+2  
006a			else  
006a 3e 5c		            LD   A, display_row_3+12  
006c			endif  
006c 11 a1 00			ld de, bootmsg1  
006f cd cc 0a			call str_at_display  
0072 cd dc 0a			call update_display  
0075 cd 3d 0a			call delay1s  
0078 cd 3d 0a			call delay1s  
007b			  
007b			;	ld a, display_row_4+3  
007b			;	ld de, bootmsg2  
007b			;	call str_at_display  
007b			;	call update_display  
007b			;	call delay1s  
007b			;	call delay1s  
007b			  
007b			; debug mark setup  
007b			  
007b 3e 5f		ld a, '_'  
007d 32 77 fb		ld (debug_mark),a  
0080 32 78 fb		ld (debug_mark+1),a  
0083 32 79 fb		ld (debug_mark+2),a  
0086 3e 00		ld a,0  
0088 32 7a fb		ld (debug_mark+3),a  
008b			  
008b c9					ret  
008c			  
008c			  
008c .. 00		bootmsg:	db "z80-homebrew OS v1.5",0  
00a1 .. 00		bootmsg1:	db "by Kevin Groves",0  
00b1			;bootmsg2:	db "Firmware v0.1",0  
00b1			  
00b1			; a 4x20 lcd  
00b1			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
00b1			  
00b1			;if display_cols == 20  
00b1			;	include "firmware_lcd_4x20.asm"  
00b1			;endif  
00b1			  
00b1			;if display_cols == 40  
00b1			;	include "firmware_lcd_4x40.asm"  
00b1			;endif  
00b1			  
00b1			;  
00b1			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
00b1			; TODO abstract the bit bang video out interface for dual display  
00b1			; TODO wire video out to tx pin on rc2014 bus  
00b1			  
00b1			; must supply cin, and cin_wait for low level hardware abstraction   
00b1			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
00b1			; test scancode  
00b1			  
00b1			;;;;;  
00b1			;;;  
00b1			; Moved out to mini and maxi versions  
00b1			;  
00b1			; include "firmware_key_4x4.asm"  
00b1			; using existing 4 wire x 4 resistor array for input  
00b1			;include "firmware_key_4x10.asm"  
00b1			; need to mod the board for 5 rows due to resistor array  
00b1			;include "firmware_key_5x10.asm"  
00b1			  
00b1			; storage hardware interface  
00b1			  
00b1			; use microchip serial eeprom for storage  
00b1			  
00b1			  
00b1			if STORAGE_SE  
00b1				include "firmware_spi.asm"  
00b1			; my spi protocol (used by storage) 
00b1			 
00b1			; SPI pins 
00b1			 
00b1			SPI_DI: equ 7       ; chip pin 5 - port a7   pin pin 7 
00b1			SPI_DO: equ 6      ; chip pin 2 - port a6   pin 8 
00b1			SPI_SCLK: equ 5      ; chip pin 6 - port a5  - pin 9 
00b1			 
00b1			; chip pin 3 (WP), 7 (HOLD) and 8 (VCC) +5v 
00b1			; chip pin 4 gnd 
00b1			 
00b1			 
00b1			SPI_CE0: equ 0      ; chip pin 1 - port a3 - pin 15 
00b1			SPI_CE1: equ 1      ;    port a1 pin 14  
00b1			SPI_CE2: equ 2      ;    port a2 pin pin 13 
00b1			SPI_CE3: equ 3      ; port    a3 pin pin 12 
00b1			SPI_CE4: equ 4      ; port a4     pin 10 
00b1			 
00b1			; active low AND masks 
00b1			 
00b1			;SPI_CE0_MASK: equ    255-1 
00b1			;SPI_CE1_MASK: equ   255-2 
00b1			;SPI_CE2_MASK: equ   255-4 
00b1			;SPI_CE3_MASK: equ   255-8 
00b1			;SPI_CE4_MASK: equ   255-16 
00b1			SPI_CE_HIGH:  equ 255 
00b1			 
00b1			 
00b1			 
00b1			 
00b1			; TODO store port id for spi device ie dev c 
00b1			; TODO store pin for SO 
00b1			; TODO store pin for SI 
00b1			; TODO store pin for SCLK 
00b1			 
00b1			; 
00b1			 
00b1			; ensure that spi bus is in a stable state with default pins  
00b1			 
00b1			se_stable_spi:   
00b1			 
00b1				 ; set DI high, CE high , SCLK low 
00b1				;ld a, SPI_DI | SPI_CE0 
00b1 3e 07			ld a, SPI_DI  
00b3 cd 87 01			call spi_ce_high 
00b6 d3 80			 out (storage_adata),a 
00b8 32 5d f8			ld (spi_portbyte),a 
00bb			 
00bb				if DEBUG_SPI 
00bb					push hl 
00bb					ld l, a 
00bb					DMARK "SPI" 
00bb					CALLMONITOR 
00bb					pop hl 
00bb				endif 
00bb c9				ret 
00bc			 
00bc			; byte to send in a 
00bc			 
00bc			spi_send_byte: 
00bc				; save byte to send for bit mask shift out 
00bc 4f			        ld c,a 
00bd 3a 5d f8			ld a,(spi_portbyte) 
00c0				  
00c0				; clock out	each bit of the byte msb first 
00c0			 
00c0 06 08			ld b, 8 
00c2			.ssb1: 
00c2				; clear so bit  
00c2 cb bf			res SPI_DI, a 
00c4 cb 11			rl c 
00c6				; if bit 7 is set then carry is set 
00c6 30 02			jr nc, .ssb2 
00c8 cb ff			set SPI_DI,a 
00ca			.ssb2:  ; output bit to ensure it is stable 
00ca d3 80			out (storage_adata),a 
00cc 00				nop 
00cd				; clock bit high 
00cd cb ef			set SPI_SCLK,a 
00cf d3 80			out (storage_adata),a 
00d1 00				nop 
00d2				; then low 
00d2 cb af			res SPI_SCLK,a 
00d4 d3 80			out (storage_adata),a 
00d6 00				nop 
00d7 10 e9			djnz .ssb1 
00d9			 
00d9 32 5d f8			ld (spi_portbyte),a 
00dc c9				ret 
00dd			 
00dd			; TODO low level get byte into A on spi 
00dd			 
00dd			spi_read_byte:  
00dd			 
00dd				; save byte to send for bit mask shift out 
00dd 0e 00		    ld c,0 
00df 3a 5d f8			ld a,(spi_portbyte) 
00e2				  
00e2				; clock out	each bit of the byte msb first 
00e2			 
00e2			 
00e2				; clock bit high 
00e2 cb ef			set SPI_SCLK,a 
00e4 d3 80			out (storage_adata),a 
00e6 00				nop 
00e7			 
00e7			    ; read DO  
00e7			 
00e7 cb f9		    set 7,c 
00e9 db 80			in a,(storage_adata) 
00eb cb 77		    bit SPI_DO,a 
00ed 20 02		    jr nz, .b7 
00ef cb b9		    res 7,c 
00f1			.b7: 
00f1				; then low 
00f1 cb af			res SPI_SCLK,a 
00f3 d3 80			out (storage_adata),a 
00f5 00				nop 
00f6			     
00f6			 
00f6				; clock bit high 
00f6 cb ef			set SPI_SCLK,a 
00f8 d3 80			out (storage_adata),a 
00fa 00				nop 
00fb			 
00fb			    ; read DO  
00fb			 
00fb cb f1		    set 6,c 
00fd db 80			in a,(storage_adata) 
00ff cb 77		    bit SPI_DO,a 
0101 20 02		    jr nz, .b6 
0103 cb b1		    res 6,c 
0105			.b6: 
0105				; then low 
0105 cb af			res SPI_SCLK,a 
0107 d3 80			out (storage_adata),a 
0109 00				nop 
010a			 
010a				; clock bit high 
010a cb ef			set SPI_SCLK,a 
010c d3 80			out (storage_adata),a 
010e 00				nop 
010f			 
010f			 
010f			    ; read DO  
010f			 
010f cb e9		    set 5,c 
0111 db 80			in a,(storage_adata) 
0113 cb 77		    bit SPI_DO,a 
0115 20 02		    jr nz, .b5 
0117 cb a9		    res 5,c 
0119			.b5: 
0119				; then low 
0119 cb af			res SPI_SCLK,a 
011b d3 80			out (storage_adata),a 
011d 00				nop 
011e				; clock bit high 
011e cb ef			set SPI_SCLK,a 
0120 d3 80			out (storage_adata),a 
0122 00				nop 
0123			 
0123			    ; read DO  
0123			 
0123 cb e1		    set 4,c 
0125 db 80			in a,(storage_adata) 
0127 cb 77		    bit SPI_DO,a 
0129 20 02		    jr nz, .b4 
012b cb a1		    res 4,c 
012d			.b4: 
012d				; then low 
012d cb af			res SPI_SCLK,a 
012f d3 80			out (storage_adata),a 
0131 00				nop 
0132				; clock bit high 
0132 cb ef			set SPI_SCLK,a 
0134 d3 80			out (storage_adata),a 
0136 00				nop 
0137			 
0137			    ; read DO  
0137			 
0137 cb d9		    set 3,c 
0139 db 80			in a,(storage_adata) 
013b cb 77		    bit SPI_DO,a 
013d 20 02		    jr nz, .b3 
013f cb 99		    res 3,c 
0141			.b3: 
0141				; then low 
0141 cb af			res SPI_SCLK,a 
0143 d3 80			out (storage_adata),a 
0145 00				nop 
0146				; clock bit high 
0146 cb ef			set SPI_SCLK,a 
0148 d3 80			out (storage_adata),a 
014a 00				nop 
014b			 
014b			    ; read DO  
014b			 
014b cb d1		    set 2,c 
014d db 80			in a,(storage_adata) 
014f cb 77		    bit SPI_DO,a 
0151 20 02		    jr nz, .b2 
0153 cb 91		    res 2,c 
0155			.b2: 
0155				; then low 
0155 cb af			res SPI_SCLK,a 
0157 d3 80			out (storage_adata),a 
0159 00				nop 
015a				; clock bit high 
015a cb ef			set SPI_SCLK,a 
015c d3 80			out (storage_adata),a 
015e 00				nop 
015f			 
015f			    ; read DO  
015f			 
015f cb c9		    set 1,c 
0161 db 80			in a,(storage_adata) 
0163 cb 77		    bit SPI_DO,a 
0165 20 02		    jr nz, .b1 
0167 cb 89		    res 1,c 
0169			.b1: 
0169				; then low 
0169 cb af			res SPI_SCLK,a 
016b d3 80			out (storage_adata),a 
016d 00				nop 
016e				; clock bit high 
016e cb ef			set SPI_SCLK,a 
0170 d3 80			out (storage_adata),a 
0172 00				nop 
0173			 
0173			    ; read DO  
0173			 
0173 cb c1		    set 0,c 
0175 db 80			in a,(storage_adata) 
0177 cb 77		    bit SPI_DO,a 
0179 20 02		    jr nz, .b0 
017b cb 81		    res 0,c 
017d			.b0: 
017d				; then low 
017d cb af			res SPI_SCLK,a 
017f d3 80			out (storage_adata),a 
0181 00				nop 
0182			 
0182			 
0182 32 5d f8			ld (spi_portbyte),a 
0185			 
0185			    ; return byte 
0185 79			    ld a,c 
0186			 
0186			 
0186 c9				ret 
0187			 
0187			 
0187			 
0187			spi_ce_high: 
0187			 
0187				if DEBUG_SPI_HARD_CE0 
0187			       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0187					ret 
0187			 
0187				endif 
0187			 
0187			 
0187 f5				push af 
0188			 
0188				; send direct ce to port b 
0188 3e ff			ld a, 255 
018a d3 81			out (storage_bdata), a 
018c			 
018c f1				pop af 
018d			 
018d				; for port a that shares with spi lines AND the mask 
018d			  
018d				if DEBUG_SPI 
018d					push hl 
018d					ld h, a 
018d				endif 
018d			;	ld c, SPI_CE_HIGH 
018d			;	and c 
018d cb c7			set SPI_CE0, a 
018f cb cf			set SPI_CE1, a 
0191 cb d7			set SPI_CE2, a 
0193 cb df			set SPI_CE3, a 
0195 cb e7			set SPI_CE4, a 
0197			 
0197				if DEBUG_SPI 
0197					ld l, a 
0197					DMARK "CEh" 
0197					CALLMONITOR 
0197					pop hl 
0197				endif 
0197 c9				ret 
0198			 
0198			 
0198			spi_ce_low: 
0198			 
0198				if DEBUG_SPI_HARD_CE0 
0198			       res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0198					ret 
0198			 
0198				endif 
0198			 
0198 c5				push bc 
0199 f5				push af 
019a			 
019a				; send direct ce to port b 
019a 3a 5f f8			ld a, (spi_cartdev) 
019d d3 81			out (storage_bdata), a 
019f			 
019f			 
019f			 
019f				; for port a that shares with spi lines AND the mask 
019f			 
019f 3a 5c f8			ld a, (spi_device)  
01a2 4f				ld c, a 
01a3			 
01a3 f1				pop af 
01a4			 
01a4				; detect CEx 
01a4			 
01a4				if DEBUG_SPI 
01a4					push hl 
01a4					ld h, a 
01a4				endif 
01a4			 
01a4 cb 41			bit SPI_CE0, c 
01a6 20 04			jr nz, .cel1 
01a8 cb 87			res SPI_CE0, a 
01aa 18 1e			jr .celn 
01ac			.cel1: 
01ac cb 49			bit SPI_CE1, c 
01ae 20 04			jr nz, .cel2 
01b0 cb 8f			res SPI_CE1, a 
01b2 18 16			jr .celn 
01b4			.cel2: 
01b4 cb 51			bit SPI_CE2, c 
01b6 20 04			jr nz, .cel3 
01b8 cb 97			res SPI_CE2, a 
01ba 18 0e			jr .celn 
01bc			.cel3: 
01bc cb 59			bit SPI_CE3, c 
01be 20 04			jr nz, .cel4 
01c0 cb 9f			res SPI_CE3, a 
01c2 18 06			jr .celn 
01c4			.cel4: 
01c4 cb 61			bit SPI_CE4, c 
01c6 20 02			jr nz, .celn 
01c8 cb a7			res SPI_CE4, a 
01ca			.celn: 
01ca			 
01ca			 
01ca			 
01ca			;	add c 
01ca			 
01ca				if DEBUG_SPI 
01ca					ld l, a 
01ca					DMARK "CEl" 
01ca					CALLMONITOR 
01ca					pop hl 
01ca				endif 
01ca c1				pop bc 
01cb c9				ret 
01cc			 
01cc			 
01cc			 
01cc			; eof 
01cc			 
01cc			 
01cc			 
01cc			 
01cc			 
# End of file firmware_spi.asm
01cc				include "firmware_seeprom.asm"  
01cc			; 
01cc			; persisent storage interface via microchip serial eeprom 
01cc			 
01cc			; port a pio 2 
01cc			; pa 7 - si 
01cc			; pa 6 - sclk  
01cc			; pa 5 - so 
01cc			; pa 4 - cs 
01cc			; pa 3 - cs 
01cc			; pa 2 - cs 
01cc			; pa 1 - cs 
01cc			; pa 0 - cs 
01cc			; 
01cc			; TODO get block 
01cc			; TODO save block 
01cc			; TODO load file 
01cc			; TODO save file 
01cc			; TODO get dir  
01cc			 
01cc			;  
01cc			storage_adata: equ Device_C    ; device c port a - onboard storage 
01cc			storage_actl: equ Device_C+2     ; device c port a 
01cc			storage_bdata: equ Device_C+1    ; device c port b - ext storage cart 
01cc			storage_bctl: equ Device_C+3     ; device c port b 
01cc			 
01cc			 
01cc			; TODO move these to hardware driver file 
01cc			 
01cc			;STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom 
01cc			;STORE_DEVICE_MAXBLOCKS:  equ  512 ; how many blocks are there on this storage device 
01cc			; storage bank file system format 
01cc			; 
01cc			; first page of bank: 
01cc			; 	addr 0 - status check 
01cc			;       addr 1 - write protect flag 
01cc			;       addr 2 - zero if all data is held on this device. >0 - next device number (not used right now) 
01cc			;       addr 3 - last file id (to save on scanning for spare file id). or could have bit mask of file ids in use????  
01cc			;         TODO see if scanning whole of for available next file id is fast enough 
01cc			;	addr 4 > zero term string of bank label 
01cc			; 
01cc			;        
01cc			;  
01cc			; first page of any file: 
01cc			;      byte 0 - file id  
01cc			;      byte 1-17 - fixed file name  
01cc			;      byte 18-end of page - extra meta data tba (date? description? keywords?) 
01cc			; 
01cc			; other pages of any file: 
01cc			;      byte 0 - file id 
01cc			;      byte 1> - file data 
01cc			; 
01cc			; TODO depending on how long it takes to load a file in if scanning the whole bank for the file id, could speed it up by having last file page flag??? high bit? that would max 127 files 
01cc			;  
01cc			; TODO need a bank format which places a 0 in each of the first byte of every page and updates the meta in page 0 
01cc			 
01cc			 
01cc			;storage_so_bit: 5 
01cc			;storage_si_bit: 7 
01cc			;storage_sclk_bit: 6 
01cc			  
01cc			 
01cc			; init storage pio 
01cc			 
01cc			storage_init: 
01cc			 
01cc 3e cf		            LD   A, 11001111b 
01ce d3 82		            OUT  (storage_actl), A  ;Port A = PIO 'control' mode 
01d0 3e 00		            LD   A, 00000000b 
01d2 cb f7			set SPI_DO,a 
01d4			;            LD   A, SPI_DO      ; only one input line  the rest are outputs 
01d4 d3 82		            OUT  (storage_actl),A   ;Port A = all lines are outputs 
01d6			 
01d6 3e cf		            LD   A, 11001111b 
01d8 d3 83		            OUT  (storage_bctl), A  ;Port A = PIO 'control' mode 
01da 3e 00		            LD   A, 00000000b 
01dc d3 83		            OUT  (storage_bctl),A   ;Port A = all lines are outputs 
01de			 
01de				; set all external spi devices off 
01de 3e 00			ld a, 0 
01e0 32 5c f8			ld (spi_device), a 
01e3 32 5f f8			ld (spi_cartdev), a 
01e6			 
01e6					; ensure the spi bus is in a default stable state 
01e6 cd b1 00				call se_stable_spi 
01e9			 
01e9			; TODO scan spi bus and gather which storage banks are present 
01e9			 
01e9			; populate store_bank_active  
01e9			; for each ce line activate and attempt to write first byte of bank and read back 
01e9			; if zero is returned then bank is empty 
01e9			;   
01e9			; 
01e9			 
01e9					; init file extent cache to save on slow reads 
01e9			 
01e9			;	ld hl, store_filecache 
01e9			;	ld de, 0 
01e9			;	ld hl,(de)	 
01e9			 
01e9			 
01e9 c9			    ret 
01ea			 
01ea			store_read_ins: equ 000000011b   ; Read data from memory array beginning at selected address 
01ea			store_write_ins: equ 000000010b  ;  Write data to memory array beginning at selected address 
01ea			store_wren_ins: equ 000000110b   ;  Set the write enable latch (enable write operations) 
01ea			 
01ea			; INSTRUCTION SET 
01ea			; READ 0000 0011 Read data from memory array beginning at selected address 
01ea			; WRITE 0000 0010 Write data to memory array beginning at selected address 
01ea			; WREN 0000 0110 Set the write enable latch (enable write operations) 
01ea			; WRDI 0000 0100 Reset the write enable latch (disable write operations) 
01ea			; RDSR 0000 0101 Read STATUS register 
01ea			; WRSR 0000 0001 Write STATUS register 
01ea			; PE 0100 0010 Page Erase – erase one page in memory array 
01ea			; SE 1101 1000 Sector Erase – erase one sector in memory array 
01ea			; CE 1100 0111 Chip Erase – erase all sectors in memory array 
01ea			; RDID 1010 1011 Release from Deep power-down and read electronic signature 
01ea			 
01ea			; TODO send byte steam for page without setting the address for every single byte 
01ea			; TODO read byte  
01ea			 
01ea			; byte in a 
01ea			; address in hl  
01ea			se_writebyte: 
01ea			        
01ea			    ;   ld c, a 
01ea f5			        push af 
01eb e5			        push hl 
01ec			 
01ec			    ; initi write mode 
01ec			    ; 
01ec			    ;CS low 
01ec			 
01ec 3a 5d f8		       ld a,(spi_portbyte) 
01ef cd 98 01			call spi_ce_low 
01f2			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
01f2 d3 80		       out (storage_adata),a 
01f4 32 5d f8		       ld (spi_portbyte), a 
01f7			 
01f7			    ;clock out wren instruction 
01f7			 
01f7 3e 06		    ld a, store_wren_ins 
01f9 cd bc 00		    call spi_send_byte  
01fc			 
01fc			    ;cs high to enable write latch 
01fc			 
01fc 3a 5d f8		       ld a,(spi_portbyte) 
01ff cd 87 01			call spi_ce_high 
0202			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask 
0202 d3 80		       out (storage_adata),a 
0204 32 5d f8		       ld (spi_portbyte), a 
0207			 
0207 00				nop 
0208			    ; 
0208			    ; intial write data 
0208			    ; 
0208			    ; cs low 
0208			     
0208 3a 5d f8		       ld a,(spi_portbyte) 
020b cd 98 01			call spi_ce_low 
020e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
020e d3 80		       out (storage_adata),a 
0210 32 5d f8		       ld (spi_portbyte), a 
0213			 
0213			    ; clock out write instruction 
0213			     
0213 3e 02		    ld a, store_write_ins  
0215 cd bc 00		    call spi_send_byte  
0218			 
0218			    ; clock out address (depending on address size) 
0218			     
0218 e1			    pop hl 
0219 7c			    ld a,h    ; address out msb first 
021a cd bc 00		    call spi_send_byte  
021d 7d			    ld a,l 
021e cd bc 00		    call spi_send_byte  
0221			 
0221			    ; clock out byte(s) for page 
0221			 
0221 f1			    pop af 
0222 cd bc 00		    call spi_send_byte  
0225			 
0225			    ; end write with ce high 
0225 3a 5d f8		       ld a,(spi_portbyte) 
0228			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
0228 cd 87 01			call spi_ce_high 
022b d3 80		       out (storage_adata),a 
022d 32 5d f8		       ld (spi_portbyte), a 
0230			 
0230				; pause for internal write cycle 
0230 3e 0a			ld a, 10 
0232 cd 22 0a			call aDelayInMS 
0235 c9			    ret 
0236			 
0236			; buffer to write in de 
0236			; address in hl  
0236			se_writepage: 
0236			        
0236			    ;   ld c, a 
0236 d5				push de 
0237 e5			        push hl 
0238			 
0238			    ; initi write mode 
0238			    ; 
0238			    ;CS low 
0238			 
0238 3a 5d f8		       ld a,(spi_portbyte) 
023b cd 98 01			call spi_ce_low 
023e			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
023e d3 80		       out (storage_adata),a 
0240 32 5d f8		       ld (spi_portbyte), a 
0243			 
0243			    ;clock out wren instruction 
0243			 
0243 3e 06		    ld a, store_wren_ins 
0245 cd bc 00		    call spi_send_byte  
0248			 
0248			    ;cs high to enable write latch 
0248			 
0248 3a 5d f8		       ld a,(spi_portbyte) 
024b cd 87 01			call spi_ce_high 
024e			       ;set SPI_CE0,a           ; TODO pass the ce bank bit mask 
024e d3 80		       out (storage_adata),a 
0250 32 5d f8		       ld (spi_portbyte), a 
0253			 
0253 00				nop 
0254			    ; 
0254			    ; intial write data 
0254			    ; 
0254			    ; cs low 
0254			     
0254 3a 5d f8		       ld a,(spi_portbyte) 
0257			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0257 cd 98 01			call spi_ce_low 
025a d3 80		       out (storage_adata),a 
025c 32 5d f8		       ld (spi_portbyte), a 
025f			 
025f			    ; clock out write instruction 
025f			     
025f 3e 02		    ld a, store_write_ins  
0261 cd bc 00		    call spi_send_byte  
0264			 
0264			    ; clock out address (depending on address size) 
0264			     
0264 e1			    pop hl 
0265 7c			    ld a,h    ; address out msb first 
0266 cd bc 00		    call spi_send_byte  
0269 7d			    ld a,l 
026a cd bc 00		    call spi_send_byte  
026d			 
026d			    ; clock out byte(s) for page 
026d			 
026d e1				pop hl 
026e 06 40			ld b, STORE_BLOCK_PHY 
0270			.bytewrite: 
0270			 
0270 7e				ld a,(hl) 
0271 e5			    push hl 
0272 c5				push bc 
0273 cd bc 00		    call spi_send_byte  
0276 c1				pop bc 
0277 e1				pop hl 
0278			 
0278			    ; end write with ce high 
0278 3a 5d f8		       ld a,(spi_portbyte) 
027b cd 87 01			call spi_ce_high 
027e			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
027e d3 80		       out (storage_adata),a 
0280 32 5d f8		       ld (spi_portbyte), a 
0283			 
0283 23				inc hl 
0284 10 ea			djnz .bytewrite 
0286			 
0286				; pause for internal write cycle 
0286 3e 64			ld a, 100 
0288 cd 22 0a			call aDelayInMS 
028b c9			    ret 
028c			; returns byte in a 
028c			; address in hl  
028c			se_readbyte: 
028c d5				push de 
028d c5				push bc 
028e			 
028e			    ;   ld c, a 
028e e5			        push hl 
028f			 
028f			    ; initi write mode 
028f			    ; 
028f			    ;CS low 
028f			 
028f 3a 5d f8		       ld a,(spi_portbyte) 
0292 cd 98 01			call spi_ce_low 
0295			       ;res SPI_CE0,a           ; TODO pass the ce bank bit mask 
0295 d3 80		       out (storage_adata),a 
0297 32 5d f8		       ld (spi_portbyte), a 
029a			 
029a			    ;clock out wren instruction 
029a			 
029a 3e 03		    ld a, store_read_ins 
029c cd bc 00		    call spi_send_byte  
029f			 
029f			 
029f			    ; clock out address (depending on address size) 
029f			     
029f e1			    pop hl 
02a0 7c			    ld a,h    ; address out msb first 
02a1 cd bc 00		    call spi_send_byte  
02a4 7d			    ld a,l 
02a5 cd bc 00		    call spi_send_byte  
02a8			 
02a8			    ; clock in byte(s) for page 
02a8			 
02a8 cd dd 00		    call spi_read_byte  
02ab f5				push af 
02ac			 
02ac			    ; end write with ce high 
02ac 3a 5d f8		       ld a,(spi_portbyte) 
02af			;       set SPI_CE0,a           ; TODO pass the ce bank bit mask - perhaps have a call that sets it 
02af cd 87 01			call spi_ce_high 
02b2 d3 80		       out (storage_adata),a 
02b4 32 5d f8		       ld (spi_portbyte), a 
02b7			 
02b7 f1				pop af 
02b8			 
02b8 c1				pop bc 
02b9 d1				pop de 
02ba			 
02ba c9			    ret 
02bb			 
02bb			if DEBUG_STORESE 
02bb			 
02bb			storageput:  
02bb			 
02bb			; get address (so long as it is in first page due to reload otherwise use prom programmer to see if) 
02bb			 
02bb 21 34 ee			ld hl,scratch+2 
02be cd c9 0f			call get_word_hl 
02c1			 
02c1				; stuff it here for the moment as it will be overwritten later anyway 
02c1			 
02c1 22 55 f1			ld (os_cur_ptr),hl	 
02c4			 
02c4			 
02c4			; get pointer to start of string 
02c4			 
02c4 21 39 ee			ld hl, scratch+7 
02c7			 
02c7			; loop writing char of string to eeprom 
02c7			 
02c7 7e			.writestr:	ld a,(hl) 
02c8 fe 00				cp 0 
02ca 28 12				jr z, .wsdone		; done writing 
02cc e5					push hl 
02cd 2a 55 f1				ld hl,(os_cur_ptr) 
02d0 cd ea 01				call se_writebyte 
02d3			 
02d3 2a 55 f1				ld hl,(os_cur_ptr)	 ; save next eeprom address 
02d6 23					inc hl 
02d7 22 55 f1				ld (os_cur_ptr),hl 
02da			 
02da					; restore string pointer and get next char 
02da			 
02da e1					pop hl 
02db 23					inc hl 
02dc 18 e9				jr .writestr 
02de			 
02de			 
02de			 
02de			.wsdone: 
02de			 
02de			 
02de			; when done load first page into a buffer  
02de			 
02de 21 00 80				ld hl,08000h		; start in ram 
02e1 22 55 f1				ld (os_cur_ptr),hl 
02e4 21 00 00				ld hl, 0		 ; start of page 
02e7 22 5a ee				ld (scratch+40),hl	; hang on to it 
02ea			 
02ea 06 80				ld b, 128		; actually get more then one page 
02ec c5			.wsload:	push bc 
02ed 2a 5a ee				ld hl,(scratch+40) 
02f0 e5					push hl 
02f1 cd 8c 02				call se_readbyte 
02f4			 
02f4					; a now as the byte 
02f4			 
02f4 2a 55 f1				ld hl,(os_cur_ptr) 
02f7 77					ld (hl),a 
02f8					; inc next buffer area 
02f8 23					inc hl 
02f9 22 55 f1				ld (os_cur_ptr),hl 
02fc			 
02fc					; get eeprom position, inc and save for next round 
02fc e1					pop hl		 
02fd 23					inc hl 
02fe 22 5a ee				ld (scratch+40),hl 
0301 c1					pop bc 
0302 10 e8				djnz .wsload 
0304			 
0304			; set 'd' pointer to start of buffer 
0304			 
0304 21 00 80				ld hl,08000h 
0307 22 55 f1				ld (os_cur_ptr),hl 
030a			 
030a			 
030a c9			ret 
030b			 
030b			 
030b c9			storageread: ret 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			 
030c			endif 
030c			 
030c			 
030c			 
# End of file firmware_seeprom.asm
030c			else  
030c			   ; create some stubs for the labels  
030c			se_readbyte: ret  
030c			se_writebyte: ret  
030c			storage_init: ret  
030c			  
030c			endif  
030c			  
030c			; use cf card for storage - throwing timeout errors. Hardware or software?????  
030c			;include "firmware_cf.asm"  
030c			  
030c			; load up high level storage hardward abstractions  
030c			include "firmware_storage.asm"  
030c			 
030c			; persisent storage hardware abstraction layer  
030c			 
030c			 
030c			 
030c			; Block 0 on storage is a config state 
030c			 
030c			 
030c			 
030c			; TODO add read phy block and write phy block functions 
030c			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
030c			 
030c			; Abstraction layer  
030c			 
030c			; Logocial block size is same size as physical size - using tape concept 
030c			 
030c			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
030c			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
030c			 
030c			 
030c			 
030c			; Filesystem layout (Logical layout) 
030c			; 
030c			; Block 0 - Bank config  
030c			; 
030c			;      Byte - 0 file id counter 
030c			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
030c			;      Byte - 3-20 zero terminated bank label 
030c			; 
030c			; Block 1 > File storage 
030c			; 
030c			;      Byte 0 file id    - block 0 file details 
030c			;      Byte 1 block id - block 0 is file  
030c			;            Byte 2-15 - File name 
030c			; 
030c			;       - to end of block data 
030c			; 
030c			 
030c			 
030c			; Read Block 
030c			; ---------- 
030c			; 
030c			; With current bank 
030c			;  
030c			; Get block number to read 
030c			; Load physical blocks starting at start block into buffer 
030c			 
030c			; de points to buffer to use 
030c			; hl holds logical block number  
030c			 
030c			storage_read_block: 
030c			 
030c				; TODO bank selection 
030c			 
030c				; for each of the physical blocks read it into the buffer 
030c 06 40			ld b, STORE_BLOCK_PHY 
030e			 
030e				if DEBUG_STORESE 
030e d5					push de 
030f				endif 
030f				 
030f			.rl1:    
030f			 
030f				; read physical block at hl into de 
030f			        ; increment hl and de to next read position on exit 
030f			 
030f e5				push hl 
0310 d5				push de	 
0311 c5				push bc 
0312			;	if DEBUG_STORESE 
0312			;		push af 
0312			;		ld a, 'R' 
0312			;		ld (debug_mark),a 
0312			;		pop af 
0312			;		CALLMONITOR 
0312			;	endif 
0312 cd 8c 02			call se_readbyte 
0315			;	if DEBUG_STORESE 
0315			;		ld a,(spi_portbyte) 
0315			;		ld l, a 
0315			;		push af 
0315			;		ld a, '1' 
0315			;		ld (debug_mark),a 
0315			;		pop af 
0315			;		CALLMONITOR 
0315			;	endif 
0315 c1				pop bc 
0316 d1				pop de 
0317 e1				pop hl 
0318 12				ld (de),a 
0319 23				inc hl 
031a 13				inc de 
031b			 
031b			;	if DEBUG_STORESE 
031b			;		push af 
031b			;		ld a, 'r' 
031b			;		ld (debug_mark),a 
031b			;		pop af 
031b			;		CALLMONITOR 
031b			;	endif 
031b			 
031b 10 f2			djnz .rl1 
031d			 
031d				if DEBUG_STORESE 
031d					DMARK "SRB" 
031d f5				push af  
031e 3a 32 03			ld a, (.dmark)  
0321 32 77 fb			ld (debug_mark),a  
0324 3a 33 03			ld a, (.dmark+1)  
0327 32 78 fb			ld (debug_mark+1),a  
032a 3a 34 03			ld a, (.dmark+2)  
032d 32 79 fb			ld (debug_mark+2),a  
0330 18 03			jr .pastdmark  
0332 ..			.dmark: db "SRB"  
0335 f1			.pastdmark: pop af  
0336			endm  
# End of macro DMARK
0336 d1					pop de 
0337			; 
0337			;		push af 
0337			;		ld a, 'R' 
0337			;		ld (debug_mark),a 
0337			;		pop af 
0337					CALLMONITOR 
0337 cd 00 14			call break_point_state  
033a				endm  
# End of macro CALLMONITOR
033a				endif 
033a c9				ret	 
033b				 
033b			 
033b			; File Size 
033b			; --------- 
033b			; 
033b			;   hl file id 
033b			; 
033b			;  returns in hl the number of blocks 
033b			 
033b			storage_file_size: 
033b 5d				ld e, l 
033c 16 00			ld d, 0 
033e 21 40 00			ld hl, STORE_BLOCK_PHY 
0341					if DEBUG_FORTH_WORDS 
0341						DMARK "SIZ" 
0341 f5				push af  
0342 3a 56 03			ld a, (.dmark)  
0345 32 77 fb			ld (debug_mark),a  
0348 3a 57 03			ld a, (.dmark+1)  
034b 32 78 fb			ld (debug_mark+1),a  
034e 3a 58 03			ld a, (.dmark+2)  
0351 32 79 fb			ld (debug_mark+2),a  
0354 18 03			jr .pastdmark  
0356 ..			.dmark: db "SIZ"  
0359 f1			.pastdmark: pop af  
035a			endm  
# End of macro DMARK
035a						CALLMONITOR 
035a cd 00 14			call break_point_state  
035d				endm  
# End of macro CALLMONITOR
035d					endif 
035d cd 22 06			call storage_findnextid 
0360			 
0360 cd 3b 0c			call ishlzero 
0363			;	ld a, l 
0363			;	add h 
0363			;	cp 0 
0363 c8				ret z			; block not found so EOF 
0364			 
0364 11 62 f8			ld de, store_page 
0367 cd 0c 03			call storage_read_block 
036a			 
036a 3a 64 f8			ld a, (store_page+2)	 ; get extent count 
036d 6f				ld l, a 
036e 26 00			ld h, 0 
0370 c9			 	ret 
0371			 
0371			 
0371			; Write Block 
0371			; ----------- 
0371			; 
0371			; With current bank 
0371			;  
0371			; Get block number to write 
0371			; Write physical blocks starting at start block from buffer 
0371			  
0371			storage_write_block: 
0371				; TODO bank selection 
0371			 
0371				; for each of the physical blocks read it into the buffer 
0371 06 40			ld b, STORE_BLOCK_PHY 
0373			 
0373				if DEBUG_STORESE 
0373					DMARK "SWB" 
0373 f5				push af  
0374 3a 88 03			ld a, (.dmark)  
0377 32 77 fb			ld (debug_mark),a  
037a 3a 89 03			ld a, (.dmark+1)  
037d 32 78 fb			ld (debug_mark+1),a  
0380 3a 8a 03			ld a, (.dmark+2)  
0383 32 79 fb			ld (debug_mark+2),a  
0386 18 03			jr .pastdmark  
0388 ..			.dmark: db "SWB"  
038b f1			.pastdmark: pop af  
038c			endm  
# End of macro DMARK
038c			 
038c					;push af 
038c					;ld a, 'W' 
038c					;ld (debug_mark),a 
038c					;pop af 
038c					CALLMONITOR 
038c cd 00 14			call break_point_state  
038f				endm  
# End of macro CALLMONITOR
038f				endif 
038f			 
038f			; might not be working 
038f			;	call se_writepage 
038f			 
038f			;	ret 
038f			; 
038f			 
038f			 
038f			 
038f			.wl1:    
038f			 
038f				; read physical block at hl into de 
038f			        ; increment hl and de to next read position on exit 
038f			 
038f e5				push hl 
0390 d5				push de	 
0391 c5				push bc 
0392 1a				ld a,(de) 
0393				;if DEBUG_STORESE 
0393			;		push af 
0393			;		ld a, 'W' 
0393			;		ld (debug_mark),a 
0393			;		pop af 
0393			;		CALLMONITOR 
0393			;	endif 
0393 cd ea 01			call se_writebyte 
0396			;	call delay250ms 
0396 00				nop 
0397 00				nop 
0398 00				nop 
0399			;	if DEBUG_STORESE 
0399			;		push af 
0399			;		ld a, 'w' 
0399			;		ld (debug_mark),a 
0399			;		pop af 
0399			;		CALLMONITOR 
0399			;	endif 
0399 c1				pop bc 
039a d1				pop de 
039b e1				pop hl 
039c 23				inc hl 
039d 13				inc de 
039e			 
039e			 
039e 10 ef			djnz .wl1 
03a0			 
03a0				if DEBUG_STORESE 
03a0					DMARK "SW2" 
03a0 f5				push af  
03a1 3a b5 03			ld a, (.dmark)  
03a4 32 77 fb			ld (debug_mark),a  
03a7 3a b6 03			ld a, (.dmark+1)  
03aa 32 78 fb			ld (debug_mark+1),a  
03ad 3a b7 03			ld a, (.dmark+2)  
03b0 32 79 fb			ld (debug_mark+2),a  
03b3 18 03			jr .pastdmark  
03b5 ..			.dmark: db "SW2"  
03b8 f1			.pastdmark: pop af  
03b9			endm  
# End of macro DMARK
03b9			 
03b9					;push af 
03b9					;ld a, 'W' 
03b9					;ld (debug_mark),a 
03b9					;pop af 
03b9					CALLMONITOR 
03b9 cd 00 14			call break_point_state  
03bc				endm  
# End of macro CALLMONITOR
03bc				endif 
03bc c9				ret	 
03bd			 
03bd			; Init bank 
03bd			; --------- 
03bd			; 
03bd			; With current bank 
03bd			; 
03bd			; Setup block 0 config 
03bd			;     Set 0 file id counter 
03bd			;     Set formatted byte pattern 
03bd			;     Zero out bank label 
03bd			;      
03bd			; For every logical block write 0-1 byte as null 
03bd			 
03bd			storage_get_block_0: 
03bd			 
03bd				; TODO check presence 
03bd			 
03bd				; get block 0 config 
03bd			 
03bd 21 00 00			ld hl, 0 
03c0 11 62 f8			ld de, store_page 
03c3 cd 0c 03			call storage_read_block 
03c6			 
03c6				if DEBUG_STORESE 
03c6					DMARK "SB0" 
03c6 f5				push af  
03c7 3a db 03			ld a, (.dmark)  
03ca 32 77 fb			ld (debug_mark),a  
03cd 3a dc 03			ld a, (.dmark+1)  
03d0 32 78 fb			ld (debug_mark+1),a  
03d3 3a dd 03			ld a, (.dmark+2)  
03d6 32 79 fb			ld (debug_mark+2),a  
03d9 18 03			jr .pastdmark  
03db ..			.dmark: db "SB0"  
03de f1			.pastdmark: pop af  
03df			endm  
# End of macro DMARK
03df 11 62 f8				ld de, store_page 
03e2			;		push af 
03e2			;		ld a, 'i' 
03e2			;		ld (debug_mark),a 
03e2			;		pop af 
03e2					CALLMONITOR 
03e2 cd 00 14			call break_point_state  
03e5				endm  
# End of macro CALLMONITOR
03e5				endif 
03e5			 
03e5				; is this area formatted? 
03e5			 
03e5			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
03e5 2a 63 f8			ld hl, (store_page+1) 
03e8 3e 80			ld a,0x80 
03ea bd				cp l 
03eb 20 22			jr nz, .ininotformatted 
03ed				; do a double check 
03ed 3e 27			ld a, 0x27 
03ef bc				cp h 
03f0 20 1d			jr nz, .ininotformatted 
03f2			 
03f2				; formatted then 
03f2			 
03f2				if DEBUG_STORESE 
03f2					DMARK "SB1" 
03f2 f5				push af  
03f3 3a 07 04			ld a, (.dmark)  
03f6 32 77 fb			ld (debug_mark),a  
03f9 3a 08 04			ld a, (.dmark+1)  
03fc 32 78 fb			ld (debug_mark+1),a  
03ff 3a 09 04			ld a, (.dmark+2)  
0402 32 79 fb			ld (debug_mark+2),a  
0405 18 03			jr .pastdmark  
0407 ..			.dmark: db "SB1"  
040a f1			.pastdmark: pop af  
040b			endm  
# End of macro DMARK
040b					;push af 
040b					;ld a, 'I' 
040b					;ld (debug_mark),a 
040b					;pop af 
040b					CALLMONITOR 
040b cd 00 14			call break_point_state  
040e				endm  
# End of macro CALLMONITOR
040e				endif 
040e c9				ret 
040f			 
040f			.ininotformatted: 
040f				; bank not formatted so poke various bits to make sure 
040f			 
040f				if DEBUG_STORESE 
040f					DMARK "SB2" 
040f f5				push af  
0410 3a 24 04			ld a, (.dmark)  
0413 32 77 fb			ld (debug_mark),a  
0416 3a 25 04			ld a, (.dmark+1)  
0419 32 78 fb			ld (debug_mark+1),a  
041c 3a 26 04			ld a, (.dmark+2)  
041f 32 79 fb			ld (debug_mark+2),a  
0422 18 03			jr .pastdmark  
0424 ..			.dmark: db "SB2"  
0427 f1			.pastdmark: pop af  
0428			endm  
# End of macro DMARK
0428					;push af 
0428					;ld a, 'f' 
0428					;ld (debug_mark),a 
0428					;pop af 
0428					CALLMONITOR 
0428 cd 00 14			call break_point_state  
042b				endm  
# End of macro CALLMONITOR
042b				endif 
042b			 
042b 21 62 f8			ld hl, store_page 
042e 3e 00			ld a, 0 
0430				 
0430 77				ld (hl),a   ; reset file counter 
0431			 
0431 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0434 22 63 f8		 	ld (store_page+1), hl	 
0437			 
0437				; set default label 
0437			 
0437 21 cc 04			ld hl, .defaultbanklabl 
043a 11 65 f8		 	ld de, store_page+3 
043d 01 0f 00			ld bc, 15 
0440 ed b0			ldir 
0442			 
0442				; save default page 0 
0442			 
0442 21 00 00			ld hl, 0 
0445 11 62 f8			ld de, store_page 
0448				if DEBUG_STORESE 
0448					DMARK "SB3" 
0448 f5				push af  
0449 3a 5d 04			ld a, (.dmark)  
044c 32 77 fb			ld (debug_mark),a  
044f 3a 5e 04			ld a, (.dmark+1)  
0452 32 78 fb			ld (debug_mark+1),a  
0455 3a 5f 04			ld a, (.dmark+2)  
0458 32 79 fb			ld (debug_mark+2),a  
045b 18 03			jr .pastdmark  
045d ..			.dmark: db "SB3"  
0460 f1			.pastdmark: pop af  
0461			endm  
# End of macro DMARK
0461			;		push af 
0461			;		ld a, 'F' 
0461			;		ld (debug_mark),a 
0461			;		pop af 
0461					CALLMONITOR 
0461 cd 00 14			call break_point_state  
0464				endm  
# End of macro CALLMONITOR
0464				endif 
0464 cd 71 03			call storage_write_block 
0467				if DEBUG_STORESE 
0467					DMARK "SB4" 
0467 f5				push af  
0468 3a 7c 04			ld a, (.dmark)  
046b 32 77 fb			ld (debug_mark),a  
046e 3a 7d 04			ld a, (.dmark+1)  
0471 32 78 fb			ld (debug_mark+1),a  
0474 3a 7e 04			ld a, (.dmark+2)  
0477 32 79 fb			ld (debug_mark+2),a  
047a 18 03			jr .pastdmark  
047c ..			.dmark: db "SB4"  
047f f1			.pastdmark: pop af  
0480			endm  
# End of macro DMARK
0480			;		push af 
0480			;		ld a, '>' 
0480			;		ld (debug_mark),a 
0480			;		pop af 
0480					CALLMONITOR 
0480 cd 00 14			call break_point_state  
0483				endm  
# End of macro CALLMONITOR
0483				endif 
0483			 
0483 00				nop 
0484 00				nop 
0485 00				nop 
0486			 
0486				; now set 0 in every page to mark as a free block 
0486			 
0486 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0488 21 40 00			ld hl, STORE_BLOCK_PHY 
048b			 
048b 3e 00		.setmark1:   	ld a,0 
048d e5					push hl 
048e c5					push bc 
048f cd ea 01				call se_writebyte 
0492 3e 0a			ld a, 10 
0494 cd 22 0a			call aDelayInMS 
0497 23				inc hl 
0498 cd ea 01				call se_writebyte 
049b 3e 0a			ld a, 10 
049d cd 22 0a			call aDelayInMS 
04a0 2b				dec hl 
04a1 c1					pop bc 
04a2 e1					pop hl 
04a3 3e 40				ld a, STORE_BLOCK_PHY 
04a5 cd 12 0c				call addatohl 
04a8 10 e1				djnz .setmark1 
04aa			 
04aa 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
04ac 3e 00		.setmark2:   	ld a,0 
04ae e5					push hl 
04af c5					push bc 
04b0 cd ea 01				call se_writebyte 
04b3 3e 0a			ld a, 10 
04b5 cd 22 0a			call aDelayInMS 
04b8 23				inc hl 
04b9 cd ea 01				call se_writebyte 
04bc 3e 0a			ld a, 10 
04be cd 22 0a			call aDelayInMS 
04c1 2b				dec hl 
04c2 c1					pop bc 
04c3 e1					pop hl 
04c4 3e 40				ld a, STORE_BLOCK_PHY 
04c6 cd 12 0c				call addatohl 
04c9 10 e1				djnz .setmark2 
04cb			 
04cb					 
04cb			 
04cb			 
04cb c9				ret 
04cc			 
04cc			 
04cc			 
04cc			 
04cc .. 00		.defaultbanklabl:   db "BankLabel",0 
04d6			 
04d6			 
04d6			 
04d6			; Label Bank 
04d6			; ---------- 
04d6			; 
04d6			; With current bank 
04d6			; Read block 0 
04d6			; Set label 
04d6			; Write block 0 
04d6			 
04d6			; label str pointer in hl 
04d6			 
04d6			storage_label:     
04d6			 
04d6				if DEBUG_STORESE 
04d6					DMARK "LBL" 
04d6 f5				push af  
04d7 3a eb 04			ld a, (.dmark)  
04da 32 77 fb			ld (debug_mark),a  
04dd 3a ec 04			ld a, (.dmark+1)  
04e0 32 78 fb			ld (debug_mark+1),a  
04e3 3a ed 04			ld a, (.dmark+2)  
04e6 32 79 fb			ld (debug_mark+2),a  
04e9 18 03			jr .pastdmark  
04eb ..			.dmark: db "LBL"  
04ee f1			.pastdmark: pop af  
04ef			endm  
# End of macro DMARK
04ef					CALLMONITOR 
04ef cd 00 14			call break_point_state  
04f2				endm  
# End of macro CALLMONITOR
04f2				endif 
04f2			 
04f2 e5				push hl 
04f3			 
04f3 cd bd 03			call storage_get_block_0 
04f6			 
04f6				; set default label 
04f6			 
04f6 e1				pop hl 
04f7			 
04f7 11 65 f8		 	ld de, store_page+3 
04fa 01 0f 00			ld bc, 15 
04fd				if DEBUG_STORESE 
04fd					DMARK "LB3" 
04fd f5				push af  
04fe 3a 12 05			ld a, (.dmark)  
0501 32 77 fb			ld (debug_mark),a  
0504 3a 13 05			ld a, (.dmark+1)  
0507 32 78 fb			ld (debug_mark+1),a  
050a 3a 14 05			ld a, (.dmark+2)  
050d 32 79 fb			ld (debug_mark+2),a  
0510 18 03			jr .pastdmark  
0512 ..			.dmark: db "LB3"  
0515 f1			.pastdmark: pop af  
0516			endm  
# End of macro DMARK
0516					CALLMONITOR 
0516 cd 00 14			call break_point_state  
0519				endm  
# End of macro CALLMONITOR
0519				endif 
0519 ed b0			ldir 
051b				; save default page 0 
051b			 
051b 21 00 00			ld hl, 0 
051e 11 62 f8			ld de, store_page 
0521				if DEBUG_STORESE 
0521					DMARK "LBW" 
0521 f5				push af  
0522 3a 36 05			ld a, (.dmark)  
0525 32 77 fb			ld (debug_mark),a  
0528 3a 37 05			ld a, (.dmark+1)  
052b 32 78 fb			ld (debug_mark+1),a  
052e 3a 38 05			ld a, (.dmark+2)  
0531 32 79 fb			ld (debug_mark+2),a  
0534 18 03			jr .pastdmark  
0536 ..			.dmark: db "LBW"  
0539 f1			.pastdmark: pop af  
053a			endm  
# End of macro DMARK
053a					CALLMONITOR 
053a cd 00 14			call break_point_state  
053d				endm  
# End of macro CALLMONITOR
053d				endif 
053d cd 71 03			call storage_write_block 
0540			 
0540 c9				ret 
0541			 
0541			 
0541			 
0541			; Read Block 0 - Config 
0541			; --------------------- 
0541			; 
0541			; With current bank 
0541			; Call presence test 
0541			;    If not present format/init bank  
0541			; Read block 0  
0541			;  
0541			 
0541			 
0541			; Dir 
0541			; --- 
0541			; 
0541			; With current bank 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block read byte 2 
0541			;      if first block of file 
0541			;         Display file name 
0541			;         Display type flags for file 
0541			;        
0541			 
0541			; moving to words as this requires stack control 
0541			 
0541			 
0541			; Delete File 
0541			; ----------- 
0541			; 
0541			; With current bank 
0541			; 
0541			; Load Block 0 Config 
0541			; Get max file id number 
0541			; For each logical block 
0541			;    Read block file id 
0541			;      If first block of file and dont have file id 
0541			;         if file to delete 
0541			;         Save file id 
0541			;         Null file id 
0541			;         Write this block back 
0541			;      If file id is one saved 
0541			;         Null file id 
0541			;         Write this block back 
0541			 
0541			storage_erase: 
0541			 
0541				; hl contains the file id 
0541			 
0541 5d				ld e, l 
0542 16 00			ld d, 0 
0544 21 40 00			ld hl, STORE_BLOCK_PHY 
0547					if DEBUG_FORTH_WORDS 
0547						DMARK "ERA" 
0547 f5				push af  
0548 3a 5c 05			ld a, (.dmark)  
054b 32 77 fb			ld (debug_mark),a  
054e 3a 5d 05			ld a, (.dmark+1)  
0551 32 78 fb			ld (debug_mark+1),a  
0554 3a 5e 05			ld a, (.dmark+2)  
0557 32 79 fb			ld (debug_mark+2),a  
055a 18 03			jr .pastdmark  
055c ..			.dmark: db "ERA"  
055f f1			.pastdmark: pop af  
0560			endm  
# End of macro DMARK
0560						CALLMONITOR 
0560 cd 00 14			call break_point_state  
0563				endm  
# End of macro CALLMONITOR
0563					endif 
0563 cd 22 06			call storage_findnextid 
0566			 
0566 e5				push hl 
0567			 
0567				; TODO check file not found 
0567			 
0567 11 62 f8			ld de, store_page 
056a cd 0c 03			call storage_read_block 
056d			 
056d					if DEBUG_FORTH_WORDS 
056d						DMARK "ER1" 
056d f5				push af  
056e 3a 82 05			ld a, (.dmark)  
0571 32 77 fb			ld (debug_mark),a  
0574 3a 83 05			ld a, (.dmark+1)  
0577 32 78 fb			ld (debug_mark+1),a  
057a 3a 84 05			ld a, (.dmark+2)  
057d 32 79 fb			ld (debug_mark+2),a  
0580 18 03			jr .pastdmark  
0582 ..			.dmark: db "ER1"  
0585 f1			.pastdmark: pop af  
0586			endm  
# End of macro DMARK
0586						CALLMONITOR 
0586 cd 00 14			call break_point_state  
0589				endm  
# End of macro CALLMONITOR
0589					endif 
0589 3a 62 f8			ld a, (store_page)	; get file id 
058c 32 5b f8			ld (store_tmpid), a 
058f			 
058f 3a 64 f8			ld a, (store_page+2)    ; get count of extends 
0592 32 5a f8			ld (store_tmpext), a 
0595			 
0595				; wipe file header 
0595			 
0595 e1				pop hl 
0596 3e 00			ld a, 0 
0598 32 62 f8			ld (store_page), a 
059b 32 63 f8			ld (store_page+1),a 
059e 11 62 f8			ld de, store_page 
05a1					if DEBUG_FORTH_WORDS 
05a1						DMARK "ER2" 
05a1 f5				push af  
05a2 3a b6 05			ld a, (.dmark)  
05a5 32 77 fb			ld (debug_mark),a  
05a8 3a b7 05			ld a, (.dmark+1)  
05ab 32 78 fb			ld (debug_mark+1),a  
05ae 3a b8 05			ld a, (.dmark+2)  
05b1 32 79 fb			ld (debug_mark+2),a  
05b4 18 03			jr .pastdmark  
05b6 ..			.dmark: db "ER2"  
05b9 f1			.pastdmark: pop af  
05ba			endm  
# End of macro DMARK
05ba						CALLMONITOR 
05ba cd 00 14			call break_point_state  
05bd				endm  
# End of macro CALLMONITOR
05bd					endif 
05bd cd 71 03			call storage_write_block 
05c0			 
05c0			 
05c0				; wipe file extents 
05c0			 
05c0 3a 5a f8			ld a, (store_tmpext) 
05c3 47				ld b, a 
05c4			 
05c4			.eraext:	  
05c4 c5				push bc 
05c5			 
05c5 21 40 00			ld hl, STORE_BLOCK_PHY 
05c8 3a 5b f8			ld a,(store_tmpid) 
05cb 5f				ld e, a 
05cc 50				ld d, b	 
05cd					if DEBUG_FORTH_WORDS 
05cd						DMARK "ER3" 
05cd f5				push af  
05ce 3a e2 05			ld a, (.dmark)  
05d1 32 77 fb			ld (debug_mark),a  
05d4 3a e3 05			ld a, (.dmark+1)  
05d7 32 78 fb			ld (debug_mark+1),a  
05da 3a e4 05			ld a, (.dmark+2)  
05dd 32 79 fb			ld (debug_mark+2),a  
05e0 18 03			jr .pastdmark  
05e2 ..			.dmark: db "ER3"  
05e5 f1			.pastdmark: pop af  
05e6			endm  
# End of macro DMARK
05e6						CALLMONITOR 
05e6 cd 00 14			call break_point_state  
05e9				endm  
# End of macro CALLMONITOR
05e9					endif 
05e9 cd 22 06			call storage_findnextid 
05ec			 
05ec e5				push hl 
05ed 11 62 f8			ld de, store_page 
05f0 cd 0c 03			call storage_read_block 
05f3			 
05f3				; free block	 
05f3			 
05f3 3e 00			ld a, 0 
05f5 32 62 f8			ld (store_page), a 
05f8 32 63 f8			ld (store_page+1),a 
05fb 11 62 f8			ld de, store_page 
05fe e1				pop hl 
05ff					if DEBUG_FORTH_WORDS 
05ff						DMARK "ER4" 
05ff f5				push af  
0600 3a 14 06			ld a, (.dmark)  
0603 32 77 fb			ld (debug_mark),a  
0606 3a 15 06			ld a, (.dmark+1)  
0609 32 78 fb			ld (debug_mark+1),a  
060c 3a 16 06			ld a, (.dmark+2)  
060f 32 79 fb			ld (debug_mark+2),a  
0612 18 03			jr .pastdmark  
0614 ..			.dmark: db "ER4"  
0617 f1			.pastdmark: pop af  
0618			endm  
# End of macro DMARK
0618						CALLMONITOR 
0618 cd 00 14			call break_point_state  
061b				endm  
# End of macro CALLMONITOR
061b					endif 
061b cd 71 03			call storage_write_block 
061e			 
061e c1				pop bc 
061f 10 a3			djnz .eraext 
0621			 
0621 c9				ret 
0622			 
0622			 
0622			; Find Free Block 
0622			; --------------- 
0622			; 
0622			; With current bank 
0622			;  
0622			; From given starting logical block 
0622			;    Read block  
0622			;    If no file id 
0622			;         Return block id 
0622			 
0622			 
0622			; hl starting page number 
0622			; hl contains free page number or zero if no pages free 
0622			; e contains the file id to locate 
0622			; d contains the block number 
0622			 
0622			; TODO change to find file id and use zero for free block 
0622			 
0622			storage_findnextid: 
0622			 
0622				; now locate first 0 page to mark as a free block 
0622			 
0622 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0624			;	ld hl, STORE_BLOCK_PHY 
0624			 
0624					if DEBUG_FORTH_WORDS 
0624					DMARK "FNI" 
0624 f5				push af  
0625 3a 39 06			ld a, (.dmark)  
0628 32 77 fb			ld (debug_mark),a  
062b 3a 3a 06			ld a, (.dmark+1)  
062e 32 78 fb			ld (debug_mark+1),a  
0631 3a 3b 06			ld a, (.dmark+2)  
0634 32 79 fb			ld (debug_mark+2),a  
0637 18 03			jr .pastdmark  
0639 ..			.dmark: db "FNI"  
063c f1			.pastdmark: pop af  
063d			endm  
# End of macro DMARK
063d						CALLMONITOR 
063d cd 00 14			call break_point_state  
0640				endm  
# End of macro CALLMONITOR
0640					endif 
0640			.ff1:   	 
0640 e5					push hl 
0641 c5					push bc 
0642 d5					push de 
0643 cd 8c 02				call se_readbyte 
0646 5f					ld e,a 
0647 23					inc hl 
0648 cd 8c 02				call se_readbyte 
064b 57					ld d, a 
064c e1					pop hl 
064d e5					push hl 
064e cd 30 0c				call cmp16 
0651 28 49				jr z, .fffound 
0653			 
0653 d1					pop de 
0654 c1					pop bc 
0655 e1					pop hl 
0656			 
0656					; is found? 
0656					;cp e 
0656					;ret z 
0656			 
0656 3e 40				ld a, STORE_BLOCK_PHY 
0658 cd 12 0c				call addatohl 
065b 10 e3				djnz .ff1 
065d			 
065d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
065f			.ff2:   	 
065f			 
065f e5					push hl 
0660 c5					push bc 
0661 d5					push de 
0662 cd 8c 02				call se_readbyte 
0665 5f					ld e,a 
0666 23					inc hl 
0667 cd 8c 02				call se_readbyte 
066a 57					ld d, a 
066b			 
066b e1					pop hl 
066c e5					push hl 
066d cd 30 0c				call cmp16 
0670 28 2a				jr z, .fffound 
0672			 
0672 d1					pop de 
0673 c1					pop bc 
0674 e1					pop hl 
0675					; is found? 
0675					;cp e 
0675					;ret z 
0675			 
0675 3e 40				ld a, STORE_BLOCK_PHY 
0677 cd 12 0c				call addatohl 
067a 10 e3				djnz .ff2 
067c			 
067c			 
067c					if DEBUG_FORTH_WORDS 
067c					DMARK "FN-" 
067c f5				push af  
067d 3a 91 06			ld a, (.dmark)  
0680 32 77 fb			ld (debug_mark),a  
0683 3a 92 06			ld a, (.dmark+1)  
0686 32 78 fb			ld (debug_mark+1),a  
0689 3a 93 06			ld a, (.dmark+2)  
068c 32 79 fb			ld (debug_mark+2),a  
068f 18 03			jr .pastdmark  
0691 ..			.dmark: db "FN-"  
0694 f1			.pastdmark: pop af  
0695			endm  
# End of macro DMARK
0695					;	push af 
0695					;	ld a, 'n' 
0695					;	ld (debug_mark),a 
0695					;	pop af 
0695						CALLMONITOR 
0695 cd 00 14			call break_point_state  
0698				endm  
# End of macro CALLMONITOR
0698					endif 
0698				; no free marks! 
0698 21 00 00				ld hl, 0 
069b c9				ret 
069c			.fffound: 
069c				 
069c			 
069c d1					pop de 
069d c1					pop bc 
069e e1					pop hl 
069f					if DEBUG_FORTH_WORDS 
069f					DMARK "FNF" 
069f f5				push af  
06a0 3a b4 06			ld a, (.dmark)  
06a3 32 77 fb			ld (debug_mark),a  
06a6 3a b5 06			ld a, (.dmark+1)  
06a9 32 78 fb			ld (debug_mark+1),a  
06ac 3a b6 06			ld a, (.dmark+2)  
06af 32 79 fb			ld (debug_mark+2),a  
06b2 18 03			jr .pastdmark  
06b4 ..			.dmark: db "FNF"  
06b7 f1			.pastdmark: pop af  
06b8			endm  
# End of macro DMARK
06b8					;	push af 
06b8					;	ld a, 'n' 
06b8					;	ld (debug_mark),a 
06b8					;	pop af 
06b8						CALLMONITOR 
06b8 cd 00 14			call break_point_state  
06bb				endm  
# End of macro CALLMONITOR
06bb					endif 
06bb c9				ret 
06bc			 
06bc			 
06bc			 
06bc			; Free Space 
06bc			; ---------- 
06bc			; 
06bc			; With current bank 
06bc			; 
06bc			; Set block count to zero 
06bc			; Starting with first logical block 
06bc			;      Find free block  
06bc			;      If block id given, increment block count 
06bc			; 
06bc			;  
06bc			 
06bc			 
06bc			; hl contains count of free blocks 
06bc			 
06bc			storage_freeblocks: 
06bc			 
06bc				; now locate first 0 page to mark as a free block 
06bc			 
06bc 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06be 21 40 00			ld hl, STORE_BLOCK_PHY 
06c1 11 00 00			ld de, 0 
06c4			 
06c4			.fb1:   	 
06c4 e5					push hl 
06c5 c5					push bc 
06c6 d5					push de 
06c7 cd 8c 02				call se_readbyte 
06ca d1					pop de 
06cb c1					pop bc 
06cc e1					pop hl 
06cd			 
06cd					; is free? 
06cd fe 00				cp 0 
06cf 20 01				jr nz, .ff1cont 
06d1 13					inc de 
06d2			 
06d2			.ff1cont: 
06d2			 
06d2			 
06d2 3e 40				ld a, STORE_BLOCK_PHY 
06d4 cd 12 0c				call addatohl 
06d7 10 eb				djnz .fb1 
06d9			 
06d9 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
06db			.fb2:   	 
06db e5					push hl 
06dc c5					push bc 
06dd d5					push de 
06de cd 8c 02				call se_readbyte 
06e1 d1					pop de 
06e2 c1					pop bc 
06e3 e1					pop hl 
06e4			 
06e4					; is free? 
06e4 fe 00				cp 0 
06e6 20 01				jr nz, .ff2cont 
06e8 13					inc de 
06e9			 
06e9			.ff2cont: 
06e9			 
06e9 3e 40				ld a, STORE_BLOCK_PHY 
06eb cd 12 0c				call addatohl 
06ee 10 eb				djnz .fb2 
06f0			 
06f0 eb				ex de, hl 
06f1 c9				ret 
06f2			 
06f2			; Get File ID 
06f2			; ----------- 
06f2			; 
06f2			; With current bank 
06f2			;  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; For each logical block 
06f2			;    Read block file id 
06f2			;      If first block of file and dont have file id 
06f2			;         if file get id and exit 
06f2			 
06f2			 
06f2			 
06f2			 
06f2			; Create File 
06f2			; ----------- 
06f2			; 
06f2			; With current bank  
06f2			; Load Block 0 Config 
06f2			; Get max file id number 
06f2			; Increment file id number 
06f2			; Save Config 
06f2			; Find free block 
06f2			; Set buffer with file name and file id 
06f2			; Write buffer to free block  
06f2			 
06f2			 
06f2			; hl point to file name 
06f2			; hl returns file id 
06f2			 
06f2			; file format: 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent number 
06f2			; byte 2-> data 
06f2			 
06f2			; format for extent number 0: 
06f2			; 
06f2			; byte 0 - file id 
06f2			; byte 1 - extent 0 
06f2			; byte 2 - extent count 
06f2			; byte 3 -> file name and meta data 
06f2			 
06f2			 
06f2			storage_create: 
06f2				if DEBUG_STORESE 
06f2					DMARK "SCR" 
06f2 f5				push af  
06f3 3a 07 07			ld a, (.dmark)  
06f6 32 77 fb			ld (debug_mark),a  
06f9 3a 08 07			ld a, (.dmark+1)  
06fc 32 78 fb			ld (debug_mark+1),a  
06ff 3a 09 07			ld a, (.dmark+2)  
0702 32 79 fb			ld (debug_mark+2),a  
0705 18 03			jr .pastdmark  
0707 ..			.dmark: db "SCR"  
070a f1			.pastdmark: pop af  
070b			endm  
# End of macro DMARK
070b					CALLMONITOR 
070b cd 00 14			call break_point_state  
070e				endm  
# End of macro CALLMONITOR
070e				endif 
070e			 
070e e5				push hl		; save file name pointer 
070f			 
070f cd bd 03			call storage_get_block_0 
0712			 
0712 3a 62 f8			ld a,(store_page)	; get current file id 
0715 3c				inc a 
0716 32 62 f8			ld (store_page),a 
0719				 
0719 32 5b f8			ld (store_tmpid),a			; save id 
071c			 
071c 21 00 00			ld hl, 0 
071f 11 62 f8			ld de, store_page 
0722				if DEBUG_STORESE 
0722					DMARK "SCw" 
0722 f5				push af  
0723 3a 37 07			ld a, (.dmark)  
0726 32 77 fb			ld (debug_mark),a  
0729 3a 38 07			ld a, (.dmark+1)  
072c 32 78 fb			ld (debug_mark+1),a  
072f 3a 39 07			ld a, (.dmark+2)  
0732 32 79 fb			ld (debug_mark+2),a  
0735 18 03			jr .pastdmark  
0737 ..			.dmark: db "SCw"  
073a f1			.pastdmark: pop af  
073b			endm  
# End of macro DMARK
073b					CALLMONITOR 
073b cd 00 14			call break_point_state  
073e				endm  
# End of macro CALLMONITOR
073e				endif 
073e cd 71 03			call storage_write_block	 ; save update 
0741			 
0741				if DEBUG_STORESE 
0741 11 62 f8				ld de, store_page 
0744					DMARK "SCC" 
0744 f5				push af  
0745 3a 59 07			ld a, (.dmark)  
0748 32 77 fb			ld (debug_mark),a  
074b 3a 5a 07			ld a, (.dmark+1)  
074e 32 78 fb			ld (debug_mark+1),a  
0751 3a 5b 07			ld a, (.dmark+2)  
0754 32 79 fb			ld (debug_mark+2),a  
0757 18 03			jr .pastdmark  
0759 ..			.dmark: db "SCC"  
075c f1			.pastdmark: pop af  
075d			endm  
# End of macro DMARK
075d					CALLMONITOR 
075d cd 00 14			call break_point_state  
0760				endm  
# End of macro CALLMONITOR
0760				endif 
0760				;  
0760				 
0760 21 40 00			ld hl, STORE_BLOCK_PHY 
0763 11 00 00			ld de, 0 
0766 cd 22 06			call storage_findnextid 
0769			 
0769 22 60 f8			ld (store_tmppageid), hl    ; save page to use  
076c			 
076c				; TODO detect 0 = no spare blocks 
076c			 
076c				; hl now contains the free page to use for the file header page 
076c			 
076c				if DEBUG_STORESE 
076c				DMARK "SCF" 
076c f5				push af  
076d 3a 81 07			ld a, (.dmark)  
0770 32 77 fb			ld (debug_mark),a  
0773 3a 82 07			ld a, (.dmark+1)  
0776 32 78 fb			ld (debug_mark+1),a  
0779 3a 83 07			ld a, (.dmark+2)  
077c 32 79 fb			ld (debug_mark+2),a  
077f 18 03			jr .pastdmark  
0781 ..			.dmark: db "SCF"  
0784 f1			.pastdmark: pop af  
0785			endm  
# End of macro DMARK
0785					CALLMONITOR 
0785 cd 00 14			call break_point_state  
0788				endm  
# End of macro CALLMONITOR
0788				endif 
0788			 
0788 22 60 f8			ld (store_tmppageid), hl 
078b				 
078b 3a 5b f8			ld a,(store_tmpid)    ; get file id 
078e			;	ld a, (store_filecache)			; save to cache 
078e			 
078e 32 62 f8			ld (store_page),a    ; set page id 
0791 3e 00			ld a, 0			 ; extent 0 is file header 
0793 32 63 f8			ld (store_page+1), a   ; set file extent 
0796			 
0796 32 64 f8			ld (store_page+2), a   ; extent count for the file 
0799			 
0799			;	inc hl 		; init block 0 of file 
0799			;	inc hl   		; skip file and extent id 
0799			 ;       ld a, 0 
0799			;	ld (hl),a 
0799			;	ld a, (store_filecache+1)  	; save to cache 
0799			 
0799			;	inc hl    ; file name 
0799				 
0799				 
0799 11 65 f8			ld de, store_page+3    ; get buffer for term string to use as file name 
079c				if DEBUG_STORESE 
079c					DMARK "SCc" 
079c f5				push af  
079d 3a b1 07			ld a, (.dmark)  
07a0 32 77 fb			ld (debug_mark),a  
07a3 3a b2 07			ld a, (.dmark+1)  
07a6 32 78 fb			ld (debug_mark+1),a  
07a9 3a b3 07			ld a, (.dmark+2)  
07ac 32 79 fb			ld (debug_mark+2),a  
07af 18 03			jr .pastdmark  
07b1 ..			.dmark: db "SCc"  
07b4 f1			.pastdmark: pop af  
07b5			endm  
# End of macro DMARK
07b5					CALLMONITOR 
07b5 cd 00 14			call break_point_state  
07b8				endm  
# End of macro CALLMONITOR
07b8				endif 
07b8 e1				pop hl    ; get zero term string 
07b9 e5				push hl 
07ba 3e 00			ld a, 0 
07bc cd 7b 10			call strlent 
07bf 23				inc hl   ; cover zero term 
07c0 06 00			ld b,0 
07c2 4d				ld c,l 
07c3 e1				pop hl 
07c4				;ex de, hl 
07c4				if DEBUG_STORESE 
07c4					DMARK "SCa" 
07c4 f5				push af  
07c5 3a d9 07			ld a, (.dmark)  
07c8 32 77 fb			ld (debug_mark),a  
07cb 3a da 07			ld a, (.dmark+1)  
07ce 32 78 fb			ld (debug_mark+1),a  
07d1 3a db 07			ld a, (.dmark+2)  
07d4 32 79 fb			ld (debug_mark+2),a  
07d7 18 03			jr .pastdmark  
07d9 ..			.dmark: db "SCa"  
07dc f1			.pastdmark: pop af  
07dd			endm  
# End of macro DMARK
07dd					;push af 
07dd					;ld a, 'a' 
07dd					;ld (debug_mark),a 
07dd					;pop af 
07dd					CALLMONITOR 
07dd cd 00 14			call break_point_state  
07e0				endm  
# End of macro CALLMONITOR
07e0				endif 
07e0 ed b0			ldir    ; copy zero term string 
07e2				if DEBUG_STORESE 
07e2					DMARK "SCA" 
07e2 f5				push af  
07e3 3a f7 07			ld a, (.dmark)  
07e6 32 77 fb			ld (debug_mark),a  
07e9 3a f8 07			ld a, (.dmark+1)  
07ec 32 78 fb			ld (debug_mark+1),a  
07ef 3a f9 07			ld a, (.dmark+2)  
07f2 32 79 fb			ld (debug_mark+2),a  
07f5 18 03			jr .pastdmark  
07f7 ..			.dmark: db "SCA"  
07fa f1			.pastdmark: pop af  
07fb			endm  
# End of macro DMARK
07fb					CALLMONITOR 
07fb cd 00 14			call break_point_state  
07fe				endm  
# End of macro CALLMONITOR
07fe				endif 
07fe			 
07fe				; write file header page 
07fe			 
07fe 2a 60 f8			ld hl,(store_tmppageid) 
0801 11 62 f8			ld de, store_page 
0804				if DEBUG_STORESE 
0804					DMARK "SCb" 
0804 f5				push af  
0805 3a 19 08			ld a, (.dmark)  
0808 32 77 fb			ld (debug_mark),a  
080b 3a 1a 08			ld a, (.dmark+1)  
080e 32 78 fb			ld (debug_mark+1),a  
0811 3a 1b 08			ld a, (.dmark+2)  
0814 32 79 fb			ld (debug_mark+2),a  
0817 18 03			jr .pastdmark  
0819 ..			.dmark: db "SCb"  
081c f1			.pastdmark: pop af  
081d			endm  
# End of macro DMARK
081d					;push af 
081d					;ld a, 'b' 
081d					;ld (debug_mark),a 
081d					;pop af 
081d					CALLMONITOR 
081d cd 00 14			call break_point_state  
0820				endm  
# End of macro CALLMONITOR
0820				endif 
0820 cd 71 03			call storage_write_block 
0823			 
0823 3a 5b f8			ld a, (store_tmpid) 
0826 6f				ld l, a 
0827 26 00			ld h,0 
0829				if DEBUG_STORESE 
0829					DMARK "SCz" 
0829 f5				push af  
082a 3a 3e 08			ld a, (.dmark)  
082d 32 77 fb			ld (debug_mark),a  
0830 3a 3f 08			ld a, (.dmark+1)  
0833 32 78 fb			ld (debug_mark+1),a  
0836 3a 40 08			ld a, (.dmark+2)  
0839 32 79 fb			ld (debug_mark+2),a  
083c 18 03			jr .pastdmark  
083e ..			.dmark: db "SCz"  
0841 f1			.pastdmark: pop af  
0842			endm  
# End of macro DMARK
0842					CALLMONITOR 
0842 cd 00 14			call break_point_state  
0845				endm  
# End of macro CALLMONITOR
0845				endif 
0845 c9				ret 
0846				 
0846			 
0846			 
0846			; 
0846			; Read File 
0846			; 
0846			; h - file id to locate 
0846			; l - extent to locate 
0846			; de - pointer to string to read into 
0846			; 
0846			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
0846			storage_read: 
0846 d5				push de 
0847			 
0847			; TODO BUG the above push is it popped before the RET Z? 
0847			 
0847			; TODO how to handle multiple part blocks 
0847			 
0847				; locate file extent to read 
0847			 
0847 5c				ld e, h 
0848 55				ld d, l 
0849 21 40 00			ld hl, STORE_BLOCK_PHY 
084c				if DEBUG_STORESE 
084c					DMARK "SRE" 
084c f5				push af  
084d 3a 61 08			ld a, (.dmark)  
0850 32 77 fb			ld (debug_mark),a  
0853 3a 62 08			ld a, (.dmark+1)  
0856 32 78 fb			ld (debug_mark+1),a  
0859 3a 63 08			ld a, (.dmark+2)  
085c 32 79 fb			ld (debug_mark+2),a  
085f 18 03			jr .pastdmark  
0861 ..			.dmark: db "SRE"  
0864 f1			.pastdmark: pop af  
0865			endm  
# End of macro DMARK
0865					CALLMONITOR 
0865 cd 00 14			call break_point_state  
0868				endm  
# End of macro CALLMONITOR
0868				endif 
0868 cd 22 06			call storage_findnextid 
086b			 
086b				if DEBUG_STORESE 
086b					DMARK "SRf" 
086b f5				push af  
086c 3a 80 08			ld a, (.dmark)  
086f 32 77 fb			ld (debug_mark),a  
0872 3a 81 08			ld a, (.dmark+1)  
0875 32 78 fb			ld (debug_mark+1),a  
0878 3a 82 08			ld a, (.dmark+2)  
087b 32 79 fb			ld (debug_mark+2),a  
087e 18 03			jr .pastdmark  
0880 ..			.dmark: db "SRf"  
0883 f1			.pastdmark: pop af  
0884			endm  
# End of macro DMARK
0884					CALLMONITOR 
0884 cd 00 14			call break_point_state  
0887				endm  
# End of macro CALLMONITOR
0887				endif 
0887 cd 3b 0c			call ishlzero 
088a			;	ld a, l 
088a			;	add h 
088a			;	cp 0 
088a c8				ret z			; block not found so EOF 
088b			 
088b				; hl contains page number to load 
088b d1				pop de   ; get storage 
088c d5				push de 
088d				if DEBUG_STORESE 
088d					DMARK "SRg" 
088d f5				push af  
088e 3a a2 08			ld a, (.dmark)  
0891 32 77 fb			ld (debug_mark),a  
0894 3a a3 08			ld a, (.dmark+1)  
0897 32 78 fb			ld (debug_mark+1),a  
089a 3a a4 08			ld a, (.dmark+2)  
089d 32 79 fb			ld (debug_mark+2),a  
08a0 18 03			jr .pastdmark  
08a2 ..			.dmark: db "SRg"  
08a5 f1			.pastdmark: pop af  
08a6			endm  
# End of macro DMARK
08a6					CALLMONITOR 
08a6 cd 00 14			call break_point_state  
08a9				endm  
# End of macro CALLMONITOR
08a9				endif 
08a9 cd 0c 03			call storage_read_block 
08ac			 
08ac			 
08ac			; TODO if block has no zeros then need to read next block  
08ac			 
08ac			 
08ac					 
08ac e1				pop hl 		 ; return start of data to show as not EOF 
08ad 23				inc hl   ; past file id 
08ae 23				inc hl   ; past ext 
08af				if DEBUG_STORESE 
08af					DMARK "SRe" 
08af f5				push af  
08b0 3a c4 08			ld a, (.dmark)  
08b3 32 77 fb			ld (debug_mark),a  
08b6 3a c5 08			ld a, (.dmark+1)  
08b9 32 78 fb			ld (debug_mark+1),a  
08bc 3a c6 08			ld a, (.dmark+2)  
08bf 32 79 fb			ld (debug_mark+2),a  
08c2 18 03			jr .pastdmark  
08c4 ..			.dmark: db "SRe"  
08c7 f1			.pastdmark: pop af  
08c8			endm  
# End of macro DMARK
08c8					CALLMONITOR 
08c8 cd 00 14			call break_point_state  
08cb				endm  
# End of macro CALLMONITOR
08cb				endif 
08cb c9					ret 
08cc			 
08cc			 
08cc			 
08cc			; 
08cc			; Append File 
08cc			; 
08cc			; hl - file id to locate 
08cc			; de - pointer to (multi block) string to write 
08cc			 
08cc			 
08cc			storage_append: 
08cc				; hl -  file id to append to 
08cc				; de - string to append 
08cc			 
08cc d5				push de 
08cd				 
08cd				if DEBUG_STORESE 
08cd					DMARK "AP1" 
08cd f5				push af  
08ce 3a e2 08			ld a, (.dmark)  
08d1 32 77 fb			ld (debug_mark),a  
08d4 3a e3 08			ld a, (.dmark+1)  
08d7 32 78 fb			ld (debug_mark+1),a  
08da 3a e4 08			ld a, (.dmark+2)  
08dd 32 79 fb			ld (debug_mark+2),a  
08e0 18 03			jr .pastdmark  
08e2 ..			.dmark: db "AP1"  
08e5 f1			.pastdmark: pop af  
08e6			endm  
# End of macro DMARK
08e6					CALLMONITOR 
08e6 cd 00 14			call break_point_state  
08e9				endm  
# End of macro CALLMONITOR
08e9				endif 
08e9			 
08e9 7d				ld a, l 
08ea 32 5b f8			ld (store_tmpid), a 
08ed			 
08ed				; get file header  
08ed			 
08ed 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
08ef 3a 5b f8			ld a, (store_tmpid) 
08f2 5f				ld e, a 
08f3			 
08f3 21 40 00				ld hl, STORE_BLOCK_PHY 
08f6 cd 22 06				call storage_findnextid 
08f9			 
08f9 22 60 f8			ld (store_tmppageid), hl 
08fc			 
08fc				; TODO handle file id not found 
08fc			 
08fc				if DEBUG_STORESE 
08fc					DMARK "AP2" 
08fc f5				push af  
08fd 3a 11 09			ld a, (.dmark)  
0900 32 77 fb			ld (debug_mark),a  
0903 3a 12 09			ld a, (.dmark+1)  
0906 32 78 fb			ld (debug_mark+1),a  
0909 3a 13 09			ld a, (.dmark+2)  
090c 32 79 fb			ld (debug_mark+2),a  
090f 18 03			jr .pastdmark  
0911 ..			.dmark: db "AP2"  
0914 f1			.pastdmark: pop af  
0915			endm  
# End of macro DMARK
0915					CALLMONITOR 
0915 cd 00 14			call break_point_state  
0918				endm  
# End of macro CALLMONITOR
0918				endif 
0918			 
0918				; update file extent count 
0918			 
0918 11 62 f8			ld de, store_page 
091b			 
091b cd 0c 03			call storage_read_block 
091e			 
091e				if DEBUG_STORESE 
091e					DMARK "AP3" 
091e f5				push af  
091f 3a 33 09			ld a, (.dmark)  
0922 32 77 fb			ld (debug_mark),a  
0925 3a 34 09			ld a, (.dmark+1)  
0928 32 78 fb			ld (debug_mark+1),a  
092b 3a 35 09			ld a, (.dmark+2)  
092e 32 79 fb			ld (debug_mark+2),a  
0931 18 03			jr .pastdmark  
0933 ..			.dmark: db "AP3"  
0936 f1			.pastdmark: pop af  
0937			endm  
# End of macro DMARK
0937					CALLMONITOR 
0937 cd 00 14			call break_point_state  
093a				endm  
# End of macro CALLMONITOR
093a				endif 
093a			;	ld (store_tmppageid), hl 
093a			 
093a 3a 64 f8			ld a, (store_page+2) 
093d 3c				inc a 
093e 32 64 f8			ld (store_page+2), a 
0941 32 5a f8			ld (store_tmpext), a 
0944				 
0944				if DEBUG_STORESE 
0944					DMARK "AP3" 
0944 f5				push af  
0945 3a 59 09			ld a, (.dmark)  
0948 32 77 fb			ld (debug_mark),a  
094b 3a 5a 09			ld a, (.dmark+1)  
094e 32 78 fb			ld (debug_mark+1),a  
0951 3a 5b 09			ld a, (.dmark+2)  
0954 32 79 fb			ld (debug_mark+2),a  
0957 18 03			jr .pastdmark  
0959 ..			.dmark: db "AP3"  
095c f1			.pastdmark: pop af  
095d			endm  
# End of macro DMARK
095d					CALLMONITOR 
095d cd 00 14			call break_point_state  
0960				endm  
# End of macro CALLMONITOR
0960				endif 
0960 2a 60 f8			ld hl, (store_tmppageid) 
0963 11 62 f8			ld de, store_page 
0966 cd 71 03			call storage_write_block 
0969			 
0969				; find free block 
0969			 
0969 11 00 00			ld de, 0			 ; file extent to locate 
096c			 
096c 21 40 00				ld hl, STORE_BLOCK_PHY 
096f cd 22 06				call storage_findnextid 
0972			 
0972					; TODO handle no space left 
0972					 
0972 22 60 f8				ld (store_tmppageid), hl 
0975			 
0975				if DEBUG_STORESE 
0975					DMARK "AP4" 
0975 f5				push af  
0976 3a 8a 09			ld a, (.dmark)  
0979 32 77 fb			ld (debug_mark),a  
097c 3a 8b 09			ld a, (.dmark+1)  
097f 32 78 fb			ld (debug_mark+1),a  
0982 3a 8c 09			ld a, (.dmark+2)  
0985 32 79 fb			ld (debug_mark+2),a  
0988 18 03			jr .pastdmark  
098a ..			.dmark: db "AP4"  
098d f1			.pastdmark: pop af  
098e			endm  
# End of macro DMARK
098e					CALLMONITOR 
098e cd 00 14			call break_point_state  
0991				endm  
# End of macro CALLMONITOR
0991				endif 
0991					; init the buffer with zeros so we can id if the buffer is full or not 
0991			 
0991 e5					push hl 
0992 c5					push bc 
0993			 
0993 21 62 f8				ld hl, store_page 
0996 06 40				ld b, STORE_BLOCK_PHY 
0998 3e 00				ld a, 0 
099a 77			.zeroblock:	ld (hl), a 
099b 23					inc hl 
099c 10 fc				djnz .zeroblock 
099e			 
099e c1					pop bc 
099f e1					pop hl 
09a0			 
09a0					; construct block 
09a0			 
09a0 3a 5b f8				ld a, (store_tmpid) 
09a3 32 62 f8				ld (store_page), a   ; file id 
09a6 3a 5a f8				ld a, (store_tmpext)   ; extent for this block 
09a9 32 63 f8				ld (store_page+1), a 
09ac			 
09ac e1					pop hl    ; get string to write 
09ad 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
09af 11 64 f8				ld de, store_page+2 
09b2			 
09b2				if DEBUG_STORESE 
09b2					DMARK "AP5" 
09b2 f5				push af  
09b3 3a c7 09			ld a, (.dmark)  
09b6 32 77 fb			ld (debug_mark),a  
09b9 3a c8 09			ld a, (.dmark+1)  
09bc 32 78 fb			ld (debug_mark+1),a  
09bf 3a c9 09			ld a, (.dmark+2)  
09c2 32 79 fb			ld (debug_mark+2),a  
09c5 18 03			jr .pastdmark  
09c7 ..			.dmark: db "AP5"  
09ca f1			.pastdmark: pop af  
09cb			endm  
# End of macro DMARK
09cb					CALLMONITOR 
09cb cd 00 14			call break_point_state  
09ce				endm  
# End of macro CALLMONITOR
09ce				endif 
09ce			 
09ce			 
09ce			 
09ce					; fill buffer with data until end of string or full block 
09ce			 
09ce 7e			.appd:		ld a, (hl) 
09cf 12					ld (de), a 
09d0 fe 00				cp 0 
09d2 28 04				jr z, .appdone 
09d4 23					inc hl 
09d5 13					inc de 
09d6 10 f6				djnz .appd 
09d8			 
09d8 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
09d9 f5					push af   		; save last byte dumped 
09da			 
09da			 
09da 2a 60 f8			ld hl, (store_tmppageid) 
09dd 11 62 f8			ld de, store_page 
09e0				if DEBUG_STORESE 
09e0					DMARK "AP6" 
09e0 f5				push af  
09e1 3a f5 09			ld a, (.dmark)  
09e4 32 77 fb			ld (debug_mark),a  
09e7 3a f6 09			ld a, (.dmark+1)  
09ea 32 78 fb			ld (debug_mark+1),a  
09ed 3a f7 09			ld a, (.dmark+2)  
09f0 32 79 fb			ld (debug_mark+2),a  
09f3 18 03			jr .pastdmark  
09f5 ..			.dmark: db "AP6"  
09f8 f1			.pastdmark: pop af  
09f9			endm  
# End of macro DMARK
09f9					CALLMONITOR 
09f9 cd 00 14			call break_point_state  
09fc				endm  
# End of macro CALLMONITOR
09fc				endif 
09fc cd 71 03				call storage_write_block 
09ff			 
09ff			 
09ff				; was that a full block of data written? 
09ff				; any more to write out? 
09ff			 
09ff				; if yes then set vars and jump to start of function again 
09ff			 
09ff f1					pop af 
0a00 d1					pop de 
0a01			 
0a01 fe 00				cp 0		 ; no, string was fully written 
0a03 c8					ret z 
0a04			 
0a04					; setup vars for next cycle 
0a04			 
0a04 3a 5b f8				ld a, (store_tmpid) 
0a07 6f					ld l, a 
0a08 26 00				ld h, 0 
0a0a			 
0a0a c3 cc 08			 	jp storage_append	 ; yes, need to write out some more 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			 
0a0d			if DEBUG_STORECF 
0a0d			storageput:	 
0a0d					ret 
0a0d			storageread: 
0a0d					ld hl, store_page 
0a0d					ld b, 200 
0a0d					ld a,0 
0a0d			.src:		ld (hl),a 
0a0d					inc hl 
0a0d					djnz .src 
0a0d					 
0a0d			 
0a0d					ld de, 0 
0a0d					ld bc, 1 
0a0d					ld hl, store_page 
0a0d					call cfRead 
0a0d			 
0a0d				call cfGetError 
0a0d				ld hl,scratch 
0a0d				call hexout 
0a0d				ld hl, scratch+2 
0a0d				ld a, 0 
0a0d				ld (hl),a 
0a0d				ld de, scratch 
0a0d				ld a,display_row_1 
0a0d				call str_at_display 
0a0d				call update_display 
0a0d			 
0a0d					ld hl, store_page 
0a0d					ld (os_cur_ptr),hl 
0a0d			 
0a0d					ret 
0a0d			endif 
0a0d			 
0a0d			 
0a0d			; Clear out the main buffer store (used to remove junk before writing a new block) 
0a0d			 
0a0d			storage_clear_page: 
0a0d e5				push hl 
0a0e d5				push de 
0a0f c5				push bc 
0a10 21 62 f8			ld hl, store_page 
0a13 3e 00			ld a, 0 
0a15 77				ld (hl), a 
0a16			 
0a16 11 63 f8			ld de, store_page+1 
0a19 01 40 00			ld bc, STORE_BLOCK_PHY 
0a1c			 
0a1c ed b0			ldir 
0a1e				 
0a1e c1				pop bc 
0a1f d1				pop de 
0a20 e1				pop hl 
0a21 c9				ret 
0a22			 
0a22			; eof 
# End of file firmware_storage.asm
0a22			  
0a22			; support routines for above hardware abstraction layer  
0a22			  
0a22			include "firmware_general.asm"        ; general support functions  
0a22			 
0a22			 
0a22			 
0a22			; Delay loops 
0a22			 
0a22			 
0a22			 
0a22			aDelayInMS: 
0a22 c5				push bc 
0a23 47				ld b,a 
0a24			msdelay: 
0a24 c5				push bc 
0a25				 
0a25			 
0a25 01 41 00			ld bc,041h 
0a28 cd 40 0a			call delayloop 
0a2b c1				pop bc 
0a2c 05				dec b 
0a2d 20 f5			jr nz,msdelay 
0a2f			 
0a2f			;if CPU_CLOCK_8MHZ 
0a2f			;msdelay8: 
0a2f			;	push bc 
0a2f			;	 
0a2f			; 
0a2f			;	ld bc,041h 
0a2f			;	call delayloop 
0a2f			;	pop bc 
0a2f			;	dec b 
0a2f			;	jr nz,msdelay8 
0a2f			;endif 
0a2f			 
0a2f			 
0a2f c1				pop bc 
0a30 c9				ret 
0a31			 
0a31			 
0a31			delay250ms: 
0a31				;push de 
0a31 01 00 40			ld bc, 04000h 
0a34 c3 40 0a			jp delayloop 
0a37			delay500ms: 
0a37				;push de 
0a37 01 00 80			ld bc, 08000h 
0a3a c3 40 0a			jp delayloop 
0a3d			delay1s: 
0a3d				;push bc 
0a3d			   ; Clobbers A, d and e 
0a3d 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
0a40			delayloop: 
0a40 c5			    push bc 
0a41			 
0a41			if BASE_CPM 
0a41				ld bc, CPM_DELAY_TUNE 
0a41			.cpmloop: 
0a41				push bc 
0a41			 
0a41			endif 
0a41			 
0a41			 
0a41			 
0a41			delayloopi: 
0a41			;	push bc 
0a41			;.dl: 
0a41 cb 47		    bit     0,a    	; 8 
0a43 cb 47		    bit     0,a    	; 8 
0a45 cb 47		    bit     0,a    	; 8 
0a47 e6 ff		    and     255  	; 7 
0a49 0b			    dec     bc      	; 6 
0a4a 79			    ld      a,c     	; 4 
0a4b b0			    or      b     	; 4 
0a4c c2 41 0a		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
0a4f			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
0a4f				;pop de 
0a4f			;pop bc 
0a4f			 
0a4f			if BASE_CPM 
0a4f				pop bc 
0a4f				 
0a4f			    dec     bc      	; 6 
0a4f			    ld      a,c     	; 4 
0a4f			    or      b     	; 4 
0a4f			    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
0a4f				 
0a4f			 
0a4f			endif 
0a4f			;if CPU_CLOCK_8MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f			 
0a4f			;if CPU_CLOCK_10MHZ 
0a4f			;    pop bc 
0a4f			;    push bc 
0a4f			;.dl8: 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    bit     0,a    	; 8 
0a4f			;    and     255  	; 7 
0a4f			;    dec     bc      	; 6 
0a4f			;    ld      a,c     	; 4 
0a4f			;    or      b     	; 4 
0a4f			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
0a4f			;endif 
0a4f c1			    pop bc 
0a50			 
0a50 c9				ret 
0a51			 
0a51			 
0a51			 
0a51			; eof 
# End of file firmware_general.asm
0a51			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
0a51			; display routines that use the physical hardware abstraction layer 
0a51			 
0a51			 
0a51			; TODO windowing? 
0a51			 
0a51			; TODO scroll line up 
0a51			 
0a51			scroll_up: 
0a51			 
0a51 e5				push hl 
0a52 d5				push de 
0a53 c5				push bc 
0a54			 
0a54				; get frame buffer  
0a54			 
0a54 2a d8 f8			ld hl, (display_fb_active) 
0a57 e5				push hl    ; future de destination 
0a58			 
0a58 11 28 00			ld  de, display_cols 
0a5b 19				add hl, de 
0a5c			 
0a5c d1				pop de 
0a5d			 
0a5d				;ex de, hl 
0a5d 01 9f 00			ld bc, display_fb_len -1  
0a60			;if DEBUG_FORTH_WORDS 
0a60			;	DMARK "SCL" 
0a60			;	CALLMONITOR 
0a60			;endif	 
0a60 ed b0			ldir 
0a62			 
0a62				; wipe bottom row 
0a62			 
0a62			 
0a62 2a d8 f8			ld hl, (display_fb_active) 
0a65 11 a0 00			ld de, display_cols*display_rows 
0a68 19				add hl, de 
0a69 06 28			ld b, display_cols 
0a6b 3e 20			ld a, ' ' 
0a6d			.scwipe: 
0a6d 77				ld (hl), a 
0a6e 2b				dec hl 
0a6f 10 fc			djnz .scwipe 
0a71			 
0a71				;pop hl 
0a71			 
0a71 c1				pop bc 
0a72 d1				pop de 
0a73 e1				pop hl 
0a74			 
0a74 c9				ret 
0a75			 
0a75			 
0a75			scroll_upo: 
0a75 11 00 00			ld de, display_row_1 
0a78 21 28 00		 	ld hl, display_row_2 
0a7b 01 28 00			ld bc, display_cols 
0a7e ed b0			ldir 
0a80 11 28 00			ld de, display_row_2 
0a83 21 50 00		 	ld hl, display_row_3 
0a86 01 28 00			ld bc, display_cols 
0a89 ed b0			ldir 
0a8b 11 50 00			ld de, display_row_3 
0a8e 21 78 00		 	ld hl, display_row_4 
0a91 01 28 00			ld bc, display_cols 
0a94 ed b0			ldir 
0a96			 
0a96			; TODO clear row 4 
0a96			 
0a96 c9				ret 
0a97				 
0a97			scroll_down: 
0a97 11 78 00			ld de, display_row_4 
0a9a 21 50 00		 	ld hl, display_row_3 
0a9d 01 28 00			ld bc, display_cols 
0aa0 ed b0			ldir 
0aa2 11 50 00			ld de, display_row_3 
0aa5 21 28 00		 	ld hl, display_row_2 
0aa8 01 28 00			ld bc, display_cols 
0aab ed b0			ldir 
0aad 11 28 00			ld de, display_row_2 
0ab0 21 00 00		 	ld hl, display_row_1 
0ab3 01 28 00			ld bc, display_cols 
0ab6 ed b0			ldir 
0ab8			; TODO clear row 1 
0ab8 c9				ret 
0ab9			 
0ab9			 
0ab9			 
0ab9			 
0ab9			 
0ab9			; clear active frame buffer 
0ab9			 
0ab9			clear_display: 
0ab9 3e 20			ld a, ' ' 
0abb c3 be 0a			jp fill_display 
0abe			 
0abe			; fill active frame buffer with a char in A 
0abe			 
0abe			fill_display: 
0abe 06 a0			ld b,display_fb_len 
0ac0 2a d8 f8			ld hl, (display_fb_active) 
0ac3 77			.fd1:	ld (hl),a 
0ac4 23				inc hl 
0ac5 10 fc			djnz .fd1 
0ac7 23				inc hl 
0ac8 3e 00			ld a,0 
0aca 77				ld (hl),a 
0acb			 
0acb			 
0acb c9				ret 
0acc			; Write string (DE) at pos (A) to active frame buffer 
0acc			 
0acc 2a d8 f8		str_at_display:    ld hl,(display_fb_active) 
0acf 06 00					ld b,0 
0ad1 4f					ld c,a 
0ad2 09					add hl,bc 
0ad3 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0ad4 b7			            OR   A              ;Null terminator? 
0ad5 c8			            RET  Z              ;Yes, so finished 
0ad6 77					ld (hl),a 
0ad7 23				inc hl 
0ad8 13			            INC  DE             ;Point to next character 
0ad9 18 f8		            JR   .sad1     ;Repeat 
0adb c9					ret 
0adc			 
0adc			; using current frame buffer write to physical display 
0adc			 
0adc			update_display: 
0adc e5				push hl 
0add 2a d8 f8			ld hl, (display_fb_active) 
0ae0 cd bb 61			call write_display 
0ae3 e1				pop hl 
0ae4 c9				ret 
0ae5			 
0ae5			; TODO scrolling 
0ae5			 
0ae5			 
0ae5			; move cursor right one char 
0ae5			cursor_right: 
0ae5			 
0ae5				; TODO shift right 
0ae5				; TODO if beyond max col 
0ae5				; TODO       cursor_next_line 
0ae5			 
0ae5 c9				ret 
0ae6			 
0ae6			 
0ae6			cursor_next_line: 
0ae6				; TODO first char 
0ae6				; TODO line down 
0ae6				; TODO if past last row 
0ae6				; TODO    scroll up 
0ae6			 
0ae6 c9				ret 
0ae7			 
0ae7			cursor_left: 
0ae7				; TODO shift left 
0ae7				; TODO if beyond left  
0ae7				; TODO     cursor prev line 
0ae7				 
0ae7 c9				ret 
0ae8			 
0ae8			cursor_prev_line: 
0ae8				; TODO last char 
0ae8				; TODO line up 
0ae8				; TODO if past first row 
0ae8				; TODO   scroll down 
0ae8			 
0ae8 c9				ret 
0ae9			 
0ae9			 
0ae9			cout: 
0ae9				; A - char 
0ae9 c9				ret 
0aea			 
0aea			; eof 
0aea			 
# End of file firmware_display.asm
0aea			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0aea			; random number generators 
0aea			 
0aea			 
0aea			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0aea			 
0aea			 
0aea			;-----> Generate a random number 
0aea			; output a=answer 0<=a<=255 
0aea			; all registers are preserved except: af 
0aea			random: 
0aea e5			        push    hl 
0aeb d5			        push    de 
0aec 2a ba f8		        ld      hl,(randData) 
0aef ed 5f		        ld      a,r 
0af1 57			        ld      d,a 
0af2 5e			        ld      e,(hl) 
0af3 19			        add     hl,de 
0af4 85			        add     a,l 
0af5 ac			        xor     h 
0af6 22 ba f8		        ld      (randData),hl 
0af9 d1			        pop     de 
0afa e1			        pop     hl 
0afb c9			        ret 
0afc			 
0afc			 
0afc			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0afc			 
0afc			 
0afc			 
0afc			;------LFSR------ 
0afc			;James Montelongo 
0afc			;optimized by Spencer Putt 
0afc			;out: 
0afc			; a = 8 bit random number 
0afc			RandLFSR: 
0afc 21 c0 f8		        ld hl,LFSRSeed+4 
0aff 5e			        ld e,(hl) 
0b00 23			        inc hl 
0b01 56			        ld d,(hl) 
0b02 23			        inc hl 
0b03 4e			        ld c,(hl) 
0b04 23			        inc hl 
0b05 7e			        ld a,(hl) 
0b06 47			        ld b,a 
0b07 cb 13		        rl e  
0b09 cb 12			rl d 
0b0b cb 11		        rl c  
0b0d 17				rla 
0b0e cb 13		        rl e  
0b10 cb 12			rl d 
0b12 cb 11		        rl c  
0b14 17				rla 
0b15 cb 13		        rl e  
0b17 cb 12			rl d 
0b19 cb 11		        rl c  
0b1b 17				rla 
0b1c 67			        ld h,a 
0b1d cb 13		        rl e  
0b1f cb 12			rl d 
0b21 cb 11		        rl c  
0b23 17				rla 
0b24 a8			        xor b 
0b25 cb 13		        rl e  
0b27 cb 12			rl d 
0b29 ac			        xor h 
0b2a a9			        xor c 
0b2b aa			        xor d 
0b2c 21 c2 f8		        ld hl,LFSRSeed+6 
0b2f 11 c3 f8		        ld de,LFSRSeed+7 
0b32 01 07 00		        ld bc,7 
0b35 ed b8		        lddr 
0b37 12			        ld (de),a 
0b38 c9			        ret 
0b39			 
0b39			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0b39			 
0b39			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0b39			 
0b39			 
0b39			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0b39			 
0b39			prng16: 
0b39			;Inputs: 
0b39			;   (seed1) contains a 16-bit seed value 
0b39			;   (seed2) contains a NON-ZERO 16-bit seed value 
0b39			;Outputs: 
0b39			;   HL is the result 
0b39			;   BC is the result of the LCG, so not that great of quality 
0b39			;   DE is preserved 
0b39			;Destroys: 
0b39			;   AF 
0b39			;cycle: 4,294,901,760 (almost 4.3 billion) 
0b39			;160cc 
0b39			;26 bytes 
0b39 2a b4 f8		    ld hl,(seed1) 
0b3c 44			    ld b,h 
0b3d 4d			    ld c,l 
0b3e 29			    add hl,hl 
0b3f 29			    add hl,hl 
0b40 2c			    inc l 
0b41 09			    add hl,bc 
0b42 22 b4 f8		    ld (seed1),hl 
0b45 2a b2 f8		    ld hl,(seed2) 
0b48 29			    add hl,hl 
0b49 9f			    sbc a,a 
0b4a e6 2d		    and %00101101 
0b4c ad			    xor l 
0b4d 6f			    ld l,a 
0b4e 22 b2 f8		    ld (seed2),hl 
0b51 09			    add hl,bc 
0b52 c9			    ret 
0b53			 
0b53			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0b53			 
0b53			rand32: 
0b53			;Inputs: 
0b53			;   (seed1_0) holds the lower 16 bits of the first seed 
0b53			;   (seed1_1) holds the upper 16 bits of the first seed 
0b53			;   (seed2_0) holds the lower 16 bits of the second seed 
0b53			;   (seed2_1) holds the upper 16 bits of the second seed 
0b53			;   **NOTE: seed2 must be non-zero 
0b53			;Outputs: 
0b53			;   HL is the result 
0b53			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0b53			;Destroys: 
0b53			;   AF 
0b53			;Tested and passes all CAcert tests 
0b53			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0b53			;it has a period of 18,446,744,069,414,584,320 
0b53			;roughly 18.4 quintillion. 
0b53			;LFSR taps: 0,2,6,7  = 11000101 
0b53			;291cc 
0b53			;seed1_0=$+1 
0b53			;    ld hl,12345 
0b53			;seed1_1=$+1 
0b53			;    ld de,6789 
0b53			;    ld b,h 
0b53			;    ld c,l 
0b53			;    add hl,hl \ rl e \ rl d 
0b53			;    add hl,hl \ rl e \ rl d 
0b53			;    inc l 
0b53			;    add hl,bc 
0b53			;    ld (seed1_0),hl 
0b53			;    ld hl,(seed1_1) 
0b53			;    adc hl,de 
0b53			;    ld (seed1_1),hl 
0b53			;    ex de,hl 
0b53			;seed2_0=$+1 
0b53			;    ld hl,9876 
0b53			;seed2_1=$+1 
0b53			;    ld bc,54321 
0b53			;    add hl,hl \ rl c \ rl b 
0b53			;    ld (seed2_1),bc 
0b53			;    sbc a,a 
0b53			;    and %11000101 
0b53			;    xor l 
0b53			;    ld l,a 
0b53			;    ld (seed2_0),hl 
0b53			;    ex de,hl 
0b53			;    add hl,bc 
0b53			;    ret 
0b53			; 
0b53			 
0b53			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0b53			; 20 bytes, 86 cycles (excluding ret) 
0b53			 
0b53			; returns   hl = pseudorandom number 
0b53			; corrupts   a 
0b53			 
0b53			; generates 16-bit pseudorandom numbers with a period of 65535 
0b53			; using the xorshift method: 
0b53			 
0b53			; hl ^= hl << 7 
0b53			; hl ^= hl >> 9 
0b53			; hl ^= hl << 8 
0b53			 
0b53			; some alternative shift triplets which also perform well are: 
0b53			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0b53			 
0b53			;  org 32768 
0b53			 
0b53			xrnd: 
0b53 2a b8 f8		  ld hl,(xrandc)       ; seed must not be 0 
0b56 3e 00		  ld a,0 
0b58 bd			  cp l 
0b59 20 02		  jr nz, .xrnd1 
0b5b 2e 01		  ld l, 1 
0b5d			.xrnd1: 
0b5d			 
0b5d 7c			  ld a,h 
0b5e 1f			  rra 
0b5f 7d			  ld a,l 
0b60 1f			  rra 
0b61 ac			  xor h 
0b62 67			  ld h,a 
0b63 7d			  ld a,l 
0b64 1f			  rra 
0b65 7c			  ld a,h 
0b66 1f			  rra 
0b67 ad			  xor l 
0b68 6f			  ld l,a 
0b69 ac			  xor h 
0b6a 67			  ld h,a 
0b6b			 
0b6b 22 b8 f8		  ld (xrandc),hl 
0b6e			 
0b6e c9			  ret 
0b6f			;  
0b6f			 
0b6f			 
0b6f			;;;; int maths 
0b6f			 
0b6f			; https://map.grauw.nl/articles/mult_div_shifts.php 
0b6f			; Divide 16-bit values (with 16-bit result) 
0b6f			; In: Divide BC by divider DE 
0b6f			; Out: BC = result, HL = rest 
0b6f			; 
0b6f			Div16: 
0b6f 21 00 00		    ld hl,0 
0b72 78			    ld a,b 
0b73 06 08		    ld b,8 
0b75			Div16_Loop1: 
0b75 17			    rla 
0b76 ed 6a		    adc hl,hl 
0b78 ed 52		    sbc hl,de 
0b7a 30 01		    jr nc,Div16_NoAdd1 
0b7c 19			    add hl,de 
0b7d			Div16_NoAdd1: 
0b7d 10 f6		    djnz Div16_Loop1 
0b7f 17			    rla 
0b80 2f			    cpl 
0b81 47			    ld b,a 
0b82 79			    ld a,c 
0b83 48			    ld c,b 
0b84 06 08		    ld b,8 
0b86			Div16_Loop2: 
0b86 17			    rla 
0b87 ed 6a		    adc hl,hl 
0b89 ed 52		    sbc hl,de 
0b8b 30 01		    jr nc,Div16_NoAdd2 
0b8d 19			    add hl,de 
0b8e			Div16_NoAdd2: 
0b8e 10 f6		    djnz Div16_Loop2 
0b90 17			    rla 
0b91 2f			    cpl 
0b92 41			    ld b,c 
0b93 4f			    ld c,a 
0b94 c9			ret 
0b95			 
0b95			 
0b95			;http://z80-heaven.wikidot.com/math 
0b95			; 
0b95			;Inputs: 
0b95			;     DE and A are factors 
0b95			;Outputs: 
0b95			;     A is not changed 
0b95			;     B is 0 
0b95			;     C is not changed 
0b95			;     DE is not changed 
0b95			;     HL is the product 
0b95			;Time: 
0b95			;     342+6x 
0b95			; 
0b95			Mult16: 
0b95			 
0b95 06 08		     ld b,8          ;7           7 
0b97 21 00 00		     ld hl,0         ;10         10 
0b9a 29			       add hl,hl     ;11*8       88 
0b9b 07			       rlca          ;4*8        32 
0b9c 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0b9e 19			         add hl,de   ;--         -- 
0b9f 10 f9		       djnz $-5      ;13*7+8     99 
0ba1 c9			ret 
0ba2			 
0ba2			; 
0ba2			; Square root of 16-bit value 
0ba2			; In:  HL = value 
0ba2			; Out:  D = result (rounded down) 
0ba2			; 
0ba2			;Sqr16: 
0ba2			;    ld de,#0040 
0ba2			;    ld a,l 
0ba2			;    ld l,h 
0ba2			;    ld h,d 
0ba2			;    or a 
0ba2			;    ld b,8 
0ba2			;Sqr16_Loop: 
0ba2			;    sbc hl,de 
0ba2			;    jr nc,Sqr16_Skip 
0ba2			;    add hl,de 
0ba2			;Sqr16_Skip: 
0ba2			;    ccf 
0ba2			;    rl d 
0ba2			;    add a,a 
0ba2			;    adc hl,hl 
0ba2			;    add a,a 
0ba2			;    adc hl,hl 
0ba2			;    djnz Sqr16_Loop 
0ba2			;    ret 
0ba2			; 
0ba2			; 
0ba2			; Divide 8-bit values 
0ba2			; In: Divide E by divider C 
0ba2			; Out: A = result, B = rest 
0ba2			; 
0ba2			Div8: 
0ba2 af			    xor a 
0ba3 06 08		    ld b,8 
0ba5			Div8_Loop: 
0ba5 cb 13		    rl e 
0ba7 17			    rla 
0ba8 91			    sub c 
0ba9 30 01		    jr nc,Div8_NoAdd 
0bab 81			    add a,c 
0bac			Div8_NoAdd: 
0bac 10 f7		    djnz Div8_Loop 
0bae 47			    ld b,a 
0baf 7b			    ld a,e 
0bb0 17			    rla 
0bb1 2f			    cpl 
0bb2 c9			    ret 
0bb3			 
0bb3			; 
0bb3			; Multiply 8-bit value with a 16-bit value (unrolled) 
0bb3			; In: Multiply A with DE 
0bb3			; Out: HL = result 
0bb3			; 
0bb3			Mult12U: 
0bb3 2e 00		    ld l,0 
0bb5 87			    add a,a 
0bb6 30 01		    jr nc,Mult12U_NoAdd0 
0bb8 19			    add hl,de 
0bb9			Mult12U_NoAdd0: 
0bb9 29			    add hl,hl 
0bba 87			    add a,a 
0bbb 30 01		    jr nc,Mult12U_NoAdd1 
0bbd 19			    add hl,de 
0bbe			Mult12U_NoAdd1: 
0bbe 29			    add hl,hl 
0bbf 87			    add a,a 
0bc0 30 01		    jr nc,Mult12U_NoAdd2 
0bc2 19			    add hl,de 
0bc3			Mult12U_NoAdd2: 
0bc3 29			    add hl,hl 
0bc4 87			    add a,a 
0bc5 30 01		    jr nc,Mult12U_NoAdd3 
0bc7 19			    add hl,de 
0bc8			Mult12U_NoAdd3: 
0bc8 29			    add hl,hl 
0bc9 87			    add a,a 
0bca 30 01		    jr nc,Mult12U_NoAdd4 
0bcc 19			    add hl,de 
0bcd			Mult12U_NoAdd4: 
0bcd 29			    add hl,hl 
0bce 87			    add a,a 
0bcf 30 01		    jr nc,Mult12U_NoAdd5 
0bd1 19			    add hl,de 
0bd2			Mult12U_NoAdd5: 
0bd2 29			    add hl,hl 
0bd3 87			    add a,a 
0bd4 30 01		    jr nc,Mult12U_NoAdd6 
0bd6 19			    add hl,de 
0bd7			Mult12U_NoAdd6: 
0bd7 29			    add hl,hl 
0bd8 87			    add a,a 
0bd9 d0			    ret nc 
0bda 19			    add hl,de 
0bdb c9			    ret 
0bdc			 
0bdc			; 
0bdc			; Multiply 8-bit value with a 16-bit value (right rotating) 
0bdc			; In: Multiply A with DE 
0bdc			;      Put lowest value in A for most efficient calculation 
0bdc			; Out: HL = result 
0bdc			; 
0bdc			Mult12R: 
0bdc 21 00 00		    ld hl,0 
0bdf			Mult12R_Loop: 
0bdf cb 3f		    srl a 
0be1 30 01		    jr nc,Mult12R_NoAdd 
0be3 19			    add hl,de 
0be4			Mult12R_NoAdd: 
0be4 cb 23		    sla e 
0be6 cb 12		    rl d 
0be8 b7			    or a 
0be9 c2 df 0b		    jp nz,Mult12R_Loop 
0bec c9			    ret 
0bed			 
0bed			; 
0bed			; Multiply 16-bit values (with 32-bit result) 
0bed			; In: Multiply BC with DE 
0bed			; Out: BCHL = result 
0bed			; 
0bed			Mult32: 
0bed 79			    ld a,c 
0bee 48			    ld c,b 
0bef 21 00 00		    ld hl,0 
0bf2 06 10		    ld b,16 
0bf4			Mult32_Loop: 
0bf4 29			    add hl,hl 
0bf5 17			    rla 
0bf6 cb 11		    rl c 
0bf8 30 07		    jr nc,Mult32_NoAdd 
0bfa 19			    add hl,de 
0bfb ce 00		    adc a,0 
0bfd d2 01 0c		    jp nc,Mult32_NoAdd 
0c00 0c			    inc c 
0c01			Mult32_NoAdd: 
0c01 10 f1		    djnz Mult32_Loop 
0c03 41			    ld b,c 
0c04 4f			    ld c,a 
0c05 c9			    ret 
0c06			 
0c06			 
0c06			 
0c06			; 
0c06			; Multiply 8-bit values 
0c06			; In:  Multiply H with E 
0c06			; Out: HL = result 
0c06			; 
0c06			Mult8: 
0c06 16 00		    ld d,0 
0c08 6a			    ld l,d 
0c09 06 08		    ld b,8 
0c0b			Mult8_Loop: 
0c0b 29			    add hl,hl 
0c0c 30 01		    jr nc,Mult8_NoAdd 
0c0e 19			    add hl,de 
0c0f			Mult8_NoAdd: 
0c0f 10 fa		    djnz Mult8_Loop 
0c11 c9			    ret 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			 
0c12			;;http://z80-heaven.wikidot.com/math 
0c12			;;This divides DE by BC, storing the result in DE, remainder in HL 
0c12			; 
0c12			;DE_Div_BC:          ;1281-2x, x is at most 16 
0c12			;     ld a,16        ;7 
0c12			;     ld hl,0        ;10 
0c12			;     jp $+5         ;10 
0c12			;.DivLoop: 
0c12			;       add hl,bc    ;-- 
0c12			;       dec a        ;64 
0c12			;       jr z,.DivLoopEnd        ;86 
0c12			; 
0c12			;       sla e        ;128 
0c12			;       rl d         ;128 
0c12			;       adc hl,hl    ;240 
0c12			;       sbc hl,bc    ;240 
0c12			;       jr nc,.DivLoop ;23|21 
0c12			;       inc e        ;-- 
0c12			;       jp .DivLoop+1 
0c12			; 
0c12			;.DivLoopEnd: 
0c12			 
0c12			;HL_Div_C: 
0c12			;Inputs: 
0c12			;     HL is the numerator 
0c12			;     C is the denominator 
0c12			;Outputs: 
0c12			;     A is the remainder 
0c12			;     B is 0 
0c12			;     C is not changed 
0c12			;     DE is not changed 
0c12			;     HL is the quotient 
0c12			; 
0c12			;       ld b,16 
0c12			;       xor a 
0c12			;         add hl,hl 
0c12			;         rla 
0c12			;         cp c 
0c12			;         jr c,$+4 
0c12			;           inc l 
0c12			;           sub c 
0c12			;         djnz $-7 
0c12			 
0c12			; https://plutiedev.com/z80-add-8bit-to-16bit 
0c12			 
0c12			addatohl: 
0c12 85			    add   a, l    ; A = A+L 
0c13 6f			    ld    l, a    ; L = A+L 
0c14 8c			    adc   a, h    ; A = A+L+H+carry 
0c15 95			    sub   l       ; A = H+carry 
0c16 67			    ld    h, a    ; H = H+carry 
0c17 c9			ret 
0c18			 
0c18			addatode: 
0c18 83			    add   a, e    ; A = A+L 
0c19 5f			    ld    e, a    ; L = A+L 
0c1a 8a			    adc   a, d    ; A = A+L+H+carry 
0c1b 93			    sub   e       ; A = H+carry 
0c1c 57			    ld    d, a    ; H = H+carry 
0c1d c9			ret 
0c1e			 
0c1e			 
0c1e			addatobc: 
0c1e 81			    add   a, c    ; A = A+L 
0c1f 4f			    ld    c, a    ; L = A+L 
0c20 88			    adc   a, b    ; A = A+L+H+carry 
0c21 91			    sub   c       ; A = H+carry 
0c22 47			    ld    b, a    ; H = H+carry 
0c23 c9			ret 
0c24			 
0c24			subafromhl: 
0c24			   ; If A=0 do nothing 
0c24			    ; Otherwise flip A's sign. Since 
0c24			    ; the upper byte becomes -1, also 
0c24			    ; substract 1 from H. 
0c24 ed 44		    neg 
0c26 ca 2f 0c		    jp    z, Skip 
0c29 25			    dec   h 
0c2a			     
0c2a			    ; Now add the low byte as usual 
0c2a			    ; Two's complement takes care of 
0c2a			    ; ensuring the result is correct 
0c2a 85			    add   a, l 
0c2b 6f			    ld    l, a 
0c2c 8c			    adc   a, h 
0c2d 95			    sub   l 
0c2e 67			    ld    h, a 
0c2f			Skip: 
0c2f c9				ret 
0c30			 
0c30			 
0c30			; compare hl and de 
0c30			; returns:  
0c30			; if hl = de, z=1, s=0, c0=0 
0c30			; if hl > de, z=0, s=0, c=0 
0c30			; if hl < de, z=0, s=1, c=1 
0c30			cmp16:	 
0c30 b7				or a 
0c31 ed 52			sbc hl,de 
0c33 e0				ret po 
0c34 7c				ld a,h 
0c35 1f				rra 
0c36 ee 40			xor 01000000B 
0c38 37				scf 
0c39 8f				adc a,a 
0c3a c9				ret 
0c3b			 
0c3b			 
0c3b			; test if hl contains zero   - A is destroyed 
0c3b			 
0c3b			ishlzero:    
0c3b b7				or a     ; reset flags 
0c3c 7c				ld a, h 
0c3d b5				or l        	 
0c3e			 
0c3e c9				ret 
0c3f			 
0c3f			 
0c3f			 
0c3f			 
0c3f			if FORTH_ENABLE_FLOATMATH 
0c3f			;include "float/bbcmath.z80" 
0c3f			include "float/lpfpcalc.asm" 
0c3f			endif 
0c3f			 
0c3f			 
0c3f			; eof 
0c3f			 
# End of file firmware_maths.asm
0c3f			include "firmware_strings.asm"   ; string handling  
0c3f			 
0c3f			 
0c3f			; TODO string len 
0c3f			; input text string, end on cr with zero term 
0c3f			; a offset into frame buffer to start prompt 
0c3f			; d is max length 
0c3f			; e is display size TODO 
0c3f			; c is current cursor position 
0c3f			; hl is ptr to where string will be stored 
0c3f			 
0c3f			 
0c3f			; TODO check limit of buffer for new inserts 
0c3f			; TODO check insert does not push beyond buffer 
0c3f			; TODO scroll in a limited display area 
0c3f			; TODO scroll whole screen on page wrap 
0c3f			 
0c3f			 
0c3f			; TODO handle KEY_PREVWORD 
0c3f			; TODO handle KEY_NEXTWORD 
0c3f			; TODO handle KEY_HOME 
0c3f			; TODO handle KEY_END 
0c3f			; TODO use LCD cursor? 
0c3f			 
0c3f 32 70 fb		input_str:    	ld (input_at_pos),a      ; save display position to start 
0c42 81					add c 
0c43 32 6e fb				ld (input_at_cursor),a	; save draw pos of cursor 
0c46 22 73 fb				ld (input_start), hl     ; save ptr to buffer 
0c49 79					ld a, c 
0c4a cd 12 0c				call addatohl 
0c4d 22 75 fb				ld (input_ptr), hl     ; save ptr to point under the cursor 
0c50 7a					ld a,d 
0c51 32 72 fb			        ld (input_size), a       ; save length of input area 
0c54 79					ld a, c 
0c55 32 61 fb				ld (input_cursor),a      ; init cursor start position  
0c58 7b					ld a,e 
0c59 32 71 fb			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0c5c					 
0c5c					 
0c5c			 
0c5c			;		ld a,(input_ptr) 
0c5c			;		ld (input_under_cursor),a 	; save what is under the cursor 
0c5c			 
0c5c			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0c5c					; init cursor shape if not set by the cin routines 
0c5c 21 d0 f8				ld hl, cursor_shape 
0c5f 3e ff				ld a, 255 
0c61 77					ld (hl), a 
0c62 23					inc hl 
0c63 3e 00				ld a, 0 
0c65 77					ld (hl), a 
0c66			 
0c66 3e 0f				ld a, CUR_BLINK_RATE 
0c68 32 6c fb				ld (input_cur_flash), a 
0c6b 3e 01				ld a, 1 
0c6d 32 6b fb				ld (input_cur_onoff),a 
0c70			 
0c70			;	if DEBUG_INPUT 
0c70			;		push af 
0c70			;		ld a, 'I' 
0c70			;		ld (debug_mark),a 
0c70			;		pop af 
0c70			;		CALLMONITOR 
0c70			;	endif 
0c70			.is1:		; main entry loop 
0c70			 
0c70			 
0c70			 
0c70					; pause 1ms 
0c70			 
0c70 3e 01				ld a, 1 
0c72 cd 22 0a				call aDelayInMS 
0c75			 
0c75					; dec flash counter 
0c75 3a 6c fb				ld a, (input_cur_flash) 
0c78 3d					dec a 
0c79 32 6c fb				ld (input_cur_flash), a 
0c7c fe 00				cp 0 
0c7e 20 0d				jr nz, .nochgstate 
0c80			 
0c80			 
0c80					; change state 
0c80 3a 6b fb				ld a,(input_cur_onoff) 
0c83 ed 44				neg 
0c85 32 6b fb				ld (input_cur_onoff),a 
0c88			 
0c88			 
0c88					; reset on change of state 
0c88 3e 0f				ld a, CUR_BLINK_RATE 
0c8a 32 6c fb				ld (input_cur_flash), a 
0c8d			 
0c8d			.nochgstate: 
0c8d					 
0c8d					 
0c8d			 
0c8d					; display cursor  
0c8d			 
0c8d			;		ld hl, (input_start) 
0c8d			;		ld a, (input_cursor) 
0c8d			;		call addatohl 
0c8d			 
0c8d					; get char under cursor and replace with cursor 
0c8d 2a 75 fb		ld hl, (input_ptr) 
0c90			;		ld a, (hl) 
0c90			;		ld (input_under_cursor),a 
0c90			;		ld a, '_' 
0c90			;		ld (hl), a 
0c90			 
0c90					; display string 
0c90			 
0c90 ed 5b 73 fb			ld de, (input_start) 
0c94 3a 70 fb				ld a, (input_at_pos) 
0c97 cd cc 0a				call str_at_display 
0c9a			;	        call update_display 
0c9a			 
0c9a					; find place to put the cursor 
0c9a			;		add h 
0c9a			;		ld l, display_row_1 
0c9a			;		sub l 
0c9a			; (input_at_pos) 
0c9a					;ld c, a 
0c9a			;		ld a, (input_cursor) 
0c9a			;		ld l, (input_at_pos) 
0c9a			;		;ld b, h 
0c9a			;		add l 
0c9a			;		ld (input_at_cursor),a 
0c9a					;ld l,h 
0c9a			 
0c9a			;		ld h, 0 
0c9a			;		ld l,(input_at_pos) 
0c9a			;		ld a, (input_cursor) 
0c9a			;		call addatohl 
0c9a			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0c9a			;		call subafromhl 
0c9a			;		ld a,l 
0c9a			;		ld (input_at_cursor), a 
0c9a			 
0c9a				if DEBUG_INPUT 
0c9a					ld a, (hardware_diag) 
0c9a					cp 0 
0c9a					jr z, .skip_input_diag 
0c9a			 
0c9a					ld a,(input_at_pos) 
0c9a					ld hl, LFSRSeed 
0c9a					call hexout 
0c9a					ld a, (input_cursor) 
0c9a					ld hl, LFSRSeed+2 
0c9a					call hexout 
0c9a					ld a,(input_at_cursor) 
0c9a					ld hl, LFSRSeed+4 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_cur_onoff) 
0c9a					ld hl, LFSRSeed+6 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_cur_flash) 
0c9a					ld hl, LFSRSeed+8 
0c9a					call hexout 
0c9a			 
0c9a					ld a,(input_len) 
0c9a					ld hl, LFSRSeed+10 
0c9a					call hexout 
0c9a					ld hl, LFSRSeed+12 
0c9a					ld a, 0 
0c9a					ld (hl),a 
0c9a					ld a, display_row_4 
0c9a					ld de, LFSRSeed 
0c9a					call str_at_display 
0c9a					.skip_input_diag: 
0c9a				endif 
0c9a			 
0c9a					; decide on if we are showing the cursor this time round 
0c9a			 
0c9a 3a 6b fb				ld a, (input_cur_onoff) 
0c9d fe ff				cp 255 
0c9f 28 13				jr z, .skipcur 
0ca1			 
0ca1			 
0ca1 3a 6e fb				ld a,(input_at_cursor) 
0ca4 11 d0 f8				ld de, cursor_shape 
0ca7 cd cc 0a				call str_at_display 
0caa			 
0caa					; save length of current input string 
0caa 2a 73 fb				ld hl, (input_start) 
0cad cd 70 10				call strlenz 
0cb0 7d					ld a,l 
0cb1 32 66 fb				ld (input_len),a 
0cb4			 
0cb4			.skipcur: 
0cb4			 
0cb4 cd dc 0a			        call update_display 
0cb7					 
0cb7			 
0cb7			 
0cb7					; wait 
0cb7				 
0cb7					; TODO loop without wait to flash the cursor and char under cursor	 
0cb7 cd 06 65				call cin    ; _wait 
0cba			 
0cba fe 00				cp 0 
0cbc ca 70 0c				jp z, .is1 
0cbf			 
0cbf					; get ptr to char to input into 
0cbf			 
0cbf 4f					ld c,a 
0cc0 2a 73 fb				ld hl, (input_start) 
0cc3 3a 61 fb				ld a, (input_cursor) 
0cc6 cd 12 0c				call addatohl 
0cc9 22 75 fb				ld (input_ptr), hl 
0ccc 79					ld a,c 
0ccd			 
0ccd					; replace char under cursor 
0ccd			 
0ccd			;		ld hl, (input_ptr) 
0ccd			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0ccd			;		ld (hl), a 
0ccd			 
0ccd			;	if DEBUG_INPUT 
0ccd			;		push af 
0ccd			;		ld a, 'i' 
0ccd			;		ld (debug_mark),a 
0ccd			;		pop af 
0ccd			;		CALLMONITOR 
0ccd			;	endif 
0ccd fe 0e				cp KEY_HOME 
0ccf 20 0e				jr nz, .iske 
0cd1			 
0cd1 3a 70 fb				ld a, (input_at_pos) 
0cd4 32 6e fb				ld (input_at_cursor),a 
0cd7 3e 00				ld a, 0 
0cd9 32 61 fb				ld (input_cursor), a 
0cdc c3 70 0c				jp .is1 
0cdf					 
0cdf fe 0f		.iske:		cp KEY_END 
0ce1 20 03				jr nz, .isknw 
0ce3 c3 70 0c				jp .is1 
0ce6			 
0ce6 fe 06		.isknw:		cp KEY_NEXTWORD 
0ce8 20 1b				jr nz, .iskpw 
0cea			 
0cea 2a 75 fb		.isknwm:	ld hl, (input_ptr) 
0ced 7e					ld a,(hl)	 
0cee fe 00				cp 0 
0cf0 ca 70 0c				jp z, .is1    ; end of string 
0cf3 fe 20				cp ' ' 
0cf5 ca 70 0c				jp z, .is1    ; end of word 
0cf8 23					inc hl 
0cf9 22 75 fb				ld (input_ptr), hl 
0cfc 3a 6e fb				ld a, (input_at_cursor) 
0cff 3c					inc a 
0d00 32 6e fb				ld (input_at_cursor), a 
0d03 18 e5				jr .isknwm 
0d05			 
0d05 fe 07		.iskpw:		cp KEY_PREVWORD 
0d07 20 1b				jr nz, .iskl 
0d09			.iskpwm:	 
0d09 2a 75 fb				ld hl, (input_ptr) 
0d0c 7e					ld a,(hl)	 
0d0d fe 00				cp 0  
0d0f ca 70 0c				jp z, .is1    ; end of string 
0d12 fe 20				cp ' ' 
0d14 ca 70 0c				jp z, .is1    ; end of word 
0d17 2b					dec hl 
0d18 22 75 fb				ld (input_ptr), hl 
0d1b 3a 6e fb				ld a, (input_at_cursor) 
0d1e 3d					dec a 
0d1f 32 6e fb				ld (input_at_cursor), a 
0d22 18 e5				jr .iskpwm 
0d24			 
0d24			 
0d24 fe 0b		.iskl:		cp KEY_LEFT 
0d26 20 27				jr nz, .isk1 
0d28			 
0d28 3a 61 fb				ld a, (input_cursor) 
0d2b			 
0d2b fe 00				cp 0 
0d2d ca 70 0c				jp z, .is1 		; at start of line to ignore  
0d30			 
0d30 3d					dec  a 		; TODO check underflow 
0d31 32 61 fb				ld (input_cursor), a 
0d34			 
0d34 2a 75 fb				ld hl, (input_ptr) 
0d37 2b					dec hl 
0d38 22 75 fb				ld (input_ptr), hl 
0d3b					 
0d3b 3a 6e fb				ld a, (input_at_cursor) 
0d3e 3d					dec a 
0d3f 32 6e fb				ld (input_at_cursor), a 
0d42			 
0d42 3e 01				ld a, 1		; show cursor moving 
0d44 32 6b fb				ld (input_cur_onoff),a 
0d47 3e 0f				ld a, CUR_BLINK_RATE 
0d49 32 6c fb				ld (input_cur_flash), a 
0d4c			 
0d4c c3 70 0c				jp .is1 
0d4f			 
0d4f fe 0c		.isk1:		cp KEY_RIGHT 
0d51 20 2a				jr nz, .isk2 
0d53			 
0d53 3a 66 fb				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0d56 5f					ld e,a 
0d57 3a 61 fb				ld a, (input_cursor) 
0d5a bb					cp e 
0d5b ca 70 0c				jp z, .is1		; at the end of string so dont go right 
0d5e			 
0d5e 3c					inc  a 		; TODO check overflow 
0d5f 32 61 fb				ld (input_cursor), a 
0d62			 
0d62 3a 6e fb				ld a, (input_at_cursor) 
0d65 3c					inc a 
0d66 32 6e fb				ld (input_at_cursor), a 
0d69			 
0d69 2a 75 fb				ld hl, (input_ptr) 
0d6c 23					inc hl 
0d6d 22 75 fb				ld (input_ptr), hl 
0d70			 
0d70 3e 01				ld a, 1		; show cursor moving 
0d72 32 6b fb				ld (input_cur_onoff),a 
0d75 3e 0f				ld a, CUR_BLINK_RATE 
0d77 32 6c fb				ld (input_cur_flash), a 
0d7a			 
0d7a c3 70 0c				jp .is1 
0d7d			 
0d7d fe 05		.isk2:		cp KEY_UP 
0d7f			 
0d7f 20 26				jr nz, .isk3 
0d81			 
0d81					; swap last command with the current on 
0d81			 
0d81					; move cursor to start of string 
0d81 2a 73 fb				ld hl, (input_start) 
0d84 22 75 fb				ld (input_ptr), hl 
0d87			 
0d87 3a 70 fb				ld a, (input_at_pos) 
0d8a 32 6e fb				ld (input_at_cursor), a 
0d8d			 
0d8d 3e 00				ld a, 0 
0d8f 32 61 fb				ld (input_cursor), a 
0d92					 
0d92					; swap input and last command buffers 
0d92			 
0d92 21 59 f1				ld hl, os_cli_cmd 
0d95 11 58 f2				ld de, os_last_cmd 
0d98 06 ff				ld b, 255 
0d9a 7e			.swap1:		ld a, (hl) 
0d9b 4f					ld c,a 
0d9c 1a					ld a, (de) 
0d9d 77					ld (hl), a 
0d9e 79					ld a,c 
0d9f 12					ld (de),a 
0da0 23					inc hl 
0da1 13					inc de 
0da2 10 f6				djnz .swap1 
0da4			 
0da4			 
0da4			 
0da4			 
0da4			 
0da4 c3 70 0c				jp .is1 
0da7			 
0da7 fe 08		.isk3:		cp KEY_BS 
0da9 20 3c				jr nz, .isk4 
0dab			 
0dab 3a 61 fb				ld a, (input_cursor) 
0dae			 
0dae fe 00				cp 0 
0db0 ca 70 0c				jp z, .is1 		; at start of line to ignore  
0db3			 
0db3 3d					dec  a 		; TODO check underflow 
0db4 32 61 fb				ld (input_cursor), a 
0db7			 
0db7					; hl is source 
0db7					; de needs to be source - 1 
0db7			 
0db7			;		ld a, 0 
0db7			;		dec hl 
0db7			;		ld (hl), a 
0db7			 
0db7 2a 75 fb				ld hl, (input_ptr) 
0dba 2b					dec hl 
0dbb 22 75 fb				ld (input_ptr), hl 
0dbe			 
0dbe					; shift all data 
0dbe			 
0dbe e5					push hl 
0dbf 23					inc hl 
0dc0 d1					pop de 
0dc1 3a 66 fb				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0dc4 4f					ld c,a 
0dc5 06 00				ld b,0 
0dc7 ed b0				ldir  
0dc9			 
0dc9			 
0dc9			 
0dc9			 
0dc9 3a 6e fb				ld a, (input_at_cursor) 
0dcc 3d					dec a 
0dcd 32 6e fb				ld (input_at_cursor), a 
0dd0			 
0dd0			 
0dd0 3e 01				ld a, 1		; show cursor moving 
0dd2 32 6b fb				ld (input_cur_onoff),a 
0dd5 3e 0f				ld a, CUR_BLINK_RATE 
0dd7 32 6c fb				ld (input_cur_flash), a 
0dda			 
0dda					; remove char 
0dda 3a 6e fb				ld a, (input_at_cursor) 
0ddd 3c					inc a 
0dde 11 68 0e				ld de,.iblank 
0de1 cd cc 0a				call str_at_display 
0de4			 
0de4 c3 70 0c				jp .is1 
0de7			 
0de7 fe 0d		.isk4:		cp KEY_CR 
0de9 28 6c				jr z, .endinput 
0deb			 
0deb					; else add the key press to the end 
0deb			 
0deb 4f					ld c, a			; save key pressed 
0dec			 
0dec 7e					ld a,(hl)		; get what is currently under char 
0ded			 
0ded fe 00				cp 0			; we are at the end of the string 
0def 20 2f				jr nz, .onchar 
0df1					 
0df1					; add a char to the end of the string 
0df1				 
0df1 71					ld (hl),c 
0df2 23					inc hl 
0df3			;		ld a,' ' 
0df3			;		ld (hl),a 
0df3			;		inc hl 
0df3 3e 00				ld a,0 
0df5 77					ld (hl),a 
0df6 2b					dec hl 
0df7			 
0df7 3a 61 fb				ld a, (input_cursor) 
0dfa 3c					inc a				; TODO check max string length and scroll  
0dfb 32 61 fb				ld (input_cursor), a		; inc cursor pos 
0dfe							 
0dfe 3a 6e fb				ld a, (input_at_cursor) 
0e01 3c					inc a 
0e02 32 6e fb				ld (input_at_cursor), a 
0e05			 
0e05 2a 75 fb				ld hl, (input_ptr) 
0e08 23					inc hl 
0e09 22 75 fb				ld (input_ptr), hl 
0e0c			 
0e0c 2a 75 fb				ld hl, (input_ptr) 
0e0f 23					inc hl 
0e10 22 75 fb				ld (input_ptr), hl 
0e13			;	if DEBUG_INPUT 
0e13			;		push af 
0e13			;		ld a, '+' 
0e13			;		ld (debug_mark),a 
0e13			;		pop af 
0e13			;		CALLMONITOR 
0e13			;	endif 
0e13 3e 01				ld a, 1		; show cursor moving 
0e15 32 6b fb				ld (input_cur_onoff),a 
0e18 3e 0f				ld a, CUR_BLINK_RATE 
0e1a 32 6c fb				ld (input_cur_flash), a 
0e1d c3 70 0c				jp .is1 
0e20					 
0e20			 
0e20			 
0e20					; if on a char then insert 
0e20			.onchar: 
0e20			 
0e20					; TODO over flow check: make sure insert does not blow out buffer 
0e20			 
0e20					; need to do some maths to use lddr 
0e20			 
0e20 e5					push hl   ; save char pos 
0e21 c5					push bc 
0e22			 
0e22 2a 73 fb				ld hl, (input_start) 
0e25 3a 66 fb				ld a, (input_len) 
0e28 cd 12 0c				call addatohl  		; end of string 
0e2b 23					inc hl 
0e2c 23					inc hl		; past zero term 
0e2d e5					push hl 
0e2e 23					inc hl 
0e2f e5					push hl  
0e30			 
0e30								; start and end of lddr set, now how much to move? 
0e30			 
0e30							 
0e30 3a 61 fb				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0e33 47					ld b,a 
0e34 3a 66 fb				ld a,(input_len) 
0e37 5f					ld e,a 
0e38 90					sub b 
0e39 3c					inc a		;?? 
0e3a 3c					inc a		;?? 
0e3b 3c					inc a		;?? 
0e3c			 
0e3c 06 00				ld b,0 
0e3e 4f					ld c,a 
0e3f			 
0e3f				if DEBUG_INPUT 
0e3f					push af 
0e3f					ld a, 'i' 
0e3f					ld (debug_mark),a 
0e3f					pop af 
0e3f			;		CALLMONITOR 
0e3f				endif 
0e3f d1					pop de 
0e40 e1					pop hl 
0e41				if DEBUG_INPUT 
0e41					push af 
0e41					ld a, 'I' 
0e41					ld (debug_mark),a 
0e41					pop af 
0e41			;		CALLMONITOR 
0e41				endif 
0e41 ed b8				lddr 
0e43				 
0e43			 
0e43			 
0e43					; TODO have a key for insert/overwrite mode???? 
0e43 c1					pop bc 
0e44 e1					pop hl 
0e45 71					ld (hl), c		; otherwise overwrite current char 
0e46					 
0e46			 
0e46			 
0e46			 
0e46 3a 61 fb				ld a, (input_cursor) 
0e49 3c					inc  a 		; TODO check overflow 
0e4a 32 61 fb				ld (input_cursor), a 
0e4d			 
0e4d 3a 6e fb				ld a, (input_at_cursor) 
0e50 3c					inc a 
0e51 32 6e fb				ld (input_at_cursor), a 
0e54			 
0e54 c3 70 0c				jp .is1 
0e57			 
0e57			.endinput:	; TODO look for end of string 
0e57			 
0e57					; add trailing space for end of token 
0e57			 
0e57 2a 73 fb				ld hl, (input_start) 
0e5a 3a 66 fb				ld a,(input_len) 
0e5d cd 12 0c				call addatohl 
0e60 3e 20				ld a, ' ' 
0e62 77					ld (hl),a 
0e63					; TODO eof of parse marker 
0e63			 
0e63 23					inc hl 
0e64 3e 00				ld a, 0 
0e66 77					ld (hl),a 
0e67			 
0e67			 
0e67 c9					ret 
0e68			 
0e68 .. 00		.iblank: db " ",0 
0e6a			 
0e6a			 
0e6a 32 70 fb		input_str_prev:	ld (input_at_pos), a 
0e6d 22 73 fb				ld (input_start), hl 
0e70 3e 01				ld a,1			; add cursor 
0e72 77					ld (hl),a 
0e73 23					inc hl 
0e74 3e 00				ld a,0 
0e76 77					ld (hl),a 
0e77 22 75 fb				ld (input_ptr), hl 
0e7a 7a					ld a,d 
0e7b 32 72 fb				ld (input_size), a 
0e7e 3e 00				ld a,0 
0e80 32 61 fb				ld (input_cursor),a 
0e83			.instr1:	 
0e83			 
0e83					; TODO do block cursor 
0e83					; TODO switch cursor depending on the modifer key 
0e83			 
0e83					; update cursor shape change on key hold 
0e83			 
0e83 2a 75 fb				ld hl, (input_ptr) 
0e86 2b					dec hl 
0e87 3a d0 f8				ld a,(cursor_shape) 
0e8a 77					ld (hl), a 
0e8b			 
0e8b					; display entered text 
0e8b 3a 70 fb				ld a,(input_at_pos) 
0e8e cd ca 62		            	CALL fLCD_Pos       ;Position cursor to location in A 
0e91 ed 5b 73 fb	            	LD   de, (input_start) 
0e95 cd ec 62		            	CALL fLCD_Str       ;Display string pointed to by DE 
0e98			 
0e98 cd 06 65				call cin 
0e9b fe 00				cp 0 
0e9d 28 e4				jr z, .instr1 
0e9f			 
0e9f					; proecess keyboard controls first 
0e9f			 
0e9f 2a 75 fb				ld hl,(input_ptr) 
0ea2			 
0ea2 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0ea4 28 5a				jr z, .instrcr 
0ea6			 
0ea6 fe 08				cp KEY_BS 	; back space 
0ea8 20 0f				jr nz, .instr2 
0eaa					; process back space 
0eaa			 
0eaa					; TODO stop back space if at start of string 
0eaa 2b					dec hl 
0eab 2b					dec hl ; to over write cursor 
0eac 3a d0 f8				ld a,(cursor_shape) 
0eaf					;ld a,0 
0eaf 77					ld (hl),a 
0eb0 23					inc hl 
0eb1 3e 20				ld a," " 
0eb3 77					ld (hl),a 
0eb4 22 75 fb				ld (input_ptr),hl 
0eb7					 
0eb7			 
0eb7 18 ca				jr .instr1 
0eb9			 
0eb9 fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0ebb 20 06				jr nz, .instr3 
0ebd 2b					dec hl 
0ebe 22 75 fb				ld (input_ptr),hl 
0ec1 18 c0				jr .instr1 
0ec3				 
0ec3 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0ec5 20 06				jr nz, .instr4 
0ec7 23					inc hl 
0ec8 22 75 fb				ld (input_ptr),hl 
0ecb 18 b6				jr .instr1 
0ecd			 
0ecd fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0ecf 20 06				jr nz, .instr5 
0ed1 2b					dec hl 
0ed2 22 75 fb				ld (input_ptr),hl 
0ed5 18 ac				jr .instr1 
0ed7			 
0ed7 fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0ed9 20 06				jr nz, .instr6 
0edb 2b					dec hl 
0edc 22 75 fb				ld (input_ptr),hl 
0edf 18 a2				jr .instr1 
0ee1 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0ee3 20 0b				jr nz, .instrnew 
0ee5			 
0ee5 21 32 ee			ld hl, scratch 
0ee8 11 58 f2			ld de, os_last_cmd 
0eeb cd 09 0f			call strcpy 
0eee 18 93				jr .instr1 
0ef0			 
0ef0			 
0ef0			.instrnew:	; no special key pressed to see if we have room to store it 
0ef0			 
0ef0					; TODO do string size test 
0ef0			 
0ef0 2b					dec hl ; to over write cursor 
0ef1 77					ld (hl),a 
0ef2 23					inc hl 
0ef3 3a d0 f8				ld a,(cursor_shape) 
0ef6 77					ld (hl),a 
0ef7 23					inc hl 
0ef8 3e 00				ld a,0 
0efa 77					ld (hl),a 
0efb			 
0efb 22 75 fb				ld (input_ptr),hl 
0efe					 
0efe 18 83				jr .instr1 
0f00 2b			.instrcr:	dec hl		; remove cursor 
0f01 3e 20				ld a,' '	; TODO add a trailing space for safety 
0f03 77					ld (hl),a 
0f04 23					inc hl 
0f05 3e 00				ld a,0 
0f07 77					ld (hl),a 
0f08			 
0f08			 
0f08					; if at end of line scroll up    
0f08					; TODO detecting only end of line 4 for scroll up  
0f08			 
0f08					;ld   
0f08			 
0f08 c9					ret 
0f09			 
0f09			 
0f09			; strcpy hl = dest, de source 
0f09			 
0f09 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0f0a b7			            OR   A              ;Null terminator? 
0f0b c8			            RET  Z              ;Yes, so finished 
0f0c 1a					ld a,(de) 
0f0d 77					ld (hl),a 
0f0e 13			            INC  DE             ;Point to next character 
0f0f 23					inc hl 
0f10 18 f7		            JR   strcpy       ;Repeat 
0f12 c9					ret 
0f13			 
0f13			 
0f13			; TODO string_at  
0f13			; pass string which starts with lcd offset address and then null term string 
0f13			 
0f13			; TODO string to dec 
0f13			; TODO string to hex 
0f13			; TODO byte to string hex 
0f13			; TODO byte to string dec 
0f13			 
0f13			 
0f13			 
0f13			; from z80uartmonitor 
0f13			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f13			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0f13			; pass hl for where to put the text 
0f13			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f13 c5			hexout:	PUSH BC 
0f14 f5					PUSH AF 
0f15 47					LD B, A 
0f16					; Upper nybble 
0f16 cb 3f				SRL A 
0f18 cb 3f				SRL A 
0f1a cb 3f				SRL A 
0f1c cb 3f				SRL A 
0f1e cd 2e 0f				CALL tohex 
0f21 77					ld (hl),a 
0f22 23					inc hl	 
0f23					 
0f23					; Lower nybble 
0f23 78					LD A, B 
0f24 e6 0f				AND 0FH 
0f26 cd 2e 0f				CALL tohex 
0f29 77					ld (hl),a 
0f2a 23					inc hl	 
0f2b					 
0f2b f1					POP AF 
0f2c c1					POP BC 
0f2d c9					RET 
0f2e					 
0f2e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2e			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0f2e			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f2e			tohex: 
0f2e e5					PUSH HL 
0f2f d5					PUSH DE 
0f30 16 00				LD D, 0 
0f32 5f					LD E, A 
0f33 21 3b 0f				LD HL, .DATA 
0f36 19					ADD HL, DE 
0f37 7e					LD A, (HL) 
0f38 d1					POP DE 
0f39 e1					POP HL 
0f3a c9					RET 
0f3b			 
0f3b			.DATA: 
0f3b 30					DEFB	30h	; 0 
0f3c 31					DEFB	31h	; 1 
0f3d 32					DEFB	32h	; 2 
0f3e 33					DEFB	33h	; 3 
0f3f 34					DEFB	34h	; 4 
0f40 35					DEFB	35h	; 5 
0f41 36					DEFB	36h	; 6 
0f42 37					DEFB	37h	; 7 
0f43 38					DEFB	38h	; 8 
0f44 39					DEFB	39h	; 9 
0f45 41					DEFB	41h	; A 
0f46 42					DEFB	42h	; B 
0f47 43					DEFB	43h	; C 
0f48 44					DEFB	44h	; D 
0f49 45					DEFB	45h	; E 
0f4a 46					DEFB	46h	; F 
0f4b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f4b			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0f4b			;;    subtract $30, if result > 9 then subtract $7 more 
0f4b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0f4b			atohex: 
0f4b d6 30				SUB $30 
0f4d fe 0a				CP 10 
0f4f f8					RET M		; If result negative it was 0-9 so we're done 
0f50 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0f52 c9					RET		 
0f53			 
0f53			 
0f53			 
0f53			 
0f53			; Get 2 ASCII characters as hex byte from pointer in hl 
0f53			 
0f53			BYTERD: 
0f53 16 00			LD	D,00h		;Set up 
0f55 cd 5d 0f			CALL	HEXCON		;Get byte and convert to hex 
0f58 87				ADD	A,A		;First nibble so 
0f59 87				ADD	A,A		;multiply by 16 
0f5a 87				ADD	A,A		; 
0f5b 87				ADD	A,A		; 
0f5c 57				LD	D,A		;Save hi nibble in D 
0f5d			HEXCON: 
0f5d 7e				ld a, (hl)		;Get next chr 
0f5e 23				inc hl 
0f5f d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0f61 fe 0a			CP	00Ah		;Is it 0-9 ? 
0f63 38 02			JR	C,NALPHA	;If so miss next bit 
0f65 d6 07			SUB	007h		;Else convert alpha 
0f67			NALPHA: 
0f67 b2				OR	D		;Add hi nibble back 
0f68 c9				RET			; 
0f69			 
0f69			 
0f69			; 
0f69			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0f69			; Since the routines get_byte and therefore get_nibble are called, only valid 
0f69			; characters (0-9a-f) are accepted. 
0f69			; 
0f69			;get_word        push    af 
0f69			;                call    get_byte        ; Get the upper byte 
0f69			;                ld      h, a 
0f69			;                call    get_byte        ; Get the lower byte 
0f69			;                ld      l, a 
0f69			;                pop     af 
0f69			;                ret 
0f69			; 
0f69			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0f69			; the routine get_nibble is used only valid characters are accepted - the  
0f69			; input routine only accepts characters 0-9a-f. 
0f69			; 
0f69 c5			get_byte:        push    bc              ; Save contents of B (and C) 
0f6a 7e					ld a,(hl) 
0f6b 23					inc hl 
0f6c cd 91 0f		                call    nibble2val      ; Get upper nibble 
0f6f cb 07		                rlc     a 
0f71 cb 07		                rlc     a 
0f73 cb 07		                rlc     a 
0f75 cb 07		                rlc     a 
0f77 47			                ld      b, a            ; Save upper four bits 
0f78 7e					ld a,(hl) 
0f79 cd 91 0f		                call    nibble2val      ; Get lower nibble 
0f7c b0			                or      b               ; Combine both nibbles 
0f7d c1			                pop     bc              ; Restore B (and C) 
0f7e c9			                ret 
0f7f			; 
0f7f			; Get a hexadecimal digit from the serial line. This routine blocks until 
0f7f			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0f7f			; to the serial line interface. The lower 4 bits of A contain the value of  
0f7f			; that particular digit. 
0f7f			; 
0f7f			;get_nibble      ld a,(hl)           ; Read a character 
0f7f			;                call    to_upper        ; Convert to upper case 
0f7f			;                call    is_hex          ; Was it a hex digit? 
0f7f			;                jr      nc, get_nibble  ; No, get another character 
0f7f			 ;               call    nibble2val      ; Convert nibble to value 
0f7f			 ;               call    print_nibble 
0f7f			 ;               ret 
0f7f			; 
0f7f			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0f7f			; A valid hexadecimal digit is denoted by a set C flag. 
0f7f			; 
0f7f			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0f7f			;                ret     nc              ; Yes 
0f7f			;                cp      '0'             ; Less than '0'? 
0f7f			;                jr      nc, is_hex_1    ; No, continue 
0f7f			;                ccf                     ; Complement carry (i.e. clear it) 
0f7f			;                ret 
0f7f			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0f7f			;                ret     c               ; Yes 
0f7f			;                cp      'A'             ; Less than 'A'? 
0f7f			;                jr      nc, is_hex_2    ; No, continue 
0f7f			;                ccf                     ; Yes - clear carry and return 
0f7f			;                ret 
0f7f			;is_hex_2        scf                     ; Set carry 
0f7f			;                ret 
0f7f			; 
0f7f			; Convert a single character contained in A to upper case: 
0f7f			; 
0f7f fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0f81 d8			                ret     c 
0f82 fe 7b		                cp      'z' + 1         ; > 'z'? 
0f84 d0			                ret     nc              ; Nothing to do, either 
0f85 e6 5f		                and     $5f             ; Convert to upper case 
0f87 c9			                ret 
0f88			 
0f88			 
0f88			to_lower: 
0f88			 
0f88			   ; if char is in [A-Z] make it lower case 
0f88			 
0f88			   ; enter : a = char 
0f88			   ; exit  : a = lower case char 
0f88			   ; uses  : af 
0f88			 
0f88 fe 41		   cp 'A' 
0f8a d8			   ret c 
0f8b			    
0f8b fe 5b		   cp 'Z'+1 
0f8d d0			   ret nc 
0f8e			    
0f8e f6 20		   or $20 
0f90 c9			   ret 
0f91			 
0f91			; 
0f91			; Expects a hexadecimal digit (upper case!) in A and returns the 
0f91			; corresponding value in A. 
0f91			; 
0f91 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
0f93 38 02		                jr      c, nibble2val_1 ; Yes 
0f95 d6 07		                sub     7               ; Adjust for A-F 
0f97 d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
0f99 e6 0f		                and     $f              ; Only return lower 4 bits 
0f9b c9			                ret 
0f9c			; 
0f9c			; Print_nibble prints a single hex nibble which is contained in the lower  
0f9c			; four bits of A: 
0f9c			; 
0f9c			;print_nibble    push    af              ; We won't destroy the contents of A 
0f9c			;                and     $f              ; Just in case... 
0f9c			;                add     a, '0'             ; If we have a digit we are done here. 
0f9c			;                cp      '9' + 1         ; Is the result > 9? 
0f9c			;                jr      c, print_nibble_1 
0f9c			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
0f9c			;print_nibble_1  call    putc            ; Print the nibble and 
0f9c			;                pop     af              ; restore the original value of A 
0f9c			;                ret 
0f9c			;; 
0f9c			;; Send a CR/LF pair: 
0f9c			; 
0f9c			;crlf            push    af 
0f9c			;                ld      a, cr 
0f9c			;                call    putc 
0f9c			;                ld      a, lf 
0f9c			;                call    putc 
0f9c			;                pop     af 
0f9c			;                ret 
0f9c			; 
0f9c			; Print_word prints the four hex digits of a word to the serial line. The  
0f9c			; word is expected to be in HL. 
0f9c			; 
0f9c			;print_word      push    hl 
0f9c			;                push    af 
0f9c			;                ld      a, h 
0f9c			;                call    print_byte 
0f9c			;                ld      a, l 
0f9c			;                call    print_byte 
0f9c			;                pop     af 
0f9c			;                pop     hl 
0f9c			;                ret 
0f9c			; 
0f9c			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
0f9c			; The byte to be printed is expected to be in A. 
0f9c			; 
0f9c			;print_byte      push    af              ; Save the contents of the registers 
0f9c			;                push    bc 
0f9c			;                ld      b, a 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                rrca 
0f9c			;                call    print_nibble    ; Print high nibble 
0f9c			;                ld      a, b 
0f9c			;                call    print_nibble    ; Print low nibble 
0f9c			;                pop     bc              ; Restore original register contents 
0f9c			;                pop     af 
0f9c			;                ret 
0f9c			 
0f9c			 
0f9c			 
0f9c			 
0f9c			 
0f9c			fourehexhl:  
0f9c 7e				ld a,(hl) 
0f9d cd 4b 0f			call atohex 
0fa0 cb 3f				SRL A 
0fa2 cb 3f				SRL A 
0fa4 cb 3f				SRL A 
0fa6 cb 3f				SRL A 
0fa8 47				ld b, a 
0fa9 23				inc hl 
0faa 7e				ld a,(hl) 
0fab 23				inc hl 
0fac cd 4b 0f			call atohex 
0faf 80				add b 
0fb0 57				ld d,a 
0fb1 7e				ld a,(hl) 
0fb2 cd 4b 0f			call atohex 
0fb5 cb 3f				SRL A 
0fb7 cb 3f				SRL A 
0fb9 cb 3f				SRL A 
0fbb cb 3f				SRL A 
0fbd 47				ld b, a 
0fbe 23				inc hl 
0fbf 7e				ld a,(hl) 
0fc0 23				inc hl 
0fc1 cd 4b 0f			call atohex 
0fc4 80				add b 
0fc5 5f				ld e, a 
0fc6 d5				push de 
0fc7 e1				pop hl 
0fc8 c9				ret 
0fc9			 
0fc9			; pass hl. returns z set if the byte at hl is a digit 
0fc9			;isdigithl:  
0fc9			;	push bc 
0fc9			;	ld a,(hl) 
0fc9			;	cp ':' 
0fc9			;	jr nc, .isdf 		; > 
0fc9			;	cp '0' 
0fc9			;	jr c, .isdf		; < 
0fc9			; 
0fc9			;	; TODO find a better way to set z 
0fc9			; 
0fc9			;	ld b,a 
0fc9			;	cp b 
0fc9			;	pop bc 
0fc9			;	ret 
0fc9			; 
0fc9			;.isdf:	; not digit so clear z 
0fc9			; 
0fc9			;	; TODO find a better way to unset z 
0fc9			; 
0fc9			;	ld b,a 
0fc9			;	inc b 
0fc9			;	cp b 
0fc9			; 
0fc9			;	pop bc 
0fc9			;	ret 
0fc9				 
0fc9				 
0fc9			 
0fc9			 
0fc9			; pass hl as the four byte address to load 
0fc9			 
0fc9			get_word_hl:  
0fc9 e5				push hl 
0fca cd 69 0f			call get_byte 
0fcd				 
0fcd 47				ld b, a 
0fce			 
0fce e1				pop hl 
0fcf 23				inc hl 
0fd0 23				inc hl 
0fd1			 
0fd1			; TODO not able to handle a-f  
0fd1 7e				ld a,(hl) 
0fd2			;	;cp ':' 
0fd2			;	cp 'g' 
0fd2			;	jr nc, .single_byte_hl 		; > 
0fd2			;	cp 'G' 
0fd2			;	jr nc, .single_byte_hl 		; > 
0fd2			;	cp '0' 
0fd2			;	jr c, .single_byte_hl		; < 
0fd2			 
0fd2				;call isdigithl 
0fd2 fe 00			cp 0 
0fd4 28 06			jr z, .single_byte_hl 
0fd6			 
0fd6			.getwhln:   ; hex word so get next byte 
0fd6			 
0fd6 cd 69 0f			call get_byte 
0fd9 6f				ld l, a 
0fda 60				ld h,b 
0fdb c9				ret 
0fdc 68			.single_byte_hl:   ld l,b 
0fdd 26 00				ld h,0 
0fdf c9					ret 
0fe0			 
0fe0			 
0fe0			 
0fe0			 
0fe0 21 b1 16			ld hl,asc+1 
0fe3			;	ld a, (hl) 
0fe3			;	call nibble2val 
0fe3 cd 69 0f			call get_byte 
0fe6			 
0fe6			;	call fourehexhl 
0fe6 32 66 ee			ld (scratch+52),a 
0fe9				 
0fe9 21 64 ee			ld hl,scratch+50 
0fec 22 55 f1			ld (os_cur_ptr),hl 
0fef			 
0fef c9				ret 
0ff0			 
0ff0			 
0ff0			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
0ff0			 
0ff0			; Decimal Unsigned Version 
0ff0			 
0ff0			;Number in a to decimal ASCII 
0ff0			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
0ff0			;Example: display a=56 as "056" 
0ff0			;input: a = number 
0ff0			;Output: a=0,value of a in the screen 
0ff0			;destroys af,bc (don't know about hl and de) 
0ff0			DispAToASCII: 
0ff0 0e 9c			ld	c,-100 
0ff2 cd fc 0f			call	.Na1 
0ff5 0e f6			ld	c,-10 
0ff7 cd fc 0f			call	.Na1 
0ffa 0e ff			ld	c,-1 
0ffc 06 2f		.Na1:	ld	b,'0'-1 
0ffe 04			.Na2:	inc	b 
0fff 81				add	a,c 
1000 38 fc			jr	c,.Na2 
1002 91				sub	c		;works as add 100/10/1 
1003 f5				push af		;safer than ld c,a 
1004 78				ld	a,b		;char is in b 
1005			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1005 f1				pop af		;safer than ld a,c 
1006 c9				ret 
1007			 
1007			; Decimal Signed Version 
1007			 
1007			; DispA 
1007			; -------------------------------------------------------------- 
1007			; Converts a signed integer value to a zero-terminated ASCII 
1007			; string representative of that value (using radix 10). 
1007			; -------------------------------------------------------------- 
1007			; INPUTS: 
1007			;     HL     Value to convert (two's complement integer). 
1007			;     DE     Base address of string destination. (pointer). 
1007			; -------------------------------------------------------------- 
1007			; OUTPUTS: 
1007			;     None 
1007			; -------------------------------------------------------------- 
1007			; REGISTERS/MEMORY DESTROYED 
1007			; AF HL 
1007			; -------------------------------------------------------------- 
1007			 
1007			;DispHLToASCII: 
1007			;   push    de 
1007			;   push    bc 
1007			; 
1007			;; Detect sign of HL. 
1007			;    bit    7, h 
1007			;    jr     z, ._DoConvert 
1007			; 
1007			;; HL is negative. Output '-' to string and negate HL. 
1007			;    ld     a, '-' 
1007			;    ld     (de), a 
1007			;    inc    de 
1007			; 
1007			;; Negate HL (using two's complement) 
1007			;    xor    a 
1007			;    sub    l 
1007			;    ld     l, a 
1007			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
1007			;    sbc    a, h 
1007			;    ld     h, a 
1007			; 
1007			;; Convert HL to digit characters 
1007			;._DoConvert: 
1007			;    ld     b, 0     ; B will count character length of number 
1007			;-   ld     a, 10 
1007			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
1007			;    push   af 
1007			;    inc    b 
1007			;    ld     a, h 
1007			;    or     l 
1007			;    jr     nz, - 
1007			; 
1007			;; Retrieve digits from stack 
1007			;-   pop    af 
1007			;    or     $30 
1007			;    ld     (de), a 
1007			;    inc    de 
1007			;    djnz   - 
1007			; 
1007			;; Terminate string with NULL 
1007			;    xor    a 
1007			;    ld     (de), a 
1007			; 
1007			;    pop    bc 
1007			;    pop    de 
1007			;    ret 
1007			 
1007			;Comments 
1007			; 
1007			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
1007			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
1007			;    Note that the output string will not be fixed-width. 
1007			; 
1007			;Example Usage 
1007			; 
1007			;    ld    hl, -1004 
1007			;    ld    de, OP1 
1007			;    call  DispA 
1007			;    ld    hl, OP1 
1007			;    syscall  PutS 
1007			 
1007			 
1007			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1007			 
1007			 
1007			;Converts an ASCII string to an unsigned 16-bit integer 
1007			;Quits when it reaches a non-decimal digit 
1007			 
1007			string_to_uint16: 
1007			atoui_16: 
1007			;Input: 
1007			;     DE points to the string 
1007			;Outputs: 
1007			;     HL is the result 
1007			;     A is the 8-bit value of the number 
1007			;     DE points to the byte after the number 
1007			;Destroys: 
1007			;     BC 
1007			;       if the string is non-empty, BC is HL/10 
1007			;Size:  24 bytes 
1007			;Speed: 42+d(104+{0,9}) 
1007			;       d is the number of digits in the number 
1007			;       max is 640 cycles for a 5 digit number 
1007			;Assuming no leading zeros: 
1007			;1 digit:  146cc 
1007			;2 digit:  250cc 
1007			;3 digit:  354cc or 363cc (avg: 354.126cc) 
1007			;4 digit:  458cc or 467cc (avg: 458.27cc) 
1007			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
1007			;avg: 544.81158447265625cc (544+13297/16384) 
1007			;=============================================================== 
1007 21 00 00		  ld hl,0 
100a			.u16a: 
100a 1a			  ld a,(de) 
100b d6 30		  sub 30h 
100d fe 0a		  cp 10 
100f d0			  ret nc 
1010 13			  inc de 
1011 44			  ld b,h 
1012 4d			  ld c,l 
1013 29			  add hl,hl 
1014 29			  add hl,hl 
1015 09			  add hl,bc 
1016 29			  add hl,hl 
1017 85			  add a,l 
1018 6f			  ld l,a 
1019 30 ef		  jr nc,.u16a 
101b 24			  inc h 
101c c3 0a 10		  jp .u16a 
101f			 
101f			 
101f			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
101f			 
101f			;written by Zeda 
101f			;Converts a 16-bit unsigned integer to an ASCII string. 
101f			 
101f			uitoa_16: 
101f			;Input: 
101f			;   DE is the number to convert 
101f			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
101f			;Output: 
101f			;   HL points to the null-terminated ASCII string 
101f			;      NOTE: This isn't necessarily the same as the input HL. 
101f d5			  push de 
1020 c5			  push bc 
1021 f5			  push af 
1022 eb			  ex de,hl 
1023			 
1023 01 f0 d8		  ld bc,-10000 
1026 3e 2f		  ld a,'0'-1 
1028 3c			  inc a 
1029 09			  add hl,bc  
102a 38 fc		   jr c,$-2 
102c 12			  ld (de),a 
102d 13			  inc de 
102e			 
102e 01 e8 03		  ld bc,1000 
1031 3e 3a		  ld a,'9'+1 
1033 3d			  dec a  
1034 09			  add hl,bc  
1035 30 fc		   jr nc,$-2 
1037 12			  ld (de),a 
1038 13			  inc de 
1039			 
1039 01 9c ff		  ld bc,-100 
103c 3e 2f		  ld a,'0'-1 
103e 3c			  inc a  
103f 09			  add hl,bc  
1040 38 fc		   jr c,$-2 
1042 12			  ld (de),a 
1043 13			  inc de 
1044			 
1044 7d			  ld a,l 
1045 26 3a		  ld h,'9'+1 
1047 25			  dec h  
1048 c6 0a		  add a,10  
104a 30 fb		   jr nc,$-3 
104c c6 30		  add a,'0' 
104e eb			  ex de,hl 
104f 72			  ld (hl),d 
1050 23			  inc hl 
1051 77			  ld (hl),a 
1052 23			  inc hl 
1053 36 00		  ld (hl),0 
1055			 
1055			;Now strip the leading zeros 
1055 0e fa		  ld c,-6 
1057 09			  add hl,bc 
1058 3e 30		  ld a,'0' 
105a 23			  inc hl  
105b be			  cp (hl)  
105c 28 fc		  jr z,$-2 
105e			 
105e			;Make sure that the string is non-empty! 
105e 7e			  ld a,(hl) 
105f b7			  or a 
1060 20 01		  jr nz,.atoub 
1062 2b			  dec hl 
1063			.atoub: 
1063			 
1063 f1			  pop af 
1064 c1			  pop bc 
1065 d1			  pop de 
1066 c9			  ret 
1067			 
1067			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
1067			 
1067			toUpper: 
1067			;A is the char. 
1067			;If A is a lowercase letter, this sets it to the matching uppercase 
1067			;18cc or 30cc or 41cc 
1067			;avg: 26.75cc 
1067 fe 61		  cp 'a' 
1069 d8			  ret c 
106a fe 7b		  cp 'z'+1 
106c d0			  ret nc 
106d d6 20		  sub 'a'-'A' 
106f c9			  ret 
1070			 
1070			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
1070			 
1070			; String Length 
1070			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
1070			 
1070			; Get the length of the null-terminated string starting at $8000 hl 
1070			;    LD     HL, $8000 
1070			 
1070			strlenz: 
1070			 
1070 af			    XOR    A               ; Zero is the value we are looking for. 
1071 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
1072 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
1073			                           ; 65, 536 bytes (the entire addressable memory space). 
1073 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1075			 
1075			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1075 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
1076 6f			    LD     L, A             ; number of bytes 
1077 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1079 2b			    DEC    HL              ; Compensate for null. 
107a c9				ret 
107b			 
107b			; Get the length of the A terminated string starting at $8000 hl 
107b			;    LD     HL, $8000 
107b			 
107b			strlent: 
107b			 
107b			                  ; A is the value we are looking for. 
107b 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
107d 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
107f			                           ; 65, 536 bytes (the entire addressable memory space). 
107f ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
1081			 
1081			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
1081 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
1083 2e 00		    LD     L, 0             ; number of bytes 
1085 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
1087 2b			    DEC    HL              ; Compensate for null. 
1088 c9				ret 
1089			 
1089			 
1089			;Comparing Strings 
1089			 
1089			;IN    HL     Address of string1. 
1089			;      DE     Address of string2. 
1089			 
1089			; doc given but wrong??? 
1089			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
1089			;      carry  Set if string1 > string2, reset if string1 <= string2. 
1089			; tested 
1089			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
1089			 
1089			strcmp_old: 
1089 e5			    PUSH   HL 
108a d5			    PUSH   DE 
108b			 
108b 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
108c be			    CP     (HL)            ; (want to minimize work). 
108d 38 01		    JR     C, Str1IsBigger 
108f 7e			    LD     A, (HL) 
1090			 
1090			Str1IsBigger: 
1090 4f			    LD     C, A             ; Put length in BC 
1091 06 00		    LD     B, 0 
1093 13			    INC    DE              ; Increment pointers to meat of string. 
1094 23			    INC    HL 
1095			 
1095			CmpLoop: 
1095 1a			    LD     A, (DE)          ; Compare bytes. 
1096 ed a1		    CPI 
1098 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
109a 13			    INC    DE              ; Update pointer. 
109b ea 95 10		    JP     PE, CmpLoop 
109e			 
109e d1			    POP    DE 
109f e1			    POP    HL 
10a0 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
10a1 be			    CP     (HL) 
10a2 c9			    RET 
10a3			 
10a3			NoMatch: 
10a3 2b			    DEC    HL 
10a4 be			    CP     (HL)            ; Compare again to affect carry. 
10a5 d1			    POP    DE 
10a6 e1			    POP    HL 
10a7 c9			    RET 
10a8			 
10a8			;; test strmp 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str2 
10a8			;call strcmp 
10a8			;jr z, .z1 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "NZ1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.z1: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "ZZ1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str1 
10a8			;call strcmp 
10a8			;jr z, .z2 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "NZ2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.z2: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "ZZ2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str2 
10a8			;call strcmp 
10a8			;jr c, .c1 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "Nc1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.c1: 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "cc1" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			; 
10a8			;ld de, .str1 
10a8			;ld hl, .str1 
10a8			;call strcmp 
10a8			;jr c, .c2 
10a8			;;this 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "Nc2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;.c2: 
10a8			; 
10a8			;	if DEBUG_FORTH_WORDS 
10a8			;		DMARK "cc2" 
10a8			;		CALLMONITOR 
10a8			;	endif 
10a8			;	NEXTW 
10a8			;.str1:   db "string1",0 
10a8			;.str2:   db "string2",0 
10a8			 
10a8			; only care about direct match or not 
10a8			; hl and de strings 
10a8			; zero set if the same 
10a8			 
10a8			strcmp: 
10a8 1a				ld a, (de) 
10a9 be				cp (hl) 
10aa 28 02			jr z, .ssame 
10ac b7				or a 
10ad c9				ret 
10ae			 
10ae			.ssame:  
10ae fe 00			cp 0 
10b0 c8				ret z 
10b1			 
10b1 23				inc hl 
10b2 13				inc de 
10b3 18 f3			jr strcmp 
10b5				 
10b5				 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			; eof 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			 
10b5			 
# End of file firmware_strings.asm
10b5			include "firmware_memory.asm"   ; malloc and free  
10b5			 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			.mallocsize: db "Wants malloc >256",0 
10b5			.mallocasize: db "MALLOC gives >256",0 
10b5			.malloczero: db "MALLOC gives zero",0 
10b5			 
10b5			malloc_guard_zerolen: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5				ld de, 0 
10b5			        call cmp16 
10b5				jr nz, .lowalloz 
10b5			 
10b5				push hl 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .malloczero 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5			 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				 
10b5			 
10b5				CALLMONITOR 
10b5			.lowalloz: 
10b5			 
10b5			 
10b5				pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			 
10b5			malloc_guard_entry: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5			 	or a      ;clear carry flag 
10b5				push hl 
10b5				ld de, 255 
10b5				sbc hl, de 
10b5				jr c, .lowalloc 
10b5			 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .mallocsize 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5			 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				 
10b5			 
10b5				CALLMONITOR 
10b5				jr .lowdone 
10b5			.lowalloc: 
10b5			 
10b5			 
10b5				pop hl 
10b5			.lowdone:	pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			 
10b5			malloc_guard_exit: 
10b5				push hl 
10b5				push de 
10b5				push af 
10b5			 
10b5			 	or a      ;clear carry flag 
10b5				push hl 
10b5				ld de, 255 
10b5				sbc hl, de 
10b5				jr c, .lowallocx 
10b5			 
10b5				push de 
10b5					ld hl, display_fb0 
10b5					ld (display_fb_active), hl 
10b5				call clear_display 
10b5				ld a, 0 
10b5				ld de, .mallocasize 
10b5				call str_at_display 
10b5				call update_display 
10b5				call delay1s 
10b5				call delay1s 
10b5				ld a, 0 
10b5				ld (os_view_disable), a 
10b5				pop de 
10b5				pop hl 
10b5			 
10b5				CALLMONITOR 
10b5				jr .lowdonex 
10b5			.lowallocx: 
10b5			 
10b5				pop hl 
10b5			.lowdonex:	pop af 
10b5				pop de 
10b5				pop hl 
10b5			ret 
10b5			endif 
10b5			 
10b5			if MALLOC_2 
10b5			; Z80 Malloc and Free Functions 
10b5			 
10b5			; Malloc Function: 
10b5			; Input: 
10b5			;   HL: Size of block to allocate 
10b5			; Output: 
10b5			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b5			 
10b5			malloc: 
10b5				 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			call malloc_guard_entry 
10b5			endif 
10b5			 
10b5			 
10b5			 
10b5			 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "mal" 
10b5						CALLMONITOR 
10b5					endif 
10b5			    push af            ; Save AF register 
10b5			    ld a, l            ; Load low byte of size into A 
10b5			    or h               ; Check if size is zero 
10b5			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
10b5			 
10b5			    ; Allocate memory 
10b5			    ld hl, (heap_start) ; Load start of heap into HL 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma1" 
10b5						CALLMONITOR 
10b5					endif 
10b5			    call malloc_internal ; Call internal malloc function 
10b5			    pop af             ; Restore AF register 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret                ; Return 
10b5			 
10b5			; Free Function: 
10b5			; Input: 
10b5			;   HL: Pointer to memory block to free 
10b5			; Output: 
10b5			;   None 
10b5			 
10b5			free: 
10b5			    push af            ; Save AF register 
10b5			    ld a, l            ; Load low byte of pointer into A 
10b5			    or h               ; Check if pointer is NULL 
10b5			    jp z, free_exit    ; If pointer is NULL, exit 
10b5			 
10b5			    ; Free memory 
10b5			    ld hl, (heap_start) ; Load start of heap into HL 
10b5			    call free_internal  ; Call internal free function 
10b5			    pop af             ; Restore AF register 
10b5			    ret                ; Return 
10b5			 
10b5			; Internal Malloc Function: 
10b5			; Input: 
10b5			;   HL: Size of block to allocate 
10b5			; Output: 
10b5			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
10b5			 
10b5			malloc_internal: 
10b5			    ld bc, 2           ; Number of bytes to allocate for management overhead 
10b5			    add hl, bc         ; Add management overhead to requested size 
10b5			    ex de, hl          ; Save total size in DE, and keep it in HL 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma2" 
10b5						CALLMONITOR 
10b5					endif 
10b5			 
10b5			    ; Search for free memory block 
10b5			    ld de, (heap_end)  ; Load end of heap into DE 
10b5			    ld bc, 0           ; Initialize counter 
10b5			 
10b5					if DEBUG_FORTH_MALLOC 
10b5						DMARK "ma2" 
10b5						CALLMONITOR 
10b5					endif 
10b5			malloc_search_loop: 
10b5			    ; Check if current block is free 
10b5			    ld a, (hl)         ; Load current block's status (free or used) 
10b5			    cp 0               ; Compare with zero (free) 
10b5			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
10b5			 
10b5			    ; Check if current block is large enough 
10b5			    ld a, (hl+1)       ; Load high byte of block size 
10b5			    cp l               ; Compare with low byte of requested size 
10b5			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
10b5			 
10b5			    ld a, (hl+2)       ; Load low byte of block size 
10b5			    cp h               ; Compare with high byte of requested size 
10b5			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
10b5			 
10b5			    ; Mark block as used 
10b5			    ld (hl), 0xFF      ; Set status byte to indicate used block 
10b5			 
10b5			    ; Calculate remaining space in block 
10b5			    ld bc, 0           ; Clear BC 
10b5			    add hl, bc         ; Increment HL to point to start of data block 
10b5			    add hl, de         ; HL = HL + DE (total size) 
10b5			    ld bc, 1           ; Number of bytes to allocate for management overhead 
10b5			    add hl, bc         ; Add management overhead to start of data block 
10b5			 
10b5			    ; Save pointer to allocated block in HL 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma5" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			 
10b5			malloc_skip_block_check: 
10b5			    ; Move to the next block 
10b5			    ld bc, 3           ; Size of management overhead 
10b5			    add hl, bc         ; Move to the next block 
10b5			    inc de             ; Increment counter 
10b5			 
10b5			    ; Check if we have reached the end of heap 
10b5			    ld a, e            ; Load low byte of heap end address 
10b5			    cp (hl)            ; Compare with low byte of current address 
10b5			    jr nz, malloc_search_loop  ; If not equal, continue searching 
10b5			    ld a, d            ; Load high byte of heap end address 
10b5			    cp 0               ; Check if it's zero (end of memory) 
10b5			    jr nz, malloc_search_loop  ; If not zero, continue searching 
10b5			 
10b5			    ; If we reached here, allocation failed 
10b5			    xor a              ; Set result to NULL 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma6" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			malloc_exit: 
10b5			if DEBUG_FORTH_MALLOC_HIGH 
10b5						DMARK "ma7" 
10b5			call malloc_guard_exit 
10b5			call malloc_guard_zerolen 
10b5			endif 
10b5			    ret 
10b5			 
10b5			; Internal Free Function: 
10b5			; Input: 
10b5			;   HL: Pointer to memory block to free 
10b5			; Output: 
10b5			;   None 
10b5			 
10b5			free_internal: 
10b5			    ld de, (heap_start) ; Load start of heap into DE 
10b5			    ld bc, 0            ; Initialize counter 
10b5			 
10b5			free_search_loop: 
10b5			    ; Check if current block contains the pointer 
10b5			    ld a, l             ; Load low byte of pointer 
10b5			    cp (hl+1)           ; Compare with high byte of current block's address 
10b5			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b5			    ld a, h             ; Load high byte of pointer 
10b5			    cp (hl+2)           ; Compare with low byte of current block's address 
10b5			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
10b5			 
10b5			    ; Mark block as free 
10b5			    ld (hl), 0          ; Set status byte to indicate free block 
10b5			    ret                 ; Return 
10b5			 
10b5			free_skip_block_check: 
10b5			    ; Move to the next block 
10b5			    ld bc, 3            ; Size of management overhead 
10b5			    add hl, bc          ; Move to the next block 
10b5			    inc de              ; Increment counter 
10b5			 
10b5			    ; Check if we have reached the end of heap 
10b5			    ld a, e             ; Load low byte of heap end address 
10b5			    cp (hl)             ; Compare with low byte of current address 
10b5			    jr nz, free_search_loop  ; If not equal, continue searching 
10b5			    ld a, d             ; Load high byte of heap end address 
10b5			    cp 0                ; Check if it's zero (end of memory) 
10b5			    jr nz, free_search_loop  ; If not zero, continue searching 
10b5			 
10b5			    ; If we reached here, pointer is not found in heap 
10b5			    ret 
10b5			 
10b5			free_exit: 
10b5			    ret                 ; Return 
10b5			 
10b5			; Define heap start and end addresses 
10b5			;heap_start:    .dw 0xC000   ; Start of heap 
10b5			;heap_end:      .dw 0xE000   ; End of heap 
10b5			 
10b5			endif 
10b5			 
10b5			 
10b5			if MALLOC_1 
10b5			 
10b5			 
10b5			 
10b5			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
10b5			 
10b5			;moved to firmware.asm 
10b5			;heap_start        .equ  0x9000      ; Starting address of heap 
10b5			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
10b5			 
10b5			;      .org 0 
10b5			;      jp    main 
10b5			 
10b5			 
10b5			;      .org  0x100 
10b5			;main: 
10b5			;      ld    HL, 0x8100 
10b5			;      ld    SP, HL 
10b5			; 
10b5			;      call  heap_init 
10b5			; 
10b5			;      ; Make some allocations 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9004 
10b5			; 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9014 
10b5			; 
10b5			;      ld    HL, 12 
10b5			;      call  malloc            ; Allocates 0x9024 
10b5			; 
10b5			;      ; Free some allocations 
10b5			;      ld    HL, 0x9014 
10b5			;      call  free 
10b5			; 
10b5			;      ld    HL, 0x9004 
10b5			;      call  free 
10b5			; 
10b5			;      ld    HL, 0x9024 
10b5			;      call  free 
10b5			; 
10b5			; 
10b5			;      halt 
10b5			 
10b5			 
10b5			;------------------------------------------------------------------------------ 
10b5			;     heap_init                                                               : 
10b5			;                                                                             : 
10b5			; Description                                                                 : 
10b5			;     Initialise the heap and make it ready for malloc and free operations.   : 
10b5			;                                                                             : 
10b5			;     The heap is maintained as a linked list, starting with an initial       : 
10b5			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
10b5			;     the first free block in the heap. Each block then points to the next    : 
10b5			;     free block within the heap, and the free list ends at the first block   : 
10b5			;     with a null pointer to the next free block.                             : 
10b5			;                                                                             : 
10b5			; Parameters                                                                  : 
10b5			;     Inputs are compile-time only. Two defines which specify the starting    : 
10b5			;     address of the heap and its size are required, along with a memory      : 
10b5			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
10b5			;     principally stores a pointer to the first free block in the heap.       : 
10b5			;                                                                             : 
10b5			; Returns                                                                     : 
10b5			;     Nothing                                                                 : 
10b5			;------------------------------------------------------------------------------ 
10b5			heap_init: 
10b5 e5			      push  HL 
10b6			 
10b6			      ; Initialise free list struct 
10b6 21 0e 80		      ld    HL, heap_start 
10b9 22 0a 80		      ld    (free_list), HL 
10bc 21 00 00		      ld    HL, 0 
10bf 22 0c 80		      ld    (free_list+2), HL 
10c2			 
10c2			      ; Insert first free block at bottom of heap, consumes entire heap 
10c2 21 22 ee		      ld    HL, heap_start+heap_size-4 
10c5 22 0e 80		      ld    (heap_start), HL        ; Next block (end of free list) 
10c8 21 14 6e		      ld    HL, heap_size-4 
10cb 22 10 80		      ld    (heap_start+2), HL      ; Block size 
10ce			 
10ce			      ; Insert end of free list block at top of heap - two null words will 
10ce			      ; terminate the free list 
10ce 21 00 00		      ld    HL, 0 
10d1 22 24 ee		      ld    (heap_start+heap_size-2), HL 
10d4 22 22 ee		      ld    (heap_start+heap_size-4), HL 
10d7			 
10d7 e1			      pop   HL 
10d8			 
10d8 c9			      ret 
10d9			 
10d9			 
10d9			;------------------------------------------------------------------------------ 
10d9			;     malloc                                                                  : 
10d9			;                                                                             : 
10d9			; Description                                                                 : 
10d9			;     Allocates the wanted space from the heap and returns the address of the : 
10d9			;     first useable byte of the allocation.                                   : 
10d9			;                                                                             : 
10d9			;     Allocations can happen in one of two ways:                              : 
10d9			;                                                                             : 
10d9			;     1. A free block may be found which is the exact size wanted. In this    : 
10d9			;        case the block is removed from the free list and retuedn to the      : 
10d9			;        caller.                                                              : 
10d9			;     2. A free block may be found which is larger than the size wanted. In   : 
10d9			;        this case, the larger block is split into two. The first portion of  : 
10d9			;        this block will become the requested space by the malloc call and    : 
10d9			;        is returned to the caller. The second portion becomes a new free     : 
10d9			;        block, and the free list is adjusted to maintain continuity via this : 
10d9			;        newly created block.                                                 : 
10d9			;                                                                             : 
10d9			;     malloc does not set any initial value in the allocated space, the       : 
10d9			;     caller is required to do this as required.                              : 
10d9			;                                                                             : 
10d9			;     This implementation of malloc uses the stack exclusively, and is        : 
10d9			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
10d9			;     advisable to disable interrupts before calling malloc, and recommended  : 
10d9			;     to avoid the use of malloc inside ISRs in general.                      : 
10d9			;                                                                             : 
10d9			;     NOTE: heap_init must be called before malloc and free can be used.      : 
10d9			;                                                                             : 
10d9			; Parameters                                                                  : 
10d9			;     HL  Number of bytes wanted                                              : 
10d9			;                                                                             : 
10d9			; Returns                                                                     : 
10d9			;     HL  Address of the first useable byte of the allocation                 : 
10d9			;                                                                             : 
10d9			; Flags                                                                       : 
10d9			;     Z   Set if the allocation did not succeed, clear otherwise              : 
10d9			;                                                                             : 
10d9			; Stack frame                                                                 : 
10d9			;       |             |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     BC      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     DE      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |     IX      |                                                       : 
10d9			;       +-------------+                                                       : 
10d9			;       |  prev_free  |                                                       : 
10d9			;   +4  +-------------+                                                       : 
10d9			;       |  this_free  |                                                       : 
10d9			;   +2  +-------------+                                                       : 
10d9			;       |  next_free  |                                                       : 
10d9			;   +0  +-------------+                                                       : 
10d9			;       |             |                                                       : 
10d9			;                                                                             : 
10d9			;------------------------------------------------------------------------------ 
10d9			 
10d9			 
10d9			;malloc: 
10d9			; 
10d9			;	SAVESP ON 1 
10d9			; 
10d9			;	call malloc_code 
10d9			; 
10d9			;	CHECKSP ON 1 
10d9			;	ret 
10d9			 
10d9			 
10d9			malloc: 
10d9 c5			      push  BC 
10da d5			      push  DE 
10db dd e5		      push  IX 
10dd			if DEBUG_FORTH_MALLOC_HIGH 
10dd			call malloc_guard_entry 
10dd			endif 
10dd			 
10dd					if DEBUG_FORTH_MALLOC 
10dd						DMARK "mal" 
10dd						CALLMONITOR 
10dd					endif 
10dd 7c			      ld    A, H                    ; Exit if no space requested 
10de b5			      or    L 
10df ca 9e 11		      jp    Z, malloc_early_exit 
10e2			 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			; 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			;inc hl 
10e2			 
10e2			 
10e2			 
10e2			 
10e2					if DEBUG_FORTH_MALLOC 
10e2						DMARK "maA" 
10e2						CALLMONITOR 
10e2					endif 
10e2			      ; Set up stack frame 
10e2 eb			      ex    DE, HL 
10e3 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
10e6 39			      add   HL, SP 
10e7 f9			      ld    SP, HL 
10e8 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
10ec dd 39		      add   IX, SP 
10ee			 
10ee			      ; Setup initial state 
10ee 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
10f1 19			      add   HL, DE 
10f2			 
10f2 44			      ld    B, H                    ; Move want to BC 
10f3 4d			      ld    C, L 
10f4			 
10f4 21 0a 80		      ld    HL, free_list           ; Store prev_free ptr to stack 
10f7 dd 75 04		      ld    (IX+4), L 
10fa dd 74 05		      ld    (IX+5), H 
10fd			 
10fd 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
10fe 23			      inc   HL 
10ff 56			      ld    D, (HL) 
1100 dd 73 02		      ld    (IX+2), E 
1103 dd 72 03		      ld    (IX+3), D 
1106 eb			      ex    DE, HL                  ; this_free ptr into HL 
1107			 
1107					if DEBUG_FORTH_MALLOC 
1107						DMARK "maB" 
1107						CALLMONITOR 
1107					endif 
1107			      ; Loop through free block list to find some space 
1107			malloc_find_space: 
1107 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
1108 23			      inc   HL 
1109 56			      ld    D, (HL) 
110a			 
110a 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
110b b3			      or    E 
110c ca 98 11		      jp    Z, malloc_no_space 
110f			 
110f dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1112 dd 72 01		      ld    (IX+1), D 
1115			 
1115			      ; Does this block have enough space to make the allocation? 
1115 23			      inc   HL                      ; Load free block size into DE 
1116 5e			      ld    E, (HL) 
1117 23			      inc   HL 
1118 56			      ld    D, (HL) 
1119			 
1119 eb			      ex    DE, HL                  ; Check size of block against want 
111a b7			      or    A                       ; Ensure carry flag clear 
111b ed 42		      sbc   HL, BC 
111d e5			      push  HL                      ; Store the result for later (new block size) 
111e			 
111e ca 6d 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1121 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1123			 
1123			      ; this_free block is not big enough, setup ptrs to test next free block 
1123 e1			      pop   HL                      ; Discard previous result 
1124			 
1124 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1127 dd 66 03		      ld    H, (IX+3) 
112a dd 75 04		      ld    (IX+4), L 
112d dd 74 05		      ld    (IX+5), H 
1130			 
1130 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1133 dd 66 01		      ld    H, (IX+1) 
1136 dd 75 02		      ld    (IX+2), L 
1139 dd 74 03		      ld    (IX+3), H 
113c			 
113c					if DEBUG_FORTH_MALLOC 
113c						DMARK "MA>" 
113c						CALLMONITOR 
113c					endif 
113c 18 c9		      jr    malloc_find_space 
113e			 
113e			      ; split a bigger block into two - requested size and remaining size 
113e			malloc_alloc_split: 
113e					if DEBUG_FORTH_MALLOC 
113e						DMARK "MAs" 
113e						CALLMONITOR 
113e					endif 
113e eb			      ex    DE, HL                  ; Calculate address of new free block 
113f 2b			      dec   HL 
1140 2b			      dec   HL 
1141 2b			      dec   HL 
1142 09			      add   HL, BC 
1143			 
1143			      ; Create a new block and point it at next_free 
1143 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
1146 dd 56 01		      ld    D, (IX+1) 
1149			 
1149 73			      ld    (HL), E                 ; Store next_free ptr into new block 
114a 23			      inc   HL 
114b 72			      ld    (HL), D 
114c			 
114c d1			      pop   DE                      ; Store size of new block into new block 
114d 23			      inc   HL 
114e 73			      ld    (HL), E 
114f 23			      inc   HL 
1150 72			      ld    (HL), D 
1151			 
1151			      ; Update this_free ptr to point to new block 
1151 2b			      dec   HL 
1152 2b			      dec   HL 
1153 2b			      dec   HL 
1154			 
1154 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1157 dd 56 03		      ld    D, (IX+3) 
115a			 
115a dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
115d dd 74 03		      ld    (IX+3), H 
1160			 
1160			      ; Modify this_free block to be allocation 
1160 eb			      ex    DE, HL 
1161 af			      xor   A                       ; Null the next block ptr of allocated block 
1162 77			      ld    (HL), A 
1163 23			      inc   HL 
1164 77			      ld    (HL), A 
1165			 
1165 23			      inc   HL                      ; Store want size into allocated block 
1166 71			      ld    (HL), C 
1167 23			      inc   HL 
1168 70			      ld    (HL), B 
1169 23			      inc   HL 
116a e5			      push  HL                      ; Address of allocation to return 
116b			 
116b 18 19		      jr    malloc_update_links 
116d			 
116d			malloc_alloc_fit: 
116d e1			      pop   HL                      ; Dont need new block size, want is exact fit 
116e			 
116e					if DEBUG_FORTH_MALLOC 
116e						DMARK "MAf" 
116e						CALLMONITOR 
116e					endif 
116e			      ; Modify this_free block to be allocation 
116e eb			      ex    DE, HL 
116f 2b			      dec   HL 
1170 2b			      dec   HL 
1171 2b			      dec   HL 
1172			 
1172 af			      xor   A                       ; Null the next block ptr of allocated block 
1173 77			      ld    (HL), A 
1174 23			      inc   HL 
1175 77			      ld    (HL), A 
1176			 
1176 23			      inc   HL                      ; Store address of allocation to return 
1177 23			      inc   HL 
1178 23			      inc   HL 
1179 e5			      push  HL 
117a			 
117a			      ; Copy next_free ptr to this_free, remove allocated block from free list 
117a dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
117d dd 66 01		      ld    H, (IX+1) 
1180			 
1180 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
1183 dd 74 03		      ld    (IX+3), H 
1186			 
1186			 
1186			malloc_update_links: 
1186			      ; Update prev_free ptr to point to this_free 
1186 dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
1189 dd 66 05		      ld    H, (IX+5) 
118c			 
118c dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
118f dd 56 03		      ld    D, (IX+3) 
1192			 
1192 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1193 23			      inc   HL 
1194 72			      ld    (HL), D 
1195			 
1195					if DEBUG_FORTH_MALLOC 
1195						DMARK "Mul" 
1195						CALLMONITOR 
1195					endif 
1195			      ; Clear the Z flag to indicate successful allocation 
1195 7a			      ld    A, D 
1196 b3			      or    E 
1197			 
1197 d1			      pop   DE                      ; Address of allocation 
1198					if DEBUG_FORTH_MALLOC 
1198						DMARK "MAu" 
1198						CALLMONITOR 
1198					endif 
1198			 
1198			malloc_no_space: 
1198 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
119b 39			      add   HL, SP 
119c f9			      ld    SP, HL 
119d			 
119d eb			      ex    DE, HL                  ; Alloc addr into HL for return 
119e					if DEBUG_FORTH_MALLOC 
119e						DMARK "MAN" 
119e						CALLMONITOR 
119e					endif 
119e			 
119e			malloc_early_exit: 
119e					if DEBUG_FORTH_MALLOC 
119e						DMARK "MAx" 
119e						CALLMONITOR 
119e					endif 
119e dd e1		      pop   IX 
11a0 d1			      pop   DE 
11a1 c1			      pop   BC 
11a2			 
11a2			if DEBUG_FORTH_MALLOC_HIGH 
11a2			call malloc_guard_exit 
11a2			call malloc_guard_zerolen 
11a2			endif 
11a2 c9			      ret 
11a3			 
11a3			 
11a3			;------------------------------------------------------------------------------ 
11a3			;     free                                                                    : 
11a3			;                                                                             : 
11a3			; Description                                                                 : 
11a3			;     Return the space pointed to by HL to the heap. HL must be an address as : 
11a3			;     returned by malloc, otherwise the behaviour is undefined.               : 
11a3			;                                                                             : 
11a3			;     Where possible, directly adjacent free blocks will be merged together   : 
11a3			;     into larger blocks to help ensure that the heap does not become         : 
11a3			;     excessively fragmented.                                                 : 
11a3			;                                                                             : 
11a3			;     free does not clear or set any other value into the freed space, and    : 
11a3			;     therefore its contents may be visible through subsequent malloc's. The  : 
11a3			;     caller should clear the freed space as required.                        : 
11a3			;                                                                             : 
11a3			;     This implementation of free uses the stack exclusively, and is          : 
11a3			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
11a3			;     advisable to disable interrupts before calling free, and recommended    : 
11a3			;     to avoid the use of free inside ISRs in general.                        : 
11a3			;                                                                             : 
11a3			;     NOTE: heap_init must be called before malloc and free can be used.      : 
11a3			;                                                                             : 
11a3			; Parameters                                                                  : 
11a3			;     HL  Pointer to address of first byte of allocation to be freed          : 
11a3			;                                                                             : 
11a3			; Returns                                                                     : 
11a3			;     Nothing                                                                 : 
11a3			;                                                                             : 
11a3			; Stack frame                                                                 : 
11a3			;       |             |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     BC      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     DE      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |     IX      |                                                       : 
11a3			;       +-------------+                                                       : 
11a3			;       |  prev_free  |                                                       : 
11a3			;   +2  +-------------+                                                       : 
11a3			;       |  next_free  |                                                       : 
11a3			;   +0  +-------------+                                                       : 
11a3			;       |             |                                                       : 
11a3			;                                                                             : 
11a3			;------------------------------------------------------------------------------ 
11a3			free: 
11a3 c5			      push  BC 
11a4 d5			      push  DE 
11a5 dd e5		      push  IX 
11a7			 
11a7 7c			      ld    A, H                    ; Exit if ptr is null 
11a8 b5			      or    L 
11a9 ca 6d 12		      jp    Z, free_early_exit 
11ac			 
11ac			      ; Set up stack frame 
11ac eb			      ex    DE, HL 
11ad 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
11b0 39			      add   HL, SP 
11b1 f9			      ld    SP, HL 
11b2 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
11b6 dd 39		      add   IX, SP 
11b8			 
11b8			      ; The address in HL points to the start of the useable allocated space, 
11b8			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
11b8			      ; address of the block itself. 
11b8 eb			      ex    DE, HL 
11b9 11 fc ff		      ld    DE, -4 
11bc 19			      add   HL, DE 
11bd			 
11bd			      ; An allocated block must have a null next block pointer in it 
11bd 7e			      ld    A, (HL) 
11be 23			      inc   HL 
11bf b6			      or    (HL) 
11c0 c2 68 12		      jp    NZ, free_done 
11c3			 
11c3 2b			      dec   HL 
11c4			 
11c4 44			      ld    B, H                    ; Copy HL to BC 
11c5 4d			      ld    C, L 
11c6			 
11c6			      ; Loop through the free list to find the first block with an address 
11c6			      ; higher than the block being freed 
11c6 21 0a 80		      ld    HL, free_list 
11c9			 
11c9			free_find_higher_block: 
11c9 5e			      ld    E, (HL)                 ; Load next ptr from free block 
11ca 23			      inc   HL 
11cb 56			      ld    D, (HL) 
11cc 2b			      dec   HL 
11cd			 
11cd dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
11d0 dd 72 01		      ld    (IX+1), D 
11d3 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
11d6 dd 74 03		      ld    (IX+3), H 
11d9			 
11d9 78			      ld    A, B                    ; Check if DE is greater than BC 
11da ba			      cp    D                       ; Compare MSB first 
11db 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
11dd 30 04		      jr    NC, free_find_higher_block_skip 
11df 79			      ld    A, C 
11e0 bb			      cp    E                       ; Then compare LSB 
11e1 38 08		      jr    C, free_found_higher_block 
11e3			 
11e3			free_find_higher_block_skip: 
11e3 7a			      ld    A, D                    ; Reached the end of the free list? 
11e4 b3			      or    E 
11e5 ca 68 12		      jp    Z, free_done 
11e8			 
11e8 eb			      ex    DE, HL 
11e9			 
11e9 18 de		      jr    free_find_higher_block 
11eb			 
11eb			free_found_higher_block: 
11eb			      ; Insert freed block between prev and next free blocks 
11eb 71			      ld    (HL), C                 ; Point prev free block to freed block 
11ec 23			      inc   HL 
11ed 70			      ld    (HL), B 
11ee			 
11ee 60			      ld    H, B                    ; Point freed block at next free block 
11ef 69			      ld    L, C 
11f0 73			      ld    (HL), E 
11f1 23			      inc   HL 
11f2 72			      ld    (HL), D 
11f3			 
11f3			      ; Check if the freed block is adjacent to the next free block 
11f3 23			      inc   HL                      ; Load size of freed block into HL 
11f4 5e			      ld    E, (HL) 
11f5 23			      inc   HL 
11f6 56			      ld    D, (HL) 
11f7 eb			      ex    DE, HL 
11f8			 
11f8 09			      add   HL, BC                  ; Add addr of freed block and its size 
11f9			 
11f9 dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
11fc dd 56 01		      ld    D, (IX+1) 
11ff			 
11ff b7			      or    A                       ; Clear the carry flag 
1200 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1202 20 22		      jr    NZ, free_check_adjacent_to_prev 
1204			 
1204			      ; Freed block is adjacent to next, merge into one bigger block 
1204 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1205 5e			      ld    E, (HL) 
1206 23			      inc   HL 
1207 56			      ld    D, (HL) 
1208 e5			      push  HL                      ; Save ptr to next block for later 
1209			 
1209 60			      ld    H, B                    ; Store ptr from next block into freed block 
120a 69			      ld    L, C 
120b 73			      ld    (HL), E 
120c 23			      inc   HL 
120d 72			      ld    (HL), D 
120e			 
120e e1			      pop   HL                      ; Restore ptr to next block 
120f 23			      inc   HL                      ; Load size of next block into DE 
1210 5e			      ld    E, (HL) 
1211 23			      inc   HL 
1212 56			      ld    D, (HL) 
1213 d5			      push  DE                      ; Save next block size for later 
1214			 
1214 60			      ld    H, B                    ; Load size of freed block into HL 
1215 69			      ld    L, C 
1216 23			      inc   HL 
1217 23			      inc   HL 
1218 5e			      ld    E, (HL) 
1219 23			      inc   HL 
121a 56			      ld    D, (HL) 
121b eb			      ex    DE, HL 
121c			 
121c d1			      pop   DE                      ; Restore size of next block 
121d 19			      add   HL, DE                  ; Add sizes of both blocks 
121e eb			      ex    DE, HL 
121f			 
121f 60			      ld    H, B                    ; Store new bigger size into freed block 
1220 69			      ld    L, C 
1221 23			      inc   HL 
1222 23			      inc   HL 
1223 73			      ld    (HL), E 
1224 23			      inc   HL 
1225 72			      ld    (HL), D 
1226			 
1226			free_check_adjacent_to_prev: 
1226			      ; Check if the freed block is adjacent to the prev free block 
1226 dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
1229 dd 66 03		      ld    H, (IX+3) 
122c			 
122c 23			      inc   HL                      ; Size of prev free block into DE 
122d 23			      inc   HL 
122e 5e			      ld    E, (HL) 
122f 23			      inc   HL 
1230 56			      ld    D, (HL) 
1231 2b			      dec   HL 
1232 2b			      dec   HL 
1233 2b			      dec   HL 
1234			 
1234 19			      add   HL, DE                  ; Add prev block addr and size 
1235			 
1235 b7			      or    A                       ; Clear the carry flag 
1236 ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1238 20 2e		      jr    NZ, free_done 
123a			 
123a			      ; Freed block is adjacent to prev, merge into one bigger block 
123a 60			      ld    H, B                    ; Load next ptr from freed block into DE 
123b 69			      ld    L, C 
123c 5e			      ld    E, (HL) 
123d 23			      inc   HL 
123e 56			      ld    D, (HL) 
123f e5			      push  HL                      ; Save freed block ptr for later 
1240			 
1240 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1243 dd 66 03		      ld    H, (IX+3) 
1246 73			      ld    (HL), E 
1247 23			      inc   HL 
1248 72			      ld    (HL), D 
1249			 
1249 e1			      pop   HL                      ; Restore freed block ptr 
124a 23			      inc   HL                      ; Load size of freed block into DE 
124b 5e			      ld    E, (HL) 
124c 23			      inc   HL 
124d 56			      ld    D, (HL) 
124e d5			      push  DE                      ; Save freed block size for later 
124f			 
124f dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
1252 dd 66 03		      ld    H, (IX+3) 
1255 23			      inc   HL 
1256 23			      inc   HL 
1257 5e			      ld    E, (HL) 
1258 23			      inc   HL 
1259 56			      ld    D, (HL) 
125a			 
125a e1			      pop   HL                      ; Add sizes of both blocks 
125b 19			      add   HL, DE 
125c eb			      ex    DE, HL 
125d			 
125d dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
1260 dd 66 03		      ld    H, (IX+3) 
1263 23			      inc   HL 
1264 23			      inc   HL 
1265 73			      ld    (HL), E 
1266 23			      inc   HL 
1267 72			      ld    (HL), D 
1268			 
1268			free_done: 
1268 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
126b 39			      add   HL, SP 
126c f9			      ld    SP, HL 
126d			 
126d			free_early_exit: 
126d dd e1		      pop   IX 
126f d1			      pop   DE 
1270 c1			      pop   BC 
1271			 
1271 c9			      ret 
1272			 
1272			; moved to firmware.asm 
1272			; 
1272			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1272			;                  .dw   0 
1272			 
1272			 
1272			endif 
1272			 
1272			 
1272			if MALLOC_3 
1272			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
1272			;heap_start        .equ  0x9000      ; Starting address of heap 
1272			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1272			; 
1272			 ;     .org 0 
1272			  ;    jp    main 
1272			; 
1272			; 
1272			 ;     .org  0x100 
1272			;main: 
1272			 ;     ld    HL, 0x8100 
1272			  ;    ld    SP, HL 
1272			; 
1272			;      call  heap_init 
1272			 
1272			      ; Make some allocations 
1272			;      ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9004 
1272			; 
1272			 ;     ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9014 
1272			 
1272			;      ld    HL, 12 
1272			;      call  malloc            ; Allocates 0x9024 
1272			 
1272			      ; Free some allocations 
1272			;      ld    HL, 0x9014 
1272			;      call  free 
1272			 
1272			;      ld    HL, 0x9004 
1272			;      call  free 
1272			; 
1272			;      ld    HL, 0x9024 
1272			;      call  free 
1272			 
1272			 
1272			 ;     halt 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     heap_init                                                               : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Initialise the heap and make it ready for malloc and free operations.   : 
1272			;                                                                             : 
1272			;     The heap is maintained as a linked list, starting with an initial       : 
1272			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1272			;     the first free block in the heap. Each block then points to the next    : 
1272			;     free block within the heap, and the free list ends at the first block   : 
1272			;     with a null pointer to the next free block.                             : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     Inputs are compile-time only. Two defines which specify the starting    : 
1272			;     address of the heap and its size are required, along with a memory      : 
1272			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1272			;     principally stores a pointer to the first free block in the heap.       : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     Nothing                                                                 : 
1272			;------------------------------------------------------------------------------ 
1272			heap_init: 
1272			      push  HL 
1272			 
1272			      ; Initialise free list struct 
1272			      ld    HL, heap_start 
1272			      ld    (free_list), HL 
1272			      ld    HL, 0 
1272			      ld    (free_list+2), HL 
1272			 
1272			      ; Insert first free block at bottom of heap, consumes entire heap 
1272			      ld    HL, heap_start+heap_size-4 
1272			      ld    (heap_start), HL        ; Next block (end of free list) 
1272			      ld    HL, heap_size-4 
1272			      ld    (heap_start+2), HL      ; Block size 
1272			 
1272			      ; Insert end of free list block at top of heap - two null words will 
1272			      ; terminate the free list 
1272			      ld    HL, 0 
1272			      ld    (heap_start+heap_size-2), HL 
1272			      ld    (heap_start+heap_size-4), HL 
1272			 
1272			      pop   HL 
1272			 
1272			      ret 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     malloc                                                                  : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Allocates the wanted space from the heap and returns the address of the : 
1272			;     first useable byte of the allocation.                                   : 
1272			;                                                                             : 
1272			;     Allocations can happen in one of two ways:                              : 
1272			;                                                                             : 
1272			;     1. A free block may be found which is the exact size wanted. In this    : 
1272			;        case the block is removed from the free list and retuedn to the      : 
1272			;        caller.                                                              : 
1272			;     2. A free block may be found which is larger than the size wanted. In   : 
1272			;        this case, the larger block is split into two. The first portion of  : 
1272			;        this block will become the requested space by the malloc call and    : 
1272			;        is returned to the caller. The second portion becomes a new free     : 
1272			;        block, and the free list is adjusted to maintain continuity via this : 
1272			;        newly created block.                                                 : 
1272			;                                                                             : 
1272			;     malloc does not set any initial value in the allocated space, the       : 
1272			;     caller is required to do this as required.                              : 
1272			;                                                                             : 
1272			;     This implementation of malloc uses the stack exclusively, and is        : 
1272			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1272			;     advisable to disable interrupts before calling malloc, and recommended  : 
1272			;     to avoid the use of malloc inside ISRs in general.                      : 
1272			;                                                                             : 
1272			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     HL  Number of bytes wanted                                              : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     HL  Address of the first useable byte of the allocation                 : 
1272			;                                                                             : 
1272			; Flags                                                                       : 
1272			;     Z   Set if the allocation did not succeed, clear otherwise              : 
1272			;                                                                             : 
1272			; Stack frame                                                                 : 
1272			;       |             |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     BC      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     DE      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     IX      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |  prev_free  |                                                       : 
1272			;   +4  +-------------+                                                       : 
1272			;       |  this_free  |                                                       : 
1272			;   +2  +-------------+                                                       : 
1272			;       |  next_free  |                                                       : 
1272			;   +0  +-------------+                                                       : 
1272			;       |             |                                                       : 
1272			;                                                                             : 
1272			;------------------------------------------------------------------------------ 
1272			malloc: 
1272			      push  BC 
1272			      push  DE 
1272			      push  IX 
1272			 
1272			      ld    A, H                    ; Exit if no space requested 
1272			      or    L 
1272			      jp    Z, malloc_early_exit 
1272			 
1272			      ; Set up stack frame 
1272			      ex    DE, HL 
1272			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			      ld    IX, 0                   ; Use IX as a frame pointer 
1272			      add   IX, SP 
1272			 
1272			      ; Setup initial state 
1272			      ld    HL, 4                   ; want must also include space used by block struct 
1272			      add   HL, DE 
1272			 
1272			      ld    B, H                    ; Move want to BC 
1272			      ld    C, L 
1272			 
1272			      ld    HL, free_list           ; Store prev_free ptr to stack 
1272			      ld    (IX+4), L 
1272			      ld    (IX+5), H 
1272			 
1272			      ld    E, (HL)                 ; Store this_free ptr to stack 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ld    (IX+2), E 
1272			      ld    (IX+3), D 
1272			      ex    DE, HL                  ; this_free ptr into HL 
1272			 
1272			      ; Loop through free block list to find some space 
1272			malloc_find_space: 
1272			      ld    E, (HL)                 ; Load next_free ptr into DE 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      ld    A, D                    ; Check for null next_free ptr - end of free list 
1272			      or    E 
1272			      jp    Z, malloc_no_space 
1272			 
1272			      ld    (IX+0), E               ; Store next_free ptr to stack 
1272			      ld    (IX+1), D 
1272			 
1272			      ; Does this block have enough space to make the allocation? 
1272			      inc   HL                      ; Load free block size into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      ex    DE, HL                  ; Check size of block against want 
1272			      or    A                       ; Ensure carry flag clear 
1272			      sbc   HL, BC 
1272			      push  HL                      ; Store the result for later (new block size) 
1272			 
1272			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1272			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1272			 
1272			      ; this_free block is not big enough, setup ptrs to test next free block 
1272			      pop   HL                      ; Discard previous result 
1272			 
1272			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
1272			      ld    H, (IX+3) 
1272			      ld    (IX+4), L 
1272			      ld    (IX+5), H 
1272			 
1272			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
1272			      ld    H, (IX+1) 
1272			      ld    (IX+2), L 
1272			      ld    (IX+3), H 
1272			 
1272			      jr    malloc_find_space 
1272			 
1272			      ; split a bigger block into two - requested size and remaining size 
1272			malloc_alloc_split: 
1272			      ex    DE, HL                  ; Calculate address of new free block 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			      add   HL, BC 
1272			 
1272			      ; Create a new block and point it at next_free 
1272			      ld    E, (IX+0)               ; Load next_free ptr into DE 
1272			      ld    D, (IX+1) 
1272			 
1272			      ld    (HL), E                 ; Store next_free ptr into new block 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   DE                      ; Store size of new block into new block 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Update this_free ptr to point to new block 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
1272			      ld    D, (IX+3) 
1272			 
1272			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
1272			      ld    (IX+3), H 
1272			 
1272			      ; Modify this_free block to be allocation 
1272			      ex    DE, HL 
1272			      xor   A                       ; Null the next block ptr of allocated block 
1272			      ld    (HL), A 
1272			      inc   HL 
1272			      ld    (HL), A 
1272			 
1272			      inc   HL                      ; Store want size into allocated block 
1272			      ld    (HL), C 
1272			      inc   HL 
1272			      ld    (HL), B 
1272			      inc   HL 
1272			      push  HL                      ; Address of allocation to return 
1272			 
1272			      jr    malloc_update_links 
1272			 
1272			malloc_alloc_fit: 
1272			      pop   HL                      ; Dont need new block size, want is exact fit 
1272			 
1272			      ; Modify this_free block to be allocation 
1272			      ex    DE, HL 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      xor   A                       ; Null the next block ptr of allocated block 
1272			      ld    (HL), A 
1272			      inc   HL 
1272			      ld    (HL), A 
1272			 
1272			      inc   HL                      ; Store address of allocation to return 
1272			      inc   HL 
1272			      inc   HL 
1272			      push  HL 
1272			 
1272			      ; Copy next_free ptr to this_free, remove allocated block from free list 
1272			      ld    L, (IX+0)               ; next_free to HL 
1272			      ld    H, (IX+1) 
1272			 
1272			      ld    (IX+2), L               ; HL to this_free 
1272			      ld    (IX+3), H 
1272			 
1272			 
1272			malloc_update_links: 
1272			      ; Update prev_free ptr to point to this_free 
1272			      ld    L, (IX+4)               ; prev_free ptr to HL 
1272			      ld    H, (IX+5) 
1272			 
1272			      ld    E, (IX+2)               ; this_free ptr to DE 
1272			      ld    D, (IX+3) 
1272			 
1272			      ld    (HL), E                 ; this_free ptr into prev_free 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Clear the Z flag to indicate successful allocation 
1272			      ld    A, D 
1272			      or    E 
1272			 
1272			      pop   DE                      ; Address of allocation 
1272			 
1272			malloc_no_space: 
1272			      ld    HL, 6                   ; Clean up stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			 
1272			      ex    DE, HL                  ; Alloc addr into HL for return 
1272			 
1272			malloc_early_exit: 
1272			      pop   IX 
1272			      pop   DE 
1272			      pop   BC 
1272			 
1272			      ret 
1272			 
1272			 
1272			;------------------------------------------------------------------------------ 
1272			;     free                                                                    : 
1272			;                                                                             : 
1272			; Description                                                                 : 
1272			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1272			;     returned by malloc, otherwise the behaviour is undefined.               : 
1272			;                                                                             : 
1272			;     Where possible, directly adjacent free blocks will be merged together   : 
1272			;     into larger blocks to help ensure that the heap does not become         : 
1272			;     excessively fragmented.                                                 : 
1272			;                                                                             : 
1272			;     free does not clear or set any other value into the freed space, and    : 
1272			;     therefore its contents may be visible through subsequent malloc's. The  : 
1272			;     caller should clear the freed space as required.                        : 
1272			;                                                                             : 
1272			;     This implementation of free uses the stack exclusively, and is          : 
1272			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1272			;     advisable to disable interrupts before calling free, and recommended    : 
1272			;     to avoid the use of free inside ISRs in general.                        : 
1272			;                                                                             : 
1272			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1272			;                                                                             : 
1272			; Parameters                                                                  : 
1272			;     HL  Pointer to address of first byte of allocation to be freed          : 
1272			;                                                                             : 
1272			; Returns                                                                     : 
1272			;     Nothing                                                                 : 
1272			;                                                                             : 
1272			; Stack frame                                                                 : 
1272			;       |             |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     BC      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     DE      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |     IX      |                                                       : 
1272			;       +-------------+                                                       : 
1272			;       |  prev_free  |                                                       : 
1272			;   +2  +-------------+                                                       : 
1272			;       |  next_free  |                                                       : 
1272			;   +0  +-------------+                                                       : 
1272			;       |             |                                                       : 
1272			;                                                                             : 
1272			;------------------------------------------------------------------------------ 
1272			free: 
1272			      push  BC 
1272			      push  DE 
1272			      push  IX 
1272			 
1272			      ld    A, H                    ; Exit if ptr is null 
1272			      or    L 
1272			      jp    Z, free_early_exit 
1272			 
1272			      ; Set up stack frame 
1272			      ex    DE, HL 
1272			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			      ld    IX, 0                   ; Use IX as a frame pointer 
1272			      add   IX, SP 
1272			 
1272			      ; The address in HL points to the start of the useable allocated space, 
1272			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
1272			      ; address of the block itself. 
1272			      ex    DE, HL 
1272			      ld    DE, -4 
1272			      add   HL, DE 
1272			 
1272			      ; An allocated block must have a null next block pointer in it 
1272			      ld    A, (HL) 
1272			      inc   HL 
1272			      or    (HL) 
1272			      jp    NZ, free_done 
1272			 
1272			      dec   HL 
1272			 
1272			      ld    B, H                    ; Copy HL to BC 
1272			      ld    C, L 
1272			 
1272			      ; Loop through the free list to find the first block with an address 
1272			      ; higher than the block being freed 
1272			      ld    HL, free_list 
1272			 
1272			free_find_higher_block: 
1272			      ld    E, (HL)                 ; Load next ptr from free block 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      dec   HL 
1272			 
1272			      ld    (IX+0), E               ; Save ptr to next free block 
1272			      ld    (IX+1), D 
1272			      ld    (IX+2), L               ; Save ptr to prev free block 
1272			      ld    (IX+3), H 
1272			 
1272			      ld    A, B                    ; Check if DE is greater than BC 
1272			      cp    D                       ; Compare MSB first 
1272			      jr    Z, $+4                  ; MSB the same, compare LSB 
1272			      jr    NC, free_find_higher_block_skip 
1272			      ld    A, C 
1272			      cp    E                       ; Then compare LSB 
1272			      jr    C, free_found_higher_block 
1272			 
1272			free_find_higher_block_skip: 
1272			      ld    A, D                    ; Reached the end of the free list? 
1272			      or    E 
1272			      jp    Z, free_done 
1272			 
1272			      ex    DE, HL 
1272			 
1272			      jr    free_find_higher_block 
1272			 
1272			free_found_higher_block: 
1272			      ; Insert freed block between prev and next free blocks 
1272			      ld    (HL), C                 ; Point prev free block to freed block 
1272			      inc   HL 
1272			      ld    (HL), B 
1272			 
1272			      ld    H, B                    ; Point freed block at next free block 
1272			      ld    L, C 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      ; Check if the freed block is adjacent to the next free block 
1272			      inc   HL                      ; Load size of freed block into HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ex    DE, HL 
1272			 
1272			      add   HL, BC                  ; Add addr of freed block and its size 
1272			 
1272			      ld    E, (IX+0)               ; Load addr of next free block into DE 
1272			      ld    D, (IX+1) 
1272			 
1272			      or    A                       ; Clear the carry flag 
1272			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1272			      jr    NZ, free_check_adjacent_to_prev 
1272			 
1272			      ; Freed block is adjacent to next, merge into one bigger block 
1272			      ex    DE, HL                  ; Load next ptr from next block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  HL                      ; Save ptr to next block for later 
1272			 
1272			      ld    H, B                    ; Store ptr from next block into freed block 
1272			      ld    L, C 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   HL                      ; Restore ptr to next block 
1272			      inc   HL                      ; Load size of next block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  DE                      ; Save next block size for later 
1272			 
1272			      ld    H, B                    ; Load size of freed block into HL 
1272			      ld    L, C 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      ex    DE, HL 
1272			 
1272			      pop   DE                      ; Restore size of next block 
1272			      add   HL, DE                  ; Add sizes of both blocks 
1272			      ex    DE, HL 
1272			 
1272			      ld    H, B                    ; Store new bigger size into freed block 
1272			      ld    L, C 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			free_check_adjacent_to_prev: 
1272			      ; Check if the freed block is adjacent to the prev free block 
1272			      ld    L, (IX+2)               ; Prev free block ptr into HL 
1272			      ld    H, (IX+3) 
1272			 
1272			      inc   HL                      ; Size of prev free block into DE 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      dec   HL 
1272			      dec   HL 
1272			      dec   HL 
1272			 
1272			      add   HL, DE                  ; Add prev block addr and size 
1272			 
1272			      or    A                       ; Clear the carry flag 
1272			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
1272			      jr    NZ, free_done 
1272			 
1272			      ; Freed block is adjacent to prev, merge into one bigger block 
1272			      ld    H, B                    ; Load next ptr from freed block into DE 
1272			      ld    L, C 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  HL                      ; Save freed block ptr for later 
1272			 
1272			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
1272			      ld    H, (IX+3) 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			      pop   HL                      ; Restore freed block ptr 
1272			      inc   HL                      ; Load size of freed block into DE 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			      push  DE                      ; Save freed block size for later 
1272			 
1272			      ld    L, (IX+2)               ; Load size of prev block into DE 
1272			      ld    H, (IX+3) 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    E, (HL) 
1272			      inc   HL 
1272			      ld    D, (HL) 
1272			 
1272			      pop   HL                      ; Add sizes of both blocks 
1272			      add   HL, DE 
1272			      ex    DE, HL 
1272			 
1272			      ld    L, (IX+2)               ; Store new bigger size into prev block 
1272			      ld    H, (IX+3) 
1272			      inc   HL 
1272			      inc   HL 
1272			      ld    (HL), E 
1272			      inc   HL 
1272			      ld    (HL), D 
1272			 
1272			free_done: 
1272			      ld    HL, 4                   ; Clean up stack frame 
1272			      add   HL, SP 
1272			      ld    SP, HL 
1272			 
1272			free_early_exit: 
1272			      pop   IX 
1272			      pop   DE 
1272			      pop   BC 
1272			 
1272			      ret 
1272			 
1272			 
1272			;      .org 0x8000 
1272			; 
1272			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
1272			 ;                 .dw   0 
1272			 
1272			endif 
1272			 
1272			 
1272			if MALLOC_4 
1272			 
1272			; My memory allocation code. Very very simple.... 
1272			; allocate space under 250 chars 
1272			 
1272			heap_init: 
1272				; init start of heap as zero 
1272				;  
1272			 
1272				ld hl, heap_start 
1272				ld a, 0 
1272				ld (hl), a      ; empty block 
1272				inc hl 
1272				ld a, 0 
1272				ld (hl), a      ; length of block 
1272				; write end of list 
1272				inc hl 
1272				ld a,(hl) 
1272				inc hl 
1272				ld a,(hl) 
1272				 
1272			 
1272				; init some malloc vars 
1272			 
1272				ld hl, 0 
1272				ld (free_list), hl       ; store last malloc location 
1272			 
1272				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
1272				ld a, 0 
1272				ld (hl), a 
1272			 
1272			 
1272				ld hl, heap_start 
1272				;  
1272				  
1272				ret 
1272			 
1272			 
1272			;    free block marker 
1272			;    requested size  
1272			;    pointer to next block 
1272			;    .... 
1272			;    next block marker 
1272			 
1272			 
1272			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
1272			; 
1272			 
1272			 
1272			malloc:  
1272				push de 
1272				push bc 
1272				push af 
1272			 
1272				; hl space required 
1272				 
1272				ld c, l    ; hold space   (TODO only a max of 255) 
1272			 
1272			;	inc c     ; TODO BUG need to fix memory leak on push str 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			;	inc c 
1272			 
1272			 
1272			 
1272				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
1272			 
1272				ld a, (free_list+3) 
1272				cp 0 
1272				jr z, .contheap 
1272			 
1272				ld hl, (free_list)     ; get last alloc 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mrs" 
1272						CALLMONITOR 
1272					endif 
1272				jr .startalloc 
1272			 
1272			.contheap: 
1272				ld hl, heap_start 
1272			 
1272			.startalloc: 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mym" 
1272						CALLMONITOR 
1272					endif 
1272			.findblock: 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mmf" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272				ld a,(hl)  
1272				; if byte is zero then clear to use 
1272			 
1272				cp 0 
1272				jr z, .foundemptyblock 
1272			 
1272				; if byte is not clear 
1272				;     then byte is offset to next block 
1272			 
1272				inc hl 
1272				ld a, (hl) ; get size 
1272			.nextblock:	inc hl 
1272					ld e, (hl) 
1272					inc hl 
1272					ld d, (hl) 
1272					ex de, hl 
1272			;	inc hl  ; move past the store space 
1272			;	inc hl  ; move past zero index  
1272			 
1272				; TODO detect no more space 
1272			 
1272				push hl 
1272				ld de, heap_end 
1272				call cmp16 
1272				pop hl 
1272				jr nc, .nospace 
1272			 
1272				jr .findblock 
1272			 
1272			.nospace: ld hl, 0 
1272				jp .exit 
1272			 
1272			 
1272			.foundemptyblock:	 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mme" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			; TODO has block enough space if reusing??? 
1272			 
1272				;  
1272			 
1272			; see if this block has been previously used 
1272				inc hl 
1272				ld a, (hl) 
1272				dec hl 
1272				cp 0 
1272				jr z, .newblock 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "meR" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			; no reusing previously allocated block 
1272			 
1272			; is it smaller than previously used? 
1272				 
1272				inc hl    ; move to size 
1272				ld a, c 
1272				sub (hl)        ; we want c < (hl) 
1272				dec hl    ; move back to marker 
1272			        jr z, .findblock 
1272			 
1272				; update with the new size which should be lower 
1272			 
1272			        ;inc  hl   ; negate next move. move back to size  
1272			 
1272			.newblock: 
1272				; need to be at marker here 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "meN" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			 
1272				ld a, c 
1272			 
1272				ld (free_list+3), a	 ; flag resume from last malloc  
1272				ld (free_list), hl    ; save out last location 
1272			 
1272			 
1272				;inc a     ; space for length byte 
1272				ld (hl), a     ; save block in use marker 
1272			 
1272				inc hl   ; move to space marker 
1272				ld (hl), a    ; save new space 
1272			 
1272				inc hl   ; move to start of allocated area 
1272				 
1272			;	push hl     ; save where we are - 1  
1272			 
1272			;	inc hl  ; move past zero index  
1272				; skip space to set down new marker 
1272			 
1272				; provide some extra space for now 
1272			 
1272				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
1272				inc a 
1272				inc a 
1272			 
1272				push hl   ; save where we are in the node block 
1272			 
1272				call addatohl 
1272			 
1272				; write linked list point 
1272			 
1272				pop de     ; get our node position 
1272				ex de, hl 
1272			 
1272				ld (hl), e 
1272				inc hl 
1272				ld (hl), d 
1272			 
1272				inc hl 
1272			 
1272				; now at start of allocated data so save pointer 
1272			 
1272				push hl 
1272			 
1272				; jump to position of next node and setup empty header in DE 
1272			 
1272				ex de, hl 
1272			 
1272			;	inc hl ; move past end of block 
1272			 
1272				ld a, 0 
1272				ld (hl), a   ; empty marker 
1272				inc hl 
1272				ld (hl), a   ; size 
1272				inc hl  
1272				ld (hl), a   ; ptr 
1272				inc hl 
1272				ld (hl), a   ; ptr 
1272			 
1272			 
1272				pop hl 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "mmr" 
1272						CALLMONITOR 
1272					endif 
1272			 
1272			.exit: 
1272				pop af 
1272				pop bc 
1272				pop de  
1272				ret 
1272			 
1272			 
1272			 
1272			 
1272			free:  
1272				push hl 
1272				push af 
1272				; get address in hl 
1272			 
1272					if DEBUG_FORTH_MALLOC_INT 
1272						DMARK "fre" 
1272						CALLMONITOR 
1272					endif 
1272				; data is at hl - move to block count 
1272				dec hl 
1272				dec hl    ; get past pointer 
1272				dec hl 
1272			 
1272				ld a, (hl)    ; need this for a validation check 
1272			 
1272				dec hl    ; move to block marker 
1272			 
1272				; now check that the block count and block marker are the same  
1272			        ; this checks that we are on a malloc node and not random memory 
1272			        ; OK a faint chance this could be a problem but rare - famous last words! 
1272			 
1272				ld c, a 
1272				ld a, (hl)    
1272			 
1272				cp c 
1272				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
1272			 
1272				; yes good chance we are on a malloc node 
1272			 
1272				ld a, 0      
1272				ld (hl), a   ; mark as free 
1272			 
1272				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
1272			 
1272			.freeignore:  
1272			 
1272				pop af 
1272				pop hl 
1272			 
1272				ret 
1272			 
1272			 
1272			 
1272			endif 
1272			 
1272			; eof 
# End of file firmware_memory.asm
1272			  
1272			; device C  
1272			if SOUND_ENABLE  
1272				include "firmware_sound.asm"  
1272			; Sound abstraction layer 
1272			 
1272			; support different sound chips through common interface 
1272			 
1272			SOUND_DEVICE_AY: equ 0 
1272			 
1272			SOUND_DEVICE: equ Device_A 
1272			 
1272			 
1272			 
1272			if SOUND_DEVICE_AY 
1272				include "firmware_sound_ay38910.asm" 
1272			else 
1272				include "firmware_sound_sn76489an.asm" 
1272			 
1272			; Device support for SN76489AN sound chip 
1272			 
1272			; https://arduinoplusplus.wordpress.com/2019/10/05/making-noise-with-a-sn76489-digital-sound-generator-part-1/ 
1272			; http://danceswithferrets.org/geekblog/?p=93 
1272			; https://www.smspower.org/Development/SN76489 
1272			 
1272			; D0 [ 3] 
1272			; D1 [ 2] 
1272			; D2 [ 1] 
1272			; D3 [15] 
1272			; D4 [13] 
1272			; D5 [12] 
1272			; D6 [11] 
1272			; D7 [10] 
1272			; /WE [ 5] 
1272			; CLK [14] 
1272			; /OE [ 6] 
1272			; AUDIO [ 7] 
1272			; GND 8 
1272			; +5 16 
1272			; 
1272			 
1272			; Write sequence: 
1272			; CE low 
1272			; Data bus 
1272			; WE low then high 
1272			; 32 clock cycles / 8ns write time at 4mhz 
1272			; 
1272			; https://github.com/jblang/SN76489 
1272			; Shows that the clock needs to be enabled when required. Noticed that with the clock connected it interupted the bus 
1272			; Tried: 
1272			; 
1272			; CE/OE -> Both pins of NAND -> To one pin of second NAND and second pin to full clock -> CLK on chip 
1272			; 
1272			; Connected WE to OR too 
1272			;  
1272			; That enabled the clock when required 
1272			; However still random bus corruption. Need further investigation 
1272			 
1272			 
1272			SOUND_LATCH: equ 10000000B 
1272			SOUND_DATA: equ 0B 
1272			SOUND_CH0:  equ 0B    ; Tone 
1272			SOUND_CH1: equ 0100000B        ; Tone 
1272			SOUND_CH2: equ 1000000B   ; Tone 
1272			SOUND_CH3: equ 1100000B    ; Noise 
1272			SOUND_VOL: equ 10000B 
1272			SOUND_TONE: equ 0B 
1272			 
1272			 
1272			sound_init: 
1272 3e 1f			ld a, SOUND_DATA | SOUND_CH0 | SOUND_VOL | 1111B 
1274 cd 89 12			call note_send_byte 
1277 3e 07			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0111B 
1279 cd 89 12			call note_send_byte 
127c cd 31 0a			call delay250ms 
127f 3e 05			ld a, SOUND_DATA | SOUND_CH0 | SOUND_TONE | 0101B 
1281 cd 89 12			call note_send_byte 
1284 cd 31 0a			call delay250ms 
1287 c9				ret 
1288			 
1288			; Play a note 
1288			; h = note 
1288			; l = duration 
1288			; a = channel 
1288			 
1288			 
1288			;  frequ = clock / ( 2 x reg valu x 32 )  
1288			 
1288			note:  
1288				 
1288			 
1288 c9				ret 
1289			 
1289			note_send_byte: 
1289				; byte in a 
1289			 
1289				; we high 
1289 d3 40			out (Device_B), a 
128b			;	ld a, 1 
128b			;	call aDelayInMS 
128b 00				nop  
128c 00				nop  
128d 00				nop  
128e 00				nop  
128f				; we low 
128f d3 40			out (Device_B), a 
1291			;	ld a, 1 
1291			;	call aDelayInMS 
1291 00				nop  
1292 00				nop  
1293 00				nop  
1294 00				nop  
1295				; we high 
1295 d3 40			out (Device_B), a 
1297			;	ld a, 1 
1297			;	call aDelayInMS 
1297 00				nop  
1298 00				nop  
1299 00				nop  
129a 00				nop  
129b			 
129b			 
129b c9				ret 
129c			 
129c			;void SilenceAllChannels() 
129c			;{ 
129c			;  SendByte(0x9f); 
129c			;  SendByte(0xbf); 
129c			;  SendByte(0xdf); 
129c			;  SendByte(0xff); 
129c			;} 
129c			 
129c			 
129c			; eof 
129c			 
# End of file firmware_sound_sn76489an.asm
129c			endif 
129c			 
129c			 
129c			; Abstraction entry points 
129c			 
129c			; init  
129c			 
129c			; sound_init in specific hardware files 
129c			 
129c			; Play a note 
129c			; h = note 
129c			; l = duration 
129c			; a = channel 
129c			 
129c			;note:     
129c			;	ret 
129c			 
129c			 
129c			 
129c			 
129c			; eof 
129c			 
# End of file firmware_sound.asm
129c			endif  
129c			  
129c			include "firmware_diags.asm"  
129c			; Hardware diags menu 
129c			 
129c			 
129c .. 00		hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
12bd .. 00		hd_menu2:   db "        2: Editor",0   
12cf			;hd_menu2:   db "        2: Editor       6: BASIC",0   
12cf .. 00		hd_menu3:   db "        3: Storage",0 
12e2 .. 00		hd_menu4:   db "0=quit  4: Debug",0 
12f3 .. 00		hd_don:     db "ON",0 
12f6 .. 00		hd_doff:     db "OFF",0 
12fa			 
12fa			 
12fa			 
12fa			hardware_diags:       
12fa			 
12fa			.diagmenu: 
12fa cd b9 0a			call clear_display 
12fd 3e 00			ld a, display_row_1 
12ff 11 9c 12			ld de, hd_menu1 
1302 cd cc 0a			call str_at_display 
1305			 
1305 3e 28			ld a, display_row_2 
1307 11 bd 12			ld de, hd_menu2 
130a cd cc 0a			call str_at_display 
130d			 
130d 3e 50			ld a, display_row_3 
130f 11 cf 12			ld de, hd_menu3 
1312 cd cc 0a			call str_at_display 
1315			 
1315 3e 78			ld a,  display_row_4 
1317 11 e2 12			ld de, hd_menu4 
131a cd cc 0a			call str_at_display 
131d			 
131d				; display debug state 
131d			 
131d 11 f3 12			ld de, hd_don 
1320 3a 31 ee			ld a, (os_view_disable) 
1323 fe 00			cp 0 
1325 28 03			jr z, .distog 
1327 11 f6 12			ld de, hd_doff 
132a 3e 89		.distog: ld a, display_row_4+17 
132c cd cc 0a			call str_at_display 
132f			 
132f cd dc 0a			call update_display 
1332			 
1332 cd f5 64			call cin_wait 
1335			 
1335			 
1335			 
1335 fe 34			cp '4' 
1337 20 0f			jr nz, .diagn1 
1339			 
1339				; debug toggle 
1339			 
1339 3a 31 ee			ld a, (os_view_disable) 
133c 06 2a			ld b, '*' 
133e fe 00			cp 0 
1340 28 02			jr z, .debtog 
1342 06 00			ld b, 0 
1344			.debtog:	 
1344 78				ld a,b 
1345 32 31 ee			ld (os_view_disable),a 
1348			 
1348 fe 30		.diagn1: cp '0' 
134a c8				 ret z 
134b			 
134b			;	cp '1' 
134b			;       jp z, matrix	 
134b			;   TODO keyboard matrix test 
134b			 
134b fe 32			cp '2' 
134d ca 54 13			jp z, .diagedit 
1350			 
1350			;if ENABLE_BASIC 
1350			;	cp '6' 
1350			;	jp z, basic 
1350			;endif 
1350			  
1350 c3 fa 12			jp .diagmenu 
1353			 
1353			 
1353 c9				ret 
1354			 
1354			; debug editor 
1354			 
1354			.diagedit: 
1354			 
1354 21 32 ee			ld hl, scratch 
1357			;	ld bc, 250 
1357			;	ldir 
1357				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1357 3e 00			ld a, 0 
1359 77				ld (hl), a 
135a 23				inc hl 
135b 77				ld (hl), a 
135c 23				inc hl 
135d 77				ld (hl), a 
135e			 
135e cd b9 0a		        call clear_display 
1361 cd dc 0a			call update_display 
1364 3e 01			ld a, 1 
1366 32 7d fb			ld (hardware_diag), a 
1369			.diloop: 
1369 3e 00			ld a, display_row_1 
136b 0e 00			ld c, 0 
136d 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
136f 1e 28			ld e, 40 
1371			 
1371 21 32 ee			ld hl, scratch	 
1374 cd 3f 0c			call input_str 
1377			 
1377 3e 28			ld a, display_row_2 
1379 11 32 ee			ld de, scratch 
137c cd cc 0a			call str_at_display 
137f cd dc 0a			call update_display 
1382			 
1382 c3 69 13			jp .diloop 
1385			 
1385			 
1385			; pass word in hl 
1385			; a has display location 
1385			display_word_at: 
1385 f5				push af 
1386 e5				push hl 
1387 7c				ld a,h 
1388 21 37 f1			ld hl, os_word_scratch 
138b cd 13 0f			call hexout 
138e e1				pop hl 
138f 7d				ld a,l 
1390 21 39 f1			ld hl, os_word_scratch+2 
1393 cd 13 0f			call hexout 
1396 21 3b f1			ld hl, os_word_scratch+4 
1399 3e 00			ld a,0 
139b 77				ld (hl),a 
139c 11 37 f1			ld de,os_word_scratch 
139f f1				pop af 
13a0 cd cc 0a				call str_at_display 
13a3 c9				ret 
13a4			 
13a4			display_ptr_state: 
13a4			 
13a4				; to restore afterwards 
13a4			 
13a4 d5				push de 
13a5 c5				push bc 
13a6 e5				push hl 
13a7 f5				push af 
13a8			 
13a8				; for use in here 
13a8			 
13a8			;	push bc 
13a8			;	push de 
13a8			;	push hl 
13a8			;	push af 
13a8			 
13a8 cd b9 0a			call clear_display 
13ab			 
13ab 11 7e 15			ld de, .ptrstate 
13ae 3e 00			ld a, display_row_1 
13b0 cd cc 0a			call str_at_display 
13b3			 
13b3				; display debug step 
13b3			 
13b3			 
13b3 11 77 fb			ld de, debug_mark 
13b6 3e 26			ld a, display_row_1+display_cols-2 
13b8 cd cc 0a			call str_at_display 
13bb			 
13bb				; display a 
13bb 11 88 15			ld de, .ptrcliptr 
13be 3e 28			ld a, display_row_2 
13c0 cd cc 0a			call str_at_display 
13c3			 
13c3 f1				pop af 
13c4 2a 3d f8			ld hl,(cli_ptr) 
13c7 3e 30			ld a, display_row_2+8 
13c9 cd 85 13			call display_word_at 
13cc			 
13cc			 
13cc				; display hl 
13cc			 
13cc			 
13cc 11 90 15			ld de, .ptrclioptr 
13cf 3e 32			ld a, display_row_2+10 
13d1 cd cc 0a			call str_at_display 
13d4			; 
13d4			;	pop hl 
13d4 3e 35			ld a, display_row_2+13 
13d6 2a 3b f8			ld hl,(cli_origptr) 
13d9 cd 85 13			call display_word_at 
13dc			; 
13dc			;	 
13dc			;	; display de 
13dc			 
13dc			;	ld de, .regstatede 
13dc			;	ld a, display_row_3 
13dc			;	call str_at_display 
13dc			 
13dc			;	pop de 
13dc			;	ld h,d 
13dc			;	ld l, e 
13dc			;	ld a, display_row_3+3 
13dc			;	call display_word_at 
13dc			 
13dc			 
13dc				; display bc 
13dc			 
13dc			;	ld de, .regstatebc 
13dc			;	ld a, display_row_3+10 
13dc			;	call str_at_display 
13dc			 
13dc			;	pop bc 
13dc			;	ld h,b 
13dc			;	ld l, c 
13dc			;	ld a, display_row_3+13 
13dc			;	call display_word_at 
13dc			 
13dc			 
13dc				; display dsp 
13dc			 
13dc			;	ld de, .regstatedsp 
13dc			;	ld a, display_row_4 
13dc			;	call str_at_display 
13dc			 
13dc				 
13dc			;	ld hl,(cli_data_sp) 
13dc			;	ld a, display_row_4+4 
13dc			;	call display_word_at 
13dc			 
13dc				; display rsp 
13dc			 
13dc 11 bf 15			ld de, .regstatersp 
13df 3e 82			ld a, display_row_4+10 
13e1 cd cc 0a			call str_at_display 
13e4			 
13e4				 
13e4 2a 23 f8			ld hl,(cli_ret_sp) 
13e7 3e 86			ld a, display_row_4+14 
13e9 cd 85 13			call display_word_at 
13ec			 
13ec cd dc 0a			call update_display 
13ef			 
13ef cd 3d 0a			call delay1s 
13f2 cd 3d 0a			call delay1s 
13f5 cd 3d 0a			call delay1s 
13f8			 
13f8			 
13f8 cd 12 19			call next_page_prompt 
13fb			 
13fb				; restore  
13fb			 
13fb f1				pop af 
13fc e1				pop hl 
13fd c1				pop bc 
13fe d1				pop de 
13ff c9				ret 
1400			 
1400			break_point_state: 
1400 f5				push af 
1401			 
1401				; see if disabled 
1401			 
1401 3a 31 ee			ld a, (os_view_disable) 
1404 fe 2a			cp '*' 
1406 20 02			jr nz, .bpsgo 
1408 f1				pop af 
1409 c9				ret 
140a			 
140a			.bpsgo: 
140a f1				pop af 
140b f5				push af 
140c 22 2d ee			ld (os_view_hl), hl 
140f ed 53 2b ee		ld (os_view_de), de 
1413 ed 43 29 ee		ld (os_view_bc), bc 
1417 e5				push hl 
1418 6f				ld l, a 
1419 26 00			ld h, 0 
141b 22 2f ee			ld (os_view_af),hl 
141e			 
141e 21 bd fa				ld hl, display_fb0 
1421 22 d8 f8				ld (display_fb_active), hl 
1424 e1				pop hl	 
1425			 
1425 3e 31			ld a, '1' 
1427 fe 2a		.bps1:  cp '*' 
1429 20 03			jr nz, .bps1b 
142b 32 31 ee			ld (os_view_disable),a 
142e fe 31		.bps1b:  cp '1' 
1430 20 14			jr nz, .bps2 
1432			 
1432				; display reg 
1432			 
1432				 
1432			 
1432 3a 2f ee			ld a, (os_view_af) 
1435 2a 2d ee			ld hl, (os_view_hl) 
1438 ed 5b 2b ee		ld de, (os_view_de) 
143c ed 4b 29 ee		ld bc, (os_view_bc) 
1440 cd da 14			call display_reg_state 
1443 c3 c6 14			jp .bpschk 
1446			 
1446 fe 32		.bps2:  cp '2' 
1448 20 08			jr nz, .bps3 
144a				 
144a				; display hl 
144a 2a 2d ee			ld hl, (os_view_hl) 
144d cd c4 15			call display_dump_at_hl 
1450			 
1450 18 74			jr .bpschk 
1452			 
1452 fe 33		.bps3:  cp '3' 
1454 20 08			jr nz, .bps4 
1456			 
1456			        ; display de 
1456 2a 2b ee			ld hl, (os_view_de) 
1459 cd c4 15			call display_dump_at_hl 
145c			 
145c 18 68			jr .bpschk 
145e fe 34		.bps4:  cp '4' 
1460 20 08			jr nz, .bps5 
1462			 
1462			        ; display bc 
1462 2a 29 ee			ld hl, (os_view_bc) 
1465 cd c4 15			call display_dump_at_hl 
1468			 
1468 18 5c			jr .bpschk 
146a fe 35		.bps5:  cp '5' 
146c 20 08		        jr nz, .bps7 
146e			 
146e				; display cur ptr 
146e 2a 3d f8			ld hl, (cli_ptr) 
1471 cd c4 15			call display_dump_at_hl 
1474			 
1474 18 50			jr .bpschk 
1476 fe 36		.bps7:  cp '6' 
1478 20 08			jr nz, .bps8b 
147a				 
147a				; display cur orig ptr 
147a 2a 3b f8			ld hl, (cli_origptr) 
147d cd c4 15			call display_dump_at_hl 
1480 18 44			jr .bpschk 
1482 fe 37		.bps8b:  cp '7' 
1484 20 08			jr nz, .bps9 
1486				 
1486				; display dsp 
1486 2a 1f f8			ld hl, (cli_data_sp) 
1489 cd c4 15			call display_dump_at_hl 
148c			 
148c 18 38			jr .bpschk 
148e fe 39		.bps9:  cp '9' 
1490 20 05			jr nz, .bps8c 
1492				 
1492				; display SP 
1492			;	ld hl, sp 
1492 cd c4 15			call display_dump_at_hl 
1495			 
1495 18 2f			jr .bpschk 
1497 fe 38		.bps8c:  cp '8' 
1499 20 08			jr nz, .bps8d 
149b				 
149b				; display rsp 
149b 2a 23 f8			ld hl, (cli_ret_sp) 
149e cd c4 15			call display_dump_at_hl 
14a1			 
14a1 18 23			jr .bpschk 
14a3 fe 23		.bps8d:  cp '#'     ; access monitor sub system 
14a5 20 05			jr nz, .bps8 
14a7 cd 08 17			call monitor 
14aa			 
14aa 18 1a			jr .bpschk 
14ac fe 30		.bps8:  cp '0' 
14ae 20 16			jr nz, .bpschk 
14b0			 
14b0 21 1c fa				ld hl, display_fb1 
14b3 22 d8 f8				ld (display_fb_active), hl 
14b6 cd dc 0a				call update_display 
14b9			 
14b9				;ld a, (os_view_af) 
14b9 2a 2d ee			ld hl, (os_view_hl) 
14bc ed 5b 2b ee		ld de, (os_view_de) 
14c0 ed 4b 29 ee		ld bc, (os_view_bc) 
14c4 f1				pop af 
14c5 c9				ret 
14c6			 
14c6			.bpschk:   
14c6 cd 3d 0a			call delay1s 
14c9 3e 9f		ld a,display_row_4 + display_cols - 1 
14cb 11 10 19		        ld de, endprg 
14ce cd cc 0a			call str_at_display 
14d1 cd dc 0a			call update_display 
14d4 cd f5 64			call cin_wait 
14d7			 
14d7 c3 27 14			jp .bps1 
14da			 
14da			 
14da			display_reg_state: 
14da			 
14da				; to restore afterwards 
14da			 
14da d5				push de 
14db c5				push bc 
14dc e5				push hl 
14dd f5				push af 
14de			 
14de				; for use in here 
14de			 
14de c5				push bc 
14df d5				push de 
14e0 e5				push hl 
14e1 f5				push af 
14e2			 
14e2 cd b9 0a			call clear_display 
14e5			 
14e5 11 9a 15			ld de, .regstate 
14e8 3e 00			ld a, display_row_1 
14ea cd cc 0a			call str_at_display 
14ed			 
14ed				; display debug step 
14ed			 
14ed			 
14ed 11 77 fb			ld de, debug_mark 
14f0 3e 25			ld a, display_row_1+display_cols-3 
14f2 cd cc 0a			call str_at_display 
14f5			 
14f5				; display a 
14f5 11 b6 15			ld de, .regstatea 
14f8 3e 28			ld a, display_row_2 
14fa cd cc 0a			call str_at_display 
14fd			 
14fd e1				pop hl 
14fe			;	ld h,0 
14fe			;	ld l, a 
14fe 3e 2b			ld a, display_row_2+3 
1500 cd 85 13			call display_word_at 
1503			 
1503			 
1503				; display hl 
1503			 
1503			 
1503 11 aa 15			ld de, .regstatehl 
1506 3e 32			ld a, display_row_2+10 
1508 cd cc 0a			call str_at_display 
150b			 
150b e1				pop hl 
150c 3e 35			ld a, display_row_2+13 
150e cd 85 13			call display_word_at 
1511			 
1511				 
1511				; display de 
1511			 
1511 11 ae 15			ld de, .regstatede 
1514 3e 50			ld a, display_row_3 
1516 cd cc 0a			call str_at_display 
1519			 
1519 e1				pop hl 
151a			;	ld h,d 
151a			;	ld l, e 
151a 3e 53			ld a, display_row_3+3 
151c cd 85 13			call display_word_at 
151f			 
151f			 
151f				; display bc 
151f			 
151f 11 b2 15			ld de, .regstatebc 
1522 3e 5a			ld a, display_row_3+10 
1524 cd cc 0a			call str_at_display 
1527			 
1527 e1				pop hl 
1528			;	ld h,b 
1528			;	ld l, c 
1528 3e 5d			ld a, display_row_3+13 
152a cd 85 13			call display_word_at 
152d			 
152d			 
152d				; display dsp 
152d			 
152d 11 ba 15			ld de, .regstatedsp 
1530 3e 78			ld a, display_row_4 
1532 cd cc 0a			call str_at_display 
1535			 
1535				 
1535 2a 1f f8			ld hl,(cli_data_sp) 
1538 3e 7c			ld a, display_row_4+4 
153a cd 85 13			call display_word_at 
153d			 
153d				; display rsp 
153d			 
153d 11 bf 15			ld de, .regstatersp 
1540 3e 82			ld a, display_row_4+10 
1542 cd cc 0a			call str_at_display 
1545			 
1545				 
1545 2a 23 f8			ld hl,(cli_ret_sp) 
1548 3e 86			ld a, display_row_4+14 
154a cd 85 13			call display_word_at 
154d			 
154d cd dc 0a			call update_display 
1550			 
1550			;	call delay1s 
1550			;	call delay1s 
1550			;	call delay1s 
1550			 
1550			 
1550			;	call next_page_prompt 
1550			 
1550				; restore  
1550			 
1550 f1				pop af 
1551 e1				pop hl 
1552 c1				pop bc 
1553 d1				pop de 
1554 c9				ret 
1555			 
1555 .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
1569 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
157e .. 00		.ptrstate:	db "Ptr State",0 
1588 .. 00		.ptrcliptr:     db "cli_ptr",0 
1590 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
159a .. 00		.regstate:	db "Reg State (1/0)",0 
15aa .. 00		.regstatehl:	db "HL:",0 
15ae .. 00		.regstatede:	db "DE:",0 
15b2 .. 00		.regstatebc:	db "BC:",0 
15b6 .. 00		.regstatea:	db "A :",0 
15ba .. 00		.regstatedsp:	db "DSP:",0 
15bf .. 00		.regstatersp:	db "RSP:",0 
15c4			 
15c4			display_dump_at_hl: 
15c4 e5				push hl 
15c5 d5				push de 
15c6 c5				push bc 
15c7 f5				push af 
15c8			 
15c8 22 55 f1			ld (os_cur_ptr),hl	 
15cb cd b9 0a			call clear_display 
15ce cd 1a 18			call dumpcont 
15d1			;	call delay1s 
15d1			;	call next_page_prompt 
15d1			 
15d1			 
15d1 f1				pop af 
15d2 c1				pop bc 
15d3 d1				pop de 
15d4 e1				pop hl 
15d5 c9				ret 
15d6			 
15d6			;if ENABLE_BASIC 
15d6			;	include "nascombasic.asm" 
15d6			;	basic: 
15d6			;	include "forth/FORTH.ASM" 
15d6			;endif 
15d6			 
15d6			; eof 
15d6			 
15d6			 
# End of file firmware_diags.asm
15d6			  
15d6			  
15d6			  
15d6			  
15d6			; eof  
15d6			  
# End of file firmware.asm
15d6			 
15d6			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
15d6			;if BASE_KEV  
15d6			;baseram: equ 08000h 
15d6			;endif 
15d6			 
15d6			;if BASE_SC114 
15d6			;baseram:     equ    endofcode 
15d6			;endif 
15d6			 
15d6			 
15d6			; start system 
15d6			 
15d6			coldstart: 
15d6				; set sp 
15d6				; di/ei 
15d6			 
15d6 f3				di 
15d7 31 fd ff			ld sp, tos 
15da			;	ei 
15da			 
15da			 
15da				; disable breakpoint by default 
15da			 
15da 3e 2a			ld a,'*' 
15dc 32 31 ee			ld (os_view_disable),a 
15df			 
15df				; init hardware 
15df			 
15df				; init keyboard and screen hardware 
15df			 
15df cd 03 00			call hardware_init 
15e2			 
15e2			 
15e2				; detect if any keys are held down to enable breakpoints at start up 
15e2			 
15e2 cd 06 65			call cin  
15e5 fe 00			cp 0 
15e7 28 03			jr z, .nokeys 
15e9			 
15e9 cd fa 12			call hardware_diags 
15ec			 
15ec			;	ld de, .bpen 
15ec			;	ld a, display_row_4 
15ec			;	call str_at_display 
15ec			;	call update_display 
15ec			; 
15ec			;	ld a,0 
15ec			;	ld (os_view_disable),a 
15ec			; 
15ec			;.bpwait: 
15ec			;	call cin 
15ec			;	cp 0 
15ec			;	jr z, .bpwait 
15ec			;	jr .nokeys 
15ec			; 
15ec			; 
15ec			;.bpen:  db "Break points enabled!",0 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			.nokeys: 
15ec			 
15ec			 
15ec				 
15ec			 
15ec			;jp  testkey 
15ec			 
15ec			;call storage_get_block_0 
15ec			; 
15ec			;ld hl, 0 
15ec			;ld de, store_page 
15ec			;call storage_read_block 
15ec			 
15ec				 
15ec			;ld hl, 10 
15ec			;ld de, store_page 
15ec			;call storage_read_block 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			 
15ec			;stop:	nop 
15ec			;	jp stop 
15ec			 
15ec			 
15ec			 
15ec			main: 
15ec cd b9 0a			call clear_display 
15ef cd dc 0a			call update_display 
15f2			 
15f2			 
15f2			 
15f2			;	call testlcd 
15f2			 
15f2			 
15f2			 
15f2 cd 60 1b			call forth_init 
15f5			 
15f5			 
15f5			warmstart: 
15f5 cd 36 1b			call forth_warmstart 
15f8			 
15f8				; run startup word load 
15f8			        ; TODO prevent this running at warmstart after crash  
15f8			 
15f8				if STARTUP_ENABLE 
15f8 cd cc 5e				call forth_startup 
15fb				endif 
15fb			 
15fb				; show free memory after boot 
15fb 11 a2 16			ld de, freeram 
15fe 3e 00			ld a, display_row_1 
1600 cd cc 0a			call str_at_display 
1603			 
1603			; Or use heap_size word???? 
1603 21 26 ee			ld hl, heap_end 
1606 11 0e 80			ld de, heap_start 
1609 ed 52			sbc hl, de 
160b e5				push hl 
160c 7c				ld a,h	         	 
160d 21 37 f1			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1610 cd 13 0f			call hexout 
1613 e1			   	pop hl 
1614			 
1614 7d				ld a,l 
1615 21 39 f1			ld hl, os_word_scratch+2 
1618 cd 13 0f			call hexout 
161b 21 3b f1			ld hl, os_word_scratch+4 
161e 3e 00			ld a, 0 
1620 77				ld (hl),a 
1621 11 37 f1			ld de, os_word_scratch 
1624 3e 0d			ld a, display_row_1 + 13 
1626 cd cc 0a			call str_at_display 
1629 cd dc 0a			call update_display 
162c			 
162c			 
162c				;call demo 
162c			 
162c			 
162c				; init scratch input area for cli commands 
162c			 
162c 21 59 f1			ld hl, os_cli_cmd 
162f 3e 00			ld a,0 
1631 77				ld (hl),a 
1632 23				inc hl 
1633 77				ld (hl),a 
1634			 
1634 3e 00			ld a,0 
1636 32 58 f2			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
1639			 
1639 32 55 f1			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
163c 32 56 f1			ld (os_cur_ptr+1),a	 
163f			 
163f 32 37 f1			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1642 32 38 f1			ld (os_word_scratch+1),a	 
1645				 
1645			 
1645				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1645 21 59 f1			ld hl, os_cli_cmd 
1648			 
1648 3e 00			ld a, 0		 ; init cli input 
164a 77				ld (hl), a 
164b 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
164d			cli: 
164d				; show cli prompt 
164d				;push af 
164d				;ld a, 0 
164d				;ld de, prompt 
164d				;call str_at_display 
164d			 
164d				;call update_display 
164d				;pop af 
164d				;inc a 
164d				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
164d 0e 00			ld c, 0 
164f 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
1651 1e 28			ld e, 40 
1653			 
1653 21 59 f1			ld hl, os_cli_cmd 
1656			 
1656				STACKFRAME OFF $fefe $9f9f 
1656				if DEBUG_STACK_IMB 
1656					if OFF 
1656						exx 
1656						ld de, $fefe 
1656						ld a, d 
1656						ld hl, curframe 
1656						call hexout 
1656						ld a, e 
1656						ld hl, curframe+2 
1656						call hexout 
1656						ld hl, $fefe 
1656						push hl 
1656						ld hl, $9f9f 
1656						push hl 
1656						exx 
1656					endif 
1656				endif 
1656			endm 
# End of macro STACKFRAME
1656			 
1656 cd 3f 0c			call input_str 
1659			 
1659				STACKFRAMECHK OFF $fefe $9f9f 
1659				if DEBUG_STACK_IMB 
1659					if OFF 
1659						exx 
1659						ld hl, $9f9f 
1659						pop de   ; $9f9f 
1659						call cmp16 
1659						jr nz, .spnosame 
1659						ld hl, $fefe 
1659						pop de   ; $fefe 
1659						call cmp16 
1659						jr z, .spfrsame 
1659						.spnosame: call showsperror 
1659						.spfrsame: nop 
1659						exx 
1659					endif 
1659				endif 
1659			endm 
# End of macro STACKFRAMECHK
1659			 
1659				; copy input to last command 
1659			 
1659 21 59 f1			ld hl, os_cli_cmd 
165c 11 58 f2			ld de, os_last_cmd 
165f 01 ff 00			ld bc, 255 
1662 ed b0			ldir 
1664			 
1664				; wipe current buffer 
1664			 
1664 3e 00			ld a, 0 
1666 21 59 f1			ld hl, os_cli_cmd 
1669 11 5a f1			ld de, os_cli_cmd+1 
166c 01 fe 00			ld bc, 254 
166f ed b0			ldir 
1671				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
1671			;	call strcpy 
1671			;	ld a, 0 
1671			;	ld (hl), a 
1671			;	inc hl 
1671			;	ld (hl), a 
1671			;	inc hl 
1671			;	ld (hl), a 
1671			 
1671				; switch frame buffer to program  
1671			 
1671 21 1c fa				ld hl, display_fb1 
1674 22 d8 f8				ld (display_fb_active), hl 
1677			 
1677			;	nop 
1677				STACKFRAME ON $fbfe $8f9f 
1677				if DEBUG_STACK_IMB 
1677					if ON 
1677						exx 
1677						ld de, $fbfe 
1677						ld a, d 
1677						ld hl, curframe 
1677						call hexout 
1677						ld a, e 
1677						ld hl, curframe+2 
1677						call hexout 
1677						ld hl, $fbfe 
1677						push hl 
1677						ld hl, $8f9f 
1677						push hl 
1677						exx 
1677					endif 
1677				endif 
1677			endm 
# End of macro STACKFRAME
1677				; first time into the parser so pass over the current scratch pad 
1677 21 59 f1			ld hl,os_cli_cmd 
167a				; tokenise the entered statement(s) in HL 
167a cd d9 1b			call forthparse 
167d			        ; exec forth statements in top of return stack 
167d cd 19 1c			call forthexec 
1680				;call forthexec_cleanup 
1680			;	call parsenext 
1680			 
1680				STACKFRAMECHK ON $fbfe $8f9f 
1680				if DEBUG_STACK_IMB 
1680					if ON 
1680						exx 
1680						ld hl, $8f9f 
1680						pop de   ; $8f9f 
1680						call cmp16 
1680						jr nz, .spnosame 
1680						ld hl, $fbfe 
1680						pop de   ; $fbfe 
1680						call cmp16 
1680						jr z, .spfrsame 
1680						.spnosame: call showsperror 
1680						.spfrsame: nop 
1680						exx 
1680					endif 
1680				endif 
1680			endm 
# End of macro STACKFRAMECHK
1680				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
1680			 
1680 3e 78			ld a, display_row_4 
1682 11 b4 16			ld de, endprog 
1685			 
1685 cd dc 0a			call update_display		 
1688			 
1688 cd 12 19			call next_page_prompt 
168b			 
168b				; switch frame buffer to cli 
168b			 
168b 21 bd fa				ld hl, display_fb0 
168e 22 d8 f8				ld (display_fb_active), hl 
1691			 
1691			 
1691 cd b9 0a		        call clear_display 
1694 cd dc 0a			call update_display		 
1697			 
1697 21 59 f1			ld hl, os_cli_cmd 
169a			 
169a 3e 00			ld a, 0		 ; init cli input 
169c 77				ld (hl), a 
169d			 
169d				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
169d			 
169d				; now on last line 
169d			 
169d				; TODO scroll screen up 
169d			 
169d				; TODO instead just clear screen and place at top of screen 
169d			 
169d			;	ld a, 0 
169d			;	ld (f_cursor_ptr),a 
169d			 
169d				;call clear_display 
169d				;call update_display 
169d			 
169d				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
169d 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
169f c3 4d 16			jp cli 
16a2			 
16a2 .. 00		freeram: db "Free bytes: $",0 
16b0 ..			asc: db "1A2F" 
16b4 .. 00		endprog: db "End prog...",0 
16c0			 
16c0			testenter2:   
16c0 21 64 ee			ld hl,scratch+50 
16c3 22 55 f1			ld (os_cur_ptr),hl 
16c6 c3 4d 16			jp cli 
16c9			 
16c9			testenter:  
16c9			 
16c9 21 b0 16			ld hl,asc 
16cc			;	ld a,(hl) 
16cc			;	call nibble2val 
16cc cd 69 0f			call get_byte 
16cf			 
16cf			 
16cf			;	ld a,(hl) 
16cf			;	call atohex 
16cf			 
16cf			;	call fourehexhl 
16cf 32 64 ee			ld (scratch+50),a 
16d2			 
16d2			 
16d2			 
16d2 21 b2 16			ld hl,asc+2 
16d5			;	ld a, (hl) 
16d5			;	call nibble2val 
16d5 cd 69 0f			call get_byte 
16d8			 
16d8			;	call fourehexhl 
16d8 32 66 ee			ld (scratch+52),a 
16db				 
16db 21 64 ee			ld hl,scratch+50 
16de 22 55 f1			ld (os_cur_ptr),hl 
16e1 c3 4d 16			jp cli 
16e4			 
16e4			enter:	 
16e4 3a 36 ee			ld a,(scratch+4) 
16e7 fe 00			cp 0 
16e9 28 0c			jr z, .entercont 
16eb				; no, not a null term line so has an address to work out.... 
16eb			 
16eb 21 34 ee			ld hl,scratch+2 
16ee cd c9 0f			call get_word_hl 
16f1			 
16f1 22 55 f1			ld (os_cur_ptr),hl	 
16f4 c3 4d 16			jp cli 
16f7			 
16f7			 
16f7			.entercont:  
16f7			 
16f7 21 34 ee			ld hl, scratch+2 
16fa cd 69 0f			call get_byte 
16fd			 
16fd 2a 55 f1		   	ld hl,(os_cur_ptr) 
1700 77					ld (hl),a 
1701 23					inc hl 
1702 22 55 f1				ld (os_cur_ptr),hl 
1705				 
1705			; get byte  
1705			 
1705			 
1705 c3 4d 16			jp cli 
1708			 
1708			 
1708			; basic monitor support 
1708			 
1708			monitor: 
1708				;  
1708 cd b9 0a			call clear_display 
170b 3e 00			ld a, 0 
170d 11 55 17			ld de, .monprompt 
1710 cd cc 0a			call str_at_display 
1713 cd dc 0a			call update_display 
1716			 
1716				; get a monitor command 
1716			 
1716 0e 00			ld c, 0     ; entry at top left 
1718 16 64			ld d, 100   ; max buffer size 
171a 1e 0f			ld e, 15    ; input scroll area 
171c 3e 00			ld a, 0     ; init string 
171e 21 30 f0			ld hl, os_input 
1721 77				ld (hl), a 
1722 23				inc hl 
1723 77				ld (hl), a 
1724 21 30 f0			ld hl, os_input 
1727 3e 01			ld a, 1     ; init string 
1729 cd 3f 0c			call input_str 
172c			 
172c cd b9 0a		        call clear_display 
172f cd dc 0a			call update_display		 
1732			 
1732 3a 30 f0			ld a, (os_input) 
1735 cd 67 10			call toUpper 
1738 fe 48		        cp 'H' 
173a 28 6f		        jr z, .monhelp 
173c fe 44			cp 'D'		; dump 
173e ca cc 17			jp z, .mondump	 
1741 fe 43			cp 'C'		; dump 
1743 ca e6 17			jp z, .moncdump	 
1746 fe 4d			cp 'M'		; dump 
1748 ca 57 17			jp z, .moneditstart 
174b fe 55			cp 'U'		; dump 
174d 28 14			jr z, .monedit	 
174f fe 51			cp 'Q'		; dump 
1751 c8				ret z	 
1752			 
1752			 
1752				; TODO "S" to access symbol by name and not need the address 
1752				; TODO "F" to find a string in memory 
1752			 
1752 c3 08 17			jp monitor 
1755			 
1755 .. 00		.monprompt: db ">", 0 
1757			 
1757			.moneditstart: 
1757				; get starting address 
1757			 
1757 21 32 f0			ld hl,os_input+2 
175a cd c9 0f			call get_word_hl 
175d			 
175d 22 55 f1			ld (os_cur_ptr),hl	 
1760			 
1760 c3 08 17			jp monitor 
1763			 
1763			.monedit: 
1763				; get byte to load 
1763			 
1763 21 32 f0			ld hl,os_input+2 
1766 cd 69 0f			call get_byte 
1769			 
1769				; get address to update 
1769 2a 55 f1			ld hl, (os_cur_ptr) 
176c			 
176c				; update byte 
176c			 
176c 77				ld (hl), a 
176d			 
176d				; move to next address and save it 
176d			 
176d 23				inc hl 
176e 22 55 f1			ld (os_cur_ptr),hl	 
1771			 
1771 c3 08 17			jp monitor 
1774			 
1774			 
1774 .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
1788 .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
17a4 .. 00		.monhelptext3:  db "Q-Quit",0 
17ab			        
17ab			.monhelp: 
17ab 3e 00			ld a, display_row_1 
17ad 11 74 17		        ld de, .monhelptext1 
17b0			 
17b0 cd cc 0a			call str_at_display 
17b3 3e 28			ld a, display_row_2 
17b5 11 88 17		        ld de, .monhelptext2 
17b8					 
17b8 cd cc 0a			call str_at_display 
17bb 3e 50			ld a, display_row_3 
17bd 11 a4 17		        ld de, .monhelptext3 
17c0					 
17c0 cd cc 0a			call str_at_display 
17c3 cd dc 0a			call update_display		 
17c6			 
17c6 cd 12 19			call next_page_prompt 
17c9 c3 08 17			jp monitor 
17cc			 
17cc			.mondump:    
17cc 21 32 f0			ld hl,os_input+2 
17cf cd c9 0f			call get_word_hl 
17d2			 
17d2 22 55 f1			ld (os_cur_ptr),hl	 
17d5 cd 1a 18			call dumpcont 
17d8 3e 78			ld a, display_row_4 
17da 11 b4 16			ld de, endprog 
17dd			 
17dd cd dc 0a			call update_display		 
17e0			 
17e0 cd 12 19			call next_page_prompt 
17e3 c3 08 17			jp monitor 
17e6			.moncdump: 
17e6 cd 1a 18			call dumpcont 
17e9 3e 78			ld a, display_row_4 
17eb 11 b4 16			ld de, endprog 
17ee			 
17ee cd dc 0a			call update_display		 
17f1			 
17f1 cd 12 19			call next_page_prompt 
17f4 c3 08 17			jp monitor 
17f7			 
17f7			 
17f7			; TODO symbol access  
17f7			 
17f7			.symbols:     ;; A list of symbols that can be called up  
17f7 bd fa			dw display_fb0 
17f9 .. 00			db "fb0",0  
17fd 62 f8		     	dw store_page 
17ff .. 00			db "store_page",0 
180a			 
180a			 
180a			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
180a			 
180a 3a 33 ee			ld a,(scratch+1) 
180d fe 00			cp 0 
180f 28 09			jr z, dumpcont 
1811			 
1811				; no, not a null term line so has an address to work out.... 
1811			 
1811 21 34 ee			ld hl,scratch+2 
1814 cd c9 0f			call get_word_hl 
1817			 
1817 22 55 f1			ld (os_cur_ptr),hl	 
181a			 
181a			 
181a			 
181a			dumpcont: 
181a			 
181a				; dump bytes at ptr 
181a			 
181a			 
181a 3e 00			ld a, display_row_1 
181c 2a d8 f8			ld hl, (display_fb_active) 
181f cd 12 0c			call addatohl 
1822 cd 4a 18			call .dumpbyterow 
1825			 
1825 3e 28			ld a, display_row_2 
1827 2a d8 f8			ld hl, (display_fb_active) 
182a cd 12 0c			call addatohl 
182d cd 4a 18			call .dumpbyterow 
1830			 
1830			 
1830 3e 50			ld a, display_row_3 
1832 2a d8 f8			ld hl, (display_fb_active) 
1835 cd 12 0c			call addatohl 
1838 cd 4a 18			call .dumpbyterow 
183b			 
183b 3e 78			ld a, display_row_4 
183d 2a d8 f8			ld hl, (display_fb_active) 
1840 cd 12 0c			call addatohl 
1843 cd 4a 18			call .dumpbyterow 
1846			 
1846 cd dc 0a			call update_display 
1849			;		jp cli 
1849 c9				ret 
184a			 
184a			.dumpbyterow: 
184a			 
184a				;push af 
184a			 
184a e5				push hl 
184b			 
184b				; calc where to poke the ascii 
184b			if display_cols == 20 
184b				ld a, 16 
184b			else 
184b 3e 1f			ld a, 31 
184d			endif 
184d			 
184d cd 12 0c			call addatohl 
1850 22 37 f1			ld (os_word_scratch),hl  		; save pos for later 
1853			 
1853			 
1853			; display decoding address 
1853 2a 55 f1		   	ld hl,(os_cur_ptr) 
1856			 
1856 7c				ld a,h 
1857 e1				pop hl 
1858 e5				push hl 
1859			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1859 cd 13 0f			call hexout 
185c 2a 55 f1		   	ld hl,(os_cur_ptr) 
185f			 
185f 7d				ld a,l 
1860 e1				pop hl 
1861 23				inc hl 
1862 23				inc hl 
1863 e5				push hl 
1864			;	ld hl, os_word_scratch+2 
1864 cd 13 0f			call hexout 
1867 e1				pop hl 
1868 23				inc hl 
1869 23				inc hl 
186a				;ld hl, os_word_scratch+4 
186a 3e 3a			ld a, ':' 
186c 77				ld (hl),a 
186d 23				inc hl 
186e				;ld a, 0 
186e				;ld (hl),a 
186e				;ld de, os_word_scratch 
186e				;pop af 
186e				;push af 
186e			;		ld a, display_row_2 
186e			;		call str_at_display 
186e			;		call update_display 
186e			 
186e			 
186e			;pop af 
186e			;	add 5 
186e			 
186e			if display_cols == 20 
186e				ld b, 4 
186e			else 
186e 06 08			ld b, 8 
1870			endif	 
1870			 
1870			.dumpbyte: 
1870 c5				push bc 
1871 e5				push hl 
1872			 
1872			 
1872 2a 55 f1		   	ld hl,(os_cur_ptr) 
1875 7e					ld a,(hl) 
1876			 
1876					; poke the ascii to display 
1876 2a 37 f1				ld hl,(os_word_scratch) 
1879 77					ld (hl),a 
187a 23					inc hl 
187b 22 37 f1				ld (os_word_scratch),hl 
187e			 
187e					 
187e			 
187e			 
187e e1					pop hl 
187f e5					push hl 
1880			 
1880 cd 13 0f				call hexout 
1883			 
1883					 
1883 2a 55 f1		   	ld hl,(os_cur_ptr) 
1886 23				inc hl 
1887 22 55 f1		   	ld (os_cur_ptr),hl 
188a			 
188a e1					pop hl 
188b 23					inc hl 
188c 23					inc hl 
188d 23					inc hl 
188e			 
188e			 
188e			 
188e					;ld a,0 
188e					;ld (os_word_scratch+2),a 
188e					;pop af 
188e					;push af 
188e			 
188e					;ld de, os_word_scratch 
188e					;call str_at_display 
188e			;		call update_display 
188e			;		pop af 
188e c1					pop bc 
188f c6 03				add 3 
1891 10 dd			djnz .dumpbyte 
1893			 
1893				 
1893			 
1893 c9				ret 
1894			 
1894			jump:	 
1894			 
1894 21 34 ee			ld hl,scratch+2 
1897 cd c9 0f			call get_word_hl 
189a				;ld hl,(scratch+2) 
189a				;call fourehexhl 
189a			 
189a 22 55 f1			ld (os_cur_ptr),hl	 
189d			 
189d e9				jp (hl) 
189e			 
189e			 
189e			 
189e			; TODO implement a basic monitor mode to start with 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			 
189e			; testing and demo code during development 
189e			 
189e			 
189e .. 00		str1: db "Enter some text...",0 
18b1 .. 00		clear: db "                    ",0 
18c6			 
18c6			demo: 
18c6			 
18c6			 
18c6			 
18c6			;	call update_display 
18c6			 
18c6				; init scratch input area for testing 
18c6 21 32 ee			ld hl, scratch	 
18c9 3e 00			ld a,0 
18cb 77				ld (hl),a 
18cc			 
18cc			 
18cc 3e 28		            LD   A, display_row_2 
18ce			;            CALL fLCD_Pos       ;Position cursor to location in A 
18ce 11 9e 18		            LD   DE, str1 
18d1 cd cc 0a			call str_at_display 
18d4			 
18d4			;            CALL fLCD_Str       ;Display string pointed to by DE 
18d4			cloop:	 
18d4 3e 50		            LD   A, display_row_3 
18d6			;            CALL fLCD_Pos       ;Position cursor to location in A 
18d6 11 b1 18		            LD   DE, clear 
18d9			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
18d9 cd cc 0a				call str_at_display 
18dc 3e 78			ld a, display_row_4 
18de 11 0e 19			ld de, prompt 
18e1			 
18e1 cd cc 0a				call str_at_display 
18e4 cd dc 0a			call update_display 
18e7			 
18e7 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
18e9 16 0a			ld d, 10 
18eb 21 32 ee			ld hl, scratch	 
18ee cd 3f 0c			call input_str 
18f1			 
18f1			;	call clear_display 
18f1			;'	call update_display 
18f1			 
18f1 3e 00		            LD   A, display_row_1 
18f3			;            CALL fLCD_Pos       ;Position cursor to location in A 
18f3 11 b1 18		            LD   DE, clear 
18f6 cd cc 0a				call str_at_display 
18f9			;            CALL fLCD_Str       ;Display string pointed to by DE 
18f9 3e 00		            LD   A, display_row_1 
18fb			;            CALL fLCD_Pos       ;Position cursor to location in A 
18fb 11 32 ee		            LD   DE, scratch 
18fe			;            CALL fLCD_Str       ;Display string pointed to by DE 
18fe cd cc 0a				call str_at_display 
1901 cd dc 0a			call update_display 
1904			 
1904 3e 00				ld a,0 
1906 21 32 ee			ld hl, scratch 
1909 77				ld (hl),a 
190a			 
190a 00				nop 
190b c3 d4 18			jp cloop 
190e			 
190e			 
190e			 
190e			; OS Prompt 
190e			 
190e .. 00		prompt: db ">",0 
1910 .. 00		endprg: db "?",0 
1912			 
1912			 
1912			; handy next page prompt 
1912			next_page_prompt: 
1912 e5				push hl 
1913 d5				push de 
1914 f5				push af 
1915 c5				push bc 
1916			 
1916 3e 9f			ld a,display_row_4 + display_cols - 1 
1918 11 10 19		        ld de, endprg 
191b cd cc 0a			call str_at_display 
191e cd dc 0a			call update_display 
1921 cd f5 64			call cin_wait 
1924 c1				pop bc 
1925 f1				pop af 
1926 d1				pop de 
1927 e1				pop hl 
1928			 
1928			 
1928 c9				ret 
1929			 
1929			 
1929			; forth parser 
1929			 
1929			; My forth kernel 
1929			include "forth_kernel.asm" 
1929			; 
1929			; kernel to the forth OS 
1929			 
1929			DS_TYPE_STR: equ 1     ; string type 
1929			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1929			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1929			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1929			 
1929			FORTH_PARSEV1: equ 0 
1929			FORTH_PARSEV2: equ 0 
1929			FORTH_PARSEV3: equ 0 
1929			FORTH_PARSEV4: equ 0 
1929			FORTH_PARSEV5: equ 1 
1929			 
1929			;if FORTH_PARSEV5 
1929			;	FORTH_END_BUFFER: equ 0 
1929			;else 
1929			FORTH_END_BUFFER: equ 127 
1929			;endif 
1929			 
1929			FORTH_TRUE: equ 1 
1929			FORTH_FALSE: equ 0 
1929			 
1929			if FORTH_PARSEV4 
1929			include "forth_stackops.asm" 
1929			endif 
1929			 
1929			if FORTH_PARSEV5 
1929			include "forth_stackopsv5.asm" 
1929			 
1929			; Stack operations for v5 parser on wards 
1929			; * DATA stack 
1929			; * LOOP stack 
1929			; * RETURN stack 
1929			 
1929			 
1929			 
1929			FORTH_CHK_DSP_UNDER: macro 
1929				push hl 
1929				push de 
1929				ld hl,(cli_data_sp) 
1929				ld de, cli_data_stack 
1929				call cmp16 
1929				jp c, fault_dsp_under 
1929				pop de 
1929				pop hl 
1929				endm 
1929			 
1929			 
1929			FORTH_CHK_RSP_UNDER: macro 
1929				push hl 
1929				push de 
1929				ld hl,(cli_ret_sp) 
1929				ld de, cli_ret_stack 
1929				call cmp16 
1929				jp c, fault_rsp_under 
1929				pop de 
1929				pop hl 
1929				endm 
1929			 
1929			FORTH_CHK_LOOP_UNDER: macro 
1929				push hl 
1929				push de 
1929				ld hl,(cli_loop_sp) 
1929				ld de, cli_loop_stack 
1929				call cmp16 
1929				jp c, fault_loop_under 
1929				pop de 
1929				pop hl 
1929				endm 
1929			 
1929			FORTH_ERR_TOS_NOTSTR: macro 
1929				; TOSO might need more for checks when used 
1929				push af 
1929				ld a,(hl) 
1929				cp DS_TYPE_STR 
1929				jp nz, type_faultn   
1929				pop af 
1929				endm 
1929			 
1929			FORTH_ERR_TOS_NOTNUM: macro 
1929				push af 
1929				ld a,(hl) 
1929				cp DS_TYPE_INUM 
1929				jp nz, type_faultn   
1929				pop af 
1929				endm 
1929			 
1929			 
1929			; increase data stack pointer and save hl to it 
1929				 
1929			FORTH_DSP_NEXT: macro 
1929				call macro_forth_dsp_next 
1929				endm 
1929			 
1929			 
1929			macro_forth_dsp_next: 
1929				if DEBUG_FORTH_STACK_GUARD 
1929 cd 96 5f				call check_stacks 
192c				endif 
192c e5				push hl 
192d d5				push de 
192e eb				ex de,hl 
192f 2a 1f f8			ld hl,(cli_data_sp) 
1932 23				inc hl 
1933 23				inc hl 
1934			 
1934			; PARSEV5 
1934 23				inc hl 
1935 22 1f f8			ld (cli_data_sp),hl 
1938 73				ld (hl), e 
1939 23				inc hl 
193a 72				ld (hl), d 
193b d1				pop de 
193c e1				pop hl 
193d				if DEBUG_FORTH_STACK_GUARD 
193d cd 96 5f				call check_stacks 
1940				endif 
1940 c9				ret 
1941			 
1941			 
1941			; increase ret stack pointer and save hl to it 
1941				 
1941			FORTH_RSP_NEXT: macro 
1941				call macro_forth_rsp_next 
1941				endm 
1941			 
1941			macro_forth_rsp_next: 
1941				if DEBUG_FORTH_STACK_GUARD 
1941 cd 96 5f				call check_stacks 
1944				endif 
1944 e5				push hl 
1945 d5				push de 
1946 eb				ex de,hl 
1947 2a 23 f8			ld hl,(cli_ret_sp) 
194a 23				inc hl 
194b 23				inc hl 
194c 22 23 f8			ld (cli_ret_sp),hl 
194f 73				ld (hl), e 
1950 23				inc hl 
1951 72				ld (hl), d 
1952 d1				pop de 
1953 e1				pop hl 
1954				if DEBUG_FORTH_STACK_GUARD 
1954 cd 96 5f				call check_stacks 
1957				endif 
1957 c9				ret 
1958			 
1958			; get current ret stack pointer and save to hl  
1958				 
1958			FORTH_RSP_TOS: macro 
1958				call macro_forth_rsp_tos 
1958				endm 
1958			 
1958			macro_forth_rsp_tos: 
1958				;push de 
1958 2a 23 f8			ld hl,(cli_ret_sp) 
195b cd 93 19			call loadhlptrtohl 
195e				;ld e, (hl) 
195e				;inc hl 
195e				;ld d, (hl) 
195e				;ex de, hl 
195e					if DEBUG_FORTH_WORDS 
195e			;			DMARK "RST" 
195e						CALLMONITOR 
195e cd 00 14			call break_point_state  
1961				endm  
# End of macro CALLMONITOR
1961					endif 
1961				;pop de 
1961 c9				ret 
1962			 
1962			; pop ret stack pointer 
1962				 
1962			FORTH_RSP_POP: macro 
1962				call macro_forth_rsp_pop 
1962				endm 
1962			 
1962			 
1962			macro_forth_rsp_pop: 
1962				if DEBUG_FORTH_STACK_GUARD 
1962			;		DMARK "RPP" 
1962 cd 96 5f				call check_stacks 
1965					FORTH_CHK_RSP_UNDER 
1965 e5				push hl 
1966 d5				push de 
1967 2a 23 f8			ld hl,(cli_ret_sp) 
196a 11 9d f7			ld de, cli_ret_stack 
196d cd 30 0c			call cmp16 
1970 da aa 60			jp c, fault_rsp_under 
1973 d1				pop de 
1974 e1				pop hl 
1975				endm 
# End of macro FORTH_CHK_RSP_UNDER
1975				endif 
1975 e5				push hl 
1976 2a 23 f8			ld hl,(cli_ret_sp) 
1979			 
1979			 
1979				if FORTH_ENABLE_FREE 
1979			 
1979					; get pointer 
1979			 
1979					push de 
1979					push hl 
1979			 
1979					ld e, (hl) 
1979					inc hl 
1979					ld d, (hl) 
1979			 
1979					ex de, hl 
1979					call free 
1979			 
1979					pop hl 
1979					pop de 
1979			 
1979			 
1979				endif 
1979			 
1979			 
1979 2b				dec hl 
197a 2b				dec hl 
197b 22 23 f8			ld (cli_ret_sp), hl 
197e				; do stack underflow checks 
197e e1				pop hl 
197f				if DEBUG_FORTH_STACK_GUARD 
197f cd 96 5f				call check_stacks 
1982					FORTH_CHK_RSP_UNDER 
1982 e5				push hl 
1983 d5				push de 
1984 2a 23 f8			ld hl,(cli_ret_sp) 
1987 11 9d f7			ld de, cli_ret_stack 
198a cd 30 0c			call cmp16 
198d da aa 60			jp c, fault_rsp_under 
1990 d1				pop de 
1991 e1				pop hl 
1992				endm 
# End of macro FORTH_CHK_RSP_UNDER
1992				endif 
1992 c9				ret 
1993			 
1993			 
1993			 
1993			; routine to load word pointed to by hl into hl 
1993			 
1993			loadhlptrtohl: 
1993			 
1993 d5				push de 
1994 5e				ld e, (hl) 
1995 23				inc hl 
1996 56				ld d, (hl) 
1997 eb				ex de, hl 
1998 d1				pop de 
1999			 
1999 c9				ret 
199a			 
199a			 
199a			 
199a			 
199a			 
199a			; push a number held in HL onto the data stack 
199a			; entry point for pushing a value when already in hl used in function above 
199a			 
199a			forth_push_numhl: 
199a			 
199a e5				push hl    ; save value to push 
199b			 
199b			if DEBUG_FORTH_PUSH 
199b				; see if disabled 
199b			 
199b			 
199b				push af 
199b				ld a, (os_view_disable) 
199b				cp '*' 
199b				jr z, .pskip2 
199b				push hl 
199b			push hl 
199b				call clear_display 
199b			pop hl 
199b				ld a,h 
199b				ld hl, os_word_scratch 
199b				call hexout 
199b				pop hl 
199b				ld a,l 
199b				ld hl, os_word_scratch+2 
199b				call hexout 
199b			 
199b				ld hl, os_word_scratch+4 
199b				ld a,0 
199b				ld (hl),a 
199b				ld de,os_word_scratch 
199b					ld a, display_row_2 
199b					call str_at_display 
199b				ld de, .push_num 
199b				ld a, display_row_1 
199b			 
199b					call str_at_display 
199b			 
199b			 
199b				call update_display 
199b				call delay1s 
199b				call delay1s 
199b			.pskip2:  
199b			 
199b				pop af 
199b			endif	 
199b			 
199b			 
199b				FORTH_DSP_NEXT 
199b cd 29 19			call macro_forth_dsp_next 
199e				endm 
# End of macro FORTH_DSP_NEXT
199e			 
199e 2a 1f f8			ld hl, (cli_data_sp) 
19a1			 
19a1				; save item type 
19a1 3e 02			ld a,  DS_TYPE_INUM 
19a3 77				ld (hl), a 
19a4 23				inc hl 
19a5			 
19a5				; get word off stack 
19a5 d1				pop de 
19a6 7b				ld a,e 
19a7 77				ld (hl), a 
19a8 23				inc hl 
19a9 7a				ld a,d 
19aa 77				ld (hl), a 
19ab			 
19ab			if DEBUG_FORTH_PUSH 
19ab				dec hl 
19ab				dec hl 
19ab				dec hl 
19ab						DMARK "PH5" 
19ab				CALLMONITOR 
19ab			endif	 
19ab			 
19ab c9				ret 
19ac			 
19ac			 
19ac			; Push a string to stack pointed to by hl 
19ac			 
19ac			forth_push_str: 
19ac			 
19ac			if DEBUG_FORTH_PUSH 
19ac						DMARK "PSQ" 
19ac				CALLMONITOR 
19ac			endif	 
19ac			    
19ac e5				push hl 
19ad e5				push hl 
19ae			 
19ae 3e 00			ld a, 0   ; find end of string 
19b0 cd 7b 10			call strlent       
19b3			if DEBUG_FORTH_PUSH 
19b3						DMARK "PQ2" 
19b3				CALLMONITOR 
19b3			endif	 
19b3 eb				ex de, hl 
19b4 e1				pop hl   ; get ptr to start of string 
19b5			if DEBUG_FORTH_PUSH 
19b5						DMARK "PQ3" 
19b5				CALLMONITOR 
19b5			endif	 
19b5 19				add hl,de 
19b6			if DEBUG_FORTH_PUSH 
19b6						DMARK "PQE" 
19b6				CALLMONITOR 
19b6			endif	 
19b6			 
19b6 2b				dec hl    ; see if there is an optional trailing double quote 
19b7 7e				ld a,(hl) 
19b8 fe 22			cp '"' 
19ba 20 03			jr nz, .strnoq 
19bc 3e 00			ld a, 0      ; get rid of double quote 
19be 77				ld (hl), a 
19bf 23			.strnoq: inc hl 
19c0			 
19c0 3e 00			ld a, 0 
19c2 77				ld (hl), a     ; add null term and get rid of trailing double quote 
19c3			 
19c3 13				inc de ; add one for the type string 
19c4 13				inc de ; add one for null term??? 
19c5			 
19c5				; tos is get string pointer again 
19c5				; de contains space to allocate 
19c5				 
19c5 d5				push de 
19c6			 
19c6 eb				ex de, hl 
19c7			 
19c7				;push af 
19c7			 
19c7			if DEBUG_FORTH_PUSH 
19c7						DMARK "PHm" 
19c7				CALLMONITOR 
19c7			endif	 
19c7 cd d9 10			call malloc	; on ret hl now contains allocated memory 
19ca				if DEBUG_FORTH_MALLOC_GUARD 
19ca cc fc 4e				call z,malloc_error 
19cd				endif 
19cd			 
19cd				 
19cd c1				pop bc    ; get length 
19ce d1				pop de   ;  get string start    
19cf			 
19cf				; hl has destination from malloc 
19cf			 
19cf eb				ex de, hl    ; prep for ldir 
19d0			 
19d0 e5				push hl   ; save malloc area for DSP later 
19d1			 
19d1			if DEBUG_FORTH_PUSH 
19d1						DMARK "PHc" 
19d1				CALLMONITOR 
19d1			endif	 
19d1			 
19d1			 
19d1 ed b0			ldir 
19d3			 
19d3			 
19d3				; push malloc to data stack     macro?????  
19d3			 
19d3				FORTH_DSP_NEXT 
19d3 cd 29 19			call macro_forth_dsp_next 
19d6				endm 
# End of macro FORTH_DSP_NEXT
19d6			 
19d6				; save value and type 
19d6			 
19d6 2a 1f f8			ld hl, (cli_data_sp) 
19d9			 
19d9				; save item type 
19d9 3e 01			ld a,  DS_TYPE_STR 
19db 77				ld (hl), a 
19dc 23				inc hl 
19dd			 
19dd				; get malloc word off stack 
19dd d1				pop de 
19de 73				ld (hl), e 
19df 23				inc hl 
19e0 72				ld (hl), d 
19e1			 
19e1			 
19e1			 
19e1			if DEBUG_FORTH_PUSH 
19e1				ld hl, (cli_data_sp) 
19e1						DMARK "PHS" 
19e1				CALLMONITOR 
19e1			;	ex de,hl 
19e1			endif	 
19e1				; in case of spaces, skip the ptr past the copied string 
19e1				;pop af 
19e1				;ld (cli_origptr),hl 
19e1			 
19e1 c9				ret 
19e2			 
19e2			 
19e2			 
19e2			; TODO ascii push input onto stack given hl to start of input 
19e2			 
19e2			; identify type 
19e2			; if starts with a " then a string 
19e2			; otherwise it is a number 
19e2			;  
19e2			; if a string 
19e2			;     scan for ending " to get length of string to malloc for + 1 
19e2			;     malloc 
19e2			;     put pointer to string on stack first byte flags as string 
19e2			; 
19e2			; else a number 
19e2			;    look for number format identifier 
19e2			;    $xx hex 
19e2			;    %xxxxx bin 
19e2			;    xxxxx decimal 
19e2			;    convert number to 16bit word.  
19e2			;    malloc word + 1 with flag to identiy as num 
19e2			;    put pointer to number on stack 
19e2			;   
19e2			;  
19e2			  
19e2			forth_apush: 
19e2				; kernel push 
19e2			 
19e2			if DEBUG_FORTH_PUSH 
19e2						DMARK "PSH" 
19e2				CALLMONITOR 
19e2			endif	 
19e2				; identify input type 
19e2			 
19e2 7e				ld a,(hl) 
19e3 fe 22			cp '"' 
19e5 28 0a			jr z, .fapstr 
19e7 fe 24			cp '$' 
19e9 ca 11 1a			jp z, .faphex 
19ec fe 25			cp '%' 
19ee ca f9 19			jp z, .fapbin 
19f1			;	cp 'b' 
19f1			;	jp z, .fabin 
19f1				; else decimal 
19f1			 
19f1				; TODO do decimal conversion 
19f1				; decimal is stored as a 16bit word 
19f1			 
19f1				; by default everything is a string if type is not detected 
19f1			.fapstr: ; 
19f1 fe 22			cp '"' 
19f3 20 01			jr nz, .strnoqu 
19f5 23				inc hl 
19f6			.strnoqu: 
19f6 c3 ac 19			jp forth_push_str 
19f9			 
19f9			 
19f9			 
19f9			.fapbin:    ; push a binary string.  
19f9 11 00 00			ld de, 0   ; hold a 16bit value 
19fc			 
19fc 23			.fapbinshift:	inc hl  
19fd 7e				ld a,(hl) 
19fe fe 00			cp 0     ; done scanning  
1a00 28 0b			jr z, .fapbdone  	; got it in HL so push  
1a02			 
1a02				; left shift de 
1a02 eb				ex de, hl	 
1a03 29				add hl, hl 
1a04			 
1a04				; is 1 
1a04 fe 31			cp '1' 
1a06 20 02			jr nz, .binzero 
1a08 cb 4d			bit 1, l 
1a0a			.binzero: 
1a0a eb				ex de, hl	 ; save current de 
1a0b 18 ef			jr .fapbinshift 
1a0d			 
1a0d			.fapbdone: 
1a0d eb				ex de, hl 
1a0e c3 9a 19			jp forth_push_numhl 
1a11			 
1a11			 
1a11			.faphex:   ; hex is always stored as a 16bit word 
1a11				; skip number prefix 
1a11 23				inc hl 
1a12				; turn ascii into number 
1a12 cd c9 0f			call get_word_hl	; ret 16bit word in hl 
1a15			 
1a15 c3 9a 19			jp forth_push_numhl 
1a18			 
1a18 00				 nop 
1a19			 
1a19			.fabin:   ; TODO bin conversion 
1a19			 
1a19			 
1a19 c9				ret 
1a1a			 
1a1a			 
1a1a			; get either a string ptr or a 16bit word from the data stack 
1a1a			 
1a1a			FORTH_DSP: macro 
1a1a				call macro_forth_dsp 
1a1a				endm 
1a1a			 
1a1a			macro_forth_dsp: 
1a1a				; data stack pointer points to current word on tos 
1a1a			 
1a1a 2a 1f f8			ld hl,(cli_data_sp) 
1a1d			 
1a1d				if DEBUG_FORTH_PUSH 
1a1d						DMARK "DSP" 
1a1d			 
1a1d					call display_data_sp 
1a1d				;call break_point_state 
1a1d				;rst 030h 
1a1d				CALLMONITOR 
1a1d				endif 
1a1d			 
1a1d c9				ret 
1a1e			 
1a1e			; return hl to start of value on stack 
1a1e			 
1a1e			FORTH_DSP_VALUE: macro 
1a1e				call macro_forth_dsp_value 
1a1e				endm 
1a1e			 
1a1e			macro_forth_dsp_value: 
1a1e			 
1a1e				FORTH_DSP 
1a1e cd 1a 1a			call macro_forth_dsp 
1a21				endm 
# End of macro FORTH_DSP
1a21			 
1a21 d5				push de 
1a22			 
1a22 23				inc hl ; skip type 
1a23			 
1a23 5e				ld e, (hl) 
1a24 23				inc hl 
1a25 56				ld d, (hl) 
1a26 eb				ex de,hl  
1a27			 
1a27 d1				pop de 
1a28			 
1a28 c9				ret 
1a29			 
1a29			; return hl to start of value to second item on stack 
1a29			 
1a29			FORTH_DSP_VALUEM1: macro 
1a29				call macro_forth_dsp_value_m1 
1a29				endm 
1a29			 
1a29			macro_forth_dsp_value_m1: 
1a29			 
1a29				FORTH_DSP 
1a29 cd 1a 1a			call macro_forth_dsp 
1a2c				endm 
# End of macro FORTH_DSP
1a2c			 
1a2c 2b				dec hl 
1a2d 2b				dec hl 
1a2e			;	dec hl 
1a2e			 
1a2e d5				push de 
1a2f			 
1a2f 5e				ld e, (hl) 
1a30 23				inc hl 
1a31 56				ld d, (hl) 
1a32 eb				ex de,hl  
1a33			 
1a33 d1				pop de 
1a34			 
1a34 c9				ret 
1a35			 
1a35				 
1a35			 
1a35			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1a35			 
1a35			FORTH_DSP_POP: macro 
1a35				call macro_forth_dsp_pop 
1a35				endm 
1a35			 
1a35			 
1a35			; get the tos data type 
1a35			 
1a35			FORTH_DSP_TYPE:   macro 
1a35			 
1a35				;FORTH_DSP_VALUE 
1a35				FORTH_DSP 
1a35				 
1a35				; hl points to value 
1a35				; check type 
1a35			 
1a35				ld a,(hl) 
1a35			 
1a35				endm 
1a35			 
1a35			; load the tos value into hl 
1a35			 
1a35			 
1a35			FORTH_DSP_VALUEHL:  macro 
1a35				call macro_dsp_valuehl 
1a35				endm 
1a35			 
1a35			 
1a35			 
1a35			macro_dsp_valuehl: 
1a35				FORTH_DSP_VALUE 
1a35 cd 1e 1a			call macro_forth_dsp_value 
1a38				endm 
# End of macro FORTH_DSP_VALUE
1a38			 
1a38				;FORTH_ERR_TOS_NOTNUM 
1a38			 
1a38				;inc hl   ; skip type id 
1a38			 
1a38			;	push de 
1a38			; 
1a38			;	ld e, (hl) 
1a38			;	inc hl 
1a38			;	ld d, (hl) 
1a38			;	ex de,hl  
1a38			 
1a38			;	pop de 
1a38			 
1a38				if DEBUG_FORTH_PUSH 
1a38						DMARK "DVL" 
1a38				CALLMONITOR 
1a38				endif 
1a38 c9				ret 
1a39			 
1a39			forth_apushstrhl:      
1a39				; push of string requires use of cli_origptr 
1a39				; bodge use 
1a39			 
1a39				; get current cli_origptr, save, update with temp pointer  
1a39 ed 5b 3b f8		ld de, (cli_origptr) 
1a3d 22 3b f8			ld (cli_origptr), hl 
1a40 d5				push de 
1a41 cd e2 19			call forth_apush 
1a44 d1				pop de 
1a45 ed 53 3b f8		ld (cli_origptr), de 
1a49 c9			        ret	 
1a4a			 
1a4a			 
1a4a			; increase loop stack pointer and save hl to it 
1a4a				 
1a4a			FORTH_LOOP_NEXT: macro 
1a4a				call macro_forth_loop_next 
1a4a				;nop 
1a4a				endm 
1a4a			 
1a4a			macro_forth_loop_next: 
1a4a				if DEBUG_FORTH_STACK_GUARD 
1a4a cd 96 5f				call check_stacks 
1a4d				endif 
1a4d e5				push hl 
1a4e d5				push de 
1a4f eb				ex de,hl 
1a50 2a 21 f8			ld hl,(cli_loop_sp) 
1a53 23				inc hl 
1a54 23				inc hl 
1a55					if DEBUG_FORTH_WORDS 
1a55						DMARK "LNX" 
1a55 f5				push af  
1a56 3a 6a 1a			ld a, (.dmark)  
1a59 32 77 fb			ld (debug_mark),a  
1a5c 3a 6b 1a			ld a, (.dmark+1)  
1a5f 32 78 fb			ld (debug_mark+1),a  
1a62 3a 6c 1a			ld a, (.dmark+2)  
1a65 32 79 fb			ld (debug_mark+2),a  
1a68 18 03			jr .pastdmark  
1a6a ..			.dmark: db "LNX"  
1a6d f1			.pastdmark: pop af  
1a6e			endm  
# End of macro DMARK
1a6e						CALLMONITOR 
1a6e cd 00 14			call break_point_state  
1a71				endm  
# End of macro CALLMONITOR
1a71					endif 
1a71 22 21 f8			ld (cli_loop_sp),hl 
1a74 73				ld (hl), e 
1a75 23				inc hl 
1a76 72				ld (hl), d 
1a77 d1				pop de    ; been reversed so save a swap on restore 
1a78 e1				pop hl 
1a79				if DEBUG_FORTH_STACK_GUARD 
1a79 cd 96 5f				call check_stacks 
1a7c				endif 
1a7c c9				ret 
1a7d			 
1a7d			; get current ret stack pointer and save to hl  
1a7d				 
1a7d			FORTH_LOOP_TOS: macro 
1a7d				call macro_forth_loop_tos 
1a7d				endm 
1a7d			 
1a7d			macro_forth_loop_tos: 
1a7d d5				push de 
1a7e 2a 21 f8			ld hl,(cli_loop_sp) 
1a81 5e				ld e, (hl) 
1a82 23				inc hl 
1a83 56				ld d, (hl) 
1a84 eb				ex de, hl 
1a85 d1				pop de 
1a86 c9				ret 
1a87			 
1a87			; pop loop stack pointer 
1a87				 
1a87			FORTH_LOOP_POP: macro 
1a87				call macro_forth_loop_pop 
1a87				endm 
1a87			 
1a87			 
1a87			macro_forth_loop_pop: 
1a87				if DEBUG_FORTH_STACK_GUARD 
1a87					DMARK "LPP" 
1a87 f5				push af  
1a88 3a 9c 1a			ld a, (.dmark)  
1a8b 32 77 fb			ld (debug_mark),a  
1a8e 3a 9d 1a			ld a, (.dmark+1)  
1a91 32 78 fb			ld (debug_mark+1),a  
1a94 3a 9e 1a			ld a, (.dmark+2)  
1a97 32 79 fb			ld (debug_mark+2),a  
1a9a 18 03			jr .pastdmark  
1a9c ..			.dmark: db "LPP"  
1a9f f1			.pastdmark: pop af  
1aa0			endm  
# End of macro DMARK
1aa0 cd 96 5f				call check_stacks 
1aa3					FORTH_CHK_LOOP_UNDER 
1aa3 e5				push hl 
1aa4 d5				push de 
1aa5 2a 21 f8			ld hl,(cli_loop_sp) 
1aa8 11 9b f5			ld de, cli_loop_stack 
1aab cd 30 0c			call cmp16 
1aae da b0 60			jp c, fault_loop_under 
1ab1 d1				pop de 
1ab2 e1				pop hl 
1ab3				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ab3				endif 
1ab3 e5				push hl 
1ab4 2a 21 f8			ld hl,(cli_loop_sp) 
1ab7 2b				dec hl 
1ab8 2b				dec hl 
1ab9 22 21 f8			ld (cli_loop_sp), hl 
1abc				; TODO do stack underflow checks 
1abc e1				pop hl 
1abd				if DEBUG_FORTH_STACK_GUARD 
1abd cd 96 5f				call check_stacks 
1ac0					FORTH_CHK_LOOP_UNDER 
1ac0 e5				push hl 
1ac1 d5				push de 
1ac2 2a 21 f8			ld hl,(cli_loop_sp) 
1ac5 11 9b f5			ld de, cli_loop_stack 
1ac8 cd 30 0c			call cmp16 
1acb da b0 60			jp c, fault_loop_under 
1ace d1				pop de 
1acf e1				pop hl 
1ad0				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1ad0				endif 
1ad0 c9				ret 
1ad1			 
1ad1			macro_forth_dsp_pop: 
1ad1			 
1ad1 e5				push hl 
1ad2			 
1ad2				; release malloc data 
1ad2			 
1ad2				if DEBUG_FORTH_STACK_GUARD 
1ad2 cd 96 5f				call check_stacks 
1ad5					FORTH_CHK_DSP_UNDER 
1ad5 e5				push hl 
1ad6 d5				push de 
1ad7 2a 1f f8			ld hl,(cli_data_sp) 
1ada 11 99 f3			ld de, cli_data_stack 
1add cd 30 0c			call cmp16 
1ae0 da a4 60			jp c, fault_dsp_under 
1ae3 d1				pop de 
1ae4 e1				pop hl 
1ae5				endm 
# End of macro FORTH_CHK_DSP_UNDER
1ae5				endif 
1ae5				;ld hl,(cli_data_sp) 
1ae5			if DEBUG_FORTH_DOT 
1ae5				DMARK "DPP" 
1ae5				CALLMONITOR 
1ae5			endif	 
1ae5			 
1ae5			 
1ae5			if FORTH_ENABLE_DSPPOPFREE 
1ae5			 
1ae5				FORTH_DSP 
1ae5 cd 1a 1a			call macro_forth_dsp 
1ae8				endm 
# End of macro FORTH_DSP
1ae8			 
1ae8 7e				ld a, (hl) 
1ae9 fe 01			cp DS_TYPE_STR 
1aeb 20 07			jr nz, .skippopfree 
1aed			 
1aed				FORTH_DSP_VALUEHL 
1aed cd 35 1a			call macro_dsp_valuehl 
1af0				endm 
# End of macro FORTH_DSP_VALUEHL
1af0 00				nop 
1af1			if DEBUG_FORTH_DOT 
1af1				DMARK "DPf" 
1af1				CALLMONITOR 
1af1			endif	 
1af1 cd a3 11			call free 
1af4			.skippopfree: 
1af4				 
1af4			 
1af4			endif 
1af4			 
1af4			if DEBUG_FORTH_DOT_KEY 
1af4				DMARK "DP2" 
1af4				CALLMONITOR 
1af4			endif	 
1af4			 
1af4				; move pointer down 
1af4			 
1af4 2a 1f f8			ld hl,(cli_data_sp) 
1af7 2b				dec hl 
1af8 2b				dec hl 
1af9			; PARSEV5 
1af9 2b				dec hl 
1afa 22 1f f8			ld (cli_data_sp), hl 
1afd			 
1afd				if DEBUG_FORTH_STACK_GUARD 
1afd cd 96 5f				call check_stacks 
1b00					FORTH_CHK_DSP_UNDER 
1b00 e5				push hl 
1b01 d5				push de 
1b02 2a 1f f8			ld hl,(cli_data_sp) 
1b05 11 99 f3			ld de, cli_data_stack 
1b08 cd 30 0c			call cmp16 
1b0b da a4 60			jp c, fault_dsp_under 
1b0e d1				pop de 
1b0f e1				pop hl 
1b10				endm 
# End of macro FORTH_CHK_DSP_UNDER
1b10				endif 
1b10			 
1b10 e1				pop hl 
1b11			 
1b11 c9				ret 
1b12			 
1b12			getwordathl: 
1b12				; hl points to an address 
1b12				; load hl with the word at that address 
1b12			 
1b12 d5				push de 
1b13			 
1b13 5e				ld e, (hl) 
1b14 23				inc hl 
1b15 56				ld d, (hl) 
1b16 eb				ex de, hl 
1b17			 
1b17 d1				pop de 
1b18 c9				ret 
1b19			 
1b19			 
1b19			 
1b19			 
1b19			 
1b19			; eof 
1b19			 
# End of file forth_stackopsv5.asm
1b19			endif 
1b19			 
1b19			user_word_eol:  
1b19				; hl contains the pointer to where to create a linked list item from the end 
1b19				; of the user dict to continue on at the system word dict 
1b19				 
1b19				; poke the stub of the word list linked list to repoint to rom words 
1b19			 
1b19				; stub format 
1b19				; db   word id 
1b19				; dw    link to next word 
1b19			        ; db char length of token 
1b19				; db string + 0 term 
1b19				; db exec code....  
1b19			 
1b19 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1b1b 77				ld (hl), a		; word id 
1b1c 23				inc hl 
1b1d			 
1b1d 11 e3 1c			ld de, sysdict 
1b20 73				ld (hl), e		; next word link ie system dict 
1b21 23				inc hl 
1b22 72				ld (hl), d		; next word link ie system dict 
1b23 23				inc hl	 
1b24			 
1b24			;	ld (hl), sysdict		; next word link ie system dict 
1b24			;	inc hl 
1b24			;	inc hl 
1b24			 
1b24			;	inc hl 
1b24			;	inc hl 
1b24			 
1b24 3e 02			ld a, 2			; word length is 0 
1b26 77				ld (hl), a	 
1b27 23				inc hl 
1b28			 
1b28 3e 7e			ld a, '~'			; word length is 0 
1b2a 77				ld (hl), a	 
1b2b 23				inc hl 
1b2c 3e 00			ld a, 0			; save empty word 
1b2e 77				ld (hl), a 
1b2f			 
1b2f c9				ret 
1b30			 
1b30				 
1b30			 
1b30			forthexec_cleanup: 
1b30				FORTH_RSP_POP 
1b30 cd 62 19			call macro_forth_rsp_pop 
1b33				endm 
# End of macro FORTH_RSP_POP
1b33 c9				ret 
1b34			 
1b34			forth_call_hl: 
1b34				; taking hl 
1b34 e5				push hl 
1b35 c9				ret 
1b36			 
1b36			; this is called to reset Forth system but keep existing uwords etc 
1b36			 
1b36			forth_warmstart: 
1b36				; setup stack over/under flow checks 
1b36				if DEBUG_FORTH_STACK_GUARD 
1b36 cd 7c 5f				call chk_stk_init 
1b39				endif 
1b39			 
1b39				; init stack pointers  - * these stacks go upwards *  
1b39 21 9d f7			ld hl, cli_ret_stack 
1b3c 22 23 f8			ld (cli_ret_sp), hl	 
1b3f				; set bottom of stack 
1b3f 3e 00			ld a,0 
1b41 77				ld (hl),a 
1b42 23				inc hl 
1b43 77				ld (hl),a 
1b44			 
1b44 21 99 f3			ld hl, cli_data_stack 
1b47 22 1f f8			ld (cli_data_sp), hl	 
1b4a				; set bottom of stack 
1b4a 3e 00			ld a,0 
1b4c 77				ld (hl),a 
1b4d 23				inc hl 
1b4e 77				ld (hl),a 
1b4f			 
1b4f 21 9b f5			ld hl, cli_loop_stack 
1b52 22 21 f8			ld (cli_loop_sp), hl	 
1b55				; set bottom of stack 
1b55 3e 00			ld a,0 
1b57 77				ld (hl),a 
1b58 23				inc hl 
1b59 77				ld (hl),a 
1b5a			 
1b5a				; init extent of current open file 
1b5a			 
1b5a 3e 00			ld a, 0 
1b5c 32 59 f8			ld (store_openext), a 
1b5f			 
1b5f c9				ret 
1b60			 
1b60			 
1b60			; Cold Start - this is called to setup the whole Forth system 
1b60			 
1b60			forth_init: 
1b60			 
1b60				; setup stack over/under flow checks 
1b60			 
1b60			;	if DEBUG_FORTH_STACK_GUARD 
1b60			;		call chk_stk_init 
1b60			;	endif 
1b60			 
1b60				; enable auto display updates (slow.....) 
1b60			 
1b60 3e 01			ld a, 1 
1b62 32 39 f8			ld (cli_autodisplay), a 
1b65			 
1b65			 
1b65			 
1b65				; show start up screen 
1b65			 
1b65 cd b9 0a			call clear_display 
1b68			 
1b68 3e 00			ld a,0 
1b6a 32 5b f8			ld (f_cursor_ptr), a 
1b6d			 
1b6d				; set start of word list in start of ram - for use when creating user words 
1b6d			 
1b6d 21 00 80			ld hl, baseram 
1b70 22 2f f1			ld (os_last_new_uword), hl 
1b73 cd 19 1b			call user_word_eol 
1b76				 
1b76			;		call display_data_sp 
1b76			;		call next_page_prompt 
1b76			 
1b76			 
1b76			 
1b76			 
1b76 c9				ret 
1b77			 
1b77 .. 00		.bootforth: db " Forth Kernel Init ",0 
1b8b			 
1b8b			; TODO push to stack 
1b8b			 
1b8b			;  
1b8b			 
1b8b			if FORTH_PARSEV2 
1b8b			 
1b8b			 
1b8b				include "forth_parserv2.asm" 
1b8b			 
1b8b			endif 
1b8b			 
1b8b			 
1b8b			; parse cli version 1 
1b8b			 
1b8b			if FORTH_PARSEV1 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv1.asm" 
1b8b			endif 
1b8b				 
1b8b			if FORTH_PARSEV3 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv3.asm" 
1b8b				include "forth_wordsv3.asm" 
1b8b			endif 
1b8b			 
1b8b			if FORTH_PARSEV4 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv4.asm" 
1b8b				include "forth_wordsv4.asm" 
1b8b			endif 
1b8b			 
1b8b			if FORTH_PARSEV5 
1b8b			 
1b8b			 
1b8b			 
1b8b			      include "forth_parserv5.asm" 
1b8b			 
1b8b			 
1b8b			; A better parser without using malloc and string copies all over the place.  
1b8b			; Exec in situ should be faster 
1b8b			 
1b8b			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1b8b			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1b8b			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1b8b			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1b8b			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1b8b			WORD_SYS_END: equ 0   ; Opcode for all user words 
1b8b			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1b8b			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1b8b			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1b8b			 
1b8b			; Core word preamble macro 
1b8b			 
1b8b			CWHEAD:   macro nxtword opcode lit len opflags 
1b8b				db WORD_SYS_CORE+opcode             
1b8b				; internal op code number 
1b8b				dw nxtword            
1b8b				; link to next dict word block 
1b8b				db len + 1 
1b8b				; literal length of dict word inc zero term 
1b8b				db lit,0              
1b8b				; literal dict word 
1b8b			        ; TODO db opflags        
1b8b				endm 
1b8b			 
1b8b			 
1b8b			NEXTW: macro  
1b8b				jp macro_next 
1b8b				endm 
1b8b			 
1b8b			macro_next: 
1b8b			if DEBUG_FORTH_PARSE_KEY 
1b8b				DMARK "NXT" 
1b8b				CALLMONITOR 
1b8b			endif	 
1b8b			;	inc hl  ; skip token null term  
1b8b ed 4b 3d f8		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1b8f ed 5b 3b f8		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1b93 2a 33 f1			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1b96			if DEBUG_FORTH_PARSE_KEY 
1b96				DMARK "}AA" 
1b96				CALLMONITOR 
1b96			endif	 
1b96 c3 99 1c			jp execnext 
1b99				;jp exec1 
1b99			       
1b99			 
1b99			 
1b99			; Another go at the parser to compile  
1b99			 
1b99			 
1b99			; TODO rework parser to change all of the string words to byte tokens 
1b99			; TODO do a search for  
1b99			 
1b99			; TODO first run normal parser to zero term sections 
1b99			; TODO for each word do a token look up to get the op code 
1b99			; TODO need some means to flag to the exec that this is a byte code form    
1b99			 
1b99			 
1b99			forthcompile: 
1b99			 
1b99			; 
1b99			; line parse: 
1b99			;       parse raw input buffer 
1b99			;       tokenise the words 
1b99			;       malloc new copy (for looping etc) 
1b99			;       copy to malloc + current pc in line to start of string and add line term 
1b99			;       save on new rsp 
1b99			; 
1b99			 
1b99			; hl to point to the line to tokenise 
1b99			 
1b99			;	push hl 
1b99 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1b9c			 
1b9c			;	ld a,0		; string term on input 
1b9c			;	call strlent 
1b9c			 
1b9c			;	ld (os_tok_len), hl	 ; save string length 
1b9c			 
1b9c			;if DEBUG_FORTH_TOK 
1b9c			;	ex de,hl		 
1b9c			;endif 
1b9c			 
1b9c			;	pop hl 		; get back string pointer 
1b9c			 
1b9c			if DEBUG_FORTH_TOK 
1b9c						DMARK "TOc" 
1b9c				CALLMONITOR 
1b9c			endif 
1b9c 7e			.cptoken2:    ld a,(hl) 
1b9d 23				inc hl 
1b9e fe 7f			cp FORTH_END_BUFFER 
1ba0 28 29			jr z, .cptokendone2 
1ba2 fe 00			cp 0 
1ba4 28 25			jr z, .cptokendone2 
1ba6 fe 22			cp '"' 
1ba8 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1baa fe 20			cp ' ' 
1bac 20 ee			jr nz,  .cptoken2 
1bae			 
1bae			; TODO consume comments held between ( and ) 
1bae			 
1bae				; we have a space so change to zero term for dict match later 
1bae 2b				dec hl 
1baf 3e 00			ld a,0 
1bb1 77				ld (hl), a 
1bb2 23				inc hl 
1bb3 18 e7			jr .cptoken2 
1bb5				 
1bb5			 
1bb5			.cptokenstr2: 
1bb5				; skip all white space until either eol (because forgot to term) or end double quote 
1bb5			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1bb5				;inc hl ; skip current double quote 
1bb5 7e				ld a,(hl) 
1bb6 23				inc hl 
1bb7 fe 22			cp '"' 
1bb9 28 e1			jr z, .cptoken2 
1bbb fe 7f			cp FORTH_END_BUFFER 
1bbd 28 0c			jr z, .cptokendone2 
1bbf fe 00			cp 0 
1bc1 28 08			jr z, .cptokendone2 
1bc3 fe 20			cp ' ' 
1bc5 28 02			jr z, .cptmp2 
1bc7 18 ec			jr .cptokenstr2 
1bc9			 
1bc9			.cptmp2:	; we have a space so change to zero term for dict match later 
1bc9				;dec hl 
1bc9				;ld a,"-"	; TODO remove this when working 
1bc9				;ld (hl), a 
1bc9				;inc hl 
1bc9 18 ea			jr .cptokenstr2 
1bcb			 
1bcb			.cptokendone2: 
1bcb				;inc hl 
1bcb 3e 7f			ld a, FORTH_END_BUFFER 
1bcd 77				ld (hl),a 
1bce 23				inc hl 
1bcf 3e 21			ld a, '!' 
1bd1 77				ld (hl),a 
1bd2			 
1bd2 2a 33 f1			ld hl,(os_tok_ptr) 
1bd5			         
1bd5			if DEBUG_FORTH_TOK 
1bd5						DMARK "Tc1" 
1bd5				CALLMONITOR 
1bd5			endif 
1bd5			 
1bd5				; push exec string to top of return stack 
1bd5				FORTH_RSP_NEXT 
1bd5 cd 41 19			call macro_forth_rsp_next 
1bd8				endm 
# End of macro FORTH_RSP_NEXT
1bd8 c9				ret 
1bd9			 
1bd9			; Another go at the parser need to simplify the process 
1bd9			 
1bd9			forthparse: 
1bd9			 
1bd9			; 
1bd9			; line parse: 
1bd9			;       parse raw input buffer 
1bd9			;       tokenise the words 
1bd9			;       malloc new copy (for looping etc) 
1bd9			;       copy to malloc + current pc in line to start of string and add line term 
1bd9			;       save on new rsp 
1bd9			; 
1bd9			 
1bd9			; hl to point to the line to tokenise 
1bd9			 
1bd9			;	push hl 
1bd9 22 33 f1			ld (os_tok_ptr), hl  ; save ptr to string 
1bdc			 
1bdc			;	ld a,0		; string term on input 
1bdc			;	call strlent 
1bdc			 
1bdc			;	ld (os_tok_len), hl	 ; save string length 
1bdc			 
1bdc			;if DEBUG_FORTH_TOK 
1bdc			;	ex de,hl		 
1bdc			;endif 
1bdc			 
1bdc			;	pop hl 		; get back string pointer 
1bdc			 
1bdc			if DEBUG_FORTH_TOK 
1bdc						DMARK "TOK" 
1bdc				CALLMONITOR 
1bdc			endif 
1bdc 7e			.ptoken2:    ld a,(hl) 
1bdd 23				inc hl 
1bde fe 7f			cp FORTH_END_BUFFER 
1be0 28 29			jr z, .ptokendone2 
1be2 fe 00			cp 0 
1be4 28 25			jr z, .ptokendone2 
1be6 fe 22			cp '"' 
1be8 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1bea fe 20			cp ' ' 
1bec 20 ee			jr nz,  .ptoken2 
1bee			 
1bee			; TODO consume comments held between ( and ) 
1bee			 
1bee				; we have a space so change to zero term for dict match later 
1bee 2b				dec hl 
1bef 3e 00			ld a,0 
1bf1 77				ld (hl), a 
1bf2 23				inc hl 
1bf3 18 e7			jr .ptoken2 
1bf5				 
1bf5			 
1bf5			.ptokenstr2: 
1bf5				; skip all white space until either eol (because forgot to term) or end double quote 
1bf5			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1bf5				;inc hl ; skip current double quote 
1bf5 7e				ld a,(hl) 
1bf6 23				inc hl 
1bf7 fe 22			cp '"' 
1bf9 28 e1			jr z, .ptoken2 
1bfb fe 7f			cp FORTH_END_BUFFER 
1bfd 28 0c			jr z, .ptokendone2 
1bff fe 00			cp 0 
1c01 28 08			jr z, .ptokendone2 
1c03 fe 20			cp ' ' 
1c05 28 02			jr z, .ptmp2 
1c07 18 ec			jr .ptokenstr2 
1c09			 
1c09			.ptmp2:	; we have a space so change to zero term for dict match later 
1c09				;dec hl 
1c09				;ld a,"-"	; TODO remove this when working 
1c09				;ld (hl), a 
1c09				;inc hl 
1c09 18 ea			jr .ptokenstr2 
1c0b			 
1c0b			.ptokendone2: 
1c0b				;inc hl 
1c0b 3e 7f			ld a, FORTH_END_BUFFER 
1c0d 77				ld (hl),a 
1c0e 23				inc hl 
1c0f 3e 21			ld a, '!' 
1c11 77				ld (hl),a 
1c12			 
1c12 2a 33 f1			ld hl,(os_tok_ptr) 
1c15			         
1c15			if DEBUG_FORTH_TOK 
1c15						DMARK "TK1" 
1c15				CALLMONITOR 
1c15			endif 
1c15			 
1c15				; push exec string to top of return stack 
1c15				FORTH_RSP_NEXT 
1c15 cd 41 19			call macro_forth_rsp_next 
1c18				endm 
# End of macro FORTH_RSP_NEXT
1c18 c9				ret 
1c19			 
1c19			; 
1c19			;	; malloc size + buffer pointer + if is loop flag 
1c19			;	ld hl,(os_tok_len) 		 ; get string length 
1c19			; 
1c19			;	ld a,l 
1c19			; 
1c19			;	cp 0			; we dont want to use a null string 
1c19			;	ret z 
1c19			; 
1c19			;;	add 3    ; prefix malloc with buffer for current word ptr 
1c19			; 
1c19			;	add 5     ; TODO when certain not over writing memory remove 
1c19			; 
1c19			;		 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKE" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	ld l,a 
1c19			;	ld h,0 
1c19			;;	push hl   ; save required space for the copy later 
1c19			;	call malloc 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKM" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			;	if DEBUG_FORTH_MALLOC_GUARD 
1c19			;		push af 
1c19			;		call ishlzero 
1c19			;;		ld a, l 
1c19			;;		add h 
1c19			;;		cp 0 
1c19			;		pop af 
1c19			;		 
1c19			;		call z,malloc_error 
1c19			;	endif 
1c19			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1c19			; 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKR" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	FORTH_RSP_NEXT 
1c19			; 
1c19			;	;inc hl	 ; go past current buffer pointer 
1c19			;	;inc hl 
1c19			;	;inc hl   ; and past if loop flag 
1c19			;		; TODO Need to set flag  
1c19			; 
1c19			;	 
1c19			;	 
1c19			;	ex de,hl	; malloc is dest 
1c19			;	ld hl, (os_tok_len) 
1c19			;;	pop bc 
1c19			;	ld c, l                
1c19			;	ld b,0 
1c19			;	ld hl, (os_tok_ptr) 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			;			DMARK "TKT" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	; do str cpy 
1c19			; 
1c19			;	ldir      ; copy byte in hl to de 
1c19			; 
1c19			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1c19			; 
1c19			;if DEBUG_FORTH_TOK 
1c19			; 
1c19			;			DMARK "TKY" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			;	;ld a,0 
1c19			;	;ld a,FORTH_END_BUFFER 
1c19			;	ex de, hl 
1c19			;	;dec hl			 ; go back over the space delim at the end of word 
1c19			;	;ld (hl),a 
1c19			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1c19			;	ld a,FORTH_END_BUFFER 
1c19			;	ld (hl),a 
1c19			;	inc hl 
1c19			;	ld a,FORTH_END_BUFFER 
1c19			;	ld (hl),a 
1c19			; 
1c19			;	; init the malloc area data 
1c19			;	; set pc for in current area 
1c19			;	;ld hl, (os_tok_malloc) 
1c19			;	;inc hl 
1c19			;	;inc hl 
1c19			;	;inc hl 
1c19			;	;ex de,hl 
1c19			;	;ld hl, (os_tok_malloc) 
1c19			;	;ld (hl),e 
1c19			;	;inc hl 
1c19			;	;ld (hl),d 
1c19			; 
1c19			; 
1c19			;	ld hl,(os_tok_malloc) 
1c19			;if DEBUG_FORTH_PARSE_KEY 
1c19			;			DMARK "TKU" 
1c19			;	CALLMONITOR 
1c19			;endif 
1c19			; 
1c19			;	ret 
1c19			 
1c19			forthexec: 
1c19			 
1c19			; line exec: 
1c19			; forth parser 
1c19			 
1c19			; 
1c19			;       get current exec line on rsp 
1c19			 
1c19				FORTH_RSP_TOS 
1c19 cd 58 19			call macro_forth_rsp_tos 
1c1c				endm 
# End of macro FORTH_RSP_TOS
1c1c			 
1c1c			;       restore current pc - hl points to malloc of data 
1c1c			 
1c1c				;ld e, (hl) 
1c1c				;inc hl 
1c1c				;ld d, (hl) 
1c1c				;ex de,hl 
1c1c			 
1c1c			 
1c1c			exec1: 
1c1c 22 33 f1			ld (os_tok_ptr), hl 
1c1f			 
1c1f				; copy our PC to working vars  
1c1f 22 3d f8			ld (cli_ptr), hl 
1c22 22 3b f8			ld (cli_origptr), hl 
1c25			 
1c25 7e				ld a,(hl) 
1c26 fe 7f			cp FORTH_END_BUFFER 
1c28 c8				ret z 
1c29			 
1c29				; skip any nulls 
1c29			 
1c29 fe 00			cp 0 
1c2b 20 03			jr nz, .execword 
1c2d 23				inc hl 
1c2e 18 ec			jr exec1 
1c30			 
1c30			 
1c30			.execword: 
1c30			 
1c30			 
1c30			 
1c30			if DEBUG_FORTH_PARSE_KEY 
1c30						DMARK "KYQ" 
1c30				CALLMONITOR 
1c30			endif 
1c30			;       while at start of word: 
1c30			; get start of dict (in user area first) 
1c30			 
1c30 21 00 80		ld hl, baseram 
1c33			;ld hl, sysdict 
1c33 22 3f f8		ld (cli_nextword),hl 
1c36			;           match word at pc 
1c36			;           exec word 
1c36			;           or push to dsp 
1c36			;           forward to next token 
1c36			;           if line term pop rsp and exit 
1c36			;        
1c36			 
1c36			if DEBUG_FORTH_PARSE_KEY 
1c36						DMARK "KYq" 
1c36				CALLMONITOR 
1c36			endif 
1c36			 
1c36			; 
1c36			; word comp 
1c36			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1c36			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1c36			;    move to start of word  
1c36			;    compare word to cli_token 
1c36			 
1c36			.execpnword:	; HL at start of a word in the dictionary to check 
1c36			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1c36			;	ld (cli_ptr), hl 
1c36			 
1c36 2a 3f f8			ld hl,(cli_nextword) 
1c39			 
1c39 cd dc 1c			call forth_tok_next 
1c3c			; tok next start here 
1c3c			;	; TODO skip compiled symbol for now 
1c3c			;	inc hl 
1c3c			; 
1c3c			;	; save pointer to next word 
1c3c			; 
1c3c			;	; hl now points to the address of the next word pointer  
1c3c			;	ld e, (hl) 
1c3c			;	inc hl 
1c3c			;	ld d, (hl) 
1c3c			;	inc l 
1c3c			; 
1c3c			;	ex de,hl 
1c3c			;if DEBUG_FORTH_PARSE_NEXTWORD 
1c3c			;	push bc 
1c3c			;	ld bc, (cli_nextword) 
1c3c			;			DMARK "NXW" 
1c3c			;	CALLMONITOR 
1c3c			;	pop bc 
1c3c			;endif 
1c3c			; tok next end here 
1c3c 22 3f f8			ld (cli_nextword), hl     ; save for next check if no match on this word 
1c3f eb				ex de, hl 
1c40			 
1c40			 
1c40				; save the pointer of the current token - 1 to check against 
1c40				 
1c40 22 43 f8			ld (cli_token), hl   
1c43				; TODO maybe remove below save if no debug 
1c43				; save token string ptr for any debug later 
1c43 23				inc hl  
1c44 22 45 f8			ld (cli_origtoken), hl 
1c47 2b				dec hl 
1c48				; save pointer to the start of the next dictionay word 
1c48 7e				ld a,(hl)   ; get string length 
1c49 47				ld b,a 
1c4a			.execpnwordinc:  
1c4a 23				inc hl 
1c4b 10 fd			djnz .execpnwordinc 
1c4d 22 41 f8			ld (cli_execword), hl      ; save start of this words code 
1c50			 
1c50				; now check the word token against the string being parsed 
1c50			 
1c50 2a 43 f8			ld hl,(cli_token) 
1c53 23				inc hl     ; skip string length (use zero term instead to end) 
1c54 22 43 f8			ld (cli_token), hl 
1c57			 
1c57			if DEBUG_FORTH_PARSE_KEY 
1c57						DMARK "KY2" 
1c57			endif 
1c57			if DEBUG_FORTH_PARSE_EXEC 
1c57				; see if disabled 
1c57			 
1c57				ld a, (os_view_disable) 
1c57				cp '*' 
1c57				jr z, .skip 
1c57			 
1c57				push hl 
1c57				push hl 
1c57				call clear_display 
1c57				ld de, .compword 
1c57				ld a, display_row_1 
1c57				call str_at_display 
1c57				pop de 
1c57				ld a, display_row_2 
1c57				call str_at_display 
1c57				ld hl,(cli_ptr) 
1c57				ld a,(hl) 
1c57			        ld hl, os_word_scratch 
1c57				ld (hl),a 
1c57				ld a,0 
1c57				inc hl 
1c57				ld (hl),a 	 
1c57				ld de, os_word_scratch 
1c57				ld a, display_row_2+10 
1c57				call str_at_display 
1c57				call update_display 
1c57				ld a, 100 
1c57				call aDelayInMS 
1c57				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c57				call delay250ms 
1c57				endif 
1c57				pop hl 
1c57			.skip:  
1c57			endif	 
1c57			.execpnchar:    ; compare char between token and string to parse 
1c57			 
1c57			if DEBUG_FORTH_PARSE_KEY 
1c57						DMARK "Ky3" 
1c57			endif 
1c57			if DEBUG_FORTH_PARSE_EXEC 
1c57				; see if disabled 
1c57			 
1c57				ld a, (os_view_disable) 
1c57				cp '*' 
1c57				jr z, .skip2 
1c57			 
1c57			;	call clear_display 
1c57			ld hl,(cli_token) 
1c57			ld a,(hl) 
1c57			ld (os_word_scratch),a 
1c57				ld hl,(cli_ptr) 
1c57			ld a,(hl) 
1c57				ld (os_word_scratch+1),a 
1c57				ld a,0 
1c57				ld (os_word_scratch+2),a 
1c57				ld de,os_word_scratch 
1c57				ld a,display_row_4 
1c57				call str_at_display 
1c57				call update_display 
1c57			.skip2:  
1c57			endif 
1c57 2a 43 f8			ld hl,(cli_token) 
1c5a 7e				ld a, (hl)	 ; char in word token 
1c5b 23				inc hl 		; move to next char 
1c5c 22 43 f8			ld (cli_token), hl ; and save it 
1c5f 47				ld b,a 
1c60			 
1c60 2a 3d f8			ld hl,(cli_ptr) ;	get the char from the string to parse 
1c63 7e				ld a,(hl) 
1c64 23				inc hl 
1c65 22 3d f8			ld (cli_ptr), hl		; move to next char 
1c68 cd 67 10			call toUpper 		; make sure the input string matches case 
1c6b			 
1c6b			if DEBUG_FORTH_PARSE 
1c6b			endif 
1c6b			 
1c6b				; input stream end of token is a space so get rid of it 
1c6b			 
1c6b			;	cp ' ' 
1c6b			;	jr nz, .pnskipspace 
1c6b			; 
1c6b			;	ld a, 0		; make same term as word token term 
1c6b			; 
1c6b			;.pnskipspace: 
1c6b			 
1c6b			if DEBUG_FORTH_PARSE_KEY 
1c6b						DMARK "KY7" 
1c6b			endif 
1c6b b8				cp b 
1c6c c2 82 1c			jp nz, .execpnskipword	 ; no match so move to next word 
1c6f				 
1c6f			;    if same 
1c6f			;       scan for string terms 0 for token and 32 for input 
1c6f			 
1c6f				 
1c6f			if DEBUG_FORTH_PARSE_KEY 
1c6f						DMARK "KY8" 
1c6f			endif 
1c6f			 
1c6f 80				add b			 
1c70 fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1c72							; TODO need to make sure last word in zero term string is accounted for 
1c72 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1c74			 
1c74			 
1c74				; at end of both strings so both are exact match 
1c74			 
1c74			;       skip ptr for next word 
1c74			 
1c74 2a 3d f8			ld hl,(cli_ptr) 	; at input string term 
1c77 23				inc hl			 ; at next char 
1c78 22 3d f8			ld (cli_ptr), hl     ; save for next round of the parser 
1c7b 22 3b f8			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1c7e				 
1c7e				 
1c7e			if DEBUG_FORTH_PARSE_KEY 
1c7e						DMARK "KY3" 
1c7e			endif 
1c7e			 
1c7e			 
1c7e			 
1c7e			;       exec code block 
1c7e			if DEBUG_FORTH_JP 
1c7e				call clear_display 
1c7e				call update_display 
1c7e				call delay1s 
1c7e				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c7e				ld a,h 
1c7e				ld hl, os_word_scratch 
1c7e				call hexout 
1c7e				ld hl, (cli_execword)     ; save for next check if no match on this word 
1c7e				ld a,l 
1c7e				ld hl, os_word_scratch+2 
1c7e				call hexout 
1c7e				ld hl, os_word_scratch+4 
1c7e				ld a,0 
1c7e				ld (hl),a 
1c7e				ld de,os_word_scratch 
1c7e				call str_at_display 
1c7e					ld a, display_row_2 
1c7e					call str_at_display 
1c7e				ld de, (cli_origtoken) 
1c7e				ld a, display_row_1+10 
1c7e					call str_at_display 
1c7e			 
1c7e				ld a,display_row_1 
1c7e				ld de, .foundword 
1c7e				ld a, display_row_3 
1c7e				call str_at_display 
1c7e				call update_display 
1c7e				call delay1s 
1c7e				call delay1s 
1c7e				call delay1s 
1c7e			endif 
1c7e			 
1c7e			if DEBUG_FORTH_PARSE_KEY 
1c7e						DMARK "KYj" 
1c7e			endif 
1c7e				; TODO save the word pointer in this exec 
1c7e			 
1c7e 2a 41 f8			ld hl,(cli_execword) 
1c81 e9				jp (hl) 
1c82			 
1c82			 
1c82			;    if not same 
1c82			;	scan for zero term 
1c82			;	get ptr for next word 
1c82			;	goto word comp 
1c82			 
1c82			.execpnskipword:	; get pointer to next word 
1c82 2a 3f f8			ld hl,(cli_nextword) 
1c85			 
1c85 7e				ld a,(hl) 
1c86 fe 00			cp WORD_SYS_END 
1c88			;	cp 0 
1c88 28 09			jr z, .execendofdict			 ; at end of words 
1c8a			 
1c8a			if DEBUG_FORTH_PARSE_KEY 
1c8a						DMARK "KY4" 
1c8a			endif 
1c8a			if DEBUG_FORTH_PARSE_EXEC 
1c8a			 
1c8a				; see if disabled 
1c8a			 
1c8a				ld a, (os_view_disable) 
1c8a				cp '*' 
1c8a				jr z, .noskip 
1c8a			 
1c8a			 
1c8a				ld de, .nowordfound 
1c8a				ld a, display_row_3 
1c8a				call str_at_display 
1c8a				call update_display 
1c8a				ld a, 100 
1c8a				call aDelayInMS 
1c8a				 
1c8a				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c8a					call delay250ms 
1c8a				endif 
1c8a			.noskip:  
1c8a			 
1c8a			endif	 
1c8a			 
1c8a 2a 3b f8			ld hl,(cli_origptr) 
1c8d 22 3d f8			ld (cli_ptr),hl 
1c90			 
1c90			if DEBUG_FORTH_PARSE_KEY 
1c90						DMARK "KY5" 
1c90			endif 
1c90 c3 36 1c			jp .execpnword			; else go to next word 
1c93			 
1c93			.execendofdict:  
1c93			 
1c93			if DEBUG_FORTH_PARSE_KEY 
1c93						DMARK "KYe" 
1c93			endif 
1c93			if DEBUG_FORTH_PARSE_EXEC 
1c93				; see if disabled 
1c93			 
1c93				ld a, (os_view_disable) 
1c93				cp '*' 
1c93				jr z, .ispskip 
1c93			 
1c93				call clear_display 
1c93				call update_display 
1c93				call delay1s 
1c93				ld de, (cli_origptr) 
1c93				ld a, display_row_1 
1c93				call str_at_display 
1c93				 
1c93				ld de, .enddict 
1c93				ld a, display_row_3 
1c93				call str_at_display 
1c93				call update_display 
1c93				ld a, 100 
1c93				call aDelayInMS 
1c93				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1c93				call delay1s 
1c93				call delay1s 
1c93				call delay1s 
1c93				endif 
1c93			.ispskip:  
1c93				 
1c93			endif	 
1c93			 
1c93			 
1c93			 
1c93				; if the word is not a keyword then must be a literal so push it to stack 
1c93			 
1c93			; push token to stack to end of word 
1c93			 
1c93				STACKFRAME ON $1efe $2f9f 
1c93				if DEBUG_STACK_IMB 
1c93					if ON 
1c93						exx 
1c93						ld de, $1efe 
1c93						ld a, d 
1c93						ld hl, curframe 
1c93						call hexout 
1c93						ld a, e 
1c93						ld hl, curframe+2 
1c93						call hexout 
1c93						ld hl, $1efe 
1c93						push hl 
1c93						ld hl, $2f9f 
1c93						push hl 
1c93						exx 
1c93					endif 
1c93				endif 
1c93			endm 
# End of macro STACKFRAME
1c93			 
1c93 2a 33 f1		ld hl,(os_tok_ptr) 
1c96 cd e2 19		call forth_apush 
1c99			 
1c99				STACKFRAMECHK ON $1efe $2f9f 
1c99				if DEBUG_STACK_IMB 
1c99					if ON 
1c99						exx 
1c99						ld hl, $2f9f 
1c99						pop de   ; $2f9f 
1c99						call cmp16 
1c99						jr nz, .spnosame 
1c99						ld hl, $1efe 
1c99						pop de   ; $1efe 
1c99						call cmp16 
1c99						jr z, .spfrsame 
1c99						.spnosame: call showsperror 
1c99						.spfrsame: nop 
1c99						exx 
1c99					endif 
1c99				endif 
1c99			endm 
# End of macro STACKFRAMECHK
1c99			 
1c99			execnext: 
1c99			 
1c99			if DEBUG_FORTH_PARSE_KEY 
1c99						DMARK "KY>" 
1c99			endif 
1c99			; move past token to next word 
1c99			 
1c99 2a 33 f1		ld hl, (os_tok_ptr) 
1c9c 3e 00		ld a, 0 
1c9e 01 ff 00		ld bc, 255     ; input buffer size 
1ca1 ed b1		cpir 
1ca3			 
1ca3			if DEBUG_FORTH_PARSE_KEY 
1ca3						DMARK "KY!" 
1ca3				CALLMONITOR 
1ca3			endif	 
1ca3			; TODO this might place hl on the null, so will need to forward on??? 
1ca3			;inc hl   ; see if this gets onto the next item 
1ca3			 
1ca3			 
1ca3			; TODO pass a pointer to the buffer to push 
1ca3			; TODO call function to push 
1ca3			 
1ca3			; look for end of input 
1ca3			 
1ca3			;inc hl 
1ca3			;ld a,(hl) 
1ca3			;cp FORTH_END_BUFFER 
1ca3			;ret z 
1ca3			 
1ca3			 
1ca3 c3 1c 1c		jp exec1 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			 
1ca6			findnexttok: 
1ca6			 
1ca6				; hl is pointer to move 
1ca6				; de is the token to locate 
1ca6			 
1ca6					if DEBUG_FORTH 
1ca6						DMARK "NTK" 
1ca6						CALLMONITOR 
1ca6					endif 
1ca6 d5				push de 
1ca7			 
1ca7			.fnt1:	 
1ca7				; find first char of token to locate 
1ca7			 
1ca7 1a				ld a, (de) 
1ca8 4f				ld c,a 
1ca9 7e				ld a,(hl) 
1caa cd 67 10			call toUpper 
1cad					if DEBUG_FORTH 
1cad						DMARK "NT1" 
1cad						CALLMONITOR 
1cad					endif 
1cad b9				cp c 
1cae			 
1cae 28 03			jr z, .fnt2cmpmorefirst	 
1cb0			 
1cb0				; first char not found move to next char 
1cb0			 
1cb0 23				inc hl 
1cb1 18 f4			jr .fnt1 
1cb3			 
1cb3			.fnt2cmpmorefirst:	 
1cb3				; first char of token found.  
1cb3			 
1cb3 e5				push hl     ; save start of token just in case it is the right one 
1cb4 d9				exx 
1cb5 e1				pop hl        ; save it to hl' 
1cb6 d9				exx 
1cb7			 
1cb7			 
1cb7			.fnt2cmpmore:	 
1cb7				; compare the rest 
1cb7				 
1cb7 23				inc hl 
1cb8 13				inc de 
1cb9				 
1cb9 1a				ld a, (de) 
1cba 4f				ld c,a 
1cbb 7e				ld a,(hl) 
1cbc cd 67 10			call toUpper 
1cbf			 
1cbf					if DEBUG_FORTH 
1cbf						DMARK "NT2" 
1cbf						CALLMONITOR 
1cbf					endif 
1cbf				; c has the token to find char 
1cbf				; a has the mem to scan char 
1cbf			 
1cbf b9				cp c 
1cc0 28 04			jr z,.fntmatch1 
1cc2			 
1cc2				; they are not the same 
1cc2			 
1cc2					if DEBUG_FORTH 
1cc2						DMARK "NT3" 
1cc2						CALLMONITOR 
1cc2					endif 
1cc2 d1				pop de	; reset de token to look for 
1cc3 d5				push de 
1cc4 18 e1			jr .fnt1 
1cc6				 
1cc6			.fntmatch1: 
1cc6			 
1cc6				; is the same char a null which means we might have a full hit? 
1cc6					if DEBUG_FORTH 
1cc6						DMARK "NT4" 
1cc6						CALLMONITOR 
1cc6					endif 
1cc6			 
1cc6 fe 00			cp 0 
1cc8 28 0b			jr z, .fntmatchyes 
1cca			 
1cca				; are we at the end of the token to find? 
1cca			 
1cca					if DEBUG_FORTH 
1cca						DMARK "NT5" 
1cca						CALLMONITOR 
1cca					endif 
1cca 3e 00			ld a, 0 
1ccc b9				cp c 
1ccd			 
1ccd c2 b7 1c			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1cd0			 
1cd0					if DEBUG_FORTH 
1cd0						DMARK "NT6" 
1cd0						CALLMONITOR 
1cd0					endif 
1cd0				; token to find is exhusted but no match to stream 
1cd0			 
1cd0				; restore tok pointer and continue on 
1cd0 d1				pop de 
1cd1 d5				push de 
1cd2 c3 a7 1c			jp .fnt1 
1cd5			 
1cd5			 
1cd5			.fntmatchyes: 
1cd5			 
1cd5				; hl now contains the end of the found token 
1cd5			 
1cd5				; get rid of saved token pointer to find 
1cd5			 
1cd5 d1				pop de 
1cd6			 
1cd6					if DEBUG_FORTH 
1cd6						DMARK "NT9" 
1cd6						CALLMONITOR 
1cd6					endif 
1cd6			 
1cd6				; hl will be on the null term so forward on 
1cd6			 
1cd6				; get back the saved start of the token 
1cd6			 
1cd6 d9				exx 
1cd7 e5				push hl     ; save start of token just in case it is the right one 
1cd8 d9				exx 
1cd9 e1				pop hl        ; save it to hl 
1cda			 
1cda c9				ret 
1cdb			 
1cdb			 
1cdb			; LIST needs to find a specific token   
1cdb			; FORGET needs to find a spefici token 
1cdb			 
1cdb			; SAVE needs to find all tokens by flag 
1cdb			; WORDS just needs to scan through all  by flag 
1cdb			; UWORDS needs to scan through all by flag 
1cdb			 
1cdb			 
1cdb			; given hl as pointer to start of dict look up string 
1cdb			; return hl as pointer to start of word block 
1cdb			; or 0 if not found 
1cdb			 
1cdb			forth_find_tok: 
1cdb c9				ret 
1cdc			 
1cdc			; given hl as pointer to dict structure 
1cdc			; move to the next dict block structure 
1cdc			 
1cdc			forth_tok_next: 
1cdc				; hl now points to the address of the next word pointer  
1cdc				; TODO skip compiled symbol for now 
1cdc			;	push de 
1cdc 23				inc hl 
1cdd 5e				ld e, (hl) 
1cde 23				inc hl 
1cdf 56				ld d, (hl) 
1ce0 23				inc hl 
1ce1			 
1ce1 eb				ex de,hl 
1ce2			if DEBUG_FORTH_PARSE_NEXTWORD 
1ce2				push bc 
1ce2				ld bc, (cli_nextword) 
1ce2						DMARK "NXW" 
1ce2				CALLMONITOR 
1ce2				pop bc 
1ce2			endif 
1ce2			;	pop de	 
1ce2 c9				ret 
1ce3			 
1ce3			 
1ce3			 
1ce3			; eof 
# End of file forth_parserv5.asm
1ce3				include "forth_wordsv4.asm" 
1ce3			 
1ce3			; the core word dictionary v4 
1ce3			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1ce3			 
1ce3			; this is a linked list for each of the system words used 
1ce3			; user defined words will follow the same format but will be in ram 
1ce3			 
1ce3			 
1ce3			; 
1ce3			; 
1ce3			; define linked list: 
1ce3			; 
1ce3			; 1. compiled byte op code 
1ce3			; 2. len of text word 
1ce3			; 3. text word 
1ce3			; 4. ptr to next dictionary word 
1ce3			; 5. asm, calls etc for the word 
1ce3			; 
1ce3			;  if 1 == 0 then last word in dict  
1ce3			;   
1ce3			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1ce3			;  
1ce3			;  
1ce3			; create basic standard set of words 
1ce3			; 
1ce3			;  
1ce3			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1ce3			; 2DUP 2DROP 2SWAP  
1ce3			; @ C@ - get byte  
1ce3			; ! C! - store byte 
1ce3			; 0< true if less than zero 
1ce3			; 0= true if zero 
1ce3			; < >  
1ce3			; = true if same 
1ce3			; variables 
1ce3			 
1ce3			 
1ce3			; Hardware specific words I may need 
1ce3			; 
1ce3			; IN OUT  
1ce3			; calls to key util functions 
1ce3			; calls to hardward abstraction stuff 
1ce3			; easy control of frame buffers and lcd i/o 
1ce3			; keyboard  
1ce3			 
1ce3			 
1ce3			;DICT: macro 
1ce3			; op_code, len, word, next 
1ce3			;    word: 
1ce3			;    db op_code 
1ce3			;    ds word zero term 
1ce3			;    dw next 
1ce3			;    endm 
1ce3			 
1ce3			 
1ce3			 
1ce3			 
1ce3			; op code 1 is a flag for user define words which are to be handled differently 
1ce3			 
1ce3			 
1ce3			; 
1ce3			; 
1ce3			;    TODO on entry to a word this should be the expected environment 
1ce3			;    hl - tos value if number then held, if string this is the ptr 
1ce3			;    de -  
1ce3			 
1ce3			 
1ce3			; opcode ranges 
1ce3			; 0 - end of word dict 
1ce3			; 255 - user define words 
1ce3			 
1ce3			sysdict: 
1ce3			include "forth_opcodes.asm" 
1ce3			; op codes for forth keywords 
1ce3			; free to use code 0  
1ce3				OPCODE_HEAP: equ  1 
1ce3				OPCODE_EXEC: equ 2 
1ce3				OPCODE_DUP: equ 3 
1ce3				OPCODE_SWAP: equ 4 
1ce3				OPCODE_COLN: equ 5 
1ce3				OPCODE_SCOLN: equ 6 
1ce3				OPCODE_DROP: equ 7 
1ce3				OPCODE_DUP2: equ 8 
1ce3				OPCODE_DROP2: equ 9 
1ce3				OPCODE_SWAP2: equ 10 
1ce3				OPCODE_AT: equ 11 
1ce3				OPCODE_CAT: equ 12 
1ce3				OPCODE_BANG: equ 13 
1ce3				OPCODE_CBANG: equ 14 
1ce3				OPCODE_SCALL: equ 15 
1ce3				OPCODE_DEPTH: equ 16 
1ce3				OPCODE_OVER: equ 17 
1ce3				OPCODE_PAUSE: equ 18 
1ce3				OPCODE_PAUSES: equ 19 
1ce3				OPCODE_ROT: equ 20 
1ce3			;free to reuse	OPCODE_WORDS: equ 21 
1ce3			        OPCODE_NOT: equ 21 
1ce3				OPCODE_UWORDS: equ 22 
1ce3				OPCODE_BP: equ 23 
1ce3				OPCODE_MONITOR: equ 24  
1ce3				OPCODE_MALLOC: equ 25 
1ce3				OPCODE_FREE: equ 26 
1ce3				OPCODE_LIST: equ 27 
1ce3				OPCODE_FORGET: equ 28 
1ce3				OPCODE_NOP: equ 29 
1ce3				OPCODE_COMO: equ 30 
1ce3				OPCODE_COMC: equ 31 
1ce3			;free to reuse	OPCODE_ENDCORE: equ 32 
1ce3				OPCODE_AFTERSOUND: equ 33 
1ce3				OPCODE_GP2: equ 34 
1ce3				OPCODE_GP3: equ 35 
1ce3				OPCODE_GP4: equ 36 
1ce3				OPCODE_SIN: equ 37 
1ce3				OPCODE_SOUT: equ 38 
1ce3				OPCODE_SPIO: equ 39 
1ce3				OPCODE_SPICEH: equ 40 
1ce3				OPCODE_SPIOb: equ 41 
1ce3				OPCODE_SPII: equ 42 
1ce3				OPCODE_SESEL: equ 43 
1ce3				OPCODE_CARTDEV: equ 44 
1ce3			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1ce3				OPCODE_FB: equ 46 
1ce3				OPCODE_EMIT: equ 47 
1ce3				OPCODE_DOTH: equ 48 
1ce3				OPCODE_DOTF: equ 49 
1ce3				OPCODE_DOT: equ 50 
1ce3				OPCODE_CLS: equ 51 
1ce3				OPCODE_DRAW: equ 52 
1ce3				OPCODE_DUMP: equ 53 
1ce3				OPCODE_CDUMP: equ 54 
1ce3				OPCODE_DAT: equ 55 
1ce3				OPCODE_HOME: equ 56 
1ce3				OPCODE_SPACE: equ 57 
1ce3				OPCODE_SPACES: equ 58 
1ce3				OPCODE_SCROLL: equ 59 
1ce3				OPCODE_ATQ: equ 60 
1ce3				OPCODE_AUTODSP: equ 61 
1ce3				OPCODE_MENU: equ 62 
1ce3			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1ce3				OPCODE_THEN: equ 64 
1ce3				OPCODE_ELSE: equ 65 
1ce3				OPCODE_DO: equ 66 
1ce3				OPCODE_LOOP: equ 67 
1ce3				OPCODE_I: equ 68 
1ce3				OPCODE_DLOOP: equ 69  
1ce3				OPCODE_REPEAT: equ 70  
1ce3				OPCODE_UNTIL: equ 71 
1ce3				OPCODE_ENDFLOW: equ 72 
1ce3				OPCODE_WAITK: equ 73 
1ce3				OPCODE_ACCEPT: equ 74 
1ce3				OPCODE_EDIT: equ 75 
1ce3			;free to reuse	OPCODE_ENDKEY: equ 76 
1ce3				OPCODE_LZERO: equ 77 
1ce3				OPCODE_TZERO: equ 78 
1ce3				OPCODE_LESS: equ 79 
1ce3				OPCODE_GT: equ 80 
1ce3				OPCODE_EQUAL: equ 81  
1ce3			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1ce3				OPCODE_NEG: equ 83 
1ce3				OPCODE_DIV: equ 84 
1ce3				OPCODE_MUL: equ 85 
1ce3				OPCODE_MIN: equ 86 
1ce3				OPCODE_MAX: equ 87 
1ce3				OPCODE_RND16: equ 88 
1ce3				OPCODE_RND8: equ 89 
1ce3				OPCODE_RND: equ 90 
1ce3			;free to reuse	OPCODE_ENDMATHS: equ 91  
1ce3				OPCODE_BYNAME: equ 92 
1ce3				OPCODE_DIR: equ 93 
1ce3				OPCODE_SAVE: equ 94 
1ce3				OPCODE_LOAD: equ 95 
1ce3				OPCODE_BSAVE: equ 96 
1ce3				OPCODE_BLOAD: equ 97 
1ce3				OPCODE_SEO: equ 98  
1ce3				OPCODE_SEI: equ 99 
1ce3				OPCODE_SFREE: equ 100 
1ce3				OPCODE_SIZE: equ 101 
1ce3				OPCODE_CREATE: equ 102 
1ce3				OPCODE_APPEND: equ 103 
1ce3				OPCODE_SDEL: equ 104 
1ce3				OPCODE_OPEN: equ 105 
1ce3				OPCODE_READ: equ 106 
1ce3				OPCODE_EOF: equ 106 
1ce3				OPCODE_FORMAT: equ 107 
1ce3				OPCODE_LABEL: equ 108 
1ce3				OPCODE_LABELS: equ 109 
1ce3			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1ce3				OPCODE_UPPER: equ 111 
1ce3				OPCODE_LOWER: equ 112 
1ce3				OPCODE_SUBSTR: equ 113 
1ce3				OPCODE_LEFT: equ 114 
1ce3				OPCODE_RIGHT: equ 115 
1ce3				OPCODE_STR2NUM: equ 116 
1ce3				OPCODE_NUM2STR: equ 117 
1ce3				OPCODE_CONCAT: equ 118 
1ce3				OPCODE_FIND: equ 119 
1ce3				OPCODE_LEN: equ 120 
1ce3				OPCODE_CHAR: equ 121 
1ce3			; free to reuse	OPCODE_STRLEN: equ 122 
1ce3			; free to reuse	OPCODE_ENDSTR: equ 123 
1ce3				OPCODE_V0S: equ 124 
1ce3				OPCODE_V0Q: equ 125 
1ce3				OPCODE_V1S: equ 126 
1ce3				OPCODE_V1Q: equ 127 
1ce3				OPCODE_V2S: equ 128 
1ce3				OPCODE_V2Q: equ 129 
1ce3				OPCODE_V3S: equ 130 
1ce3				OPCODE_V3Q: equ 131 
1ce3			;free to reuse	OPCODE_END: equ 132 
1ce3				OPCODE_ZDUP: equ 133 
1ce3			 
1ce3			; eof 
# End of file forth_opcodes.asm
1ce3			 
1ce3			include "forth_words_core.asm" 
1ce3			 
1ce3			; | ## Core Words 
1ce3			 
1ce3			;if MALLOC_4 
1ce3			 
1ce3			.HEAP: 
1ce3				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1ce3 15				db WORD_SYS_CORE+OPCODE_HEAP             
1ce4 22 1d			dw .EXEC            
1ce6 05				db 4 + 1 
1ce7 .. 00			db "HEAP",0              
1cec				endm 
# End of macro CWHEAD
1cec			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1cec			; | | u1 - Current number of bytes in the heap 
1cec			; | | u2 - Remaining bytes left on the heap 
1cec			; | |  
1cec			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1cec			 
1cec			 
1cec					if DEBUG_FORTH_WORDS_KEY 
1cec						DMARK "HEP" 
1cec f5				push af  
1ced 3a 01 1d			ld a, (.dmark)  
1cf0 32 77 fb			ld (debug_mark),a  
1cf3 3a 02 1d			ld a, (.dmark+1)  
1cf6 32 78 fb			ld (debug_mark+1),a  
1cf9 3a 03 1d			ld a, (.dmark+2)  
1cfc 32 79 fb			ld (debug_mark+2),a  
1cff 18 03			jr .pastdmark  
1d01 ..			.dmark: db "HEP"  
1d04 f1			.pastdmark: pop af  
1d05			endm  
# End of macro DMARK
1d05						CALLMONITOR 
1d05 cd 00 14			call break_point_state  
1d08				endm  
# End of macro CALLMONITOR
1d08					endif 
1d08 2a 0a 80				ld hl, (free_list )      
1d0b 11 0e 80				ld de, heap_start 
1d0e			 
1d0e ed 52				sbc hl, de  
1d10			 
1d10 cd 9a 19				call forth_push_numhl 
1d13			 
1d13			 
1d13 ed 5b 0a 80			ld de, (free_list )      
1d17 21 26 ee				ld hl, heap_end 
1d1a			 
1d1a ed 52				sbc hl, de 
1d1c			 
1d1c cd 9a 19				call forth_push_numhl 
1d1f					 
1d1f			 
1d1f					 
1d1f			 
1d1f			 
1d1f			 
1d1f					NEXTW 
1d1f c3 8b 1b			jp macro_next 
1d22				endm 
# End of macro NEXTW
1d22			;endif 
1d22			 
1d22			.EXEC: 
1d22				CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1d22 16				db WORD_SYS_CORE+OPCODE_EXEC             
1d23 be 1d			dw .STKEXEC            
1d25 05				db 4 + 1 
1d26 .. 00			db "EXEC",0              
1d2b				endm 
# End of macro CWHEAD
1d2b			; | EXEC ( u -- )    Execs the string on TOS as a FORTH expression | CRASHES ON NEXTW 
1d2b			; | | u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1d2b			; | | 
1d2b			; | |   
1d2b				STACKFRAME OFF $5efe $5f9f 
1d2b				if DEBUG_STACK_IMB 
1d2b					if OFF 
1d2b						exx 
1d2b						ld de, $5efe 
1d2b						ld a, d 
1d2b						ld hl, curframe 
1d2b						call hexout 
1d2b						ld a, e 
1d2b						ld hl, curframe+2 
1d2b						call hexout 
1d2b						ld hl, $5efe 
1d2b						push hl 
1d2b						ld hl, $5f9f 
1d2b						push hl 
1d2b						exx 
1d2b					endif 
1d2b				endif 
1d2b			endm 
# End of macro STACKFRAME
1d2b			 
1d2b					if DEBUG_FORTH_WORDS_KEY 
1d2b						DMARK "EXE" 
1d2b f5				push af  
1d2c 3a 40 1d			ld a, (.dmark)  
1d2f 32 77 fb			ld (debug_mark),a  
1d32 3a 41 1d			ld a, (.dmark+1)  
1d35 32 78 fb			ld (debug_mark+1),a  
1d38 3a 42 1d			ld a, (.dmark+2)  
1d3b 32 79 fb			ld (debug_mark+2),a  
1d3e 18 03			jr .pastdmark  
1d40 ..			.dmark: db "EXE"  
1d43 f1			.pastdmark: pop af  
1d44			endm  
# End of macro DMARK
1d44						CALLMONITOR 
1d44 cd 00 14			call break_point_state  
1d47				endm  
# End of macro CALLMONITOR
1d47					endif 
1d47			 
1d47				FORTH_DSP_VALUEHL 
1d47 cd 35 1a			call macro_dsp_valuehl 
1d4a				endm 
# End of macro FORTH_DSP_VALUEHL
1d4a			 
1d4a				FORTH_DSP_POP 
1d4a cd d1 1a			call macro_forth_dsp_pop 
1d4d				endm 
# End of macro FORTH_DSP_POP
1d4d			 
1d4d					if DEBUG_FORTH_WORDS 
1d4d						DMARK "EX1" 
1d4d f5				push af  
1d4e 3a 62 1d			ld a, (.dmark)  
1d51 32 77 fb			ld (debug_mark),a  
1d54 3a 63 1d			ld a, (.dmark+1)  
1d57 32 78 fb			ld (debug_mark+1),a  
1d5a 3a 64 1d			ld a, (.dmark+2)  
1d5d 32 79 fb			ld (debug_mark+2),a  
1d60 18 03			jr .pastdmark  
1d62 ..			.dmark: db "EX1"  
1d65 f1			.pastdmark: pop af  
1d66			endm  
# End of macro DMARK
1d66						CALLMONITOR 
1d66 cd 00 14			call break_point_state  
1d69				endm  
# End of macro CALLMONITOR
1d69					endif 
1d69			;	ld e,(hl) 
1d69			;	inc hl 
1d69			;	ld d,(hl) 
1d69			;	ex de,hl 
1d69			 
1d69			;		if DEBUG_FORTH_WORDS 
1d69			;			DMARK "EX2" 
1d69			;			CALLMONITOR 
1d69			;		endif 
1d69 e5				push hl 
1d6a			 
1d6a				;ld a, 0 
1d6a				;ld a, FORTH_END_BUFFER 
1d6a cd 70 10			call strlenz 
1d6d 23				inc hl   ; include zero term to copy 
1d6e 23				inc hl   ; include term 
1d6f 23				inc hl   ; include term 
1d70 06 00			ld b,0 
1d72 4d				ld c,l 
1d73 e1				pop hl 
1d74 11 31 ef			ld de, execscratch 
1d77					if DEBUG_FORTH_WORDS 
1d77						DMARK "EX3" 
1d77 f5				push af  
1d78 3a 8c 1d			ld a, (.dmark)  
1d7b 32 77 fb			ld (debug_mark),a  
1d7e 3a 8d 1d			ld a, (.dmark+1)  
1d81 32 78 fb			ld (debug_mark+1),a  
1d84 3a 8e 1d			ld a, (.dmark+2)  
1d87 32 79 fb			ld (debug_mark+2),a  
1d8a 18 03			jr .pastdmark  
1d8c ..			.dmark: db "EX3"  
1d8f f1			.pastdmark: pop af  
1d90			endm  
# End of macro DMARK
1d90						CALLMONITOR 
1d90 cd 00 14			call break_point_state  
1d93				endm  
# End of macro CALLMONITOR
1d93					endif 
1d93 ed b0			ldir 
1d95			 
1d95			 
1d95 21 31 ef			ld hl, execscratch 
1d98			 
1d98					if DEBUG_FORTH_WORDS 
1d98						DMARK "EXe" 
1d98 f5				push af  
1d99 3a ad 1d			ld a, (.dmark)  
1d9c 32 77 fb			ld (debug_mark),a  
1d9f 3a ae 1d			ld a, (.dmark+1)  
1da2 32 78 fb			ld (debug_mark+1),a  
1da5 3a af 1d			ld a, (.dmark+2)  
1da8 32 79 fb			ld (debug_mark+2),a  
1dab 18 03			jr .pastdmark  
1dad ..			.dmark: db "EXe"  
1db0 f1			.pastdmark: pop af  
1db1			endm  
# End of macro DMARK
1db1						CALLMONITOR 
1db1 cd 00 14			call break_point_state  
1db4				endm  
# End of macro CALLMONITOR
1db4					endif 
1db4			 
1db4 cd d9 1b			call forthparse 
1db7 cd 19 1c			call forthexec 
1dba			;	call forthexec_cleanup 
1dba			;	call forthparse 
1dba			;	call forthexec 
1dba			 
1dba				STACKFRAMECHK OFF $5efe $5f9f 
1dba				if DEBUG_STACK_IMB 
1dba					if OFF 
1dba						exx 
1dba						ld hl, $5f9f 
1dba						pop de   ; $5f9f 
1dba						call cmp16 
1dba						jr nz, .spnosame 
1dba						ld hl, $5efe 
1dba						pop de   ; $5efe 
1dba						call cmp16 
1dba						jr z, .spfrsame 
1dba						.spnosame: call showsperror 
1dba						.spfrsame: nop 
1dba						exx 
1dba					endif 
1dba				endif 
1dba			endm 
# End of macro STACKFRAMECHK
1dba			 
1dba				; an immediate word so no need to process any more words 
1dba c9				ret 
1dbb				NEXTW 
1dbb c3 8b 1b			jp macro_next 
1dbe				endm 
# End of macro NEXTW
1dbe			 
1dbe			; dead code - old version  
1dbe			;	FORTH_RSP_NEXT 
1dbe			 
1dbe			;  
1dbe			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1dbe			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1dbe			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1dbe			;	push hl 
1dbe			;	push de 
1dbe			;	push bc 
1dbe			; 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS_KEY 
1dbe			;			DMARK "EXR" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			; 
1dbe			; 
1dbe			; 
1dbe			;	;v5 FORTH_DSP_VALUE 
1dbe			;	FORTH_DSP_VALUEHL 
1dbe			; 
1dbe			;	; TODO do string type checks 
1dbe			; 
1dbe			;;v5	inc hl   ; skip type 
1dbe			; 
1dbe			;	push hl  ; source code  
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX1" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			;	ld a, 0 
1dbe			;	call strlent 
1dbe			; 
1dbe			;	inc hl 
1dbe			;	inc hl 
1dbe			;	inc hl 
1dbe			;	inc hl 
1dbe			; 
1dbe			;	push hl    ; size 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX2" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			;	call malloc 
1dbe			; 
1dbe			;	ex de, hl    ; de now contains malloc area 
1dbe			;	pop bc   	; get byte count 
1dbe			;	pop hl      ; get string to copy 
1dbe			; 
1dbe			;	push de     ; save malloc for free later 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX3" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			;	ldir       ; duplicate string 
1dbe			; 
1dbe			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1dbe			;	 
1dbe			;	; TODO fix the parse would be better than this...  
1dbe			;	ex de, hl 
1dbe			;	dec hl 
1dbe			;	ld a, 0 
1dbe			;	ld (hl), a 
1dbe			;	dec hl 
1dbe			;	ld a, ' ' 
1dbe			;	ld (hl), a 
1dbe			;	dec hl 
1dbe			;	ld (hl), a 
1dbe			; 
1dbe			;	dec hl 
1dbe			;	ld (hl), a 
1dbe			; 
1dbe			; 
1dbe			;	FORTH_DSP_POP  
1dbe			; 
1dbe			;	pop hl     
1dbe			;	push hl    ; save malloc area 
1dbe			; 
1dbe			;		if DEBUG_FORTH_WORDS 
1dbe			;			DMARK "EX4" 
1dbe			;			CALLMONITOR 
1dbe			;		endif 
1dbe			; 
1dbe			;	call forthparse 
1dbe			;	call forthexec 
1dbe			;	 
1dbe			;	pop hl 
1dbe			;	if DEBUG_FORTH_WORDS 
1dbe			;		DMARK "EX5" 
1dbe			;		CALLMONITOR 
1dbe			;	endif 
1dbe			; 
1dbe			;	if FORTH_ENABLE_FREE 
1dbe			;	call free 
1dbe			;	endif 
1dbe			; 
1dbe			;	if DEBUG_FORTH_WORDS 
1dbe			;		DMARK "EX6" 
1dbe			;		CALLMONITOR 
1dbe			;	endif 
1dbe			; 
1dbe			;	pop bc 
1dbe			;	pop de 
1dbe			;	pop hl 
1dbe			;;	FORTH_RSP_POP	  
1dbe			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1dbe			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1dbe			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1dbe			; 
1dbe			;	if DEBUG_FORTH_WORDS 
1dbe			;		DMARK "EX7" 
1dbe			;		CALLMONITOR 
1dbe			;	endif 
1dbe			;	NEXTW 
1dbe			 
1dbe			.STKEXEC: 
1dbe				CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1dbe 3f				db WORD_SYS_CORE+43             
1dbf 06 1f			dw .ZDUP            
1dc1 08				db 7 + 1 
1dc2 .. 00			db "STKEXEC",0              
1dca				endm 
# End of macro CWHEAD
1dca			; | STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code | TO TEST 
1dca			 
1dca			 
1dca					if DEBUG_FORTH_WORDS_KEY 
1dca						DMARK "STX" 
1dca f5				push af  
1dcb 3a df 1d			ld a, (.dmark)  
1dce 32 77 fb			ld (debug_mark),a  
1dd1 3a e0 1d			ld a, (.dmark+1)  
1dd4 32 78 fb			ld (debug_mark+1),a  
1dd7 3a e1 1d			ld a, (.dmark+2)  
1dda 32 79 fb			ld (debug_mark+2),a  
1ddd 18 03			jr .pastdmark  
1ddf ..			.dmark: db "STX"  
1de2 f1			.pastdmark: pop af  
1de3			endm  
# End of macro DMARK
1de3						CALLMONITOR 
1de3 cd 00 14			call break_point_state  
1de6				endm  
# End of macro CALLMONITOR
1de6					endif 
1de6			 
1de6				FORTH_DSP_VALUEHL 
1de6 cd 35 1a			call macro_dsp_valuehl 
1de9				endm 
# End of macro FORTH_DSP_VALUEHL
1de9			 
1de9 22 60 f8			ld (store_tmp1), hl    ; count 
1dec			 
1dec				FORTH_DSP_POP 
1dec cd d1 1a			call macro_forth_dsp_pop 
1def				endm 
# End of macro FORTH_DSP_POP
1def			.stkexec1: 
1def 2a 60 f8			ld hl, (store_tmp1)   ; count 
1df2 3e 00			ld a, 0 
1df4 bd				cp l 
1df5 c8				ret z 
1df6			 
1df6 2b				dec hl 
1df7 22 60 f8			ld (store_tmp1), hl    ; count 
1dfa				 
1dfa				FORTH_DSP_VALUEHL 
1dfa cd 35 1a			call macro_dsp_valuehl 
1dfd				endm 
# End of macro FORTH_DSP_VALUEHL
1dfd e5				push hl 
1dfe				 
1dfe					if DEBUG_FORTH_WORDS 
1dfe						DMARK "EXp" 
1dfe f5				push af  
1dff 3a 13 1e			ld a, (.dmark)  
1e02 32 77 fb			ld (debug_mark),a  
1e05 3a 14 1e			ld a, (.dmark+1)  
1e08 32 78 fb			ld (debug_mark+1),a  
1e0b 3a 15 1e			ld a, (.dmark+2)  
1e0e 32 79 fb			ld (debug_mark+2),a  
1e11 18 03			jr .pastdmark  
1e13 ..			.dmark: db "EXp"  
1e16 f1			.pastdmark: pop af  
1e17			endm  
# End of macro DMARK
1e17						CALLMONITOR 
1e17 cd 00 14			call break_point_state  
1e1a				endm  
# End of macro CALLMONITOR
1e1a					endif 
1e1a				FORTH_DSP_POP 
1e1a cd d1 1a			call macro_forth_dsp_pop 
1e1d				endm 
# End of macro FORTH_DSP_POP
1e1d			 
1e1d cd 70 10			call strlenz 
1e20 23				inc hl   ; include zero term to copy 
1e21 23				inc hl   ; include zero term to copy 
1e22 23				inc hl   ; include zero term to copy 
1e23 06 00			ld b,0 
1e25 4d				ld c,l 
1e26 e1				pop hl 
1e27 11 31 ef			ld de, execscratch 
1e2a					if DEBUG_FORTH_WORDS 
1e2a						DMARK "EX3" 
1e2a f5				push af  
1e2b 3a 3f 1e			ld a, (.dmark)  
1e2e 32 77 fb			ld (debug_mark),a  
1e31 3a 40 1e			ld a, (.dmark+1)  
1e34 32 78 fb			ld (debug_mark+1),a  
1e37 3a 41 1e			ld a, (.dmark+2)  
1e3a 32 79 fb			ld (debug_mark+2),a  
1e3d 18 03			jr .pastdmark  
1e3f ..			.dmark: db "EX3"  
1e42 f1			.pastdmark: pop af  
1e43			endm  
# End of macro DMARK
1e43						CALLMONITOR 
1e43 cd 00 14			call break_point_state  
1e46				endm  
# End of macro CALLMONITOR
1e46					endif 
1e46 ed b0			ldir 
1e48			 
1e48			 
1e48 21 31 ef			ld hl, execscratch 
1e4b			 
1e4b					if DEBUG_FORTH_WORDS 
1e4b						DMARK "EXP" 
1e4b f5				push af  
1e4c 3a 60 1e			ld a, (.dmark)  
1e4f 32 77 fb			ld (debug_mark),a  
1e52 3a 61 1e			ld a, (.dmark+1)  
1e55 32 78 fb			ld (debug_mark+1),a  
1e58 3a 62 1e			ld a, (.dmark+2)  
1e5b 32 79 fb			ld (debug_mark+2),a  
1e5e 18 03			jr .pastdmark  
1e60 ..			.dmark: db "EXP"  
1e63 f1			.pastdmark: pop af  
1e64			endm  
# End of macro DMARK
1e64						CALLMONITOR 
1e64 cd 00 14			call break_point_state  
1e67				endm  
# End of macro CALLMONITOR
1e67					endif 
1e67			 
1e67 cd d9 1b			call forthparse 
1e6a 21 31 ef			ld hl, execscratch 
1e6d					if DEBUG_FORTH_WORDS 
1e6d						DMARK "EXx" 
1e6d f5				push af  
1e6e 3a 82 1e			ld a, (.dmark)  
1e71 32 77 fb			ld (debug_mark),a  
1e74 3a 83 1e			ld a, (.dmark+1)  
1e77 32 78 fb			ld (debug_mark+1),a  
1e7a 3a 84 1e			ld a, (.dmark+2)  
1e7d 32 79 fb			ld (debug_mark+2),a  
1e80 18 03			jr .pastdmark  
1e82 ..			.dmark: db "EXx"  
1e85 f1			.pastdmark: pop af  
1e86			endm  
# End of macro DMARK
1e86						CALLMONITOR 
1e86 cd 00 14			call break_point_state  
1e89				endm  
# End of macro CALLMONITOR
1e89					endif 
1e89 cd 19 1c			call forthexec 
1e8c			 
1e8c c3 ef 1d			jp .stkexec1 
1e8f			 
1e8f c9				ret 
1e90			 
1e90			 
1e90			.DUP: 
1e90				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1e90 17				db WORD_SYS_CORE+OPCODE_DUP             
1e91 06 1f			dw .ZDUP            
1e93 04				db 3 + 1 
1e94 .. 00			db "DUP",0              
1e98				endm 
# End of macro CWHEAD
1e98			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1e98			 
1e98					if DEBUG_FORTH_WORDS_KEY 
1e98						DMARK "DUP" 
1e98 f5				push af  
1e99 3a ad 1e			ld a, (.dmark)  
1e9c 32 77 fb			ld (debug_mark),a  
1e9f 3a ae 1e			ld a, (.dmark+1)  
1ea2 32 78 fb			ld (debug_mark+1),a  
1ea5 3a af 1e			ld a, (.dmark+2)  
1ea8 32 79 fb			ld (debug_mark+2),a  
1eab 18 03			jr .pastdmark  
1ead ..			.dmark: db "DUP"  
1eb0 f1			.pastdmark: pop af  
1eb1			endm  
# End of macro DMARK
1eb1						CALLMONITOR 
1eb1 cd 00 14			call break_point_state  
1eb4				endm  
# End of macro CALLMONITOR
1eb4					endif 
1eb4			 
1eb4					FORTH_DSP 
1eb4 cd 1a 1a			call macro_forth_dsp 
1eb7				endm 
# End of macro FORTH_DSP
1eb7			 
1eb7 7e					ld a, (HL) 
1eb8 fe 01				cp DS_TYPE_STR 
1eba 20 25				jr nz, .dupinum 
1ebc			 
1ebc					; push another string 
1ebc			 
1ebc					FORTH_DSP_VALUEHL     		 
1ebc cd 35 1a			call macro_dsp_valuehl 
1ebf				endm 
# End of macro FORTH_DSP_VALUEHL
1ebf			 
1ebf				if DEBUG_FORTH_WORDS 
1ebf					DMARK "DUs" 
1ebf f5				push af  
1ec0 3a d4 1e			ld a, (.dmark)  
1ec3 32 77 fb			ld (debug_mark),a  
1ec6 3a d5 1e			ld a, (.dmark+1)  
1ec9 32 78 fb			ld (debug_mark+1),a  
1ecc 3a d6 1e			ld a, (.dmark+2)  
1ecf 32 79 fb			ld (debug_mark+2),a  
1ed2 18 03			jr .pastdmark  
1ed4 ..			.dmark: db "DUs"  
1ed7 f1			.pastdmark: pop af  
1ed8			endm  
# End of macro DMARK
1ed8					CALLMONITOR 
1ed8 cd 00 14			call break_point_state  
1edb				endm  
# End of macro CALLMONITOR
1edb				endif 
1edb cd ac 19				call forth_push_str 
1ede			 
1ede					NEXTW 
1ede c3 8b 1b			jp macro_next 
1ee1				endm 
# End of macro NEXTW
1ee1			 
1ee1			 
1ee1			.dupinum: 
1ee1					 
1ee1			 
1ee1			 
1ee1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1ee1 cd 35 1a			call macro_dsp_valuehl 
1ee4				endm 
# End of macro FORTH_DSP_VALUEHL
1ee4			 
1ee4				; TODO add floating point number detection 
1ee4			 
1ee4				if DEBUG_FORTH_WORDS 
1ee4					DMARK "DUi" 
1ee4 f5				push af  
1ee5 3a f9 1e			ld a, (.dmark)  
1ee8 32 77 fb			ld (debug_mark),a  
1eeb 3a fa 1e			ld a, (.dmark+1)  
1eee 32 78 fb			ld (debug_mark+1),a  
1ef1 3a fb 1e			ld a, (.dmark+2)  
1ef4 32 79 fb			ld (debug_mark+2),a  
1ef7 18 03			jr .pastdmark  
1ef9 ..			.dmark: db "DUi"  
1efc f1			.pastdmark: pop af  
1efd			endm  
# End of macro DMARK
1efd					CALLMONITOR 
1efd cd 00 14			call break_point_state  
1f00				endm  
# End of macro CALLMONITOR
1f00				endif 
1f00			 
1f00 cd 9a 19				call forth_push_numhl 
1f03					NEXTW 
1f03 c3 8b 1b			jp macro_next 
1f06				endm 
# End of macro NEXTW
1f06			.ZDUP: 
1f06				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
1f06 99				db WORD_SYS_CORE+OPCODE_ZDUP             
1f07 3e 1f			dw .SWAP            
1f09 05				db 4 + 1 
1f0a .. 00			db "?DUP",0              
1f0f				endm 
# End of macro CWHEAD
1f0f			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
1f0f			 
1f0f					if DEBUG_FORTH_WORDS_KEY 
1f0f						DMARK "qDU" 
1f0f f5				push af  
1f10 3a 24 1f			ld a, (.dmark)  
1f13 32 77 fb			ld (debug_mark),a  
1f16 3a 25 1f			ld a, (.dmark+1)  
1f19 32 78 fb			ld (debug_mark+1),a  
1f1c 3a 26 1f			ld a, (.dmark+2)  
1f1f 32 79 fb			ld (debug_mark+2),a  
1f22 18 03			jr .pastdmark  
1f24 ..			.dmark: db "qDU"  
1f27 f1			.pastdmark: pop af  
1f28			endm  
# End of macro DMARK
1f28						CALLMONITOR 
1f28 cd 00 14			call break_point_state  
1f2b				endm  
# End of macro CALLMONITOR
1f2b					endif 
1f2b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
1f2b cd 35 1a			call macro_dsp_valuehl 
1f2e				endm 
# End of macro FORTH_DSP_VALUEHL
1f2e			 
1f2e e5					push hl 
1f2f			 
1f2f					; is it a zero? 
1f2f			 
1f2f 3e 00				ld a, 0 
1f31 84					add h 
1f32 85					add l 
1f33			 
1f33 e1					pop hl 
1f34			 
1f34 fe 00				cp 0 
1f36 28 03				jr z, .dup2orig 
1f38			 
1f38			 
1f38 cd 9a 19				call forth_push_numhl 
1f3b			 
1f3b			 
1f3b				; TODO add floating point number detection 
1f3b			 
1f3b			.dup2orig: 
1f3b			 
1f3b					NEXTW 
1f3b c3 8b 1b			jp macro_next 
1f3e				endm 
# End of macro NEXTW
1f3e			.SWAP: 
1f3e				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
1f3e 18				db WORD_SYS_CORE+OPCODE_SWAP             
1f3f 7d 1f			dw .COLN            
1f41 05				db 4 + 1 
1f42 .. 00			db "SWAP",0              
1f47				endm 
# End of macro CWHEAD
1f47			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
1f47					if DEBUG_FORTH_WORDS_KEY 
1f47						DMARK "SWP" 
1f47 f5				push af  
1f48 3a 5c 1f			ld a, (.dmark)  
1f4b 32 77 fb			ld (debug_mark),a  
1f4e 3a 5d 1f			ld a, (.dmark+1)  
1f51 32 78 fb			ld (debug_mark+1),a  
1f54 3a 5e 1f			ld a, (.dmark+2)  
1f57 32 79 fb			ld (debug_mark+2),a  
1f5a 18 03			jr .pastdmark  
1f5c ..			.dmark: db "SWP"  
1f5f f1			.pastdmark: pop af  
1f60			endm  
# End of macro DMARK
1f60						CALLMONITOR 
1f60 cd 00 14			call break_point_state  
1f63				endm  
# End of macro CALLMONITOR
1f63					endif 
1f63			 
1f63					FORTH_DSP_VALUEHL 
1f63 cd 35 1a			call macro_dsp_valuehl 
1f66				endm 
# End of macro FORTH_DSP_VALUEHL
1f66 e5					push hl     ; w2 
1f67			 
1f67					FORTH_DSP_POP 
1f67 cd d1 1a			call macro_forth_dsp_pop 
1f6a				endm 
# End of macro FORTH_DSP_POP
1f6a			 
1f6a					FORTH_DSP_VALUEHL 
1f6a cd 35 1a			call macro_dsp_valuehl 
1f6d				endm 
# End of macro FORTH_DSP_VALUEHL
1f6d			 
1f6d					FORTH_DSP_POP 
1f6d cd d1 1a			call macro_forth_dsp_pop 
1f70				endm 
# End of macro FORTH_DSP_POP
1f70			 
1f70 d1					pop de     ; w2	, hl = w1 
1f71			 
1f71 eb					ex de, hl 
1f72 d5					push de 
1f73			 
1f73 cd 9a 19				call forth_push_numhl 
1f76			 
1f76 e1					pop hl 
1f77			 
1f77 cd 9a 19				call forth_push_numhl 
1f7a					 
1f7a			 
1f7a					NEXTW 
1f7a c3 8b 1b			jp macro_next 
1f7d				endm 
# End of macro NEXTW
1f7d			.COLN: 
1f7d				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
1f7d 19				db WORD_SYS_CORE+OPCODE_COLN             
1f7e 09 21			dw .SCOLN            
1f80 02				db 1 + 1 
1f81 .. 00			db ":",0              
1f83				endm 
# End of macro CWHEAD
1f83			; | : ( -- )         Create new word | DONE 
1f83			 
1f83					if DEBUG_FORTH_WORDS_KEY 
1f83						DMARK "CLN" 
1f83 f5				push af  
1f84 3a 98 1f			ld a, (.dmark)  
1f87 32 77 fb			ld (debug_mark),a  
1f8a 3a 99 1f			ld a, (.dmark+1)  
1f8d 32 78 fb			ld (debug_mark+1),a  
1f90 3a 9a 1f			ld a, (.dmark+2)  
1f93 32 79 fb			ld (debug_mark+2),a  
1f96 18 03			jr .pastdmark  
1f98 ..			.dmark: db "CLN"  
1f9b f1			.pastdmark: pop af  
1f9c			endm  
# End of macro DMARK
1f9c						CALLMONITOR 
1f9c cd 00 14			call break_point_state  
1f9f				endm  
# End of macro CALLMONITOR
1f9f					endif 
1f9f				STACKFRAME OFF $8efe $989f 
1f9f				if DEBUG_STACK_IMB 
1f9f					if OFF 
1f9f						exx 
1f9f						ld de, $8efe 
1f9f						ld a, d 
1f9f						ld hl, curframe 
1f9f						call hexout 
1f9f						ld a, e 
1f9f						ld hl, curframe+2 
1f9f						call hexout 
1f9f						ld hl, $8efe 
1f9f						push hl 
1f9f						ld hl, $989f 
1f9f						push hl 
1f9f						exx 
1f9f					endif 
1f9f				endif 
1f9f			endm 
# End of macro STACKFRAME
1f9f				; get parser buffer length  of new word 
1f9f			 
1f9f				 
1f9f			 
1f9f					; move tok past this to start of name defintition 
1f9f					; TODO get word to define 
1f9f					; TODO Move past word token 
1f9f					; TODO get length of string up to the ';' 
1f9f			 
1f9f 2a 33 f1			ld hl, (os_tok_ptr) 
1fa2 23				inc hl 
1fa3 23				inc hl 
1fa4			 
1fa4 3e 3b			ld a, ';' 
1fa6 cd 7b 10			call strlent 
1fa9			 
1fa9 7d				ld a,l 
1faa 32 32 f0			ld (os_new_parse_len), a 
1fad			 
1fad			 
1fad			if DEBUG_FORTH_UWORD 
1fad ed 5b 33 f1		ld de, (os_tok_ptr) 
1fb1						DMARK ":01" 
1fb1 f5				push af  
1fb2 3a c6 1f			ld a, (.dmark)  
1fb5 32 77 fb			ld (debug_mark),a  
1fb8 3a c7 1f			ld a, (.dmark+1)  
1fbb 32 78 fb			ld (debug_mark+1),a  
1fbe 3a c8 1f			ld a, (.dmark+2)  
1fc1 32 79 fb			ld (debug_mark+2),a  
1fc4 18 03			jr .pastdmark  
1fc6 ..			.dmark: db ":01"  
1fc9 f1			.pastdmark: pop af  
1fca			endm  
# End of macro DMARK
1fca				CALLMONITOR 
1fca cd 00 14			call break_point_state  
1fcd				endm  
# End of macro CALLMONITOR
1fcd			endif 
1fcd			 
1fcd			; 
1fcd			;  new word memory layout: 
1fcd			;  
1fcd			;    : adg 6666 ;  
1fcd			; 
1fcd			;    db   1     ; user defined word  
1fcd 23				inc hl    
1fce			;    dw   sysdict 
1fce 23				inc hl 
1fcf 23				inc hl 
1fd0			;    db <word len>+1 (for null) 
1fd0 23				inc hl 
1fd1			;    db .... <word> 
1fd1			; 
1fd1			 
1fd1 23				inc hl    ; some extras for the word preamble before the above 
1fd2 23				inc hl 
1fd3 23				inc hl 
1fd4 23				inc hl 
1fd5 23				inc hl 
1fd6 23				inc hl 
1fd7 23				inc hl  
1fd8 23				inc hl 
1fd9 23				inc hl 
1fda 23				inc hl 
1fdb 23				inc hl 
1fdc 23				inc hl 
1fdd 23				inc hl 
1fde 23				inc hl     ; TODO how many do we really need?     maybe only 6 
1fdf			;       exec word buffer 
1fdf			;	<ptr word>   
1fdf 23				inc hl 
1fe0 23				inc hl 
1fe1			;       <word list><null term> 7F final term 
1fe1			 
1fe1			 
1fe1			if DEBUG_FORTH_UWORD 
1fe1						DMARK ":02" 
1fe1 f5				push af  
1fe2 3a f6 1f			ld a, (.dmark)  
1fe5 32 77 fb			ld (debug_mark),a  
1fe8 3a f7 1f			ld a, (.dmark+1)  
1feb 32 78 fb			ld (debug_mark+1),a  
1fee 3a f8 1f			ld a, (.dmark+2)  
1ff1 32 79 fb			ld (debug_mark+2),a  
1ff4 18 03			jr .pastdmark  
1ff6 ..			.dmark: db ":02"  
1ff9 f1			.pastdmark: pop af  
1ffa			endm  
# End of macro DMARK
1ffa				CALLMONITOR 
1ffa cd 00 14			call break_point_state  
1ffd				endm  
# End of macro CALLMONITOR
1ffd			endif 
1ffd			 
1ffd				 
1ffd					; malloc the size 
1ffd			 
1ffd cd d9 10				call malloc 
2000 22 30 f0				ld (os_new_malloc), hl     ; save malloc start 
2003			 
2003			;    db   1     ; user defined word  
2003 3e 01				ld a, WORD_SYS_UWORD  
2005 77					ld (hl), a 
2006				 
2006 23				inc hl    
2007			;    dw   sysdict 
2007 11 e3 1c			ld de, sysdict       ; continue on with the scan to the system dict 
200a 73				ld (hl), e 
200b 23				inc hl 
200c 72				ld (hl), d 
200d 23				inc hl 
200e			 
200e			 
200e			;    Setup dict word 
200e			 
200e 23				inc hl 
200f 22 36 f0			ld (os_new_work_ptr), hl     ; save start of dict word  
2012			 
2012				; 1. get length of dict word 
2012			 
2012			 
2012 2a 33 f1			ld hl, (os_tok_ptr) 
2015 23				inc hl 
2016 23				inc hl    ; position to start of dict word 
2017 3e 00			ld a, 0 
2019 cd 7b 10			call strlent 
201c			 
201c			 
201c 23				inc hl    ; to include null??? 
201d			 
201d				; write length of dict word 
201d			 
201d ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2021 1b				dec de 
2022 eb				ex de, hl 
2023 73				ld (hl), e 
2024 eb				ex de, hl 
2025			 
2025				 
2025			 
2025				; copy  
2025 4d				ld c, l 
2026 06 00			ld b, 0 
2028 ed 5b 36 f0		ld de, (os_new_work_ptr)   ; get dest for copy of word 
202c 2a 33 f1			ld hl, (os_tok_ptr) 
202f 23				inc hl 
2030 23				inc hl    ; position to start of dict word 
2031				 
2031			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2031				 
2031				; TODO need to convert word to upper case 
2031			 
2031			ucasetok:	 
2031 7e				ld a,(hl) 
2032 cd 67 10			call toUpper 
2035 77				ld (hl),a 
2036 ed a0			ldi 
2038 f2 31 20		 	jp p, ucasetok 
203b			 
203b			 
203b			 
203b				; de now points to start of where the word body code should be placed 
203b ed 53 36 f0		ld (os_new_work_ptr), de 
203f				; hl now points to the words to throw at forthexec which needs to be copied 
203f 22 38 f0			ld (os_new_src_ptr), hl 
2042			 
2042				; TODO add 'call to forthexec' 
2042			 
2042			if DEBUG_FORTH_UWORD 
2042 c5				push bc 
2043 ed 4b 30 f0		ld bc, (os_new_malloc) 
2047						DMARK ":0x" 
2047 f5				push af  
2048 3a 5c 20			ld a, (.dmark)  
204b 32 77 fb			ld (debug_mark),a  
204e 3a 5d 20			ld a, (.dmark+1)  
2051 32 78 fb			ld (debug_mark+1),a  
2054 3a 5e 20			ld a, (.dmark+2)  
2057 32 79 fb			ld (debug_mark+2),a  
205a 18 03			jr .pastdmark  
205c ..			.dmark: db ":0x"  
205f f1			.pastdmark: pop af  
2060			endm  
# End of macro DMARK
2060				CALLMONITOR 
2060 cd 00 14			call break_point_state  
2063				endm  
# End of macro CALLMONITOR
2063 c1				pop bc 
2064			endif 
2064			 
2064			 
2064				; create word preamble which should be: 
2064			 
2064			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
2064			 
2064				;    ld hl, <word code> 
2064				;    jp user_exec 
2064			        ;    <word code bytes> 
2064			 
2064			 
2064			;	inc de     ; TODO ??? or are we already past the word's null 
2064 eb				ex de, hl 
2065			 
2065 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
2067			 
2067 23				inc hl 
2068 22 3c f0			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
206b 23				inc hl 
206c			 
206c 23				inc hl 
206d 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
206f			 
206f 01 2a 4e			ld bc, user_exec 
2072 23				inc hl 
2073 71				ld (hl), c     ; poke address of user_exec 
2074 23				inc hl 
2075 70				ld (hl), b     
2076			 ; 
2076			;	inc hl 
2076			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2076			; 
2076			; 
2076			;	ld bc, macro_forth_rsp_next 
2076			;	inc hl 
2076			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
2076			;	inc hl 
2076			;	ld (hl), b     
2076			 ; 
2076			;	inc hl 
2076			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
2076			; 
2076			; 
2076			;	inc hl 
2076			;	ld bc, forthexec 
2076			;	ld (hl), c     ; poke address of forthexec 
2076			;	inc hl 
2076			;	ld (hl), b      
2076			; 
2076			;	inc hl 
2076			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
2076			; 
2076			;	ld bc, user_dict_next 
2076			;	inc hl 
2076			;	ld (hl), c     ; poke address of forthexec 
2076			;	inc hl 
2076			;	ld (hl), b      
2076			 
2076				; hl is now where we need to copy the word byte data to save this 
2076			 
2076 23				inc hl 
2077 22 3a f0			ld (os_new_exec), hl 
207a				 
207a				; copy definition 
207a			 
207a eb				ex de, hl 
207b			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
207b			;	inc de    ; skip the PC for this parse 
207b 3a 32 f0			ld a, (os_new_parse_len) 
207e 4f				ld c, a 
207f 06 00			ld b, 0 
2081 ed b0			ldir		 ; copy defintion 
2083			 
2083			 
2083				; poke the address of where the new word bytes live for forthexec 
2083			 
2083 2a 3c f0			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
2086			 
2086 ed 5b 3a f0		ld de, (os_new_exec)      
208a				 
208a 73				ld (hl), e 
208b 23				inc hl 
208c 72				ld (hl), d 
208d			 
208d					; TODO copy last user dict word next link to this word 
208d					; TODO update last user dict word to point to this word 
208d			; 
208d			; hl f923 de 812a ; bc 811a 
208d			 
208d			if DEBUG_FORTH_UWORD 
208d c5				push bc 
208e ed 4b 30 f0		ld bc, (os_new_malloc) 
2092						DMARK ":0A" 
2092 f5				push af  
2093 3a a7 20			ld a, (.dmark)  
2096 32 77 fb			ld (debug_mark),a  
2099 3a a8 20			ld a, (.dmark+1)  
209c 32 78 fb			ld (debug_mark+1),a  
209f 3a a9 20			ld a, (.dmark+2)  
20a2 32 79 fb			ld (debug_mark+2),a  
20a5 18 03			jr .pastdmark  
20a7 ..			.dmark: db ":0A"  
20aa f1			.pastdmark: pop af  
20ab			endm  
# End of macro DMARK
20ab				CALLMONITOR 
20ab cd 00 14			call break_point_state  
20ae				endm  
# End of macro CALLMONITOR
20ae c1				pop bc 
20af			endif 
20af			if DEBUG_FORTH_UWORD 
20af c5				push bc 
20b0 ed 4b 30 f0		ld bc, (os_new_malloc) 
20b4 03				inc bc 
20b5 03				inc bc 
20b6 03				inc bc 
20b7 03				inc bc 
20b8 03				inc bc 
20b9 03				inc bc 
20ba 03				inc bc 
20bb 03				inc bc 
20bc			 
20bc						DMARK ":0B" 
20bc f5				push af  
20bd 3a d1 20			ld a, (.dmark)  
20c0 32 77 fb			ld (debug_mark),a  
20c3 3a d2 20			ld a, (.dmark+1)  
20c6 32 78 fb			ld (debug_mark+1),a  
20c9 3a d3 20			ld a, (.dmark+2)  
20cc 32 79 fb			ld (debug_mark+2),a  
20cf 18 03			jr .pastdmark  
20d1 ..			.dmark: db ":0B"  
20d4 f1			.pastdmark: pop af  
20d5			endm  
# End of macro DMARK
20d5				CALLMONITOR 
20d5 cd 00 14			call break_point_state  
20d8				endm  
# End of macro CALLMONITOR
20d8 c1				pop bc 
20d9			endif 
20d9			 
20d9			; update word dict linked list for new word 
20d9			 
20d9			 
20d9 2a 2f f1		ld hl, (os_last_new_uword)		; get the start of the last added uword 
20dc 23			inc hl     ; move to next work linked list ptr 
20dd			 
20dd ed 5b 30 f0	ld de, (os_new_malloc)		 ; new next word 
20e1 73			ld (hl), e 
20e2 23			inc hl 
20e3 72			ld (hl), d 
20e4			 
20e4			if DEBUG_FORTH_UWORD 
20e4 ed 4b 2f f1		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
20e8			endif 
20e8			 
20e8 ed 53 2f f1	ld (os_last_new_uword), de      ; update last new uword ptr 
20ec			 
20ec			 
20ec			if DEBUG_FORTH_UWORD 
20ec						DMARK ":0+" 
20ec f5				push af  
20ed 3a 01 21			ld a, (.dmark)  
20f0 32 77 fb			ld (debug_mark),a  
20f3 3a 02 21			ld a, (.dmark+1)  
20f6 32 78 fb			ld (debug_mark+1),a  
20f9 3a 03 21			ld a, (.dmark+2)  
20fc 32 79 fb			ld (debug_mark+2),a  
20ff 18 03			jr .pastdmark  
2101 ..			.dmark: db ":0+"  
2104 f1			.pastdmark: pop af  
2105			endm  
# End of macro DMARK
2105				CALLMONITOR 
2105 cd 00 14			call break_point_state  
2108				endm  
# End of macro CALLMONITOR
2108			endif 
2108			 
2108				STACKFRAMECHK OFF $8efe $989f 
2108				if DEBUG_STACK_IMB 
2108					if OFF 
2108						exx 
2108						ld hl, $989f 
2108						pop de   ; $989f 
2108						call cmp16 
2108						jr nz, .spnosame 
2108						ld hl, $8efe 
2108						pop de   ; $8efe 
2108						call cmp16 
2108						jr z, .spfrsame 
2108						.spnosame: call showsperror 
2108						.spfrsame: nop 
2108						exx 
2108					endif 
2108				endif 
2108			endm 
# End of macro STACKFRAMECHK
2108			 
2108 c9			ret    ; dont process any remaining parser tokens as they form new word 
2109			 
2109			 
2109			 
2109			 
2109			;		NEXT 
2109			.SCOLN: 
2109			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
2109 06				db OPCODE_SCOLN 
210a 55 21			dw .DROP 
210c 02				db 2 
210d .. 00			db ";",0           
210f			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
210f					if DEBUG_FORTH_WORDS_KEY 
210f						DMARK "SCN" 
210f f5				push af  
2110 3a 24 21			ld a, (.dmark)  
2113 32 77 fb			ld (debug_mark),a  
2116 3a 25 21			ld a, (.dmark+1)  
2119 32 78 fb			ld (debug_mark+1),a  
211c 3a 26 21			ld a, (.dmark+2)  
211f 32 79 fb			ld (debug_mark+2),a  
2122 18 03			jr .pastdmark  
2124 ..			.dmark: db "SCN"  
2127 f1			.pastdmark: pop af  
2128			endm  
# End of macro DMARK
2128						CALLMONITOR 
2128 cd 00 14			call break_point_state  
212b				endm  
# End of macro CALLMONITOR
212b					endif 
212b					FORTH_RSP_TOS 
212b cd 58 19			call macro_forth_rsp_tos 
212e				endm 
# End of macro FORTH_RSP_TOS
212e e5					push hl 
212f					FORTH_RSP_POP 
212f cd 62 19			call macro_forth_rsp_pop 
2132				endm 
# End of macro FORTH_RSP_POP
2132 e1					pop hl 
2133			;		ex de,hl 
2133 22 33 f1				ld (os_tok_ptr),hl 
2136			 
2136			if DEBUG_FORTH_UWORD 
2136						DMARK "SCL" 
2136 f5				push af  
2137 3a 4b 21			ld a, (.dmark)  
213a 32 77 fb			ld (debug_mark),a  
213d 3a 4c 21			ld a, (.dmark+1)  
2140 32 78 fb			ld (debug_mark+1),a  
2143 3a 4d 21			ld a, (.dmark+2)  
2146 32 79 fb			ld (debug_mark+2),a  
2149 18 03			jr .pastdmark  
214b ..			.dmark: db "SCL"  
214e f1			.pastdmark: pop af  
214f			endm  
# End of macro DMARK
214f				CALLMONITOR 
214f cd 00 14			call break_point_state  
2152				endm  
# End of macro CALLMONITOR
2152			endif 
2152					NEXTW 
2152 c3 8b 1b			jp macro_next 
2155				endm 
# End of macro NEXTW
2155			 
2155			.DROP: 
2155				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
2155 1b				db WORD_SYS_CORE+OPCODE_DROP             
2156 80 21			dw .DUP2            
2158 05				db 4 + 1 
2159 .. 00			db "DROP",0              
215e				endm 
# End of macro CWHEAD
215e			; | DROP ( w -- )   drop the TOS item   | DONE 
215e					if DEBUG_FORTH_WORDS_KEY 
215e						DMARK "DRP" 
215e f5				push af  
215f 3a 73 21			ld a, (.dmark)  
2162 32 77 fb			ld (debug_mark),a  
2165 3a 74 21			ld a, (.dmark+1)  
2168 32 78 fb			ld (debug_mark+1),a  
216b 3a 75 21			ld a, (.dmark+2)  
216e 32 79 fb			ld (debug_mark+2),a  
2171 18 03			jr .pastdmark  
2173 ..			.dmark: db "DRP"  
2176 f1			.pastdmark: pop af  
2177			endm  
# End of macro DMARK
2177						CALLMONITOR 
2177 cd 00 14			call break_point_state  
217a				endm  
# End of macro CALLMONITOR
217a					endif 
217a					FORTH_DSP_POP 
217a cd d1 1a			call macro_forth_dsp_pop 
217d				endm 
# End of macro FORTH_DSP_POP
217d					NEXTW 
217d c3 8b 1b			jp macro_next 
2180				endm 
# End of macro NEXTW
2180			.DUP2: 
2180				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
2180 1c				db WORD_SYS_CORE+OPCODE_DUP2             
2181 c5 21			dw .DROP2            
2183 05				db 4 + 1 
2184 .. 00			db "2DUP",0              
2189				endm 
# End of macro CWHEAD
2189			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
2189					if DEBUG_FORTH_WORDS_KEY 
2189						DMARK "2DU" 
2189 f5				push af  
218a 3a 9e 21			ld a, (.dmark)  
218d 32 77 fb			ld (debug_mark),a  
2190 3a 9f 21			ld a, (.dmark+1)  
2193 32 78 fb			ld (debug_mark+1),a  
2196 3a a0 21			ld a, (.dmark+2)  
2199 32 79 fb			ld (debug_mark+2),a  
219c 18 03			jr .pastdmark  
219e ..			.dmark: db "2DU"  
21a1 f1			.pastdmark: pop af  
21a2			endm  
# End of macro DMARK
21a2						CALLMONITOR 
21a2 cd 00 14			call break_point_state  
21a5				endm  
# End of macro CALLMONITOR
21a5					endif 
21a5					FORTH_DSP_VALUEHL 
21a5 cd 35 1a			call macro_dsp_valuehl 
21a8				endm 
# End of macro FORTH_DSP_VALUEHL
21a8 e5					push hl      ; 2 
21a9			 
21a9					FORTH_DSP_POP 
21a9 cd d1 1a			call macro_forth_dsp_pop 
21ac				endm 
# End of macro FORTH_DSP_POP
21ac					 
21ac					FORTH_DSP_VALUEHL 
21ac cd 35 1a			call macro_dsp_valuehl 
21af				endm 
# End of macro FORTH_DSP_VALUEHL
21af			;		push hl      ; 1 
21af			 
21af					FORTH_DSP_POP 
21af cd d1 1a			call macro_forth_dsp_pop 
21b2				endm 
# End of macro FORTH_DSP_POP
21b2			 
21b2			;		pop hl       ; 1 
21b2 d1					pop de       ; 2 
21b3			 
21b3 cd 9a 19				call forth_push_numhl 
21b6 eb					ex de, hl 
21b7 cd 9a 19				call forth_push_numhl 
21ba			 
21ba					 
21ba eb					ex de, hl 
21bb			 
21bb cd 9a 19				call forth_push_numhl 
21be eb					ex de, hl 
21bf cd 9a 19				call forth_push_numhl 
21c2			 
21c2			 
21c2					NEXTW 
21c2 c3 8b 1b			jp macro_next 
21c5				endm 
# End of macro NEXTW
21c5			.DROP2: 
21c5				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
21c5 1d				db WORD_SYS_CORE+OPCODE_DROP2             
21c6 f4 21			dw .SWAP2            
21c8 06				db 5 + 1 
21c9 .. 00			db "2DROP",0              
21cf				endm 
# End of macro CWHEAD
21cf			; | 2DROP ( w w -- )    Double drop | DONE 
21cf					if DEBUG_FORTH_WORDS_KEY 
21cf						DMARK "2DR" 
21cf f5				push af  
21d0 3a e4 21			ld a, (.dmark)  
21d3 32 77 fb			ld (debug_mark),a  
21d6 3a e5 21			ld a, (.dmark+1)  
21d9 32 78 fb			ld (debug_mark+1),a  
21dc 3a e6 21			ld a, (.dmark+2)  
21df 32 79 fb			ld (debug_mark+2),a  
21e2 18 03			jr .pastdmark  
21e4 ..			.dmark: db "2DR"  
21e7 f1			.pastdmark: pop af  
21e8			endm  
# End of macro DMARK
21e8						CALLMONITOR 
21e8 cd 00 14			call break_point_state  
21eb				endm  
# End of macro CALLMONITOR
21eb					endif 
21eb					FORTH_DSP_POP 
21eb cd d1 1a			call macro_forth_dsp_pop 
21ee				endm 
# End of macro FORTH_DSP_POP
21ee					FORTH_DSP_POP 
21ee cd d1 1a			call macro_forth_dsp_pop 
21f1				endm 
# End of macro FORTH_DSP_POP
21f1					NEXTW 
21f1 c3 8b 1b			jp macro_next 
21f4				endm 
# End of macro NEXTW
21f4			.SWAP2: 
21f4				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
21f4 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
21f5 1d 22			dw .AT            
21f7 06				db 5 + 1 
21f8 .. 00			db "2SWAP",0              
21fe				endm 
# End of macro CWHEAD
21fe			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
21fe					if DEBUG_FORTH_WORDS_KEY 
21fe						DMARK "2SW" 
21fe f5				push af  
21ff 3a 13 22			ld a, (.dmark)  
2202 32 77 fb			ld (debug_mark),a  
2205 3a 14 22			ld a, (.dmark+1)  
2208 32 78 fb			ld (debug_mark+1),a  
220b 3a 15 22			ld a, (.dmark+2)  
220e 32 79 fb			ld (debug_mark+2),a  
2211 18 03			jr .pastdmark  
2213 ..			.dmark: db "2SW"  
2216 f1			.pastdmark: pop af  
2217			endm  
# End of macro DMARK
2217						CALLMONITOR 
2217 cd 00 14			call break_point_state  
221a				endm  
# End of macro CALLMONITOR
221a					endif 
221a					NEXTW 
221a c3 8b 1b			jp macro_next 
221d				endm 
# End of macro NEXTW
221d			.AT: 
221d				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
221d 1f				db WORD_SYS_CORE+OPCODE_AT             
221e 4f 22			dw .CAT            
2220 02				db 1 + 1 
2221 .. 00			db "@",0              
2223				endm 
# End of macro CWHEAD
2223			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2223			 
2223					if DEBUG_FORTH_WORDS_KEY 
2223						DMARK "AT." 
2223 f5				push af  
2224 3a 38 22			ld a, (.dmark)  
2227 32 77 fb			ld (debug_mark),a  
222a 3a 39 22			ld a, (.dmark+1)  
222d 32 78 fb			ld (debug_mark+1),a  
2230 3a 3a 22			ld a, (.dmark+2)  
2233 32 79 fb			ld (debug_mark+2),a  
2236 18 03			jr .pastdmark  
2238 ..			.dmark: db "AT."  
223b f1			.pastdmark: pop af  
223c			endm  
# End of macro DMARK
223c						CALLMONITOR 
223c cd 00 14			call break_point_state  
223f				endm  
# End of macro CALLMONITOR
223f					endif 
223f			.getbyteat:	 
223f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
223f cd 35 1a			call macro_dsp_valuehl 
2242				endm 
# End of macro FORTH_DSP_VALUEHL
2242					 
2242			;		push hl 
2242				 
2242					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2242 cd d1 1a			call macro_forth_dsp_pop 
2245				endm 
# End of macro FORTH_DSP_POP
2245			 
2245			;		pop hl 
2245			 
2245 7e					ld a, (hl) 
2246			 
2246 6f					ld l, a 
2247 26 00				ld h, 0 
2249 cd 9a 19				call forth_push_numhl 
224c			 
224c					NEXTW 
224c c3 8b 1b			jp macro_next 
224f				endm 
# End of macro NEXTW
224f			.CAT: 
224f				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
224f 20				db WORD_SYS_CORE+OPCODE_CAT             
2250 78 22			dw .BANG            
2252 03				db 2 + 1 
2253 .. 00			db "C@",0              
2256				endm 
# End of macro CWHEAD
2256			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
2256					if DEBUG_FORTH_WORDS_KEY 
2256						DMARK "CAA" 
2256 f5				push af  
2257 3a 6b 22			ld a, (.dmark)  
225a 32 77 fb			ld (debug_mark),a  
225d 3a 6c 22			ld a, (.dmark+1)  
2260 32 78 fb			ld (debug_mark+1),a  
2263 3a 6d 22			ld a, (.dmark+2)  
2266 32 79 fb			ld (debug_mark+2),a  
2269 18 03			jr .pastdmark  
226b ..			.dmark: db "CAA"  
226e f1			.pastdmark: pop af  
226f			endm  
# End of macro DMARK
226f						CALLMONITOR 
226f cd 00 14			call break_point_state  
2272				endm  
# End of macro CALLMONITOR
2272					endif 
2272 c3 3f 22				jp .getbyteat 
2275					NEXTW 
2275 c3 8b 1b			jp macro_next 
2278				endm 
# End of macro NEXTW
2278			.BANG: 
2278				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
2278 21				db WORD_SYS_CORE+OPCODE_BANG             
2279 ae 22			dw .CBANG            
227b 02				db 1 + 1 
227c .. 00			db "!",0              
227e				endm 
# End of macro CWHEAD
227e			; | ! ( x w -- ) Store x at address w      | DONE 
227e					if DEBUG_FORTH_WORDS_KEY 
227e						DMARK "BNG" 
227e f5				push af  
227f 3a 93 22			ld a, (.dmark)  
2282 32 77 fb			ld (debug_mark),a  
2285 3a 94 22			ld a, (.dmark+1)  
2288 32 78 fb			ld (debug_mark+1),a  
228b 3a 95 22			ld a, (.dmark+2)  
228e 32 79 fb			ld (debug_mark+2),a  
2291 18 03			jr .pastdmark  
2293 ..			.dmark: db "BNG"  
2296 f1			.pastdmark: pop af  
2297			endm  
# End of macro DMARK
2297						CALLMONITOR 
2297 cd 00 14			call break_point_state  
229a				endm  
# End of macro CALLMONITOR
229a					endif 
229a			 
229a			.storebyteat:		 
229a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
229a cd 35 1a			call macro_dsp_valuehl 
229d				endm 
# End of macro FORTH_DSP_VALUEHL
229d					 
229d e5					push hl 
229e				 
229e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
229e cd d1 1a			call macro_forth_dsp_pop 
22a1				endm 
# End of macro FORTH_DSP_POP
22a1			 
22a1					; get byte to poke 
22a1			 
22a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22a1 cd 35 1a			call macro_dsp_valuehl 
22a4				endm 
# End of macro FORTH_DSP_VALUEHL
22a4 e5					push hl 
22a5			 
22a5			 
22a5					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22a5 cd d1 1a			call macro_forth_dsp_pop 
22a8				endm 
# End of macro FORTH_DSP_POP
22a8			 
22a8			 
22a8 d1					pop de 
22a9 e1					pop hl 
22aa			 
22aa 73					ld (hl),e 
22ab			 
22ab			 
22ab					NEXTW 
22ab c3 8b 1b			jp macro_next 
22ae				endm 
# End of macro NEXTW
22ae			.CBANG: 
22ae				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
22ae 22				db WORD_SYS_CORE+OPCODE_CBANG             
22af d7 22			dw .SCALL            
22b1 03				db 2 + 1 
22b2 .. 00			db "C!",0              
22b5				endm 
# End of macro CWHEAD
22b5			; | C!  ( x w -- ) Store x at address w  | DONE 
22b5					if DEBUG_FORTH_WORDS_KEY 
22b5						DMARK "CBA" 
22b5 f5				push af  
22b6 3a ca 22			ld a, (.dmark)  
22b9 32 77 fb			ld (debug_mark),a  
22bc 3a cb 22			ld a, (.dmark+1)  
22bf 32 78 fb			ld (debug_mark+1),a  
22c2 3a cc 22			ld a, (.dmark+2)  
22c5 32 79 fb			ld (debug_mark+2),a  
22c8 18 03			jr .pastdmark  
22ca ..			.dmark: db "CBA"  
22cd f1			.pastdmark: pop af  
22ce			endm  
# End of macro DMARK
22ce						CALLMONITOR 
22ce cd 00 14			call break_point_state  
22d1				endm  
# End of macro CALLMONITOR
22d1					endif 
22d1 c3 9a 22				jp .storebyteat 
22d4					NEXTW 
22d4 c3 8b 1b			jp macro_next 
22d7				endm 
# End of macro NEXTW
22d7			.SCALL: 
22d7				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
22d7 23				db WORD_SYS_CORE+OPCODE_SCALL             
22d8 0b 23			dw .DEPTH            
22da 05				db 4 + 1 
22db .. 00			db "CALL",0              
22e0				endm 
# End of macro CWHEAD
22e0			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
22e0					if DEBUG_FORTH_WORDS_KEY 
22e0						DMARK "CLL" 
22e0 f5				push af  
22e1 3a f5 22			ld a, (.dmark)  
22e4 32 77 fb			ld (debug_mark),a  
22e7 3a f6 22			ld a, (.dmark+1)  
22ea 32 78 fb			ld (debug_mark+1),a  
22ed 3a f7 22			ld a, (.dmark+2)  
22f0 32 79 fb			ld (debug_mark+2),a  
22f3 18 03			jr .pastdmark  
22f5 ..			.dmark: db "CLL"  
22f8 f1			.pastdmark: pop af  
22f9			endm  
# End of macro DMARK
22f9						CALLMONITOR 
22f9 cd 00 14			call break_point_state  
22fc				endm  
# End of macro CALLMONITOR
22fc					endif 
22fc			 
22fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
22fc cd 35 1a			call macro_dsp_valuehl 
22ff				endm 
# End of macro FORTH_DSP_VALUEHL
22ff			 
22ff			;		push hl 
22ff			 
22ff					; destroy value TOS 
22ff			 
22ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
22ff cd d1 1a			call macro_forth_dsp_pop 
2302				endm 
# End of macro FORTH_DSP_POP
2302			 
2302						 
2302			;		pop hl 
2302			 
2302					; how to do a call with hl???? save SP? 
2302 cd 34 1b				call forth_call_hl 
2305			 
2305			 
2305					; TODO push value back onto stack for another op etc 
2305			 
2305 cd 9a 19				call forth_push_numhl 
2308					NEXTW 
2308 c3 8b 1b			jp macro_next 
230b				endm 
# End of macro NEXTW
230b			.DEPTH: 
230b				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
230b 24				db WORD_SYS_CORE+OPCODE_DEPTH             
230c 48 23			dw .OVER            
230e 06				db 5 + 1 
230f .. 00			db "DEPTH",0              
2315				endm 
# End of macro CWHEAD
2315			; | DEPTH ( -- u ) Push count of stack | DONE 
2315					; take current TOS and remove from base value div by two to get count 
2315					if DEBUG_FORTH_WORDS_KEY 
2315						DMARK "DEP" 
2315 f5				push af  
2316 3a 2a 23			ld a, (.dmark)  
2319 32 77 fb			ld (debug_mark),a  
231c 3a 2b 23			ld a, (.dmark+1)  
231f 32 78 fb			ld (debug_mark+1),a  
2322 3a 2c 23			ld a, (.dmark+2)  
2325 32 79 fb			ld (debug_mark+2),a  
2328 18 03			jr .pastdmark  
232a ..			.dmark: db "DEP"  
232d f1			.pastdmark: pop af  
232e			endm  
# End of macro DMARK
232e						CALLMONITOR 
232e cd 00 14			call break_point_state  
2331				endm  
# End of macro CALLMONITOR
2331					endif 
2331			 
2331			 
2331 2a 1f f8			ld hl, (cli_data_sp) 
2334 11 99 f3			ld de, cli_data_stack 
2337 ed 52			sbc hl,de 
2339				 
2339				; div by size of stack item 
2339			 
2339 5d				ld e,l 
233a 0e 03			ld c, 3 
233c cd a2 0b			call Div8 
233f			 
233f 6f				ld l,a 
2340 26 00			ld h,0 
2342			 
2342				;srl h 
2342				;rr l 
2342			 
2342 cd 9a 19				call forth_push_numhl 
2345					NEXTW 
2345 c3 8b 1b			jp macro_next 
2348				endm 
# End of macro NEXTW
2348			.OVER: 
2348				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2348 42				db WORD_SYS_CORE+46             
2349 8f 23			dw .PAUSE            
234b 05				db 4 + 1 
234c .. 00			db "OVER",0              
2351				endm 
# End of macro CWHEAD
2351			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
2351					if DEBUG_FORTH_WORDS_KEY 
2351						DMARK "OVR" 
2351 f5				push af  
2352 3a 66 23			ld a, (.dmark)  
2355 32 77 fb			ld (debug_mark),a  
2358 3a 67 23			ld a, (.dmark+1)  
235b 32 78 fb			ld (debug_mark+1),a  
235e 3a 68 23			ld a, (.dmark+2)  
2361 32 79 fb			ld (debug_mark+2),a  
2364 18 03			jr .pastdmark  
2366 ..			.dmark: db "OVR"  
2369 f1			.pastdmark: pop af  
236a			endm  
# End of macro DMARK
236a						CALLMONITOR 
236a cd 00 14			call break_point_state  
236d				endm  
# End of macro CALLMONITOR
236d					endif 
236d			 
236d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
236d cd 35 1a			call macro_dsp_valuehl 
2370				endm 
# End of macro FORTH_DSP_VALUEHL
2370 e5					push hl    ; n2 
2371					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2371 cd d1 1a			call macro_forth_dsp_pop 
2374				endm 
# End of macro FORTH_DSP_POP
2374			 
2374					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2374 cd 35 1a			call macro_dsp_valuehl 
2377				endm 
# End of macro FORTH_DSP_VALUEHL
2377 e5					push hl    ; n1 
2378					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2378 cd d1 1a			call macro_forth_dsp_pop 
237b				endm 
# End of macro FORTH_DSP_POP
237b			 
237b d1					pop de     ; n1 
237c e1					pop hl     ; n2 
237d			 
237d d5					push de 
237e e5					push hl 
237f d5					push de 
2380			 
2380					; push back  
2380			 
2380 e1					pop hl 
2381 cd 9a 19				call forth_push_numhl 
2384 e1					pop hl 
2385 cd 9a 19				call forth_push_numhl 
2388 e1					pop hl 
2389 cd 9a 19				call forth_push_numhl 
238c					NEXTW 
238c c3 8b 1b			jp macro_next 
238f				endm 
# End of macro NEXTW
238f			 
238f			.PAUSE: 
238f				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
238f 43				db WORD_SYS_CORE+47             
2390 c4 23			dw .PAUSES            
2392 08				db 7 + 1 
2393 .. 00			db "PAUSEMS",0              
239b				endm 
# End of macro CWHEAD
239b			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
239b					if DEBUG_FORTH_WORDS_KEY 
239b						DMARK "PMS" 
239b f5				push af  
239c 3a b0 23			ld a, (.dmark)  
239f 32 77 fb			ld (debug_mark),a  
23a2 3a b1 23			ld a, (.dmark+1)  
23a5 32 78 fb			ld (debug_mark+1),a  
23a8 3a b2 23			ld a, (.dmark+2)  
23ab 32 79 fb			ld (debug_mark+2),a  
23ae 18 03			jr .pastdmark  
23b0 ..			.dmark: db "PMS"  
23b3 f1			.pastdmark: pop af  
23b4			endm  
# End of macro DMARK
23b4						CALLMONITOR 
23b4 cd 00 14			call break_point_state  
23b7				endm  
# End of macro CALLMONITOR
23b7					endif 
23b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23b7 cd 35 1a			call macro_dsp_valuehl 
23ba				endm 
# End of macro FORTH_DSP_VALUEHL
23ba			;		push hl    ; n2 
23ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ba cd d1 1a			call macro_forth_dsp_pop 
23bd				endm 
# End of macro FORTH_DSP_POP
23bd			;		pop hl 
23bd			 
23bd 7d					ld a, l 
23be cd 22 0a				call aDelayInMS 
23c1				       NEXTW 
23c1 c3 8b 1b			jp macro_next 
23c4				endm 
# End of macro NEXTW
23c4			.PAUSES:  
23c4				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
23c4 44				db WORD_SYS_CORE+48             
23c5 33 24			dw .ROT            
23c7 06				db 5 + 1 
23c8 .. 00			db "PAUSE",0              
23ce				endm 
# End of macro CWHEAD
23ce			; | PAUSE ( n -- )  Pause for n seconds | DONE 
23ce					if DEBUG_FORTH_WORDS_KEY 
23ce						DMARK "PAU" 
23ce f5				push af  
23cf 3a e3 23			ld a, (.dmark)  
23d2 32 77 fb			ld (debug_mark),a  
23d5 3a e4 23			ld a, (.dmark+1)  
23d8 32 78 fb			ld (debug_mark+1),a  
23db 3a e5 23			ld a, (.dmark+2)  
23de 32 79 fb			ld (debug_mark+2),a  
23e1 18 03			jr .pastdmark  
23e3 ..			.dmark: db "PAU"  
23e6 f1			.pastdmark: pop af  
23e7			endm  
# End of macro DMARK
23e7						CALLMONITOR 
23e7 cd 00 14			call break_point_state  
23ea				endm  
# End of macro CALLMONITOR
23ea					endif 
23ea					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23ea cd 35 1a			call macro_dsp_valuehl 
23ed				endm 
# End of macro FORTH_DSP_VALUEHL
23ed			;		push hl    ; n2 
23ed					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ed cd d1 1a			call macro_forth_dsp_pop 
23f0				endm 
# End of macro FORTH_DSP_POP
23f0			;		pop hl 
23f0 45					ld b, l 
23f1					if DEBUG_FORTH_WORDS 
23f1						DMARK "PAU" 
23f1 f5				push af  
23f2 3a 06 24			ld a, (.dmark)  
23f5 32 77 fb			ld (debug_mark),a  
23f8 3a 07 24			ld a, (.dmark+1)  
23fb 32 78 fb			ld (debug_mark+1),a  
23fe 3a 08 24			ld a, (.dmark+2)  
2401 32 79 fb			ld (debug_mark+2),a  
2404 18 03			jr .pastdmark  
2406 ..			.dmark: db "PAU"  
2409 f1			.pastdmark: pop af  
240a			endm  
# End of macro DMARK
240a						CALLMONITOR 
240a cd 00 14			call break_point_state  
240d				endm  
# End of macro CALLMONITOR
240d					endif 
240d c5			.pauses1:	push bc 
240e cd 3d 0a				call delay1s 
2411 c1					pop bc 
2412					if DEBUG_FORTH_WORDS 
2412						DMARK "PA1" 
2412 f5				push af  
2413 3a 27 24			ld a, (.dmark)  
2416 32 77 fb			ld (debug_mark),a  
2419 3a 28 24			ld a, (.dmark+1)  
241c 32 78 fb			ld (debug_mark+1),a  
241f 3a 29 24			ld a, (.dmark+2)  
2422 32 79 fb			ld (debug_mark+2),a  
2425 18 03			jr .pastdmark  
2427 ..			.dmark: db "PA1"  
242a f1			.pastdmark: pop af  
242b			endm  
# End of macro DMARK
242b						CALLMONITOR 
242b cd 00 14			call break_point_state  
242e				endm  
# End of macro CALLMONITOR
242e					endif 
242e 10 dd				djnz .pauses1 
2430			 
2430				       NEXTW 
2430 c3 8b 1b			jp macro_next 
2433				endm 
# End of macro NEXTW
2433			.ROT: 
2433				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2433 45				db WORD_SYS_CORE+49             
2434 81 24			dw .UWORDS            
2436 04				db 3 + 1 
2437 .. 00			db "ROT",0              
243b				endm 
# End of macro CWHEAD
243b			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
243b					if DEBUG_FORTH_WORDS_KEY 
243b						DMARK "ROT" 
243b f5				push af  
243c 3a 50 24			ld a, (.dmark)  
243f 32 77 fb			ld (debug_mark),a  
2442 3a 51 24			ld a, (.dmark+1)  
2445 32 78 fb			ld (debug_mark+1),a  
2448 3a 52 24			ld a, (.dmark+2)  
244b 32 79 fb			ld (debug_mark+2),a  
244e 18 03			jr .pastdmark  
2450 ..			.dmark: db "ROT"  
2453 f1			.pastdmark: pop af  
2454			endm  
# End of macro DMARK
2454						CALLMONITOR 
2454 cd 00 14			call break_point_state  
2457				endm  
# End of macro CALLMONITOR
2457					endif 
2457			 
2457					FORTH_DSP_VALUEHL 
2457 cd 35 1a			call macro_dsp_valuehl 
245a				endm 
# End of macro FORTH_DSP_VALUEHL
245a e5					push hl    ; u3  
245b			 
245b					FORTH_DSP_POP 
245b cd d1 1a			call macro_forth_dsp_pop 
245e				endm 
# End of macro FORTH_DSP_POP
245e			   
245e					FORTH_DSP_VALUEHL 
245e cd 35 1a			call macro_dsp_valuehl 
2461				endm 
# End of macro FORTH_DSP_VALUEHL
2461 e5					push hl     ; u2 
2462			 
2462					FORTH_DSP_POP 
2462 cd d1 1a			call macro_forth_dsp_pop 
2465				endm 
# End of macro FORTH_DSP_POP
2465			 
2465					FORTH_DSP_VALUEHL 
2465 cd 35 1a			call macro_dsp_valuehl 
2468				endm 
# End of macro FORTH_DSP_VALUEHL
2468 e5					push hl     ; u1 
2469			 
2469					FORTH_DSP_POP 
2469 cd d1 1a			call macro_forth_dsp_pop 
246c				endm 
# End of macro FORTH_DSP_POP
246c			 
246c c1					pop bc      ; u1 
246d e1					pop hl      ; u2 
246e d1					pop de      ; u3 
246f			 
246f			 
246f c5					push bc 
2470 d5					push de 
2471 e5					push hl 
2472			 
2472			 
2472 e1					pop hl 
2473 cd 9a 19				call forth_push_numhl 
2476			 
2476 e1					pop hl 
2477 cd 9a 19				call forth_push_numhl 
247a			 
247a e1					pop hl 
247b cd 9a 19				call forth_push_numhl 
247e					 
247e			 
247e			 
247e			 
247e			 
247e			 
247e				       NEXTW 
247e c3 8b 1b			jp macro_next 
2481				endm 
# End of macro NEXTW
2481			 
2481			.UWORDS: 
2481				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
2481 50				db WORD_SYS_CORE+60             
2482 43 25			dw .BP            
2484 07				db 6 + 1 
2485 .. 00			db "UWORDS",0              
248c				endm 
# End of macro CWHEAD
248c			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
248c			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
248c			; | | Following the count are the individual words. 
248c			; | | 
248c			; | | e.g. UWORDS 
248c			; | | BOX DIRLIST 2 
248c			; | |  
248c			; | | Can be used to save the words to storage via: 
248c			; | | UWORDS $01 DO $01 APPEND LOOP 
248c				if DEBUG_FORTH_WORDS_KEY 
248c					DMARK "UWR" 
248c f5				push af  
248d 3a a1 24			ld a, (.dmark)  
2490 32 77 fb			ld (debug_mark),a  
2493 3a a2 24			ld a, (.dmark+1)  
2496 32 78 fb			ld (debug_mark+1),a  
2499 3a a3 24			ld a, (.dmark+2)  
249c 32 79 fb			ld (debug_mark+2),a  
249f 18 03			jr .pastdmark  
24a1 ..			.dmark: db "UWR"  
24a4 f1			.pastdmark: pop af  
24a5			endm  
# End of macro DMARK
24a5					CALLMONITOR 
24a5 cd 00 14			call break_point_state  
24a8				endm  
# End of macro CALLMONITOR
24a8				endif 
24a8 21 00 80				ld hl, baseram 
24ab					;ld hl, baseusermem 
24ab 01 00 00				ld bc, 0    ; start a counter 
24ae			 
24ae				; skip dict stub 
24ae			 
24ae cd dc 1c				call forth_tok_next 
24b1			 
24b1			 
24b1			; while we have words to look for 
24b1			 
24b1 7e			.douscan:	ld a, (hl)      
24b2				if DEBUG_FORTH_WORDS 
24b2					DMARK "UWs" 
24b2 f5				push af  
24b3 3a c7 24			ld a, (.dmark)  
24b6 32 77 fb			ld (debug_mark),a  
24b9 3a c8 24			ld a, (.dmark+1)  
24bc 32 78 fb			ld (debug_mark+1),a  
24bf 3a c9 24			ld a, (.dmark+2)  
24c2 32 79 fb			ld (debug_mark+2),a  
24c5 18 03			jr .pastdmark  
24c7 ..			.dmark: db "UWs"  
24ca f1			.pastdmark: pop af  
24cb			endm  
# End of macro DMARK
24cb					CALLMONITOR 
24cb cd 00 14			call break_point_state  
24ce				endm  
# End of macro CALLMONITOR
24ce				endif 
24ce fe 00				cp WORD_SYS_END 
24d0 28 4d				jr z, .udone 
24d2 fe 01				cp WORD_SYS_UWORD 
24d4 20 44				jr nz, .nuword 
24d6			 
24d6				if DEBUG_FORTH_WORDS 
24d6					DMARK "UWu" 
24d6 f5				push af  
24d7 3a eb 24			ld a, (.dmark)  
24da 32 77 fb			ld (debug_mark),a  
24dd 3a ec 24			ld a, (.dmark+1)  
24e0 32 78 fb			ld (debug_mark+1),a  
24e3 3a ed 24			ld a, (.dmark+2)  
24e6 32 79 fb			ld (debug_mark+2),a  
24e9 18 03			jr .pastdmark  
24eb ..			.dmark: db "UWu"  
24ee f1			.pastdmark: pop af  
24ef			endm  
# End of macro DMARK
24ef					CALLMONITOR 
24ef cd 00 14			call break_point_state  
24f2				endm  
# End of macro CALLMONITOR
24f2				endif 
24f2					; we have a uword so push its name to the stack 
24f2			 
24f2 e5				   	push hl  ; save so we can move to next dict block 
24f3			 
24f3					; skip opcode 
24f3 23					inc hl  
24f4					; skip next ptr 
24f4 23					inc hl  
24f5 23					inc hl 
24f6					; skip len 
24f6 23					inc hl 
24f7				if DEBUG_FORTH_WORDS 
24f7					DMARK "UWt" 
24f7 f5				push af  
24f8 3a 0c 25			ld a, (.dmark)  
24fb 32 77 fb			ld (debug_mark),a  
24fe 3a 0d 25			ld a, (.dmark+1)  
2501 32 78 fb			ld (debug_mark+1),a  
2504 3a 0e 25			ld a, (.dmark+2)  
2507 32 79 fb			ld (debug_mark+2),a  
250a 18 03			jr .pastdmark  
250c ..			.dmark: db "UWt"  
250f f1			.pastdmark: pop af  
2510			endm  
# End of macro DMARK
2510					CALLMONITOR 
2510 cd 00 14			call break_point_state  
2513				endm  
# End of macro CALLMONITOR
2513				endif 
2513 03					inc bc 
2514			 
2514 c5					push bc 
2515 cd ac 19				call forth_push_str 
2518 c1					pop bc 
2519			 
2519 e1					pop hl 	 
251a			 
251a cd dc 1c		.nuword:	call forth_tok_next 
251d 18 92				jr .douscan  
251f			 
251f			.udone:		 ; push count of uwords found 
251f c5					push bc 
2520 e1					pop hl 
2521			 
2521				if DEBUG_FORTH_WORDS 
2521					DMARK "UWc" 
2521 f5				push af  
2522 3a 36 25			ld a, (.dmark)  
2525 32 77 fb			ld (debug_mark),a  
2528 3a 37 25			ld a, (.dmark+1)  
252b 32 78 fb			ld (debug_mark+1),a  
252e 3a 38 25			ld a, (.dmark+2)  
2531 32 79 fb			ld (debug_mark+2),a  
2534 18 03			jr .pastdmark  
2536 ..			.dmark: db "UWc"  
2539 f1			.pastdmark: pop af  
253a			endm  
# End of macro DMARK
253a					CALLMONITOR 
253a cd 00 14			call break_point_state  
253d				endm  
# End of macro CALLMONITOR
253d				endif 
253d cd 9a 19				call forth_push_numhl 
2540			 
2540			 
2540				       NEXTW 
2540 c3 8b 1b			jp macro_next 
2543				endm 
# End of macro NEXTW
2543			 
2543			.BP: 
2543				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2543 54				db WORD_SYS_CORE+64             
2544 79 25			dw .MONITOR            
2546 03				db 2 + 1 
2547 .. 00			db "BP",0              
254a				endm 
# End of macro CWHEAD
254a			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
254a			; | | $00 Will enable the break points within specific code paths 
254a			; | | $01 Will disable break points 
254a			; | |  
254a			; | | By default break points are off. Either the above can be used to enable them 
254a			; | | or if a key is held down during start up the spashscreen will appear to freeze 
254a			; | | and on release of the pressed key a message will be disaplayed to notify 
254a			; | | that break points are enabled. Pressing any key will then continue boot process. 
254a					; get byte count 
254a					if DEBUG_FORTH_WORDS_KEY 
254a						DMARK "BP." 
254a f5				push af  
254b 3a 5f 25			ld a, (.dmark)  
254e 32 77 fb			ld (debug_mark),a  
2551 3a 60 25			ld a, (.dmark+1)  
2554 32 78 fb			ld (debug_mark+1),a  
2557 3a 61 25			ld a, (.dmark+2)  
255a 32 79 fb			ld (debug_mark+2),a  
255d 18 03			jr .pastdmark  
255f ..			.dmark: db "BP."  
2562 f1			.pastdmark: pop af  
2563			endm  
# End of macro DMARK
2563						CALLMONITOR 
2563 cd 00 14			call break_point_state  
2566				endm  
# End of macro CALLMONITOR
2566					endif 
2566			 
2566					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2566 cd 35 1a			call macro_dsp_valuehl 
2569				endm 
# End of macro FORTH_DSP_VALUEHL
2569			 
2569			;		push hl 
2569			 
2569					; destroy value TOS 
2569			 
2569					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2569 cd d1 1a			call macro_forth_dsp_pop 
256c				endm 
# End of macro FORTH_DSP_POP
256c			 
256c			;		pop hl 
256c			 
256c 3e 00				ld a,0 
256e bd					cp l 
256f 28 02				jr z, .bpset 
2571 3e 2a				ld a, '*' 
2573			 
2573 32 31 ee		.bpset:		ld (os_view_disable), a 
2576			 
2576			 
2576					NEXTW 
2576 c3 8b 1b			jp macro_next 
2579				endm 
# End of macro NEXTW
2579			 
2579			 
2579			.MONITOR: 
2579				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
2579 55				db WORD_SYS_CORE+65             
257a ac 25			dw .MALLOC            
257c 08				db 7 + 1 
257d .. 00			db "MONITOR",0              
2585				endm 
# End of macro CWHEAD
2585			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
2585			; | | At start the current various registers will be displayed with contents. 
2585			; | | Top right corner will show the most recent debug marker seen. 
2585			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
2585			; | | and the return stack pointer (RSP). 
2585			; | | Pressing: 
2585			; | |    1 - Initial screen 
2585			; | |    2 - Display a data dump of HL 
2585			; | |    3 - Display a data dump of DE 
2585			; | |    4 - Display a data dump of BC 
2585			; | |    5 - Display a data dump of HL 
2585			; | |    6 - Display a data dump of DSP 
2585			; | |    7 - Display a data dump of RSP 
2585			; | |    8 - Display a data dump of what is at DSP 
2585			; | |    9 - Display a data dump of what is at RSP 
2585			; | |    0 - Exit monitor and continue running. This will also enable break points 
2585			; | |    * - Disable break points 
2585			; | |    # - Enter traditional monitor mode 
2585			; | | 
2585			; | | Monitor Mode 
2585			; | | ------------ 
2585			; | | A prompt of '>' will be shown for various commands: 
2585			; | |    D xxxx - Display a data dump starting from hex address xxxx 
2585			; | |    C - Continue display a data dump from the last set address 
2585			; | |    M xxxx - Set start of memory edit at address xx 
2585			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
2585			; | |    Q - Return to previous 
2585					if DEBUG_FORTH_WORDS_KEY 
2585						DMARK "MON" 
2585 f5				push af  
2586 3a 9a 25			ld a, (.dmark)  
2589 32 77 fb			ld (debug_mark),a  
258c 3a 9b 25			ld a, (.dmark+1)  
258f 32 78 fb			ld (debug_mark+1),a  
2592 3a 9c 25			ld a, (.dmark+2)  
2595 32 79 fb			ld (debug_mark+2),a  
2598 18 03			jr .pastdmark  
259a ..			.dmark: db "MON"  
259d f1			.pastdmark: pop af  
259e			endm  
# End of macro DMARK
259e						CALLMONITOR 
259e cd 00 14			call break_point_state  
25a1				endm  
# End of macro CALLMONITOR
25a1					endif 
25a1 3e 00				ld a, 0 
25a3 32 31 ee				ld (os_view_disable), a 
25a6			 
25a6					CALLMONITOR 
25a6 cd 00 14			call break_point_state  
25a9				endm  
# End of macro CALLMONITOR
25a9			 
25a9			;	call monitor 
25a9			 
25a9					NEXTW 
25a9 c3 8b 1b			jp macro_next 
25ac				endm 
# End of macro NEXTW
25ac			 
25ac			 
25ac			.MALLOC: 
25ac				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
25ac 56				db WORD_SYS_CORE+66             
25ad d5 25			dw .MALLOC2            
25af 06				db 5 + 1 
25b0 .. 00			db "ALLOT",0              
25b6				endm 
# End of macro CWHEAD
25b6			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25b6					if DEBUG_FORTH_WORDS_KEY 
25b6						DMARK "ALL" 
25b6 f5				push af  
25b7 3a cb 25			ld a, (.dmark)  
25ba 32 77 fb			ld (debug_mark),a  
25bd 3a cc 25			ld a, (.dmark+1)  
25c0 32 78 fb			ld (debug_mark+1),a  
25c3 3a cd 25			ld a, (.dmark+2)  
25c6 32 79 fb			ld (debug_mark+2),a  
25c9 18 03			jr .pastdmark  
25cb ..			.dmark: db "ALL"  
25ce f1			.pastdmark: pop af  
25cf			endm  
# End of macro DMARK
25cf						CALLMONITOR 
25cf cd 00 14			call break_point_state  
25d2				endm  
# End of macro CALLMONITOR
25d2					endif 
25d2 c3 fc 25				jp .mallocc 
25d5			.MALLOC2: 
25d5				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
25d5 56				db WORD_SYS_CORE+66             
25d6 13 26			dw .FREE            
25d8 07				db 6 + 1 
25d9 .. 00			db "MALLOC",0              
25e0				endm 
# End of macro CWHEAD
25e0			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
25e0					; get byte count 
25e0					if DEBUG_FORTH_WORDS_KEY 
25e0						DMARK "MAL" 
25e0 f5				push af  
25e1 3a f5 25			ld a, (.dmark)  
25e4 32 77 fb			ld (debug_mark),a  
25e7 3a f6 25			ld a, (.dmark+1)  
25ea 32 78 fb			ld (debug_mark+1),a  
25ed 3a f7 25			ld a, (.dmark+2)  
25f0 32 79 fb			ld (debug_mark+2),a  
25f3 18 03			jr .pastdmark  
25f5 ..			.dmark: db "MAL"  
25f8 f1			.pastdmark: pop af  
25f9			endm  
# End of macro DMARK
25f9						CALLMONITOR 
25f9 cd 00 14			call break_point_state  
25fc				endm  
# End of macro CALLMONITOR
25fc					endif 
25fc			.mallocc: 
25fc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
25fc cd 35 1a			call macro_dsp_valuehl 
25ff				endm 
# End of macro FORTH_DSP_VALUEHL
25ff			 
25ff			;		push hl 
25ff			 
25ff					; destroy value TOS 
25ff			 
25ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
25ff cd d1 1a			call macro_forth_dsp_pop 
2602				endm 
# End of macro FORTH_DSP_POP
2602			 
2602			;		pop hl 
2602 cd d9 10				call malloc 
2605				if DEBUG_FORTH_MALLOC_GUARD 
2605 f5					push af 
2606 cd 3b 0c				call ishlzero 
2609			;		ld a, l 
2609			;		add h 
2609			;		cp 0 
2609 f1					pop af 
260a					 
260a cc fc 4e				call z,malloc_error 
260d				endif 
260d			 
260d cd 9a 19				call forth_push_numhl 
2610					NEXTW 
2610 c3 8b 1b			jp macro_next 
2613				endm 
# End of macro NEXTW
2613			 
2613			.FREE: 
2613				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2613 57				db WORD_SYS_CORE+67             
2614 44 26			dw .LIST            
2616 05				db 4 + 1 
2617 .. 00			db "FREE",0              
261c				endm 
# End of macro CWHEAD
261c			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
261c					if DEBUG_FORTH_WORDS_KEY 
261c						DMARK "FRE" 
261c f5				push af  
261d 3a 31 26			ld a, (.dmark)  
2620 32 77 fb			ld (debug_mark),a  
2623 3a 32 26			ld a, (.dmark+1)  
2626 32 78 fb			ld (debug_mark+1),a  
2629 3a 33 26			ld a, (.dmark+2)  
262c 32 79 fb			ld (debug_mark+2),a  
262f 18 03			jr .pastdmark  
2631 ..			.dmark: db "FRE"  
2634 f1			.pastdmark: pop af  
2635			endm  
# End of macro DMARK
2635						CALLMONITOR 
2635 cd 00 14			call break_point_state  
2638				endm  
# End of macro CALLMONITOR
2638					endif 
2638					; get address 
2638			 
2638					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2638 cd 35 1a			call macro_dsp_valuehl 
263b				endm 
# End of macro FORTH_DSP_VALUEHL
263b			 
263b			;		push hl 
263b			 
263b					; destroy value TOS 
263b			 
263b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
263b cd d1 1a			call macro_forth_dsp_pop 
263e				endm 
# End of macro FORTH_DSP_POP
263e			 
263e			;		pop hl 
263e			if FORTH_ENABLE_MALLOCFREE 
263e cd a3 11				call free 
2641			endif 
2641					NEXTW 
2641 c3 8b 1b			jp macro_next 
2644				endm 
# End of macro NEXTW
2644			.LIST: 
2644				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2644 5c				db WORD_SYS_CORE+72             
2645 07 28			dw .FORGET            
2647 05				db 4 + 1 
2648 .. 00			db "LIST",0              
264d				endm 
# End of macro CWHEAD
264d			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
264d			; | | The quoted word must be in upper case. 
264d				if DEBUG_FORTH_WORDS_KEY 
264d					DMARK "LST" 
264d f5				push af  
264e 3a 62 26			ld a, (.dmark)  
2651 32 77 fb			ld (debug_mark),a  
2654 3a 63 26			ld a, (.dmark+1)  
2657 32 78 fb			ld (debug_mark+1),a  
265a 3a 64 26			ld a, (.dmark+2)  
265d 32 79 fb			ld (debug_mark+2),a  
2660 18 03			jr .pastdmark  
2662 ..			.dmark: db "LST"  
2665 f1			.pastdmark: pop af  
2666			endm  
# End of macro DMARK
2666					CALLMONITOR 
2666 cd 00 14			call break_point_state  
2669				endm  
# End of macro CALLMONITOR
2669				endif 
2669			 
2669					FORTH_DSP_VALUEHL 
2669 cd 35 1a			call macro_dsp_valuehl 
266c				endm 
# End of macro FORTH_DSP_VALUEHL
266c			 
266c e5					push hl 
266d c1					pop bc 
266e			 
266e			; Start format of scratch string 
266e			 
266e 21 32 ee				ld hl, scratch 
2671			 
2671 3e 3a				ld a, ':' 
2673 77					ld (hl),a 
2674 23					inc hl 
2675 3e 20				ld a, ' ' 
2677 77					ld (hl), a 
2678			 
2678					; Get ptr to the word we need to look up 
2678			 
2678			;		FORTH_DSP_VALUEHL 
2678					;v5 FORTH_DSP_VALUE 
2678				; TODO type check 
2678			;		inc hl    ; Skip type check  
2678			;		push hl 
2678			;		ex de, hl    ; put into DE 
2678			 
2678			 
2678 21 00 80				ld hl, baseram 
267b					;ld hl, baseusermem 
267b			 
267b e5			push hl   ; sacreifical push 
267c			 
267c			.ldouscanm: 
267c e1				pop hl 
267d			.ldouscan: 
267d				if DEBUG_FORTH_WORDS 
267d					DMARK "LSs" 
267d f5				push af  
267e 3a 92 26			ld a, (.dmark)  
2681 32 77 fb			ld (debug_mark),a  
2684 3a 93 26			ld a, (.dmark+1)  
2687 32 78 fb			ld (debug_mark+1),a  
268a 3a 94 26			ld a, (.dmark+2)  
268d 32 79 fb			ld (debug_mark+2),a  
2690 18 03			jr .pastdmark  
2692 ..			.dmark: db "LSs"  
2695 f1			.pastdmark: pop af  
2696			endm  
# End of macro DMARK
2696					CALLMONITOR 
2696 cd 00 14			call break_point_state  
2699				endm  
# End of macro CALLMONITOR
2699				endif 
2699				; skip dict stub 
2699 cd dc 1c				call forth_tok_next 
269c			 
269c			 
269c			; while we have words to look for 
269c			 
269c 7e				ld a, (hl)      
269d				if DEBUG_FORTH_WORDS 
269d					DMARK "LSk" 
269d f5				push af  
269e 3a b2 26			ld a, (.dmark)  
26a1 32 77 fb			ld (debug_mark),a  
26a4 3a b3 26			ld a, (.dmark+1)  
26a7 32 78 fb			ld (debug_mark+1),a  
26aa 3a b4 26			ld a, (.dmark+2)  
26ad 32 79 fb			ld (debug_mark+2),a  
26b0 18 03			jr .pastdmark  
26b2 ..			.dmark: db "LSk"  
26b5 f1			.pastdmark: pop af  
26b6			endm  
# End of macro DMARK
26b6					CALLMONITOR 
26b6 cd 00 14			call break_point_state  
26b9				endm  
# End of macro CALLMONITOR
26b9				endif 
26b9 fe 00				cp WORD_SYS_END 
26bb ca ee 27				jp z, .lunotfound 
26be fe 01				cp WORD_SYS_UWORD 
26c0 c2 7d 26				jp nz, .ldouscan 
26c3			 
26c3				if DEBUG_FORTH_WORDS 
26c3					DMARK "LSu" 
26c3 f5				push af  
26c4 3a d8 26			ld a, (.dmark)  
26c7 32 77 fb			ld (debug_mark),a  
26ca 3a d9 26			ld a, (.dmark+1)  
26cd 32 78 fb			ld (debug_mark+1),a  
26d0 3a da 26			ld a, (.dmark+2)  
26d3 32 79 fb			ld (debug_mark+2),a  
26d6 18 03			jr .pastdmark  
26d8 ..			.dmark: db "LSu"  
26db f1			.pastdmark: pop af  
26dc			endm  
# End of macro DMARK
26dc					CALLMONITOR 
26dc cd 00 14			call break_point_state  
26df				endm  
# End of macro CALLMONITOR
26df				endif 
26df			 
26df					; found a uword but is it the one we want... 
26df			 
26df c5					push bc     ; uword to find is on bc 
26e0 d1					pop de 
26e1			 
26e1 e5					push hl  ; to save the ptr 
26e2			 
26e2					; skip opcode 
26e2 23					inc hl  
26e3					; skip next ptr 
26e3 23					inc hl  
26e4 23					inc hl 
26e5					; skip len 
26e5 23					inc hl 
26e6			 
26e6				if DEBUG_FORTH_WORDS 
26e6					DMARK "LSc" 
26e6 f5				push af  
26e7 3a fb 26			ld a, (.dmark)  
26ea 32 77 fb			ld (debug_mark),a  
26ed 3a fc 26			ld a, (.dmark+1)  
26f0 32 78 fb			ld (debug_mark+1),a  
26f3 3a fd 26			ld a, (.dmark+2)  
26f6 32 79 fb			ld (debug_mark+2),a  
26f9 18 03			jr .pastdmark  
26fb ..			.dmark: db "LSc"  
26fe f1			.pastdmark: pop af  
26ff			endm  
# End of macro DMARK
26ff					CALLMONITOR 
26ff cd 00 14			call break_point_state  
2702				endm  
# End of macro CALLMONITOR
2702				endif 
2702 cd a8 10				call strcmp 
2705 c2 7c 26				jp nz, .ldouscanm 
2708				 
2708			 
2708			 
2708					; we have a uword so push its name to the stack 
2708			 
2708			;	   	push hl  ; save so we can move to next dict block 
2708 e1			pop hl 
2709			 
2709				if DEBUG_FORTH_WORDS 
2709					DMARK "LSm" 
2709 f5				push af  
270a 3a 1e 27			ld a, (.dmark)  
270d 32 77 fb			ld (debug_mark),a  
2710 3a 1f 27			ld a, (.dmark+1)  
2713 32 78 fb			ld (debug_mark+1),a  
2716 3a 20 27			ld a, (.dmark+2)  
2719 32 79 fb			ld (debug_mark+2),a  
271c 18 03			jr .pastdmark  
271e ..			.dmark: db "LSm"  
2721 f1			.pastdmark: pop af  
2722			endm  
# End of macro DMARK
2722					CALLMONITOR 
2722 cd 00 14			call break_point_state  
2725				endm  
# End of macro CALLMONITOR
2725				endif 
2725			 
2725					; skip opcode 
2725 23					inc hl  
2726					; skip next ptr 
2726 23					inc hl  
2727 23					inc hl 
2728					; skip len 
2728 7e					ld a, (hl)   ; save length to add 
2729				if DEBUG_FORTH_WORDS 
2729					DMARK "LS2" 
2729 f5				push af  
272a 3a 3e 27			ld a, (.dmark)  
272d 32 77 fb			ld (debug_mark),a  
2730 3a 3f 27			ld a, (.dmark+1)  
2733 32 78 fb			ld (debug_mark+1),a  
2736 3a 40 27			ld a, (.dmark+2)  
2739 32 79 fb			ld (debug_mark+2),a  
273c 18 03			jr .pastdmark  
273e ..			.dmark: db "LS2"  
2741 f1			.pastdmark: pop af  
2742			endm  
# End of macro DMARK
2742					CALLMONITOR 
2742 cd 00 14			call break_point_state  
2745				endm  
# End of macro CALLMONITOR
2745				endif 
2745			 
2745					; save this location 
2745				 
2745 e5					push hl 
2746			 
2746 23					inc hl 
2747 11 34 ee				ld de, scratch+2 
274a 4f					ld c, a 
274b 06 00				ld b, 0 
274d			 
274d				if DEBUG_FORTH_WORDS 
274d					DMARK "LSn" 
274d f5				push af  
274e 3a 62 27			ld a, (.dmark)  
2751 32 77 fb			ld (debug_mark),a  
2754 3a 63 27			ld a, (.dmark+1)  
2757 32 78 fb			ld (debug_mark+1),a  
275a 3a 64 27			ld a, (.dmark+2)  
275d 32 79 fb			ld (debug_mark+2),a  
2760 18 03			jr .pastdmark  
2762 ..			.dmark: db "LSn"  
2765 f1			.pastdmark: pop af  
2766			endm  
# End of macro DMARK
2766					CALLMONITOR 
2766 cd 00 14			call break_point_state  
2769				endm  
# End of macro CALLMONITOR
2769				endif 
2769			 
2769					; copy uword name to scratch 
2769			 
2769 ed b0				ldir 
276b			 
276b 1b					dec de 
276c 3e 20				ld a, ' '    ; change null to space 
276e 12					ld (de), a 
276f			 
276f 13					inc de 
2770			 
2770 d5					push de 
2771 c1					pop bc     ; move scratch pointer to end of word name and save it 
2772			 
2772 e1					pop hl 
2773 7e					ld a, (hl) 
2774					;inc hl 
2774					; skip word string 
2774 cd 12 0c				call addatohl 
2777			 
2777 23					inc hl 
2778			 
2778				if DEBUG_FORTH_WORDS 
2778					DMARK "LS3" 
2778 f5				push af  
2779 3a 8d 27			ld a, (.dmark)  
277c 32 77 fb			ld (debug_mark),a  
277f 3a 8e 27			ld a, (.dmark+1)  
2782 32 78 fb			ld (debug_mark+1),a  
2785 3a 8f 27			ld a, (.dmark+2)  
2788 32 79 fb			ld (debug_mark+2),a  
278b 18 03			jr .pastdmark  
278d ..			.dmark: db "LS3"  
2790 f1			.pastdmark: pop af  
2791			endm  
# End of macro DMARK
2791					CALLMONITOR 
2791 cd 00 14			call break_point_state  
2794				endm  
# End of macro CALLMONITOR
2794				endif 
2794					; should now be at the start of the machine code to setup the eval of the uword 
2794					; now locate the ptr to the string defintion 
2794			 
2794					; skip ld hl, 
2794					; then load the ptr 
2794			 
2794 23					inc hl 
2795 5e					ld e, (hl) 
2796 23					inc hl 
2797 56					ld d, (hl) 
2798 eb					ex de, hl 
2799			 
2799			 
2799				if DEBUG_FORTH_WORDS 
2799					DMARK "LSt" 
2799 f5				push af  
279a 3a ae 27			ld a, (.dmark)  
279d 32 77 fb			ld (debug_mark),a  
27a0 3a af 27			ld a, (.dmark+1)  
27a3 32 78 fb			ld (debug_mark+1),a  
27a6 3a b0 27			ld a, (.dmark+2)  
27a9 32 79 fb			ld (debug_mark+2),a  
27ac 18 03			jr .pastdmark  
27ae ..			.dmark: db "LSt"  
27b1 f1			.pastdmark: pop af  
27b2			endm  
# End of macro DMARK
27b2					CALLMONITOR 
27b2 cd 00 14			call break_point_state  
27b5				endm  
# End of macro CALLMONITOR
27b5				endif 
27b5			 
27b5			; cant push right now due to tokenised strings  
27b5			 
27b5			; get the destination of where to copy this definition to. 
27b5			 
27b5 c5					push bc 
27b6 d1					pop de 
27b7			 
27b7 7e			.listl:         ld a,(hl) 
27b8 fe 00				cp 0 
27ba 28 09				jr z, .lreplsp     ; replace zero with space 
27bc fe 7f				cp FORTH_END_BUFFER 
27be 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
27c0				 
27c0					; just copy this char as is then 
27c0			 
27c0 12					ld (de), a 
27c1			 
27c1 23			.listnxt:	inc hl 
27c2 13					inc de 
27c3 18 f2				jr .listl 
27c5			 
27c5 3e 20		.lreplsp:	ld a,' ' 
27c7 12					ld (de), a 
27c8 18 f7				jr .listnxt 
27ca			 
27ca			; close up uword def 
27ca			 
27ca			.listdone: 
27ca 3e 00				ld a, 0 
27cc 12					ld (de), a 
27cd			 
27cd			; now have def so clean up and push to stack 
27cd			 
27cd 21 32 ee				ld hl, scratch 
27d0				if DEBUG_FORTH_WORDS 
27d0					DMARK "Ltp" 
27d0 f5				push af  
27d1 3a e5 27			ld a, (.dmark)  
27d4 32 77 fb			ld (debug_mark),a  
27d7 3a e6 27			ld a, (.dmark+1)  
27da 32 78 fb			ld (debug_mark+1),a  
27dd 3a e7 27			ld a, (.dmark+2)  
27e0 32 79 fb			ld (debug_mark+2),a  
27e3 18 03			jr .pastdmark  
27e5 ..			.dmark: db "Ltp"  
27e8 f1			.pastdmark: pop af  
27e9			endm  
# End of macro DMARK
27e9					CALLMONITOR 
27e9 cd 00 14			call break_point_state  
27ec				endm  
# End of macro CALLMONITOR
27ec				endif 
27ec			 
27ec 18 06			jr .listpush 
27ee			 
27ee			;.lnuword:	pop hl 
27ee			;		call forth_tok_next 
27ee			;		jp .ldouscan  
27ee			 
27ee			.lunotfound:		  
27ee			 
27ee			 
27ee					 
27ee					FORTH_DSP_POP 
27ee cd d1 1a			call macro_forth_dsp_pop 
27f1				endm 
# End of macro FORTH_DSP_POP
27f1 21 fa 27				ld hl, .luno 
27f4						 
27f4			 
27f4			.listpush: 
27f4 cd ac 19				call forth_push_str 
27f7			 
27f7			 
27f7			 
27f7					NEXTW 
27f7 c3 8b 1b			jp macro_next 
27fa				endm 
# End of macro NEXTW
27fa			 
27fa .. 00		.luno:    db "Not found",0 
2804			 
2804			 
2804			 
2804			 
2804			 
2804			;		push hl   ; save pointer to start of uword def string 
2804			; 
2804			;; look for FORTH_EOL_LINE 
2804			;		ld a, FORTH_END_BUFFER 
2804			;		call strlent 
2804			; 
2804			;		inc hl		 ; space for coln def 
2804			;		inc hl 
2804			;		inc hl          ; space for terms 
2804			;		inc hl 
2804			; 
2804			;		ld a, 20   ; TODO get actual length 
2804			;		call addatohl    ; include a random amount of room for the uword name 
2804			; 
2804			;		 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt1" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;		 
2804			; 
2804			;; malloc space for the string because we cant change it 
2804			; 
2804			;		call malloc 
2804			;	if DEBUG_FORTH_MALLOC_GUARD 
2804			;		push af 
2804			;		call ishlzero 
2804			;		pop af 
2804			;		 
2804			;		call z,malloc_error 
2804			;	endif 
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt2" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;		pop de 
2804			;		push hl    ; push the malloc to release later 
2804			;		push hl   ;  push back a copy for the later stack push 
2804			;		 
2804			;; copy the string swapping out the zero terms for spaces 
2804			; 
2804			;		; de has our source 
2804			;		; hl has our dest 
2804			; 
2804			;; add the coln def 
2804			; 
2804			;		ld a, ':' 
2804			;		ld (hl), a 
2804			;		inc hl 
2804			;		ld a, ' ' 
2804			;		ld (hl), a 
2804			;		inc hl 
2804			; 
2804			;; add the uname word 
2804			;		push de   ; save our string for now 
2804			;		ex de, hl 
2804			; 
2804			;		FORTH_DSP_VALUE 
2804			;		;v5 FORTH_DSP_VALUE 
2804			; 
2804			;		inc hl   ; skip type but we know by now this is OK 
2804			; 
2804			;.luword:	ld a,(hl) 
2804			;		cp 0 
2804			;		jr z, .luword2 
2804			;		ld (de), a 
2804			;		inc de 
2804			;		inc hl 
2804			;		jr .luword 
2804			; 
2804			;.luword2:	ld a, ' ' 
2804			;		ld (de), a 
2804			;;		inc hl 
2804			;;		inc de 
2804			;;		ld (de), a 
2804			;;		inc hl 
2804			;		inc de 
2804			; 
2804			;		ex de, hl 
2804			;		pop de 
2804			;		 
2804			;		 
2804			; 
2804			;; detoken that string and copy it 
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt2" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;.ldetok:	ld a, (de) 
2804			;		cp FORTH_END_BUFFER 
2804			;		jr z, .ldetokend 
2804			;		; swap out any zero term for space 
2804			;		cp 0 
2804			;		jr nz, .ldetoknext 
2804			;		ld a, ' ' 
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "LtS" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;.ldetoknext:	ld (hl), a 
2804			;		inc de 
2804			;		inc hl 
2804			;		jr .ldetok 
2804			; 
2804			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2804			;		ld (hl), a  
2804			; 
2804			;; free that temp malloc 
2804			; 
2804			;		pop hl    
2804			; 
2804			;	if DEBUG_FORTH_WORDS 
2804			;		DMARK "Lt4" 
2804			;		CALLMONITOR 
2804			;	endif 
2804			;		call forth_apushstrhl 
2804			; 
2804			;		; get rid of temp malloc area 
2804			; 
2804			;		pop hl 
2804			;		call free 
2804			; 
2804			;		jr .ludone 
2804			; 
2804			;.lnuword:	pop hl 
2804			;		call forth_tok_next 
2804			;		jp .ldouscan  
2804			; 
2804			;.ludone:		 pop hl 
2804			; 
2804					NEXTW 
2804 c3 8b 1b			jp macro_next 
2807				endm 
# End of macro NEXTW
2807			 
2807			.FORGET: 
2807				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2807 5d				db WORD_SYS_CORE+73             
2808 80 28			dw .NOP            
280a 07				db 6 + 1 
280b .. 00			db "FORGET",0              
2812				endm 
# End of macro CWHEAD
2812			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
2812			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
2812			; | |  
2812			; | | e.g. "MORE" forget 
2812					if DEBUG_FORTH_WORDS_KEY 
2812						DMARK "FRG" 
2812 f5				push af  
2813 3a 27 28			ld a, (.dmark)  
2816 32 77 fb			ld (debug_mark),a  
2819 3a 28 28			ld a, (.dmark+1)  
281c 32 78 fb			ld (debug_mark+1),a  
281f 3a 29 28			ld a, (.dmark+2)  
2822 32 79 fb			ld (debug_mark+2),a  
2825 18 03			jr .pastdmark  
2827 ..			.dmark: db "FRG"  
282a f1			.pastdmark: pop af  
282b			endm  
# End of macro DMARK
282b						CALLMONITOR 
282b cd 00 14			call break_point_state  
282e				endm  
# End of macro CALLMONITOR
282e					endif 
282e			 
282e				; find uword 
282e			        ; update start of word with "_" 
282e				; replace uword with deleted flag 
282e			 
282e			 
282e			;	if DEBUG_FORTH_WORDS 
282e			;		DMARK "FOG" 
282e			;		CALLMONITOR 
282e			;	endif 
282e			 
282e			 
282e					; Get ptr to the word we need to look up 
282e			 
282e					FORTH_DSP_VALUEHL 
282e cd 35 1a			call macro_dsp_valuehl 
2831				endm 
# End of macro FORTH_DSP_VALUEHL
2831					;v5 FORTH_DSP_VALUE 
2831				; TODO type check 
2831			;		inc hl    ; Skip type check  
2831 e5					push hl 
2832 c1					pop bc 
2833			;		ex de, hl    ; put into DE 
2833			 
2833			 
2833 21 00 80				ld hl, baseram 
2836					;ld hl, baseusermem 
2836			 
2836				; skip dict stub 
2836			;	call forth_tok_next 
2836 e5			push hl   ; sacreifical push 
2837			 
2837			.fldouscanm: 
2837 e1				pop hl 
2838			.fldouscan: 
2838			;	if DEBUG_FORTH_WORDS 
2838			;		DMARK "LSs" 
2838			;		CALLMONITOR 
2838			;	endif 
2838				; skip dict stub 
2838 cd dc 1c				call forth_tok_next 
283b			 
283b			 
283b			; while we have words to look for 
283b			 
283b 7e				ld a, (hl)      
283c			;	if DEBUG_FORTH_WORDS 
283c			;		DMARK "LSk" 
283c			;		CALLMONITOR 
283c			;	endif 
283c fe 00				cp WORD_SYS_END 
283e ca 7a 28				jp z, .flunotfound 
2841 fe 01				cp WORD_SYS_UWORD 
2843 c2 38 28				jp nz, .fldouscan 
2846			 
2846			;	if DEBUG_FORTH_WORDS 
2846			;		DMARK "LSu" 
2846			;		CALLMONITOR 
2846			;	endif 
2846			 
2846					; found a uword but is it the one we want... 
2846			 
2846 c5					push bc     ; uword to find is on bc 
2847 d1					pop de 
2848			 
2848 e5					push hl  ; to save the ptr 
2849			 
2849					; skip opcode 
2849 23					inc hl  
284a					; skip next ptr 
284a 23					inc hl  
284b 23					inc hl 
284c					; skip len 
284c 23					inc hl 
284d			 
284d			;	if DEBUG_FORTH_WORDS 
284d			;		DMARK "LSc" 
284d			;		CALLMONITOR 
284d			;	endif 
284d cd a8 10				call strcmp 
2850 c2 37 28				jp nz, .fldouscanm 
2853			; 
2853			; 
2853			;; while we have words to look for 
2853			; 
2853			;.fdouscan:	ld a, (hl)      
2853			;	if DEBUG_FORTH_WORDS 
2853			;		DMARK "LSs" 
2853			;		CALLMONITOR 
2853			;	endif 
2853			;		cp WORD_SYS_END 
2853			;		jp z, .fudone 
2853			;		cp WORD_SYS_UWORD 
2853			;		jp nz, .fnuword 
2853			; 
2853			;	if DEBUG_FORTH_WORDS 
2853			;		DMARK "FGu" 
2853			;		CALLMONITOR 
2853			;	endif 
2853			; 
2853			;		; found a uword but is it the one we want... 
2853			; 
2853			; 
2853			;	        pop de   ; get back the dsp name 
2853			;		push de 
2853			; 
2853			;		push hl  ; to save the ptr 
2853			; 
2853			;		; skip opcode 
2853			;		inc hl  
2853			;		; skip next ptr 
2853			;		inc hl  
2853			;		inc hl 
2853			;		; skip len 
2853			;		inc hl 
2853			; 
2853			;	if DEBUG_FORTH_WORDS 
2853			;		DMARK "FGc" 
2853			;		CALLMONITOR 
2853			;	endif 
2853			;		call strcmp 
2853			;		jp nz, .fnuword 
2853			 
2853			 
2853 e1			pop hl 
2854			 
2854				 
2854				if DEBUG_FORTH_WORDS 
2854					DMARK "FGm" 
2854 f5				push af  
2855 3a 69 28			ld a, (.dmark)  
2858 32 77 fb			ld (debug_mark),a  
285b 3a 6a 28			ld a, (.dmark+1)  
285e 32 78 fb			ld (debug_mark+1),a  
2861 3a 6b 28			ld a, (.dmark+2)  
2864 32 79 fb			ld (debug_mark+2),a  
2867 18 03			jr .pastdmark  
2869 ..			.dmark: db "FGm"  
286c f1			.pastdmark: pop af  
286d			endm  
# End of macro DMARK
286d					CALLMONITOR 
286d cd 00 14			call break_point_state  
2870				endm  
# End of macro CALLMONITOR
2870				endif 
2870			 
2870			 
2870			 
2870					; we have a uword so push its name to the stack 
2870			 
2870			;	   	push hl  ; save so we can move to next dict block 
2870			;pop hl 
2870			 
2870					; update opcode to deleted 
2870 3e 03				ld a, WORD_SYS_DELETED 
2872 77					ld (hl), a 
2873			 
2873 23					inc hl  
2874					; skip next ptr 
2874 23					inc hl  
2875 23					inc hl 
2876					; skip len 
2876 23					inc hl 
2877			 
2877					; TODO change parser to skip deleted words but for now mark it out 
2877 3e 5f				ld a, "_" 
2879 77					ld  (hl),a 
287a			 
287a			;		jr .fudone 
287a			; 
287a			;.fnuword:	pop hl 
287a			;		call forth_tok_next 
287a			;		jp .fdouscan  
287a			 
287a			.flunotfound:		  
287a			 
287a			 
287a					 
287a					FORTH_DSP_POP 
287a cd d1 1a			call macro_forth_dsp_pop 
287d				endm 
# End of macro FORTH_DSP_POP
287d			;		ld hl, .luno 
287d			;.fudone:		 pop hl 
287d					NEXTW 
287d c3 8b 1b			jp macro_next 
2880				endm 
# End of macro NEXTW
2880			.NOP: 
2880				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
2880 61				db WORD_SYS_CORE+77             
2881 a7 28			dw .COMO            
2883 04				db 3 + 1 
2884 .. 00			db "NOP",0              
2888				endm 
# End of macro CWHEAD
2888			; | NOP (  --  ) Do nothing | DONE 
2888					if DEBUG_FORTH_WORDS_KEY 
2888						DMARK "NOP" 
2888 f5				push af  
2889 3a 9d 28			ld a, (.dmark)  
288c 32 77 fb			ld (debug_mark),a  
288f 3a 9e 28			ld a, (.dmark+1)  
2892 32 78 fb			ld (debug_mark+1),a  
2895 3a 9f 28			ld a, (.dmark+2)  
2898 32 79 fb			ld (debug_mark+2),a  
289b 18 03			jr .pastdmark  
289d ..			.dmark: db "NOP"  
28a0 f1			.pastdmark: pop af  
28a1			endm  
# End of macro DMARK
28a1						CALLMONITOR 
28a1 cd 00 14			call break_point_state  
28a4				endm  
# End of macro CALLMONITOR
28a4					endif 
28a4				       NEXTW 
28a4 c3 8b 1b			jp macro_next 
28a7				endm 
# End of macro NEXTW
28a7			.COMO: 
28a7				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
28a7 6e				db WORD_SYS_CORE+90             
28a8 f9 28			dw .COMC            
28aa 02				db 1 + 1 
28ab .. 00			db "(",0              
28ad				endm 
# End of macro CWHEAD
28ad			; | ( ( -- )  Start of comment | DONE 
28ad			 
28ad			 
28ad 2a 33 f1				ld hl, ( os_tok_ptr) 
28b0 11 f4 28			ld de, .closepar 
28b3					 
28b3					if DEBUG_FORTH_WORDS 
28b3						DMARK ").." 
28b3 f5				push af  
28b4 3a c8 28			ld a, (.dmark)  
28b7 32 77 fb			ld (debug_mark),a  
28ba 3a c9 28			ld a, (.dmark+1)  
28bd 32 78 fb			ld (debug_mark+1),a  
28c0 3a ca 28			ld a, (.dmark+2)  
28c3 32 79 fb			ld (debug_mark+2),a  
28c6 18 03			jr .pastdmark  
28c8 ..			.dmark: db ").."  
28cb f1			.pastdmark: pop af  
28cc			endm  
# End of macro DMARK
28cc						CALLMONITOR 
28cc cd 00 14			call break_point_state  
28cf				endm  
# End of macro CALLMONITOR
28cf					endif 
28cf cd a6 1c			call findnexttok  
28d2			 
28d2					if DEBUG_FORTH_WORDS 
28d2						DMARK "IF5" 
28d2 f5				push af  
28d3 3a e7 28			ld a, (.dmark)  
28d6 32 77 fb			ld (debug_mark),a  
28d9 3a e8 28			ld a, (.dmark+1)  
28dc 32 78 fb			ld (debug_mark+1),a  
28df 3a e9 28			ld a, (.dmark+2)  
28e2 32 79 fb			ld (debug_mark+2),a  
28e5 18 03			jr .pastdmark  
28e7 ..			.dmark: db "IF5"  
28ea f1			.pastdmark: pop af  
28eb			endm  
# End of macro DMARK
28eb						CALLMONITOR 
28eb cd 00 14			call break_point_state  
28ee				endm  
# End of macro CALLMONITOR
28ee					endif 
28ee				; replace below with ) exec using tok_ptr 
28ee 22 33 f1			ld (os_tok_ptr), hl 
28f1 c3 1c 1c			jp exec1 
28f4			 
28f4 .. 00			.closepar:   db ")",0 
28f6			 
28f6				       NEXTW 
28f6 c3 8b 1b			jp macro_next 
28f9				endm 
# End of macro NEXTW
28f9			.COMC: 
28f9				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
28f9 6f				db WORD_SYS_CORE+91             
28fa 02 29			dw .SCRATCH            
28fc 02				db 1 + 1 
28fd .. 00			db ")",0              
28ff				endm 
# End of macro CWHEAD
28ff			; | ) ( -- )  End of comment |  DONE  
28ff				       NEXTW 
28ff c3 8b 1b			jp macro_next 
2902				endm 
# End of macro NEXTW
2902			 
2902			.SCRATCH: 
2902				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2902 6f				db WORD_SYS_CORE+91             
2903 3d 29			dw .INC            
2905 08				db 7 + 1 
2906 .. 00			db "SCRATCH",0              
290e				endm 
# End of macro CWHEAD
290e			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
290e			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
290e			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
290e			; | |  
290e			; | | e.g.    : score $00 scratch ; 
290e			; | |  
290e			; | | $00 score ! 
290e			; | | $01 score +! 
290e			; | |  
290e			; | | e.g.   : varword $0a scratch ;  
290e			; | | 
290e			; | | $8000 varword ! 
290e					if DEBUG_FORTH_WORDS_KEY 
290e						DMARK "SCR" 
290e f5				push af  
290f 3a 23 29			ld a, (.dmark)  
2912 32 77 fb			ld (debug_mark),a  
2915 3a 24 29			ld a, (.dmark+1)  
2918 32 78 fb			ld (debug_mark+1),a  
291b 3a 25 29			ld a, (.dmark+2)  
291e 32 79 fb			ld (debug_mark+2),a  
2921 18 03			jr .pastdmark  
2923 ..			.dmark: db "SCR"  
2926 f1			.pastdmark: pop af  
2927			endm  
# End of macro DMARK
2927						CALLMONITOR 
2927 cd 00 14			call break_point_state  
292a				endm  
# End of macro CALLMONITOR
292a					endif 
292a			 
292a					FORTH_DSP_VALUEHL 
292a cd 35 1a			call macro_dsp_valuehl 
292d				endm 
# End of macro FORTH_DSP_VALUEHL
292d				 
292d					FORTH_DSP_POP 
292d cd d1 1a			call macro_forth_dsp_pop 
2930				endm 
# End of macro FORTH_DSP_POP
2930			 
2930 7d					ld a, l 
2931 21 57 f3				ld hl, os_var_array 
2934 cd 12 0c				call addatohl 
2937			 
2937 cd 9a 19				call forth_push_numhl 
293a			 
293a				       NEXTW 
293a c3 8b 1b			jp macro_next 
293d				endm 
# End of macro NEXTW
293d			 
293d			.INC: 
293d				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
293d 6f				db WORD_SYS_CORE+91             
293e 91 29			dw .DEC            
2940 03				db 2 + 1 
2941 .. 00			db "+!",0              
2944				endm 
# End of macro CWHEAD
2944			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2944					if DEBUG_FORTH_WORDS_KEY 
2944						DMARK "+s_" 
2944 f5				push af  
2945 3a 59 29			ld a, (.dmark)  
2948 32 77 fb			ld (debug_mark),a  
294b 3a 5a 29			ld a, (.dmark+1)  
294e 32 78 fb			ld (debug_mark+1),a  
2951 3a 5b 29			ld a, (.dmark+2)  
2954 32 79 fb			ld (debug_mark+2),a  
2957 18 03			jr .pastdmark  
2959 ..			.dmark: db "+s_"  
295c f1			.pastdmark: pop af  
295d			endm  
# End of macro DMARK
295d						CALLMONITOR 
295d cd 00 14			call break_point_state  
2960				endm  
# End of macro CALLMONITOR
2960					endif 
2960			 
2960					FORTH_DSP_VALUEHL 
2960 cd 35 1a			call macro_dsp_valuehl 
2963				endm 
# End of macro FORTH_DSP_VALUEHL
2963			 
2963 e5					push hl   ; save address 
2964			 
2964					FORTH_DSP_POP 
2964 cd d1 1a			call macro_forth_dsp_pop 
2967				endm 
# End of macro FORTH_DSP_POP
2967			 
2967					FORTH_DSP_VALUEHL 
2967 cd 35 1a			call macro_dsp_valuehl 
296a				endm 
# End of macro FORTH_DSP_VALUEHL
296a			 
296a					FORTH_DSP_POP 
296a cd d1 1a			call macro_forth_dsp_pop 
296d				endm 
# End of macro FORTH_DSP_POP
296d			 
296d					; hl contains value to add to byte at a 
296d				 
296d eb					ex de, hl 
296e			 
296e e1					pop hl 
296f			 
296f					if DEBUG_FORTH_WORDS 
296f						DMARK "INC" 
296f f5				push af  
2970 3a 84 29			ld a, (.dmark)  
2973 32 77 fb			ld (debug_mark),a  
2976 3a 85 29			ld a, (.dmark+1)  
2979 32 78 fb			ld (debug_mark+1),a  
297c 3a 86 29			ld a, (.dmark+2)  
297f 32 79 fb			ld (debug_mark+2),a  
2982 18 03			jr .pastdmark  
2984 ..			.dmark: db "INC"  
2987 f1			.pastdmark: pop af  
2988			endm  
# End of macro DMARK
2988						CALLMONITOR 
2988 cd 00 14			call break_point_state  
298b				endm  
# End of macro CALLMONITOR
298b					endif 
298b			 
298b 7e					ld a,(hl) 
298c 83					add e 
298d 77					ld (hl),a 
298e			 
298e			 
298e			 
298e				       NEXTW 
298e c3 8b 1b			jp macro_next 
2991				endm 
# End of macro NEXTW
2991			 
2991			.DEC: 
2991				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2991 6f				db WORD_SYS_CORE+91             
2992 e2 29			dw .INC2            
2994 03				db 2 + 1 
2995 .. 00			db "-!",0              
2998				endm 
# End of macro CWHEAD
2998			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2998					if DEBUG_FORTH_WORDS_KEY 
2998						DMARK "-s_" 
2998 f5				push af  
2999 3a ad 29			ld a, (.dmark)  
299c 32 77 fb			ld (debug_mark),a  
299f 3a ae 29			ld a, (.dmark+1)  
29a2 32 78 fb			ld (debug_mark+1),a  
29a5 3a af 29			ld a, (.dmark+2)  
29a8 32 79 fb			ld (debug_mark+2),a  
29ab 18 03			jr .pastdmark  
29ad ..			.dmark: db "-s_"  
29b0 f1			.pastdmark: pop af  
29b1			endm  
# End of macro DMARK
29b1						CALLMONITOR 
29b1 cd 00 14			call break_point_state  
29b4				endm  
# End of macro CALLMONITOR
29b4					endif 
29b4			 
29b4					FORTH_DSP_VALUEHL 
29b4 cd 35 1a			call macro_dsp_valuehl 
29b7				endm 
# End of macro FORTH_DSP_VALUEHL
29b7			 
29b7 e5					push hl   ; save address 
29b8			 
29b8					FORTH_DSP_POP 
29b8 cd d1 1a			call macro_forth_dsp_pop 
29bb				endm 
# End of macro FORTH_DSP_POP
29bb			 
29bb					FORTH_DSP_VALUEHL 
29bb cd 35 1a			call macro_dsp_valuehl 
29be				endm 
# End of macro FORTH_DSP_VALUEHL
29be			 
29be					; hl contains value to add to byte at a 
29be				 
29be eb					ex de, hl 
29bf			 
29bf e1					pop hl 
29c0			 
29c0					if DEBUG_FORTH_WORDS 
29c0						DMARK "DEC" 
29c0 f5				push af  
29c1 3a d5 29			ld a, (.dmark)  
29c4 32 77 fb			ld (debug_mark),a  
29c7 3a d6 29			ld a, (.dmark+1)  
29ca 32 78 fb			ld (debug_mark+1),a  
29cd 3a d7 29			ld a, (.dmark+2)  
29d0 32 79 fb			ld (debug_mark+2),a  
29d3 18 03			jr .pastdmark  
29d5 ..			.dmark: db "DEC"  
29d8 f1			.pastdmark: pop af  
29d9			endm  
# End of macro DMARK
29d9						CALLMONITOR 
29d9 cd 00 14			call break_point_state  
29dc				endm  
# End of macro CALLMONITOR
29dc					endif 
29dc			 
29dc 7e					ld a,(hl) 
29dd 93					sub e 
29de 77					ld (hl),a 
29df			 
29df			 
29df			 
29df				       NEXTW 
29df c3 8b 1b			jp macro_next 
29e2				endm 
# End of macro NEXTW
29e2			 
29e2			.INC2: 
29e2				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
29e2 6f				db WORD_SYS_CORE+91             
29e3 8c 2a			dw .DEC2            
29e5 04				db 3 + 1 
29e6 .. 00			db "+2!",0              
29ea				endm 
# End of macro CWHEAD
29ea			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
29ea			 
29ea					if DEBUG_FORTH_WORDS_KEY 
29ea						DMARK "+2s" 
29ea f5				push af  
29eb 3a ff 29			ld a, (.dmark)  
29ee 32 77 fb			ld (debug_mark),a  
29f1 3a 00 2a			ld a, (.dmark+1)  
29f4 32 78 fb			ld (debug_mark+1),a  
29f7 3a 01 2a			ld a, (.dmark+2)  
29fa 32 79 fb			ld (debug_mark+2),a  
29fd 18 03			jr .pastdmark  
29ff ..			.dmark: db "+2s"  
2a02 f1			.pastdmark: pop af  
2a03			endm  
# End of macro DMARK
2a03						CALLMONITOR 
2a03 cd 00 14			call break_point_state  
2a06				endm  
# End of macro CALLMONITOR
2a06					endif 
2a06			 
2a06					; Address 
2a06			 
2a06					FORTH_DSP_VALUEHL 
2a06 cd 35 1a			call macro_dsp_valuehl 
2a09				endm 
# End of macro FORTH_DSP_VALUEHL
2a09			 
2a09 e5					push hl    ; save address 
2a0a			 
2a0a					; load content into de 
2a0a			 
2a0a 5e					ld e,(hl) 
2a0b 23					inc hl 
2a0c 56					ld d, (hl) 
2a0d			 
2a0d					if DEBUG_FORTH_WORDS 
2a0d						DMARK "+2a" 
2a0d f5				push af  
2a0e 3a 22 2a			ld a, (.dmark)  
2a11 32 77 fb			ld (debug_mark),a  
2a14 3a 23 2a			ld a, (.dmark+1)  
2a17 32 78 fb			ld (debug_mark+1),a  
2a1a 3a 24 2a			ld a, (.dmark+2)  
2a1d 32 79 fb			ld (debug_mark+2),a  
2a20 18 03			jr .pastdmark  
2a22 ..			.dmark: db "+2a"  
2a25 f1			.pastdmark: pop af  
2a26			endm  
# End of macro DMARK
2a26						CALLMONITOR 
2a26 cd 00 14			call break_point_state  
2a29				endm  
# End of macro CALLMONITOR
2a29					endif 
2a29			 
2a29					FORTH_DSP_POP 
2a29 cd d1 1a			call macro_forth_dsp_pop 
2a2c				endm 
# End of macro FORTH_DSP_POP
2a2c			 
2a2c					; Get value to add 
2a2c			 
2a2c					FORTH_DSP_VALUE 
2a2c cd 1e 1a			call macro_forth_dsp_value 
2a2f				endm 
# End of macro FORTH_DSP_VALUE
2a2f			 
2a2f					if DEBUG_FORTH_WORDS 
2a2f						DMARK "+2v" 
2a2f f5				push af  
2a30 3a 44 2a			ld a, (.dmark)  
2a33 32 77 fb			ld (debug_mark),a  
2a36 3a 45 2a			ld a, (.dmark+1)  
2a39 32 78 fb			ld (debug_mark+1),a  
2a3c 3a 46 2a			ld a, (.dmark+2)  
2a3f 32 79 fb			ld (debug_mark+2),a  
2a42 18 03			jr .pastdmark  
2a44 ..			.dmark: db "+2v"  
2a47 f1			.pastdmark: pop af  
2a48			endm  
# End of macro DMARK
2a48						CALLMONITOR 
2a48 cd 00 14			call break_point_state  
2a4b				endm  
# End of macro CALLMONITOR
2a4b					endif 
2a4b			 
2a4b 19					add hl, de 
2a4c			 
2a4c					if DEBUG_FORTH_WORDS 
2a4c						DMARK "+2+" 
2a4c f5				push af  
2a4d 3a 61 2a			ld a, (.dmark)  
2a50 32 77 fb			ld (debug_mark),a  
2a53 3a 62 2a			ld a, (.dmark+1)  
2a56 32 78 fb			ld (debug_mark+1),a  
2a59 3a 63 2a			ld a, (.dmark+2)  
2a5c 32 79 fb			ld (debug_mark+2),a  
2a5f 18 03			jr .pastdmark  
2a61 ..			.dmark: db "+2+"  
2a64 f1			.pastdmark: pop af  
2a65			endm  
# End of macro DMARK
2a65						CALLMONITOR 
2a65 cd 00 14			call break_point_state  
2a68				endm  
# End of macro CALLMONITOR
2a68					endif 
2a68			 
2a68					; move result to de 
2a68			 
2a68 eb					ex de, hl 
2a69			 
2a69					; Address 
2a69			 
2a69 e1					pop hl 
2a6a			 
2a6a					; save it back 
2a6a			 
2a6a 73					ld (hl), e 
2a6b 23					inc hl 
2a6c 72					ld (hl), d 
2a6d			 
2a6d					if DEBUG_FORTH_WORDS 
2a6d						DMARK "+2e" 
2a6d f5				push af  
2a6e 3a 82 2a			ld a, (.dmark)  
2a71 32 77 fb			ld (debug_mark),a  
2a74 3a 83 2a			ld a, (.dmark+1)  
2a77 32 78 fb			ld (debug_mark+1),a  
2a7a 3a 84 2a			ld a, (.dmark+2)  
2a7d 32 79 fb			ld (debug_mark+2),a  
2a80 18 03			jr .pastdmark  
2a82 ..			.dmark: db "+2e"  
2a85 f1			.pastdmark: pop af  
2a86			endm  
# End of macro DMARK
2a86						CALLMONITOR 
2a86 cd 00 14			call break_point_state  
2a89				endm  
# End of macro CALLMONITOR
2a89					endif 
2a89			 
2a89			 
2a89			 
2a89			 
2a89			 
2a89				       NEXTW 
2a89 c3 8b 1b			jp macro_next 
2a8c				endm 
# End of macro NEXTW
2a8c			 
2a8c			.DEC2: 
2a8c				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2a8c 6f				db WORD_SYS_CORE+91             
2a8d 38 2b			dw .GET2            
2a8f 04				db 3 + 1 
2a90 .. 00			db "-2!",0              
2a94				endm 
# End of macro CWHEAD
2a94			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2a94			 
2a94			 
2a94					if DEBUG_FORTH_WORDS_KEY 
2a94						DMARK "-2s" 
2a94 f5				push af  
2a95 3a a9 2a			ld a, (.dmark)  
2a98 32 77 fb			ld (debug_mark),a  
2a9b 3a aa 2a			ld a, (.dmark+1)  
2a9e 32 78 fb			ld (debug_mark+1),a  
2aa1 3a ab 2a			ld a, (.dmark+2)  
2aa4 32 79 fb			ld (debug_mark+2),a  
2aa7 18 03			jr .pastdmark  
2aa9 ..			.dmark: db "-2s"  
2aac f1			.pastdmark: pop af  
2aad			endm  
# End of macro DMARK
2aad						CALLMONITOR 
2aad cd 00 14			call break_point_state  
2ab0				endm  
# End of macro CALLMONITOR
2ab0					endif 
2ab0			 
2ab0					; Address 
2ab0			 
2ab0					FORTH_DSP_VALUEHL 
2ab0 cd 35 1a			call macro_dsp_valuehl 
2ab3				endm 
# End of macro FORTH_DSP_VALUEHL
2ab3			 
2ab3 e5					push hl    ; save address 
2ab4			 
2ab4					; load content into de 
2ab4			 
2ab4 5e					ld e,(hl) 
2ab5 23					inc hl 
2ab6 56					ld d, (hl) 
2ab7			 
2ab7					if DEBUG_FORTH_WORDS 
2ab7						DMARK "-2a" 
2ab7 f5				push af  
2ab8 3a cc 2a			ld a, (.dmark)  
2abb 32 77 fb			ld (debug_mark),a  
2abe 3a cd 2a			ld a, (.dmark+1)  
2ac1 32 78 fb			ld (debug_mark+1),a  
2ac4 3a ce 2a			ld a, (.dmark+2)  
2ac7 32 79 fb			ld (debug_mark+2),a  
2aca 18 03			jr .pastdmark  
2acc ..			.dmark: db "-2a"  
2acf f1			.pastdmark: pop af  
2ad0			endm  
# End of macro DMARK
2ad0						CALLMONITOR 
2ad0 cd 00 14			call break_point_state  
2ad3				endm  
# End of macro CALLMONITOR
2ad3					endif 
2ad3			 
2ad3					FORTH_DSP_POP 
2ad3 cd d1 1a			call macro_forth_dsp_pop 
2ad6				endm 
# End of macro FORTH_DSP_POP
2ad6			 
2ad6					; Get value to remove 
2ad6			 
2ad6					FORTH_DSP_VALUE 
2ad6 cd 1e 1a			call macro_forth_dsp_value 
2ad9				endm 
# End of macro FORTH_DSP_VALUE
2ad9			 
2ad9					if DEBUG_FORTH_WORDS 
2ad9						DMARK "-2v" 
2ad9 f5				push af  
2ada 3a ee 2a			ld a, (.dmark)  
2add 32 77 fb			ld (debug_mark),a  
2ae0 3a ef 2a			ld a, (.dmark+1)  
2ae3 32 78 fb			ld (debug_mark+1),a  
2ae6 3a f0 2a			ld a, (.dmark+2)  
2ae9 32 79 fb			ld (debug_mark+2),a  
2aec 18 03			jr .pastdmark  
2aee ..			.dmark: db "-2v"  
2af1 f1			.pastdmark: pop af  
2af2			endm  
# End of macro DMARK
2af2						CALLMONITOR 
2af2 cd 00 14			call break_point_state  
2af5				endm  
# End of macro CALLMONITOR
2af5					endif 
2af5			 
2af5 eb					ex de, hl 
2af6 ed 52				sbc hl, de 
2af8			 
2af8					if DEBUG_FORTH_WORDS 
2af8						DMARK "-2d" 
2af8 f5				push af  
2af9 3a 0d 2b			ld a, (.dmark)  
2afc 32 77 fb			ld (debug_mark),a  
2aff 3a 0e 2b			ld a, (.dmark+1)  
2b02 32 78 fb			ld (debug_mark+1),a  
2b05 3a 0f 2b			ld a, (.dmark+2)  
2b08 32 79 fb			ld (debug_mark+2),a  
2b0b 18 03			jr .pastdmark  
2b0d ..			.dmark: db "-2d"  
2b10 f1			.pastdmark: pop af  
2b11			endm  
# End of macro DMARK
2b11						CALLMONITOR 
2b11 cd 00 14			call break_point_state  
2b14				endm  
# End of macro CALLMONITOR
2b14					endif 
2b14			 
2b14					; move result to de 
2b14			 
2b14 eb					ex de, hl 
2b15			 
2b15					; Address 
2b15			 
2b15 e1					pop hl 
2b16			 
2b16					; save it back 
2b16			 
2b16 73					ld (hl), e 
2b17 23					inc hl 
2b18 72					ld (hl), d 
2b19			 
2b19					if DEBUG_FORTH_WORDS 
2b19						DMARK "-2e" 
2b19 f5				push af  
2b1a 3a 2e 2b			ld a, (.dmark)  
2b1d 32 77 fb			ld (debug_mark),a  
2b20 3a 2f 2b			ld a, (.dmark+1)  
2b23 32 78 fb			ld (debug_mark+1),a  
2b26 3a 30 2b			ld a, (.dmark+2)  
2b29 32 79 fb			ld (debug_mark+2),a  
2b2c 18 03			jr .pastdmark  
2b2e ..			.dmark: db "-2e"  
2b31 f1			.pastdmark: pop af  
2b32			endm  
# End of macro DMARK
2b32						CALLMONITOR 
2b32 cd 00 14			call break_point_state  
2b35				endm  
# End of macro CALLMONITOR
2b35					endif 
2b35			 
2b35			 
2b35			 
2b35			 
2b35			 
2b35				       NEXTW 
2b35 c3 8b 1b			jp macro_next 
2b38				endm 
# End of macro NEXTW
2b38			.GET2: 
2b38				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2b38 6f				db WORD_SYS_CORE+91             
2b39 68 2b			dw .BANG2            
2b3b 03				db 2 + 1 
2b3c .. 00			db "2@",0              
2b3f				endm 
# End of macro CWHEAD
2b3f			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2b3f					if DEBUG_FORTH_WORDS_KEY 
2b3f						DMARK "2A_" 
2b3f f5				push af  
2b40 3a 54 2b			ld a, (.dmark)  
2b43 32 77 fb			ld (debug_mark),a  
2b46 3a 55 2b			ld a, (.dmark+1)  
2b49 32 78 fb			ld (debug_mark+1),a  
2b4c 3a 56 2b			ld a, (.dmark+2)  
2b4f 32 79 fb			ld (debug_mark+2),a  
2b52 18 03			jr .pastdmark  
2b54 ..			.dmark: db "2A_"  
2b57 f1			.pastdmark: pop af  
2b58			endm  
# End of macro DMARK
2b58						CALLMONITOR 
2b58 cd 00 14			call break_point_state  
2b5b				endm  
# End of macro CALLMONITOR
2b5b					endif 
2b5b			 
2b5b					FORTH_DSP_VALUEHL 
2b5b cd 35 1a			call macro_dsp_valuehl 
2b5e				endm 
# End of macro FORTH_DSP_VALUEHL
2b5e			 
2b5e 5e					ld e, (hl) 
2b5f 23					inc hl 
2b60 56					ld d, (hl) 
2b61			 
2b61 eb					ex de, hl 
2b62			 
2b62 cd 9a 19				call forth_push_numhl 
2b65			 
2b65				       NEXTW 
2b65 c3 8b 1b			jp macro_next 
2b68				endm 
# End of macro NEXTW
2b68			.BANG2: 
2b68				CWHEAD .ENDCORE 91 "2!" 2 WORD_FLAG_CODE 
2b68 6f				db WORD_SYS_CORE+91             
2b69 a0 2b			dw .ENDCORE            
2b6b 03				db 2 + 1 
2b6c .. 00			db "2!",0              
2b6f				endm 
# End of macro CWHEAD
2b6f			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2b6f					if DEBUG_FORTH_WORDS_KEY 
2b6f						DMARK "2S_" 
2b6f f5				push af  
2b70 3a 84 2b			ld a, (.dmark)  
2b73 32 77 fb			ld (debug_mark),a  
2b76 3a 85 2b			ld a, (.dmark+1)  
2b79 32 78 fb			ld (debug_mark+1),a  
2b7c 3a 86 2b			ld a, (.dmark+2)  
2b7f 32 79 fb			ld (debug_mark+2),a  
2b82 18 03			jr .pastdmark  
2b84 ..			.dmark: db "2S_"  
2b87 f1			.pastdmark: pop af  
2b88			endm  
# End of macro DMARK
2b88						CALLMONITOR 
2b88 cd 00 14			call break_point_state  
2b8b				endm  
# End of macro CALLMONITOR
2b8b					endif 
2b8b			 
2b8b					FORTH_DSP_VALUEHL 
2b8b cd 35 1a			call macro_dsp_valuehl 
2b8e				endm 
# End of macro FORTH_DSP_VALUEHL
2b8e			 
2b8e e5					push hl   ; save address 
2b8f			 
2b8f			 
2b8f					FORTH_DSP_POP 
2b8f cd d1 1a			call macro_forth_dsp_pop 
2b92				endm 
# End of macro FORTH_DSP_POP
2b92			 
2b92					 
2b92					FORTH_DSP_VALUEHL 
2b92 cd 35 1a			call macro_dsp_valuehl 
2b95				endm 
# End of macro FORTH_DSP_VALUEHL
2b95			 
2b95					FORTH_DSP_POP 
2b95 cd d1 1a			call macro_forth_dsp_pop 
2b98				endm 
# End of macro FORTH_DSP_POP
2b98			 
2b98 eb					ex de, hl    ; value now in de 
2b99			 
2b99 e1					pop hl 
2b9a			 
2b9a 73					ld (hl), e 
2b9b			 
2b9b 23					inc hl 
2b9c			 
2b9c 72					ld (hl), d 
2b9d			 
2b9d			 
2b9d				       NEXTW 
2b9d c3 8b 1b			jp macro_next 
2ba0				endm 
# End of macro NEXTW
2ba0			.ENDCORE: 
2ba0			 
2ba0			; eof 
2ba0			 
2ba0			 
# End of file forth_words_core.asm
2ba0			include "forth_words_flow.asm" 
2ba0			 
2ba0			; | ## Program Flow Words 
2ba0			 
2ba0			.IF: 
2ba0				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2ba0 1e				db WORD_SYS_CORE+10             
2ba1 95 2c			dw .THEN            
2ba3 03				db 2 + 1 
2ba4 .. 00			db "IF",0              
2ba7				endm 
# End of macro CWHEAD
2ba7			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2ba7			; 
2ba7					if DEBUG_FORTH_WORDS_KEY 
2ba7						DMARK "IF." 
2ba7 f5				push af  
2ba8 3a bc 2b			ld a, (.dmark)  
2bab 32 77 fb			ld (debug_mark),a  
2bae 3a bd 2b			ld a, (.dmark+1)  
2bb1 32 78 fb			ld (debug_mark+1),a  
2bb4 3a be 2b			ld a, (.dmark+2)  
2bb7 32 79 fb			ld (debug_mark+2),a  
2bba 18 03			jr .pastdmark  
2bbc ..			.dmark: db "IF."  
2bbf f1			.pastdmark: pop af  
2bc0			endm  
# End of macro DMARK
2bc0						CALLMONITOR 
2bc0 cd 00 14			call break_point_state  
2bc3				endm  
# End of macro CALLMONITOR
2bc3					endif 
2bc3			; eval TOS 
2bc3			 
2bc3				FORTH_DSP_VALUEHL 
2bc3 cd 35 1a			call macro_dsp_valuehl 
2bc6				endm 
# End of macro FORTH_DSP_VALUEHL
2bc6			 
2bc6			;	push hl 
2bc6				FORTH_DSP_POP 
2bc6 cd d1 1a			call macro_forth_dsp_pop 
2bc9				endm 
# End of macro FORTH_DSP_POP
2bc9			;	pop hl 
2bc9			 
2bc9					if DEBUG_FORTH_WORDS 
2bc9						DMARK "IF1" 
2bc9 f5				push af  
2bca 3a de 2b			ld a, (.dmark)  
2bcd 32 77 fb			ld (debug_mark),a  
2bd0 3a df 2b			ld a, (.dmark+1)  
2bd3 32 78 fb			ld (debug_mark+1),a  
2bd6 3a e0 2b			ld a, (.dmark+2)  
2bd9 32 79 fb			ld (debug_mark+2),a  
2bdc 18 03			jr .pastdmark  
2bde ..			.dmark: db "IF1"  
2be1 f1			.pastdmark: pop af  
2be2			endm  
# End of macro DMARK
2be2						CALLMONITOR 
2be2 cd 00 14			call break_point_state  
2be5				endm  
# End of macro CALLMONITOR
2be5					endif 
2be5 b7				or a        ; clear carry flag 
2be6 11 00 00			ld de, 0 
2be9 eb				ex de,hl 
2bea ed 52			sbc hl, de 
2bec c2 76 2c			jp nz, .iftrue 
2bef			 
2bef					if DEBUG_FORTH_WORDS 
2bef						DMARK "IF2" 
2bef f5				push af  
2bf0 3a 04 2c			ld a, (.dmark)  
2bf3 32 77 fb			ld (debug_mark),a  
2bf6 3a 05 2c			ld a, (.dmark+1)  
2bf9 32 78 fb			ld (debug_mark+1),a  
2bfc 3a 06 2c			ld a, (.dmark+2)  
2bff 32 79 fb			ld (debug_mark+2),a  
2c02 18 03			jr .pastdmark  
2c04 ..			.dmark: db "IF2"  
2c07 f1			.pastdmark: pop af  
2c08			endm  
# End of macro DMARK
2c08						CALLMONITOR 
2c08 cd 00 14			call break_point_state  
2c0b				endm  
# End of macro CALLMONITOR
2c0b					endif 
2c0b			 
2c0b			; if not true then skip to THEN 
2c0b			 
2c0b				; TODO get tok_ptr 
2c0b				; TODO consume toks until we get to THEN 
2c0b			 
2c0b 2a 33 f1			ld hl, (os_tok_ptr) 
2c0e					if DEBUG_FORTH_WORDS 
2c0e						DMARK "IF3" 
2c0e f5				push af  
2c0f 3a 23 2c			ld a, (.dmark)  
2c12 32 77 fb			ld (debug_mark),a  
2c15 3a 24 2c			ld a, (.dmark+1)  
2c18 32 78 fb			ld (debug_mark+1),a  
2c1b 3a 25 2c			ld a, (.dmark+2)  
2c1e 32 79 fb			ld (debug_mark+2),a  
2c21 18 03			jr .pastdmark  
2c23 ..			.dmark: db "IF3"  
2c26 f1			.pastdmark: pop af  
2c27			endm  
# End of macro DMARK
2c27						CALLMONITOR 
2c27 cd 00 14			call break_point_state  
2c2a				endm  
# End of macro CALLMONITOR
2c2a						 
2c2a					endif 
2c2a 11 71 2c			ld de, .ifthen 
2c2d					if DEBUG_FORTH_WORDS 
2c2d						DMARK "IF4" 
2c2d f5				push af  
2c2e 3a 42 2c			ld a, (.dmark)  
2c31 32 77 fb			ld (debug_mark),a  
2c34 3a 43 2c			ld a, (.dmark+1)  
2c37 32 78 fb			ld (debug_mark+1),a  
2c3a 3a 44 2c			ld a, (.dmark+2)  
2c3d 32 79 fb			ld (debug_mark+2),a  
2c40 18 03			jr .pastdmark  
2c42 ..			.dmark: db "IF4"  
2c45 f1			.pastdmark: pop af  
2c46			endm  
# End of macro DMARK
2c46						CALLMONITOR 
2c46 cd 00 14			call break_point_state  
2c49				endm  
# End of macro CALLMONITOR
2c49					endif 
2c49 cd a6 1c			call findnexttok  
2c4c			 
2c4c					if DEBUG_FORTH_WORDS 
2c4c						DMARK "IF5" 
2c4c f5				push af  
2c4d 3a 61 2c			ld a, (.dmark)  
2c50 32 77 fb			ld (debug_mark),a  
2c53 3a 62 2c			ld a, (.dmark+1)  
2c56 32 78 fb			ld (debug_mark+1),a  
2c59 3a 63 2c			ld a, (.dmark+2)  
2c5c 32 79 fb			ld (debug_mark+2),a  
2c5f 18 03			jr .pastdmark  
2c61 ..			.dmark: db "IF5"  
2c64 f1			.pastdmark: pop af  
2c65			endm  
# End of macro DMARK
2c65						CALLMONITOR 
2c65 cd 00 14			call break_point_state  
2c68				endm  
# End of macro CALLMONITOR
2c68					endif 
2c68				; TODO replace below with ; exec using tok_ptr 
2c68 22 33 f1			ld (os_tok_ptr), hl 
2c6b c3 1c 1c			jp exec1 
2c6e				NEXTW 
2c6e c3 8b 1b			jp macro_next 
2c71				endm 
# End of macro NEXTW
2c71			 
2c71 .. 00		.ifthen:  db "THEN",0 
2c76			 
2c76			.iftrue:		 
2c76				; Exec next words normally 
2c76			 
2c76				; if true then exec following IF as normal 
2c76					if DEBUG_FORTH_WORDS 
2c76						DMARK "IFT" 
2c76 f5				push af  
2c77 3a 8b 2c			ld a, (.dmark)  
2c7a 32 77 fb			ld (debug_mark),a  
2c7d 3a 8c 2c			ld a, (.dmark+1)  
2c80 32 78 fb			ld (debug_mark+1),a  
2c83 3a 8d 2c			ld a, (.dmark+2)  
2c86 32 79 fb			ld (debug_mark+2),a  
2c89 18 03			jr .pastdmark  
2c8b ..			.dmark: db "IFT"  
2c8e f1			.pastdmark: pop af  
2c8f			endm  
# End of macro DMARK
2c8f						CALLMONITOR 
2c8f cd 00 14			call break_point_state  
2c92				endm  
# End of macro CALLMONITOR
2c92					endif 
2c92			 
2c92					NEXTW 
2c92 c3 8b 1b			jp macro_next 
2c95				endm 
# End of macro NEXTW
2c95			.THEN: 
2c95				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2c95 1f				db WORD_SYS_CORE+11             
2c96 bd 2c			dw .ELSE            
2c98 05				db 4 + 1 
2c99 .. 00			db "THEN",0              
2c9e				endm 
# End of macro CWHEAD
2c9e			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2c9e					if DEBUG_FORTH_WORDS_KEY 
2c9e						DMARK "THN" 
2c9e f5				push af  
2c9f 3a b3 2c			ld a, (.dmark)  
2ca2 32 77 fb			ld (debug_mark),a  
2ca5 3a b4 2c			ld a, (.dmark+1)  
2ca8 32 78 fb			ld (debug_mark+1),a  
2cab 3a b5 2c			ld a, (.dmark+2)  
2cae 32 79 fb			ld (debug_mark+2),a  
2cb1 18 03			jr .pastdmark  
2cb3 ..			.dmark: db "THN"  
2cb6 f1			.pastdmark: pop af  
2cb7			endm  
# End of macro DMARK
2cb7						CALLMONITOR 
2cb7 cd 00 14			call break_point_state  
2cba				endm  
# End of macro CALLMONITOR
2cba					endif 
2cba					NEXTW 
2cba c3 8b 1b			jp macro_next 
2cbd				endm 
# End of macro NEXTW
2cbd			.ELSE: 
2cbd				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2cbd 20				db WORD_SYS_CORE+12             
2cbe e5 2c			dw .DO            
2cc0 03				db 2 + 1 
2cc1 .. 00			db "ELSE",0              
2cc6				endm 
# End of macro CWHEAD
2cc6			; | ELSE ( -- ) Not supported - does nothing | TODO 
2cc6			 
2cc6					if DEBUG_FORTH_WORDS_KEY 
2cc6						DMARK "ELS" 
2cc6 f5				push af  
2cc7 3a db 2c			ld a, (.dmark)  
2cca 32 77 fb			ld (debug_mark),a  
2ccd 3a dc 2c			ld a, (.dmark+1)  
2cd0 32 78 fb			ld (debug_mark+1),a  
2cd3 3a dd 2c			ld a, (.dmark+2)  
2cd6 32 79 fb			ld (debug_mark+2),a  
2cd9 18 03			jr .pastdmark  
2cdb ..			.dmark: db "ELS"  
2cde f1			.pastdmark: pop af  
2cdf			endm  
# End of macro DMARK
2cdf						CALLMONITOR 
2cdf cd 00 14			call break_point_state  
2ce2				endm  
# End of macro CALLMONITOR
2ce2					endif 
2ce2			 
2ce2			 
2ce2					NEXTW 
2ce2 c3 8b 1b			jp macro_next 
2ce5				endm 
# End of macro NEXTW
2ce5			.DO: 
2ce5				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2ce5 21				db WORD_SYS_CORE+13             
2ce6 0c 2e			dw .LOOP            
2ce8 03				db 2 + 1 
2ce9 .. 00			db "DO",0              
2cec				endm 
# End of macro CWHEAD
2cec			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2cec			 
2cec					if DEBUG_FORTH_WORDS_KEY 
2cec						DMARK "DO." 
2cec f5				push af  
2ced 3a 01 2d			ld a, (.dmark)  
2cf0 32 77 fb			ld (debug_mark),a  
2cf3 3a 02 2d			ld a, (.dmark+1)  
2cf6 32 78 fb			ld (debug_mark+1),a  
2cf9 3a 03 2d			ld a, (.dmark+2)  
2cfc 32 79 fb			ld (debug_mark+2),a  
2cff 18 03			jr .pastdmark  
2d01 ..			.dmark: db "DO."  
2d04 f1			.pastdmark: pop af  
2d05			endm  
# End of macro DMARK
2d05						CALLMONITOR 
2d05 cd 00 14			call break_point_state  
2d08				endm  
# End of macro CALLMONITOR
2d08					endif 
2d08			;  push pc to rsp stack past the DO 
2d08			 
2d08 2a 33 f1				ld hl, (os_tok_ptr) 
2d0b 23					inc hl   ; D 
2d0c 23					inc hl  ; O 
2d0d 23					inc hl   ; null 
2d0e					if DEBUG_FORTH_WORDS 
2d0e						DMARK "DO2" 
2d0e f5				push af  
2d0f 3a 23 2d			ld a, (.dmark)  
2d12 32 77 fb			ld (debug_mark),a  
2d15 3a 24 2d			ld a, (.dmark+1)  
2d18 32 78 fb			ld (debug_mark+1),a  
2d1b 3a 25 2d			ld a, (.dmark+2)  
2d1e 32 79 fb			ld (debug_mark+2),a  
2d21 18 03			jr .pastdmark  
2d23 ..			.dmark: db "DO2"  
2d26 f1			.pastdmark: pop af  
2d27			endm  
# End of macro DMARK
2d27						CALLMONITOR 
2d27 cd 00 14			call break_point_state  
2d2a				endm  
# End of macro CALLMONITOR
2d2a					endif 
2d2a					FORTH_RSP_NEXT 
2d2a cd 41 19			call macro_forth_rsp_next 
2d2d				endm 
# End of macro FORTH_RSP_NEXT
2d2d					if DEBUG_FORTH_WORDS 
2d2d						DMARK "DO3" 
2d2d f5				push af  
2d2e 3a 42 2d			ld a, (.dmark)  
2d31 32 77 fb			ld (debug_mark),a  
2d34 3a 43 2d			ld a, (.dmark+1)  
2d37 32 78 fb			ld (debug_mark+1),a  
2d3a 3a 44 2d			ld a, (.dmark+2)  
2d3d 32 79 fb			ld (debug_mark+2),a  
2d40 18 03			jr .pastdmark  
2d42 ..			.dmark: db "DO3"  
2d45 f1			.pastdmark: pop af  
2d46			endm  
# End of macro DMARK
2d46						CALLMONITOR 
2d46 cd 00 14			call break_point_state  
2d49				endm  
# End of macro CALLMONITOR
2d49					endif 
2d49			 
2d49					;if DEBUG_FORTH_WORDS 
2d49				;		push hl 
2d49			;		endif  
2d49			 
2d49			; get counters from data stack 
2d49			 
2d49			 
2d49					FORTH_DSP_VALUEHL 
2d49 cd 35 1a			call macro_dsp_valuehl 
2d4c				endm 
# End of macro FORTH_DSP_VALUEHL
2d4c e5					push hl		 ; hl now has starting counter which needs to be tos 
2d4d			 
2d4d					if DEBUG_FORTH_WORDS 
2d4d						DMARK "DO4" 
2d4d f5				push af  
2d4e 3a 62 2d			ld a, (.dmark)  
2d51 32 77 fb			ld (debug_mark),a  
2d54 3a 63 2d			ld a, (.dmark+1)  
2d57 32 78 fb			ld (debug_mark+1),a  
2d5a 3a 64 2d			ld a, (.dmark+2)  
2d5d 32 79 fb			ld (debug_mark+2),a  
2d60 18 03			jr .pastdmark  
2d62 ..			.dmark: db "DO4"  
2d65 f1			.pastdmark: pop af  
2d66			endm  
# End of macro DMARK
2d66						CALLMONITOR 
2d66 cd 00 14			call break_point_state  
2d69				endm  
# End of macro CALLMONITOR
2d69					endif 
2d69					FORTH_DSP_POP 
2d69 cd d1 1a			call macro_forth_dsp_pop 
2d6c				endm 
# End of macro FORTH_DSP_POP
2d6c			 
2d6c					if DEBUG_FORTH_WORDS 
2d6c						DMARK "DO5" 
2d6c f5				push af  
2d6d 3a 81 2d			ld a, (.dmark)  
2d70 32 77 fb			ld (debug_mark),a  
2d73 3a 82 2d			ld a, (.dmark+1)  
2d76 32 78 fb			ld (debug_mark+1),a  
2d79 3a 83 2d			ld a, (.dmark+2)  
2d7c 32 79 fb			ld (debug_mark+2),a  
2d7f 18 03			jr .pastdmark  
2d81 ..			.dmark: db "DO5"  
2d84 f1			.pastdmark: pop af  
2d85			endm  
# End of macro DMARK
2d85						CALLMONITOR 
2d85 cd 00 14			call break_point_state  
2d88				endm  
# End of macro CALLMONITOR
2d88					endif 
2d88			 
2d88					FORTH_DSP_VALUEHL 
2d88 cd 35 1a			call macro_dsp_valuehl 
2d8b				endm 
# End of macro FORTH_DSP_VALUEHL
2d8b			;		push hl		 ; hl now has starting limit counter 
2d8b			 
2d8b					if DEBUG_FORTH_WORDS 
2d8b						DMARK "DO6" 
2d8b f5				push af  
2d8c 3a a0 2d			ld a, (.dmark)  
2d8f 32 77 fb			ld (debug_mark),a  
2d92 3a a1 2d			ld a, (.dmark+1)  
2d95 32 78 fb			ld (debug_mark+1),a  
2d98 3a a2 2d			ld a, (.dmark+2)  
2d9b 32 79 fb			ld (debug_mark+2),a  
2d9e 18 03			jr .pastdmark  
2da0 ..			.dmark: db "DO6"  
2da3 f1			.pastdmark: pop af  
2da4			endm  
# End of macro DMARK
2da4						CALLMONITOR 
2da4 cd 00 14			call break_point_state  
2da7				endm  
# End of macro CALLMONITOR
2da7					endif 
2da7					FORTH_DSP_POP 
2da7 cd d1 1a			call macro_forth_dsp_pop 
2daa				endm 
# End of macro FORTH_DSP_POP
2daa			 
2daa			; put counters on the loop stack 
2daa			 
2daa			;		pop hl			 ; limit counter 
2daa d1					pop de			; start counter 
2dab			 
2dab					; push limit counter 
2dab			 
2dab					if DEBUG_FORTH_WORDS 
2dab						DMARK "DO7" 
2dab f5				push af  
2dac 3a c0 2d			ld a, (.dmark)  
2daf 32 77 fb			ld (debug_mark),a  
2db2 3a c1 2d			ld a, (.dmark+1)  
2db5 32 78 fb			ld (debug_mark+1),a  
2db8 3a c2 2d			ld a, (.dmark+2)  
2dbb 32 79 fb			ld (debug_mark+2),a  
2dbe 18 03			jr .pastdmark  
2dc0 ..			.dmark: db "DO7"  
2dc3 f1			.pastdmark: pop af  
2dc4			endm  
# End of macro DMARK
2dc4						CALLMONITOR 
2dc4 cd 00 14			call break_point_state  
2dc7				endm  
# End of macro CALLMONITOR
2dc7					endif 
2dc7					FORTH_LOOP_NEXT 
2dc7 cd 4a 1a			call macro_forth_loop_next 
2dca				endm 
# End of macro FORTH_LOOP_NEXT
2dca			 
2dca					; push start counter 
2dca			 
2dca eb					ex de, hl 
2dcb					if DEBUG_FORTH_WORDS 
2dcb						DMARK "DO7" 
2dcb f5				push af  
2dcc 3a e0 2d			ld a, (.dmark)  
2dcf 32 77 fb			ld (debug_mark),a  
2dd2 3a e1 2d			ld a, (.dmark+1)  
2dd5 32 78 fb			ld (debug_mark+1),a  
2dd8 3a e2 2d			ld a, (.dmark+2)  
2ddb 32 79 fb			ld (debug_mark+2),a  
2dde 18 03			jr .pastdmark  
2de0 ..			.dmark: db "DO7"  
2de3 f1			.pastdmark: pop af  
2de4			endm  
# End of macro DMARK
2de4						CALLMONITOR 
2de4 cd 00 14			call break_point_state  
2de7				endm  
# End of macro CALLMONITOR
2de7					endif 
2de7					FORTH_LOOP_NEXT 
2de7 cd 4a 1a			call macro_forth_loop_next 
2dea				endm 
# End of macro FORTH_LOOP_NEXT
2dea			 
2dea			 
2dea					; init first round of I counter 
2dea			 
2dea 22 57 f1				ld (os_current_i), hl 
2ded			 
2ded					if DEBUG_FORTH_WORDS 
2ded						DMARK "DO8" 
2ded f5				push af  
2dee 3a 02 2e			ld a, (.dmark)  
2df1 32 77 fb			ld (debug_mark),a  
2df4 3a 03 2e			ld a, (.dmark+1)  
2df7 32 78 fb			ld (debug_mark+1),a  
2dfa 3a 04 2e			ld a, (.dmark+2)  
2dfd 32 79 fb			ld (debug_mark+2),a  
2e00 18 03			jr .pastdmark  
2e02 ..			.dmark: db "DO8"  
2e05 f1			.pastdmark: pop af  
2e06			endm  
# End of macro DMARK
2e06						CALLMONITOR 
2e06 cd 00 14			call break_point_state  
2e09				endm  
# End of macro CALLMONITOR
2e09					endif 
2e09			 
2e09					NEXTW 
2e09 c3 8b 1b			jp macro_next 
2e0c				endm 
# End of macro NEXTW
2e0c			.LOOP: 
2e0c				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2e0c 22				db WORD_SYS_CORE+14             
2e0d 24 2f			dw .I            
2e0f 05				db 4 + 1 
2e10 .. 00			db "LOOP",0              
2e15				endm 
# End of macro CWHEAD
2e15			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2e15			 
2e15				; pop tos as current loop count to hl 
2e15			 
2e15				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2e15			 
2e15				FORTH_LOOP_TOS 
2e15 cd 7d 1a			call macro_forth_loop_tos 
2e18				endm 
# End of macro FORTH_LOOP_TOS
2e18 e5				push hl 
2e19			 
2e19					if DEBUG_FORTH_WORDS_KEY 
2e19						DMARK "LOP" 
2e19 f5				push af  
2e1a 3a 2e 2e			ld a, (.dmark)  
2e1d 32 77 fb			ld (debug_mark),a  
2e20 3a 2f 2e			ld a, (.dmark+1)  
2e23 32 78 fb			ld (debug_mark+1),a  
2e26 3a 30 2e			ld a, (.dmark+2)  
2e29 32 79 fb			ld (debug_mark+2),a  
2e2c 18 03			jr .pastdmark  
2e2e ..			.dmark: db "LOP"  
2e31 f1			.pastdmark: pop af  
2e32			endm  
# End of macro DMARK
2e32						CALLMONITOR 
2e32 cd 00 14			call break_point_state  
2e35				endm  
# End of macro CALLMONITOR
2e35					endif 
2e35				; next item on the stack is the limit. get it 
2e35			 
2e35			 
2e35				FORTH_LOOP_POP 
2e35 cd 87 1a			call macro_forth_loop_pop 
2e38				endm 
# End of macro FORTH_LOOP_POP
2e38			 
2e38				FORTH_LOOP_TOS 
2e38 cd 7d 1a			call macro_forth_loop_tos 
2e3b				endm 
# End of macro FORTH_LOOP_TOS
2e3b			 
2e3b d1				pop de		 ; de = i, hl = limit 
2e3c			 
2e3c					if DEBUG_FORTH_WORDS 
2e3c						DMARK "LP1" 
2e3c f5				push af  
2e3d 3a 51 2e			ld a, (.dmark)  
2e40 32 77 fb			ld (debug_mark),a  
2e43 3a 52 2e			ld a, (.dmark+1)  
2e46 32 78 fb			ld (debug_mark+1),a  
2e49 3a 53 2e			ld a, (.dmark+2)  
2e4c 32 79 fb			ld (debug_mark+2),a  
2e4f 18 03			jr .pastdmark  
2e51 ..			.dmark: db "LP1"  
2e54 f1			.pastdmark: pop af  
2e55			endm  
# End of macro DMARK
2e55						CALLMONITOR 
2e55 cd 00 14			call break_point_state  
2e58				endm  
# End of macro CALLMONITOR
2e58					endif 
2e58			 
2e58				; go back to previous word 
2e58			 
2e58 d5				push de    ; save I for inc later 
2e59			 
2e59			 
2e59				; get limit 
2e59				;  is I at limit? 
2e59			 
2e59			 
2e59					if DEBUG_FORTH_WORDS 
2e59						DMARK "LP1" 
2e59 f5				push af  
2e5a 3a 6e 2e			ld a, (.dmark)  
2e5d 32 77 fb			ld (debug_mark),a  
2e60 3a 6f 2e			ld a, (.dmark+1)  
2e63 32 78 fb			ld (debug_mark+1),a  
2e66 3a 70 2e			ld a, (.dmark+2)  
2e69 32 79 fb			ld (debug_mark+2),a  
2e6c 18 03			jr .pastdmark  
2e6e ..			.dmark: db "LP1"  
2e71 f1			.pastdmark: pop af  
2e72			endm  
# End of macro DMARK
2e72						CALLMONITOR 
2e72 cd 00 14			call break_point_state  
2e75				endm  
# End of macro CALLMONITOR
2e75					endif 
2e75			 
2e75 ed 52			sbc hl, de 
2e77			 
2e77			 
2e77				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2e77			 
2e77 20 26				jr nz, .loopnotdone 
2e79			 
2e79 e1				pop hl   ; get rid of saved I 
2e7a				FORTH_LOOP_POP     ; get rid of limit 
2e7a cd 87 1a			call macro_forth_loop_pop 
2e7d				endm 
# End of macro FORTH_LOOP_POP
2e7d			 
2e7d				FORTH_RSP_POP     ; get rid of DO ptr 
2e7d cd 62 19			call macro_forth_rsp_pop 
2e80				endm 
# End of macro FORTH_RSP_POP
2e80			 
2e80			if DEBUG_FORTH_WORDS 
2e80						DMARK "LP>" 
2e80 f5				push af  
2e81 3a 95 2e			ld a, (.dmark)  
2e84 32 77 fb			ld (debug_mark),a  
2e87 3a 96 2e			ld a, (.dmark+1)  
2e8a 32 78 fb			ld (debug_mark+1),a  
2e8d 3a 97 2e			ld a, (.dmark+2)  
2e90 32 79 fb			ld (debug_mark+2),a  
2e93 18 03			jr .pastdmark  
2e95 ..			.dmark: db "LP>"  
2e98 f1			.pastdmark: pop af  
2e99			endm  
# End of macro DMARK
2e99				CALLMONITOR 
2e99 cd 00 14			call break_point_state  
2e9c				endm  
# End of macro CALLMONITOR
2e9c			endif 
2e9c			 
2e9c					NEXTW 
2e9c c3 8b 1b			jp macro_next 
2e9f				endm 
# End of macro NEXTW
2e9f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2e9f			 
2e9f			.loopnotdone: 
2e9f			 
2e9f e1				pop hl    ; get I 
2ea0 23				inc hl 
2ea1			 
2ea1			   	; save new I 
2ea1			 
2ea1			 
2ea1					; set I counter 
2ea1			 
2ea1 22 57 f1				ld (os_current_i), hl 
2ea4			 
2ea4					if DEBUG_FORTH_WORDS 
2ea4						DMARK "LPN" 
2ea4 f5				push af  
2ea5 3a b9 2e			ld a, (.dmark)  
2ea8 32 77 fb			ld (debug_mark),a  
2eab 3a ba 2e			ld a, (.dmark+1)  
2eae 32 78 fb			ld (debug_mark+1),a  
2eb1 3a bb 2e			ld a, (.dmark+2)  
2eb4 32 79 fb			ld (debug_mark+2),a  
2eb7 18 03			jr .pastdmark  
2eb9 ..			.dmark: db "LPN"  
2ebc f1			.pastdmark: pop af  
2ebd			endm  
# End of macro DMARK
2ebd					CALLMONITOR 
2ebd cd 00 14			call break_point_state  
2ec0				endm  
# End of macro CALLMONITOR
2ec0					endif 
2ec0					 
2ec0				FORTH_LOOP_NEXT 
2ec0 cd 4a 1a			call macro_forth_loop_next 
2ec3				endm 
# End of macro FORTH_LOOP_NEXT
2ec3			 
2ec3			 
2ec3					if DEBUG_FORTH_WORDS 
2ec3 eb						ex de,hl 
2ec4					endif 
2ec4			 
2ec4			;	; get DO ptr 
2ec4			; 
2ec4					if DEBUG_FORTH_WORDS 
2ec4						DMARK "LP7" 
2ec4 f5				push af  
2ec5 3a d9 2e			ld a, (.dmark)  
2ec8 32 77 fb			ld (debug_mark),a  
2ecb 3a da 2e			ld a, (.dmark+1)  
2ece 32 78 fb			ld (debug_mark+1),a  
2ed1 3a db 2e			ld a, (.dmark+2)  
2ed4 32 79 fb			ld (debug_mark+2),a  
2ed7 18 03			jr .pastdmark  
2ed9 ..			.dmark: db "LP7"  
2edc f1			.pastdmark: pop af  
2edd			endm  
# End of macro DMARK
2edd					CALLMONITOR 
2edd cd 00 14			call break_point_state  
2ee0				endm  
# End of macro CALLMONITOR
2ee0					endif 
2ee0				FORTH_RSP_TOS 
2ee0 cd 58 19			call macro_forth_rsp_tos 
2ee3				endm 
# End of macro FORTH_RSP_TOS
2ee3			 
2ee3					if DEBUG_FORTH_WORDS 
2ee3						DMARK "LP8" 
2ee3 f5				push af  
2ee4 3a f8 2e			ld a, (.dmark)  
2ee7 32 77 fb			ld (debug_mark),a  
2eea 3a f9 2e			ld a, (.dmark+1)  
2eed 32 78 fb			ld (debug_mark+1),a  
2ef0 3a fa 2e			ld a, (.dmark+2)  
2ef3 32 79 fb			ld (debug_mark+2),a  
2ef6 18 03			jr .pastdmark  
2ef8 ..			.dmark: db "LP8"  
2efb f1			.pastdmark: pop af  
2efc			endm  
# End of macro DMARK
2efc					CALLMONITOR 
2efc cd 00 14			call break_point_state  
2eff				endm  
# End of macro CALLMONITOR
2eff					endif 
2eff				;push hl 
2eff			 
2eff				; not going to DO any more 
2eff				; get rid of the RSP pointer as DO will add it back in 
2eff				;FORTH_RSP_POP 
2eff				;pop hl 
2eff			 
2eff				;ld hl,(cli_ret_sp) 
2eff				;ld e, (hl) 
2eff				;inc hl 
2eff				;ld d, (hl) 
2eff				;ex de,hl 
2eff 22 33 f1			ld (os_tok_ptr), hl 
2f02					if DEBUG_FORTH_WORDS 
2f02						DMARK "LP<" 
2f02 f5				push af  
2f03 3a 17 2f			ld a, (.dmark)  
2f06 32 77 fb			ld (debug_mark),a  
2f09 3a 18 2f			ld a, (.dmark+1)  
2f0c 32 78 fb			ld (debug_mark+1),a  
2f0f 3a 19 2f			ld a, (.dmark+2)  
2f12 32 79 fb			ld (debug_mark+2),a  
2f15 18 03			jr .pastdmark  
2f17 ..			.dmark: db "LP<"  
2f1a f1			.pastdmark: pop af  
2f1b			endm  
# End of macro DMARK
2f1b					CALLMONITOR 
2f1b cd 00 14			call break_point_state  
2f1e				endm  
# End of macro CALLMONITOR
2f1e				endif 
2f1e c3 1c 1c			jp exec1 
2f21			 
2f21					 
2f21			 
2f21			 
2f21					NEXTW 
2f21 c3 8b 1b			jp macro_next 
2f24				endm 
# End of macro NEXTW
2f24			.I:  
2f24			 
2f24				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
2f24 5e				db WORD_SYS_CORE+74             
2f25 4f 2f			dw .DLOOP            
2f27 02				db 1 + 1 
2f28 .. 00			db "I",0              
2f2a				endm 
# End of macro CWHEAD
2f2a			; | I ( -- ) Current loop counter | DONE 
2f2a					if DEBUG_FORTH_WORDS_KEY 
2f2a						DMARK "I.." 
2f2a f5				push af  
2f2b 3a 3f 2f			ld a, (.dmark)  
2f2e 32 77 fb			ld (debug_mark),a  
2f31 3a 40 2f			ld a, (.dmark+1)  
2f34 32 78 fb			ld (debug_mark+1),a  
2f37 3a 41 2f			ld a, (.dmark+2)  
2f3a 32 79 fb			ld (debug_mark+2),a  
2f3d 18 03			jr .pastdmark  
2f3f ..			.dmark: db "I.."  
2f42 f1			.pastdmark: pop af  
2f43			endm  
# End of macro DMARK
2f43						CALLMONITOR 
2f43 cd 00 14			call break_point_state  
2f46				endm  
# End of macro CALLMONITOR
2f46					endif 
2f46			 
2f46 2a 57 f1				ld hl,(os_current_i) 
2f49 cd 9a 19				call forth_push_numhl 
2f4c			 
2f4c					NEXTW 
2f4c c3 8b 1b			jp macro_next 
2f4f				endm 
# End of macro NEXTW
2f4f			.DLOOP: 
2f4f				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
2f4f 5f				db WORD_SYS_CORE+75             
2f50 30 30			dw .REPEAT            
2f52 06				db 5 + 1 
2f53 .. 00			db "-LOOP",0              
2f59				endm 
# End of macro CWHEAD
2f59			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
2f59				; pop tos as current loop count to hl 
2f59					if DEBUG_FORTH_WORDS_KEY 
2f59						DMARK "-LP" 
2f59 f5				push af  
2f5a 3a 6e 2f			ld a, (.dmark)  
2f5d 32 77 fb			ld (debug_mark),a  
2f60 3a 6f 2f			ld a, (.dmark+1)  
2f63 32 78 fb			ld (debug_mark+1),a  
2f66 3a 70 2f			ld a, (.dmark+2)  
2f69 32 79 fb			ld (debug_mark+2),a  
2f6c 18 03			jr .pastdmark  
2f6e ..			.dmark: db "-LP"  
2f71 f1			.pastdmark: pop af  
2f72			endm  
# End of macro DMARK
2f72						CALLMONITOR 
2f72 cd 00 14			call break_point_state  
2f75				endm  
# End of macro CALLMONITOR
2f75					endif 
2f75			 
2f75				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2f75			 
2f75				FORTH_LOOP_TOS 
2f75 cd 7d 1a			call macro_forth_loop_tos 
2f78				endm 
# End of macro FORTH_LOOP_TOS
2f78 e5				push hl 
2f79			 
2f79					if DEBUG_FORTH_WORDS 
2f79						DMARK "-LP" 
2f79 f5				push af  
2f7a 3a 8e 2f			ld a, (.dmark)  
2f7d 32 77 fb			ld (debug_mark),a  
2f80 3a 8f 2f			ld a, (.dmark+1)  
2f83 32 78 fb			ld (debug_mark+1),a  
2f86 3a 90 2f			ld a, (.dmark+2)  
2f89 32 79 fb			ld (debug_mark+2),a  
2f8c 18 03			jr .pastdmark  
2f8e ..			.dmark: db "-LP"  
2f91 f1			.pastdmark: pop af  
2f92			endm  
# End of macro DMARK
2f92						CALLMONITOR 
2f92 cd 00 14			call break_point_state  
2f95				endm  
# End of macro CALLMONITOR
2f95					endif 
2f95				; next item on the stack is the limit. get it 
2f95			 
2f95			 
2f95				FORTH_LOOP_POP 
2f95 cd 87 1a			call macro_forth_loop_pop 
2f98				endm 
# End of macro FORTH_LOOP_POP
2f98			 
2f98				FORTH_LOOP_TOS 
2f98 cd 7d 1a			call macro_forth_loop_tos 
2f9b				endm 
# End of macro FORTH_LOOP_TOS
2f9b			 
2f9b d1				pop de		 ; de = i, hl = limit 
2f9c			 
2f9c					if DEBUG_FORTH_WORDS 
2f9c						DMARK "-L1" 
2f9c f5				push af  
2f9d 3a b1 2f			ld a, (.dmark)  
2fa0 32 77 fb			ld (debug_mark),a  
2fa3 3a b2 2f			ld a, (.dmark+1)  
2fa6 32 78 fb			ld (debug_mark+1),a  
2fa9 3a b3 2f			ld a, (.dmark+2)  
2fac 32 79 fb			ld (debug_mark+2),a  
2faf 18 03			jr .pastdmark  
2fb1 ..			.dmark: db "-L1"  
2fb4 f1			.pastdmark: pop af  
2fb5			endm  
# End of macro DMARK
2fb5						CALLMONITOR 
2fb5 cd 00 14			call break_point_state  
2fb8				endm  
# End of macro CALLMONITOR
2fb8					endif 
2fb8			 
2fb8				; go back to previous word 
2fb8			 
2fb8 d5				push de    ; save I for inc later 
2fb9			 
2fb9			 
2fb9				; get limit 
2fb9				;  is I at limit? 
2fb9			 
2fb9			 
2fb9					if DEBUG_FORTH_WORDS 
2fb9						DMARK "-L1" 
2fb9 f5				push af  
2fba 3a ce 2f			ld a, (.dmark)  
2fbd 32 77 fb			ld (debug_mark),a  
2fc0 3a cf 2f			ld a, (.dmark+1)  
2fc3 32 78 fb			ld (debug_mark+1),a  
2fc6 3a d0 2f			ld a, (.dmark+2)  
2fc9 32 79 fb			ld (debug_mark+2),a  
2fcc 18 03			jr .pastdmark  
2fce ..			.dmark: db "-L1"  
2fd1 f1			.pastdmark: pop af  
2fd2			endm  
# End of macro DMARK
2fd2						CALLMONITOR 
2fd2 cd 00 14			call break_point_state  
2fd5				endm  
# End of macro CALLMONITOR
2fd5					endif 
2fd5			 
2fd5 ed 52			sbc hl, de 
2fd7			 
2fd7			 
2fd7				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
2fd7			 
2fd7 20 26				jr nz, .mloopnotdone 
2fd9			 
2fd9 e1				pop hl   ; get rid of saved I 
2fda				FORTH_LOOP_POP     ; get rid of limit 
2fda cd 87 1a			call macro_forth_loop_pop 
2fdd				endm 
# End of macro FORTH_LOOP_POP
2fdd			 
2fdd				FORTH_RSP_POP     ; get rid of DO ptr 
2fdd cd 62 19			call macro_forth_rsp_pop 
2fe0				endm 
# End of macro FORTH_RSP_POP
2fe0			 
2fe0			if DEBUG_FORTH_WORDS 
2fe0						DMARK "-L>" 
2fe0 f5				push af  
2fe1 3a f5 2f			ld a, (.dmark)  
2fe4 32 77 fb			ld (debug_mark),a  
2fe7 3a f6 2f			ld a, (.dmark+1)  
2fea 32 78 fb			ld (debug_mark+1),a  
2fed 3a f7 2f			ld a, (.dmark+2)  
2ff0 32 79 fb			ld (debug_mark+2),a  
2ff3 18 03			jr .pastdmark  
2ff5 ..			.dmark: db "-L>"  
2ff8 f1			.pastdmark: pop af  
2ff9			endm  
# End of macro DMARK
2ff9				CALLMONITOR 
2ff9 cd 00 14			call break_point_state  
2ffc				endm  
# End of macro CALLMONITOR
2ffc			endif 
2ffc			 
2ffc					NEXTW 
2ffc c3 8b 1b			jp macro_next 
2fff				endm 
# End of macro NEXTW
2fff				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
2fff			 
2fff			.mloopnotdone: 
2fff			 
2fff e1				pop hl    ; get I 
3000 2b				dec hl 
3001			 
3001			   	; save new I 
3001			 
3001			 
3001					; set I counter 
3001			 
3001 22 57 f1				ld (os_current_i), hl 
3004			 
3004					 
3004				FORTH_LOOP_NEXT 
3004 cd 4a 1a			call macro_forth_loop_next 
3007				endm 
# End of macro FORTH_LOOP_NEXT
3007			 
3007			 
3007					if DEBUG_FORTH_WORDS 
3007 eb						ex de,hl 
3008					endif 
3008			 
3008			;	; get DO ptr 
3008			; 
3008				FORTH_RSP_TOS 
3008 cd 58 19			call macro_forth_rsp_tos 
300b				endm 
# End of macro FORTH_RSP_TOS
300b			 
300b				;push hl 
300b			 
300b				; not going to DO any more 
300b				; get rid of the RSP pointer as DO will add it back in 
300b				;FORTH_RSP_POP 
300b				;pop hl 
300b			 
300b			 
300b 22 33 f1			ld (os_tok_ptr), hl 
300e					if DEBUG_FORTH_WORDS 
300e						DMARK "-L<" 
300e f5				push af  
300f 3a 23 30			ld a, (.dmark)  
3012 32 77 fb			ld (debug_mark),a  
3015 3a 24 30			ld a, (.dmark+1)  
3018 32 78 fb			ld (debug_mark+1),a  
301b 3a 25 30			ld a, (.dmark+2)  
301e 32 79 fb			ld (debug_mark+2),a  
3021 18 03			jr .pastdmark  
3023 ..			.dmark: db "-L<"  
3026 f1			.pastdmark: pop af  
3027			endm  
# End of macro DMARK
3027					CALLMONITOR 
3027 cd 00 14			call break_point_state  
302a				endm  
# End of macro CALLMONITOR
302a				endif 
302a c3 1c 1c			jp exec1 
302d			 
302d					 
302d			 
302d			 
302d			 
302d				NEXTW 
302d c3 8b 1b			jp macro_next 
3030				endm 
# End of macro NEXTW
3030			 
3030			 
3030			 
3030			 
3030			.REPEAT: 
3030				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
3030 71				db WORD_SYS_CORE+93             
3031 83 30			dw .UNTIL            
3033 06				db 5 + 1 
3034 .. 00			db "REPEAT",0              
303b				endm 
# End of macro CWHEAD
303b			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
303b			;  push pc to rsp stack past the REPEAT 
303b					if DEBUG_FORTH_WORDS_KEY 
303b						DMARK "REP" 
303b f5				push af  
303c 3a 50 30			ld a, (.dmark)  
303f 32 77 fb			ld (debug_mark),a  
3042 3a 51 30			ld a, (.dmark+1)  
3045 32 78 fb			ld (debug_mark+1),a  
3048 3a 52 30			ld a, (.dmark+2)  
304b 32 79 fb			ld (debug_mark+2),a  
304e 18 03			jr .pastdmark  
3050 ..			.dmark: db "REP"  
3053 f1			.pastdmark: pop af  
3054			endm  
# End of macro DMARK
3054						CALLMONITOR 
3054 cd 00 14			call break_point_state  
3057				endm  
# End of macro CALLMONITOR
3057					endif 
3057			 
3057 2a 33 f1				ld hl, (os_tok_ptr) 
305a 23					inc hl   ; R 
305b 23					inc hl  ; E 
305c 23					inc hl   ; P 
305d 23					inc hl   ; E 
305e 23					inc hl   ; A 
305f 23					inc hl   ; T 
3060 23					inc hl   ; zero 
3061					FORTH_RSP_NEXT 
3061 cd 41 19			call macro_forth_rsp_next 
3064				endm 
# End of macro FORTH_RSP_NEXT
3064			 
3064			 
3064					if DEBUG_FORTH_WORDS 
3064						DMARK "REP" 
3064 f5				push af  
3065 3a 79 30			ld a, (.dmark)  
3068 32 77 fb			ld (debug_mark),a  
306b 3a 7a 30			ld a, (.dmark+1)  
306e 32 78 fb			ld (debug_mark+1),a  
3071 3a 7b 30			ld a, (.dmark+2)  
3074 32 79 fb			ld (debug_mark+2),a  
3077 18 03			jr .pastdmark  
3079 ..			.dmark: db "REP"  
307c f1			.pastdmark: pop af  
307d			endm  
# End of macro DMARK
307d						;pop bc    ; TODO BUG ?????? what is this for???? 
307d						CALLMONITOR 
307d cd 00 14			call break_point_state  
3080				endm  
# End of macro CALLMONITOR
3080					endif 
3080			 
3080					NEXTW 
3080 c3 8b 1b			jp macro_next 
3083				endm 
# End of macro NEXTW
3083			;	       NEXTW 
3083			 
3083			.UNTIL: 
3083				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3083 72				db WORD_SYS_CORE+94             
3084 1a 31			dw .ENDFLOW            
3086 06				db 5 + 1 
3087 .. 00			db "UNTIL",0              
308d				endm 
# End of macro CWHEAD
308d			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
308d			 
308d				; pop tos as check 
308d			 
308d				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
308d			 
308d				FORTH_DSP_VALUEHL 
308d cd 35 1a			call macro_dsp_valuehl 
3090				endm 
# End of macro FORTH_DSP_VALUEHL
3090			 
3090					if DEBUG_FORTH_WORDS_KEY 
3090						DMARK "UNT" 
3090 f5				push af  
3091 3a a5 30			ld a, (.dmark)  
3094 32 77 fb			ld (debug_mark),a  
3097 3a a6 30			ld a, (.dmark+1)  
309a 32 78 fb			ld (debug_mark+1),a  
309d 3a a7 30			ld a, (.dmark+2)  
30a0 32 79 fb			ld (debug_mark+2),a  
30a3 18 03			jr .pastdmark  
30a5 ..			.dmark: db "UNT"  
30a8 f1			.pastdmark: pop af  
30a9			endm  
# End of macro DMARK
30a9						CALLMONITOR 
30a9 cd 00 14			call break_point_state  
30ac				endm  
# End of macro CALLMONITOR
30ac					endif 
30ac			 
30ac			;	push hl 
30ac				FORTH_DSP_POP 
30ac cd d1 1a			call macro_forth_dsp_pop 
30af				endm 
# End of macro FORTH_DSP_POP
30af			 
30af			;	pop hl 
30af			 
30af				; test if true 
30af			 
30af cd 3b 0c			call ishlzero 
30b2			;	ld a,l 
30b2			;	add h 
30b2			; 
30b2			;	cp 0 
30b2			 
30b2 20 3e			jr nz, .untilnotdone 
30b4			 
30b4					if DEBUG_FORTH_WORDS 
30b4						DMARK "UNf" 
30b4 f5				push af  
30b5 3a c9 30			ld a, (.dmark)  
30b8 32 77 fb			ld (debug_mark),a  
30bb 3a ca 30			ld a, (.dmark+1)  
30be 32 78 fb			ld (debug_mark+1),a  
30c1 3a cb 30			ld a, (.dmark+2)  
30c4 32 79 fb			ld (debug_mark+2),a  
30c7 18 03			jr .pastdmark  
30c9 ..			.dmark: db "UNf"  
30cc f1			.pastdmark: pop af  
30cd			endm  
# End of macro DMARK
30cd						CALLMONITOR 
30cd cd 00 14			call break_point_state  
30d0				endm  
# End of macro CALLMONITOR
30d0					endif 
30d0			 
30d0			 
30d0			 
30d0				FORTH_RSP_POP     ; get rid of DO ptr 
30d0 cd 62 19			call macro_forth_rsp_pop 
30d3				endm 
# End of macro FORTH_RSP_POP
30d3			 
30d3			if DEBUG_FORTH_WORDS 
30d3						DMARK "UN>" 
30d3 f5				push af  
30d4 3a e8 30			ld a, (.dmark)  
30d7 32 77 fb			ld (debug_mark),a  
30da 3a e9 30			ld a, (.dmark+1)  
30dd 32 78 fb			ld (debug_mark+1),a  
30e0 3a ea 30			ld a, (.dmark+2)  
30e3 32 79 fb			ld (debug_mark+2),a  
30e6 18 03			jr .pastdmark  
30e8 ..			.dmark: db "UN>"  
30eb f1			.pastdmark: pop af  
30ec			endm  
# End of macro DMARK
30ec				CALLMONITOR 
30ec cd 00 14			call break_point_state  
30ef				endm  
# End of macro CALLMONITOR
30ef			endif 
30ef			 
30ef					NEXTW 
30ef c3 8b 1b			jp macro_next 
30f2				endm 
# End of macro NEXTW
30f2				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
30f2			 
30f2			.untilnotdone: 
30f2			 
30f2			 
30f2			;	; get DO ptr 
30f2			; 
30f2				FORTH_RSP_TOS 
30f2 cd 58 19			call macro_forth_rsp_tos 
30f5				endm 
# End of macro FORTH_RSP_TOS
30f5			 
30f5				;push hl 
30f5			 
30f5				; not going to DO any more 
30f5				; get rid of the RSP pointer as DO will add it back in 
30f5				;FORTH_RSP_POP 
30f5				;pop hl 
30f5			 
30f5			 
30f5 22 33 f1			ld (os_tok_ptr), hl 
30f8					if DEBUG_FORTH_WORDS 
30f8						DMARK "UN<" 
30f8 f5				push af  
30f9 3a 0d 31			ld a, (.dmark)  
30fc 32 77 fb			ld (debug_mark),a  
30ff 3a 0e 31			ld a, (.dmark+1)  
3102 32 78 fb			ld (debug_mark+1),a  
3105 3a 0f 31			ld a, (.dmark+2)  
3108 32 79 fb			ld (debug_mark+2),a  
310b 18 03			jr .pastdmark  
310d ..			.dmark: db "UN<"  
3110 f1			.pastdmark: pop af  
3111			endm  
# End of macro DMARK
3111					CALLMONITOR 
3111 cd 00 14			call break_point_state  
3114				endm  
# End of macro CALLMONITOR
3114				endif 
3114 c3 1c 1c			jp exec1 
3117			 
3117					 
3117			 
3117			 
3117					NEXTW 
3117 c3 8b 1b			jp macro_next 
311a				endm 
# End of macro NEXTW
311a			 
311a			 
311a			.ENDFLOW: 
311a			 
311a			; eof 
311a			 
# End of file forth_words_flow.asm
311a			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
311a			include "forth_words_logic.asm" 
311a			 
311a			; | ## Logic Words 
311a			 
311a			.NOT: 
311a				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
311a 2d				db WORD_SYS_CORE+25             
311b 62 31			dw .IS            
311d 04				db 3 + 1 
311e .. 00			db "NOT",0              
3122				endm 
# End of macro CWHEAD
3122			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
3122					if DEBUG_FORTH_WORDS_KEY 
3122						DMARK "NOT" 
3122 f5				push af  
3123 3a 37 31			ld a, (.dmark)  
3126 32 77 fb			ld (debug_mark),a  
3129 3a 38 31			ld a, (.dmark+1)  
312c 32 78 fb			ld (debug_mark+1),a  
312f 3a 39 31			ld a, (.dmark+2)  
3132 32 79 fb			ld (debug_mark+2),a  
3135 18 03			jr .pastdmark  
3137 ..			.dmark: db "NOT"  
313a f1			.pastdmark: pop af  
313b			endm  
# End of macro DMARK
313b						CALLMONITOR 
313b cd 00 14			call break_point_state  
313e				endm  
# End of macro CALLMONITOR
313e					endif 
313e					FORTH_DSP 
313e cd 1a 1a			call macro_forth_dsp 
3141				endm 
# End of macro FORTH_DSP
3141 7e					ld a,(hl)	; get type of value on TOS 
3142 fe 02				cp DS_TYPE_INUM  
3144 28 03				jr z, .noti 
3146					NEXTW 
3146 c3 8b 1b			jp macro_next 
3149				endm 
# End of macro NEXTW
3149			.noti:          FORTH_DSP_VALUEHL 
3149 cd 35 1a			call macro_dsp_valuehl 
314c				endm 
# End of macro FORTH_DSP_VALUEHL
314c			;		push hl 
314c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
314c cd d1 1a			call macro_forth_dsp_pop 
314f				endm 
# End of macro FORTH_DSP_POP
314f			;		pop hl 
314f 3e 00				ld a,0 
3151 bd					cp l 
3152 28 04				jr z, .not2t 
3154 2e 00				ld l, 0 
3156 18 02				jr .notip 
3158			 
3158 2e ff		.not2t:		ld l, 255 
315a			 
315a 26 00		.notip:		ld h, 0	 
315c			 
315c cd 9a 19				call forth_push_numhl 
315f					NEXTW 
315f c3 8b 1b			jp macro_next 
3162				endm 
# End of macro NEXTW
3162			 
3162			.IS: 
3162				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
3162 2d				db WORD_SYS_CORE+25             
3163 88 31			dw .LZERO            
3165 03				db 2 + 1 
3166 .. 00			db "IS",0              
3169				endm 
# End of macro CWHEAD
3169			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
3169					if DEBUG_FORTH_WORDS_KEY 
3169						DMARK "IS." 
3169 f5				push af  
316a 3a 7e 31			ld a, (.dmark)  
316d 32 77 fb			ld (debug_mark),a  
3170 3a 7f 31			ld a, (.dmark+1)  
3173 32 78 fb			ld (debug_mark+1),a  
3176 3a 80 31			ld a, (.dmark+2)  
3179 32 79 fb			ld (debug_mark+2),a  
317c 18 03			jr .pastdmark  
317e ..			.dmark: db "IS."  
3181 f1			.pastdmark: pop af  
3182			endm  
# End of macro DMARK
3182						CALLMONITOR 
3182 cd 00 14			call break_point_state  
3185				endm  
# End of macro CALLMONITOR
3185					endif 
3185					NEXTW 
3185 c3 8b 1b			jp macro_next 
3188				endm 
# End of macro NEXTW
3188			.LZERO: 
3188				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3188 2d				db WORD_SYS_CORE+25             
3189 92 31			dw .TZERO            
318b 03				db 2 + 1 
318c .. 00			db "0<",0              
318f				endm 
# End of macro CWHEAD
318f			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
318f					NEXTW 
318f c3 8b 1b			jp macro_next 
3192				endm 
# End of macro NEXTW
3192			.TZERO: 
3192				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
3192 2e				db WORD_SYS_CORE+26             
3193 d9 31			dw .LESS            
3195 03				db 2 + 1 
3196 .. 00			db "0=",0              
3199				endm 
# End of macro CWHEAD
3199			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3199				; TODO add floating point number detection 
3199					;v5 FORTH_DSP_VALUE 
3199					if DEBUG_FORTH_WORDS_KEY 
3199						DMARK "0=." 
3199 f5				push af  
319a 3a ae 31			ld a, (.dmark)  
319d 32 77 fb			ld (debug_mark),a  
31a0 3a af 31			ld a, (.dmark+1)  
31a3 32 78 fb			ld (debug_mark+1),a  
31a6 3a b0 31			ld a, (.dmark+2)  
31a9 32 79 fb			ld (debug_mark+2),a  
31ac 18 03			jr .pastdmark  
31ae ..			.dmark: db "0=."  
31b1 f1			.pastdmark: pop af  
31b2			endm  
# End of macro DMARK
31b2						CALLMONITOR 
31b2 cd 00 14			call break_point_state  
31b5				endm  
# End of macro CALLMONITOR
31b5					endif 
31b5					FORTH_DSP 
31b5 cd 1a 1a			call macro_forth_dsp 
31b8				endm 
# End of macro FORTH_DSP
31b8 7e					ld a,(hl)	; get type of value on TOS 
31b9 fe 02				cp DS_TYPE_INUM  
31bb 28 00				jr z, .tz_inum 
31bd			 
31bd				if FORTH_ENABLE_FLOATMATH 
31bd					jr .tz_done 
31bd			 
31bd				endif 
31bd					 
31bd			 
31bd			.tz_inum: 
31bd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
31bd cd 35 1a			call macro_dsp_valuehl 
31c0				endm 
# End of macro FORTH_DSP_VALUEHL
31c0			 
31c0			;		push hl 
31c0			 
31c0					; destroy value TOS 
31c0			 
31c0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
31c0 cd d1 1a			call macro_forth_dsp_pop 
31c3				endm 
# End of macro FORTH_DSP_POP
31c3			 
31c3			;		pop hl 
31c3			 
31c3 3e 00				ld a,0 
31c5			 
31c5 bd					cp l 
31c6 20 08				jr nz, .tz_notzero 
31c8			 
31c8 bc					cp h 
31c9			 
31c9 20 05				jr nz, .tz_notzero 
31cb			 
31cb			 
31cb 21 01 00				ld hl, FORTH_TRUE 
31ce 18 03				jr .tz_done 
31d0			 
31d0 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
31d3			 
31d3					; push value back onto stack for another op etc 
31d3			 
31d3			.tz_done: 
31d3 cd 9a 19				call forth_push_numhl 
31d6			 
31d6					NEXTW 
31d6 c3 8b 1b			jp macro_next 
31d9				endm 
# End of macro NEXTW
31d9			.LESS: 
31d9				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
31d9 2f				db WORD_SYS_CORE+27             
31da 42 32			dw .GT            
31dc 02				db 1 + 1 
31dd .. 00			db "<",0              
31df				endm 
# End of macro CWHEAD
31df			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
31df				; TODO add floating point number detection 
31df					if DEBUG_FORTH_WORDS_KEY 
31df						DMARK "LES" 
31df f5				push af  
31e0 3a f4 31			ld a, (.dmark)  
31e3 32 77 fb			ld (debug_mark),a  
31e6 3a f5 31			ld a, (.dmark+1)  
31e9 32 78 fb			ld (debug_mark+1),a  
31ec 3a f6 31			ld a, (.dmark+2)  
31ef 32 79 fb			ld (debug_mark+2),a  
31f2 18 03			jr .pastdmark  
31f4 ..			.dmark: db "LES"  
31f7 f1			.pastdmark: pop af  
31f8			endm  
# End of macro DMARK
31f8						CALLMONITOR 
31f8 cd 00 14			call break_point_state  
31fb				endm  
# End of macro CALLMONITOR
31fb					endif 
31fb					FORTH_DSP 
31fb cd 1a 1a			call macro_forth_dsp 
31fe				endm 
# End of macro FORTH_DSP
31fe					;v5 FORTH_DSP_VALUE 
31fe 7e					ld a,(hl)	; get type of value on TOS 
31ff fe 02				cp DS_TYPE_INUM  
3201 28 00				jr z, .less_inum 
3203			 
3203				if FORTH_ENABLE_FLOATMATH 
3203					jr .less_done 
3203			 
3203				endif 
3203					 
3203			 
3203			.less_inum: 
3203					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3203 cd 35 1a			call macro_dsp_valuehl 
3206				endm 
# End of macro FORTH_DSP_VALUEHL
3206			 
3206 e5					push hl  ; u2 
3207			 
3207					; destroy value TOS 
3207			 
3207					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3207 cd d1 1a			call macro_forth_dsp_pop 
320a				endm 
# End of macro FORTH_DSP_POP
320a			 
320a			 
320a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
320a cd 35 1a			call macro_dsp_valuehl 
320d				endm 
# End of macro FORTH_DSP_VALUEHL
320d			 
320d e5					push hl    ; u1 
320e			 
320e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
320e cd d1 1a			call macro_forth_dsp_pop 
3211				endm 
# End of macro FORTH_DSP_POP
3211			 
3211			 
3211 b7			 or a      ;clear carry flag 
3212 01 00 00		 ld bc, FORTH_FALSE 
3215 e1			  pop hl    ; u1 
3216 d1			  pop de    ; u2 
3217 ed 52		  sbc hl,de 
3219 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
321b			 
321b 01 01 00		 ld bc, FORTH_TRUE 
321e			.lscont:  
321e c5					push bc 
321f e1					pop hl 
3220			 
3220					if DEBUG_FORTH_WORDS 
3220						DMARK "LT1" 
3220 f5				push af  
3221 3a 35 32			ld a, (.dmark)  
3224 32 77 fb			ld (debug_mark),a  
3227 3a 36 32			ld a, (.dmark+1)  
322a 32 78 fb			ld (debug_mark+1),a  
322d 3a 37 32			ld a, (.dmark+2)  
3230 32 79 fb			ld (debug_mark+2),a  
3233 18 03			jr .pastdmark  
3235 ..			.dmark: db "LT1"  
3238 f1			.pastdmark: pop af  
3239			endm  
# End of macro DMARK
3239						CALLMONITOR 
3239 cd 00 14			call break_point_state  
323c				endm  
# End of macro CALLMONITOR
323c					endif 
323c cd 9a 19				call forth_push_numhl 
323f			 
323f					NEXTW 
323f c3 8b 1b			jp macro_next 
3242				endm 
# End of macro NEXTW
3242			.GT: 
3242				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
3242 30				db WORD_SYS_CORE+28             
3243 ab 32			dw .EQUAL            
3245 02				db 1 + 1 
3246 .. 00			db ">",0              
3248				endm 
# End of macro CWHEAD
3248			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
3248				; TODO add floating point number detection 
3248					if DEBUG_FORTH_WORDS_KEY 
3248						DMARK "GRT" 
3248 f5				push af  
3249 3a 5d 32			ld a, (.dmark)  
324c 32 77 fb			ld (debug_mark),a  
324f 3a 5e 32			ld a, (.dmark+1)  
3252 32 78 fb			ld (debug_mark+1),a  
3255 3a 5f 32			ld a, (.dmark+2)  
3258 32 79 fb			ld (debug_mark+2),a  
325b 18 03			jr .pastdmark  
325d ..			.dmark: db "GRT"  
3260 f1			.pastdmark: pop af  
3261			endm  
# End of macro DMARK
3261						CALLMONITOR 
3261 cd 00 14			call break_point_state  
3264				endm  
# End of macro CALLMONITOR
3264					endif 
3264					FORTH_DSP 
3264 cd 1a 1a			call macro_forth_dsp 
3267				endm 
# End of macro FORTH_DSP
3267					;FORTH_DSP_VALUE 
3267 7e					ld a,(hl)	; get type of value on TOS 
3268 fe 02				cp DS_TYPE_INUM  
326a 28 00				jr z, .gt_inum 
326c			 
326c				if FORTH_ENABLE_FLOATMATH 
326c					jr .gt_done 
326c			 
326c				endif 
326c					 
326c			 
326c			.gt_inum: 
326c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
326c cd 35 1a			call macro_dsp_valuehl 
326f				endm 
# End of macro FORTH_DSP_VALUEHL
326f			 
326f e5					push hl  ; u2 
3270			 
3270					; destroy value TOS 
3270			 
3270					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3270 cd d1 1a			call macro_forth_dsp_pop 
3273				endm 
# End of macro FORTH_DSP_POP
3273			 
3273			 
3273					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3273 cd 35 1a			call macro_dsp_valuehl 
3276				endm 
# End of macro FORTH_DSP_VALUEHL
3276			 
3276 e5					push hl    ; u1 
3277			 
3277					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3277 cd d1 1a			call macro_forth_dsp_pop 
327a				endm 
# End of macro FORTH_DSP_POP
327a			 
327a			 
327a b7			 or a      ;clear carry flag 
327b 01 00 00		 ld bc, FORTH_FALSE 
327e e1			  pop hl    ; u1 
327f d1			  pop de    ; u2 
3280 ed 52		  sbc hl,de 
3282 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3284			 
3284 01 01 00		 ld bc, FORTH_TRUE 
3287			.gtcont:  
3287 c5					push bc 
3288 e1					pop hl 
3289			 
3289					if DEBUG_FORTH_WORDS 
3289						DMARK "GT1" 
3289 f5				push af  
328a 3a 9e 32			ld a, (.dmark)  
328d 32 77 fb			ld (debug_mark),a  
3290 3a 9f 32			ld a, (.dmark+1)  
3293 32 78 fb			ld (debug_mark+1),a  
3296 3a a0 32			ld a, (.dmark+2)  
3299 32 79 fb			ld (debug_mark+2),a  
329c 18 03			jr .pastdmark  
329e ..			.dmark: db "GT1"  
32a1 f1			.pastdmark: pop af  
32a2			endm  
# End of macro DMARK
32a2						CALLMONITOR 
32a2 cd 00 14			call break_point_state  
32a5				endm  
# End of macro CALLMONITOR
32a5					endif 
32a5 cd 9a 19				call forth_push_numhl 
32a8			 
32a8					NEXTW 
32a8 c3 8b 1b			jp macro_next 
32ab				endm 
# End of macro NEXTW
32ab			.EQUAL: 
32ab				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
32ab 31				db WORD_SYS_CORE+29             
32ac 16 33			dw .ENDLOGIC            
32ae 02				db 1 + 1 
32af .. 00			db "=",0              
32b1				endm 
# End of macro CWHEAD
32b1			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
32b1				; TODO add floating point number detection 
32b1					if DEBUG_FORTH_WORDS_KEY 
32b1						DMARK "EQ." 
32b1 f5				push af  
32b2 3a c6 32			ld a, (.dmark)  
32b5 32 77 fb			ld (debug_mark),a  
32b8 3a c7 32			ld a, (.dmark+1)  
32bb 32 78 fb			ld (debug_mark+1),a  
32be 3a c8 32			ld a, (.dmark+2)  
32c1 32 79 fb			ld (debug_mark+2),a  
32c4 18 03			jr .pastdmark  
32c6 ..			.dmark: db "EQ."  
32c9 f1			.pastdmark: pop af  
32ca			endm  
# End of macro DMARK
32ca						CALLMONITOR 
32ca cd 00 14			call break_point_state  
32cd				endm  
# End of macro CALLMONITOR
32cd					endif 
32cd					FORTH_DSP 
32cd cd 1a 1a			call macro_forth_dsp 
32d0				endm 
# End of macro FORTH_DSP
32d0					;v5 FORTH_DSP_VALUE 
32d0 7e					ld a,(hl)	; get type of value on TOS 
32d1 fe 02				cp DS_TYPE_INUM  
32d3 28 00				jr z, .eq_inum 
32d5			 
32d5				if FORTH_ENABLE_FLOATMATH 
32d5					jr .eq_done 
32d5			 
32d5				endif 
32d5					 
32d5			 
32d5			.eq_inum: 
32d5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32d5 cd 35 1a			call macro_dsp_valuehl 
32d8				endm 
# End of macro FORTH_DSP_VALUEHL
32d8			 
32d8 e5					push hl 
32d9			 
32d9					; destroy value TOS 
32d9			 
32d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d9 cd d1 1a			call macro_forth_dsp_pop 
32dc				endm 
# End of macro FORTH_DSP_POP
32dc			 
32dc			 
32dc					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
32dc cd 35 1a			call macro_dsp_valuehl 
32df				endm 
# End of macro FORTH_DSP_VALUEHL
32df			 
32df					; one value on hl get other one back 
32df			 
32df e5					push hl 
32e0			 
32e0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32e0 cd d1 1a			call macro_forth_dsp_pop 
32e3				endm 
# End of macro FORTH_DSP_POP
32e3			 
32e3 0e 00				ld c, FORTH_FALSE 
32e5			 
32e5 e1					pop hl 
32e6 d1					pop de 
32e7			 
32e7 7b					ld a, e 
32e8 bd					cp l 
32e9			 
32e9 20 06				jr nz, .eq_done 
32eb			 
32eb 7a					ld a, d 
32ec bc					cp h 
32ed			 
32ed 20 02				jr nz, .eq_done 
32ef			 
32ef 0e 01				ld c, FORTH_TRUE 
32f1					 
32f1			 
32f1			 
32f1			.eq_done: 
32f1			 
32f1					; TODO push value back onto stack for another op etc 
32f1			 
32f1 26 00				ld h, 0 
32f3 69					ld l, c 
32f4					if DEBUG_FORTH_WORDS 
32f4						DMARK "EQ1" 
32f4 f5				push af  
32f5 3a 09 33			ld a, (.dmark)  
32f8 32 77 fb			ld (debug_mark),a  
32fb 3a 0a 33			ld a, (.dmark+1)  
32fe 32 78 fb			ld (debug_mark+1),a  
3301 3a 0b 33			ld a, (.dmark+2)  
3304 32 79 fb			ld (debug_mark+2),a  
3307 18 03			jr .pastdmark  
3309 ..			.dmark: db "EQ1"  
330c f1			.pastdmark: pop af  
330d			endm  
# End of macro DMARK
330d						CALLMONITOR 
330d cd 00 14			call break_point_state  
3310				endm  
# End of macro CALLMONITOR
3310					endif 
3310 cd 9a 19				call forth_push_numhl 
3313			 
3313					NEXTW 
3313 c3 8b 1b			jp macro_next 
3316				endm 
# End of macro NEXTW
3316			 
3316			 
3316			.ENDLOGIC: 
3316			; eof 
3316			 
3316			 
# End of file forth_words_logic.asm
3316			include "forth_words_maths.asm" 
3316			 
3316			; | ## Maths Words 
3316			 
3316			.PLUS:	 
3316				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
3316 15				db WORD_SYS_CORE+1             
3317 58 33			dw .NEG            
3319 02				db 1 + 1 
331a .. 00			db "+",0              
331c				endm 
# End of macro CWHEAD
331c			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
331c					if DEBUG_FORTH_WORDS_KEY 
331c						DMARK "PLU" 
331c f5				push af  
331d 3a 31 33			ld a, (.dmark)  
3320 32 77 fb			ld (debug_mark),a  
3323 3a 32 33			ld a, (.dmark+1)  
3326 32 78 fb			ld (debug_mark+1),a  
3329 3a 33 33			ld a, (.dmark+2)  
332c 32 79 fb			ld (debug_mark+2),a  
332f 18 03			jr .pastdmark  
3331 ..			.dmark: db "PLU"  
3334 f1			.pastdmark: pop af  
3335			endm  
# End of macro DMARK
3335						CALLMONITOR 
3335 cd 00 14			call break_point_state  
3338				endm  
# End of macro CALLMONITOR
3338					endif 
3338					; add top two values and push back result 
3338			 
3338					;for v5 FORTH_DSP_VALUE 
3338					FORTH_DSP 
3338 cd 1a 1a			call macro_forth_dsp 
333b				endm 
# End of macro FORTH_DSP
333b 7e					ld a,(hl)	; get type of value on TOS 
333c fe 02				cp DS_TYPE_INUM  
333e 28 03				jr z, .dot_inum 
3340			 
3340					NEXTW 
3340 c3 8b 1b			jp macro_next 
3343				endm 
# End of macro NEXTW
3343			 
3343			; float maths 
3343			 
3343				if FORTH_ENABLE_FLOATMATH 
3343						inc hl      ; now at start of numeric as string 
3343			 
3343					if DEBUG_FORTH_MATHS 
3343						DMARK "ADD" 
3343				CALLMONITOR 
3343					endif 
3343			 
3343					;ld ix, hl 
3343					call CON 
3343			 
3343			 
3343					push hl 
3343					 
3343					 
3343			 
3343						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
3343			 
3343					; get next number 
3343			 
3343						FORTH_DSP_VALUE 
3343			 
3343						inc hl      ; now at start of numeric as string 
3343			 
3343					;ld ix, hl 
3343					call CON 
3343			 
3343					push hl 
3343			 
3343			 
3343						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3343			 
3343						; TODO do add 
3343			 
3343						call IADD 
3343			 
3343						; TODO get result back as ascii 
3343			 
3343						; TODO push result  
3343			 
3343			 
3343			 
3343						jr .dot_done 
3343				endif 
3343			 
3343			.dot_inum: 
3343			 
3343			 
3343					if DEBUG_FORTH_DOT 
3343						DMARK "+IT" 
3343				CALLMONITOR 
3343					endif 
3343			 
3343					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3343 cd 35 1a			call macro_dsp_valuehl 
3346				endm 
# End of macro FORTH_DSP_VALUEHL
3346			 
3346				; TODO add floating point number detection 
3346			 
3346 e5					push hl 
3347			 
3347					; destroy value TOS 
3347			 
3347					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3347 cd d1 1a			call macro_forth_dsp_pop 
334a				endm 
# End of macro FORTH_DSP_POP
334a			 
334a			 
334a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
334a cd 35 1a			call macro_dsp_valuehl 
334d				endm 
# End of macro FORTH_DSP_VALUEHL
334d			 
334d					; one value on hl get other one back 
334d			 
334d d1					pop de 
334e			 
334e					; do the add 
334e			 
334e 19					add hl,de 
334f			 
334f					; save it 
334f			 
334f			;		push hl	 
334f			 
334f					; 
334f			 
334f					; destroy value TOS 
334f			 
334f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
334f cd d1 1a			call macro_forth_dsp_pop 
3352				endm 
# End of macro FORTH_DSP_POP
3352			 
3352					; TODO push value back onto stack for another op etc 
3352			 
3352			;		pop hl 
3352			 
3352			.dot_done: 
3352 cd 9a 19				call forth_push_numhl 
3355			 
3355					NEXTW 
3355 c3 8b 1b			jp macro_next 
3358				endm 
# End of macro NEXTW
3358			.NEG: 
3358			 
3358				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
3358 17				db WORD_SYS_CORE+3             
3359 9b 33			dw .DIV            
335b 02				db 1 + 1 
335c .. 00			db "-",0              
335e				endm 
# End of macro CWHEAD
335e			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
335e					if DEBUG_FORTH_WORDS_KEY 
335e						DMARK "SUB" 
335e f5				push af  
335f 3a 73 33			ld a, (.dmark)  
3362 32 77 fb			ld (debug_mark),a  
3365 3a 74 33			ld a, (.dmark+1)  
3368 32 78 fb			ld (debug_mark+1),a  
336b 3a 75 33			ld a, (.dmark+2)  
336e 32 79 fb			ld (debug_mark+2),a  
3371 18 03			jr .pastdmark  
3373 ..			.dmark: db "SUB"  
3376 f1			.pastdmark: pop af  
3377			endm  
# End of macro DMARK
3377						CALLMONITOR 
3377 cd 00 14			call break_point_state  
337a				endm  
# End of macro CALLMONITOR
337a					endif 
337a			 
337a			 
337a				; TODO add floating point number detection 
337a					; v5 FORTH_DSP_VALUE 
337a					FORTH_DSP 
337a cd 1a 1a			call macro_forth_dsp 
337d				endm 
# End of macro FORTH_DSP
337d 7e					ld a,(hl)	; get type of value on TOS 
337e fe 02				cp DS_TYPE_INUM  
3380 28 03				jr z, .neg_inum 
3382			 
3382					NEXTW 
3382 c3 8b 1b			jp macro_next 
3385				endm 
# End of macro NEXTW
3385			 
3385			; float maths 
3385			 
3385				if FORTH_ENABLE_FLOATMATH 
3385					jr .neg_done 
3385			 
3385				endif 
3385					 
3385			 
3385			.neg_inum: 
3385					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3385 cd 35 1a			call macro_dsp_valuehl 
3388				endm 
# End of macro FORTH_DSP_VALUEHL
3388			 
3388 e5					push hl 
3389			 
3389					; destroy value TOS 
3389			 
3389					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3389 cd d1 1a			call macro_forth_dsp_pop 
338c				endm 
# End of macro FORTH_DSP_POP
338c			 
338c			 
338c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
338c cd 35 1a			call macro_dsp_valuehl 
338f				endm 
# End of macro FORTH_DSP_VALUEHL
338f			 
338f					; one value on hl get other one back 
338f			 
338f d1					pop de 
3390			 
3390					; do the sub 
3390			;		ex de, hl 
3390			 
3390 ed 52				sbc hl,de 
3392			 
3392					; save it 
3392			 
3392			;		push hl	 
3392			 
3392					; 
3392			 
3392					; destroy value TOS 
3392			 
3392					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3392 cd d1 1a			call macro_forth_dsp_pop 
3395				endm 
# End of macro FORTH_DSP_POP
3395			 
3395					; TODO push value back onto stack for another op etc 
3395			 
3395			;		pop hl 
3395			 
3395 cd 9a 19				call forth_push_numhl 
3398			.neg_done: 
3398			 
3398					NEXTW 
3398 c3 8b 1b			jp macro_next 
339b				endm 
# End of macro NEXTW
339b			.DIV: 
339b				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
339b 18				db WORD_SYS_CORE+4             
339c e8 33			dw .MUL            
339e 02				db 1 + 1 
339f .. 00			db "/",0              
33a1				endm 
# End of macro CWHEAD
33a1			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
33a1					if DEBUG_FORTH_WORDS_KEY 
33a1						DMARK "DIV" 
33a1 f5				push af  
33a2 3a b6 33			ld a, (.dmark)  
33a5 32 77 fb			ld (debug_mark),a  
33a8 3a b7 33			ld a, (.dmark+1)  
33ab 32 78 fb			ld (debug_mark+1),a  
33ae 3a b8 33			ld a, (.dmark+2)  
33b1 32 79 fb			ld (debug_mark+2),a  
33b4 18 03			jr .pastdmark  
33b6 ..			.dmark: db "DIV"  
33b9 f1			.pastdmark: pop af  
33ba			endm  
# End of macro DMARK
33ba						CALLMONITOR 
33ba cd 00 14			call break_point_state  
33bd				endm  
# End of macro CALLMONITOR
33bd					endif 
33bd				; TODO add floating point number detection 
33bd					; v5 FORTH_DSP_VALUE 
33bd					FORTH_DSP 
33bd cd 1a 1a			call macro_forth_dsp 
33c0				endm 
# End of macro FORTH_DSP
33c0 7e					ld a,(hl)	; get type of value on TOS 
33c1 fe 02				cp DS_TYPE_INUM  
33c3 28 03				jr z, .div_inum 
33c5			 
33c5				if FORTH_ENABLE_FLOATMATH 
33c5					jr .div_done 
33c5			 
33c5				endif 
33c5					NEXTW 
33c5 c3 8b 1b			jp macro_next 
33c8				endm 
# End of macro NEXTW
33c8			.div_inum: 
33c8			 
33c8					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33c8 cd 35 1a			call macro_dsp_valuehl 
33cb				endm 
# End of macro FORTH_DSP_VALUEHL
33cb			 
33cb e5					push hl    ; to go to bc 
33cc			 
33cc					; destroy value TOS 
33cc			 
33cc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33cc cd d1 1a			call macro_forth_dsp_pop 
33cf				endm 
# End of macro FORTH_DSP_POP
33cf			 
33cf			 
33cf					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33cf cd 35 1a			call macro_dsp_valuehl 
33d2				endm 
# End of macro FORTH_DSP_VALUEHL
33d2			 
33d2					; hl to go to de 
33d2			 
33d2 e5					push hl 
33d3			 
33d3 c1					pop bc 
33d4 d1					pop de		 
33d5			 
33d5			 
33d5					if DEBUG_FORTH_MATHS 
33d5						DMARK "DIV" 
33d5				CALLMONITOR 
33d5					endif 
33d5					; one value on hl but move to a get other one back 
33d5			 
33d5			        
33d5 cd 6f 0b			call Div16 
33d8			 
33d8			;	push af	 
33d8 e5				push hl 
33d9 c5				push bc 
33da			 
33da					if DEBUG_FORTH_MATHS 
33da						DMARK "DI1" 
33da				CALLMONITOR 
33da					endif 
33da			 
33da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33da cd d1 1a			call macro_forth_dsp_pop 
33dd				endm 
# End of macro FORTH_DSP_POP
33dd			 
33dd			 
33dd			 
33dd e1					pop hl    ; result 
33de			 
33de cd 9a 19				call forth_push_numhl 
33e1			 
33e1 e1					pop hl    ; reminder 
33e2			;		ld h,0 
33e2			;		ld l,d 
33e2			 
33e2 cd 9a 19				call forth_push_numhl 
33e5			.div_done: 
33e5					NEXTW 
33e5 c3 8b 1b			jp macro_next 
33e8				endm 
# End of macro NEXTW
33e8			.MUL: 
33e8				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
33e8 19				db WORD_SYS_CORE+5             
33e9 2d 34			dw .MIN            
33eb 02				db 1 + 1 
33ec .. 00			db "*",0              
33ee				endm 
# End of macro CWHEAD
33ee			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
33ee				; TODO add floating point number detection 
33ee					if DEBUG_FORTH_WORDS_KEY 
33ee						DMARK "MUL" 
33ee f5				push af  
33ef 3a 03 34			ld a, (.dmark)  
33f2 32 77 fb			ld (debug_mark),a  
33f5 3a 04 34			ld a, (.dmark+1)  
33f8 32 78 fb			ld (debug_mark+1),a  
33fb 3a 05 34			ld a, (.dmark+2)  
33fe 32 79 fb			ld (debug_mark+2),a  
3401 18 03			jr .pastdmark  
3403 ..			.dmark: db "MUL"  
3406 f1			.pastdmark: pop af  
3407			endm  
# End of macro DMARK
3407						CALLMONITOR 
3407 cd 00 14			call break_point_state  
340a				endm  
# End of macro CALLMONITOR
340a					endif 
340a					FORTH_DSP 
340a cd 1a 1a			call macro_forth_dsp 
340d				endm 
# End of macro FORTH_DSP
340d					; v5 FORTH_DSP_VALUE 
340d 7e					ld a,(hl)	; get type of value on TOS 
340e fe 02				cp DS_TYPE_INUM  
3410 28 03				jr z, .mul_inum 
3412			 
3412				if FORTH_ENABLE_FLOATMATH 
3412					jr .mul_done 
3412			 
3412				endif 
3412			 
3412					NEXTW 
3412 c3 8b 1b			jp macro_next 
3415				endm 
# End of macro NEXTW
3415			.mul_inum:	 
3415			 
3415					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3415 cd 35 1a			call macro_dsp_valuehl 
3418				endm 
# End of macro FORTH_DSP_VALUEHL
3418			 
3418 e5					push hl 
3419			 
3419					; destroy value TOS 
3419			 
3419					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3419 cd d1 1a			call macro_forth_dsp_pop 
341c				endm 
# End of macro FORTH_DSP_POP
341c			 
341c			 
341c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
341c cd 35 1a			call macro_dsp_valuehl 
341f				endm 
# End of macro FORTH_DSP_VALUEHL
341f			 
341f					; one value on hl but move to a get other one back 
341f			 
341f 7d					ld a, l 
3420			 
3420 d1					pop de 
3421			 
3421					; do the mull 
3421			;		ex de, hl 
3421			 
3421 cd 95 0b				call Mult16 
3424					; save it 
3424			 
3424			;		push hl	 
3424			 
3424					; 
3424			 
3424					; destroy value TOS 
3424			 
3424					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3424 cd d1 1a			call macro_forth_dsp_pop 
3427				endm 
# End of macro FORTH_DSP_POP
3427			 
3427					; TODO push value back onto stack for another op etc 
3427			 
3427			;		pop hl 
3427			 
3427 cd 9a 19				call forth_push_numhl 
342a			 
342a			.mul_done: 
342a					NEXTW 
342a c3 8b 1b			jp macro_next 
342d				endm 
# End of macro NEXTW
342d			 
342d			 
342d			 
342d			 
342d			.MIN: 
342d				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
342d 49				db WORD_SYS_CORE+53             
342e ae 34			dw .MAX            
3430 04				db 3 + 1 
3431 .. 00			db "MIN",0              
3435				endm 
# End of macro CWHEAD
3435			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
3435					if DEBUG_FORTH_WORDS_KEY 
3435						DMARK "MIN" 
3435 f5				push af  
3436 3a 4a 34			ld a, (.dmark)  
3439 32 77 fb			ld (debug_mark),a  
343c 3a 4b 34			ld a, (.dmark+1)  
343f 32 78 fb			ld (debug_mark+1),a  
3442 3a 4c 34			ld a, (.dmark+2)  
3445 32 79 fb			ld (debug_mark+2),a  
3448 18 03			jr .pastdmark  
344a ..			.dmark: db "MIN"  
344d f1			.pastdmark: pop af  
344e			endm  
# End of macro DMARK
344e						CALLMONITOR 
344e cd 00 14			call break_point_state  
3451				endm  
# End of macro CALLMONITOR
3451					endif 
3451					; get u2 
3451			 
3451					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3451 cd 35 1a			call macro_dsp_valuehl 
3454				endm 
# End of macro FORTH_DSP_VALUEHL
3454			 
3454 e5					push hl   ; u2 
3455			 
3455					; destroy value TOS 
3455			 
3455					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3455 cd d1 1a			call macro_forth_dsp_pop 
3458				endm 
# End of macro FORTH_DSP_POP
3458			 
3458					; get u1 
3458			 
3458					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3458 cd 35 1a			call macro_dsp_valuehl 
345b				endm 
# End of macro FORTH_DSP_VALUEHL
345b			 
345b e5					push hl  ; u1 
345c			 
345c					; destroy value TOS 
345c			 
345c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
345c cd d1 1a			call macro_forth_dsp_pop 
345f				endm 
# End of macro FORTH_DSP_POP
345f			 
345f b7			 or a      ;clear carry flag 
3460 e1			  pop hl    ; u1 
3461 d1			  pop de    ; u2 
3462 e5				push hl   ; saved in case hl is lowest 
3463 ed 52		  sbc hl,de 
3465 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
3467			 
3467 e1				pop hl 
3468					if DEBUG_FORTH_WORDS 
3468						DMARK "MIN" 
3468 f5				push af  
3469 3a 7d 34			ld a, (.dmark)  
346c 32 77 fb			ld (debug_mark),a  
346f 3a 7e 34			ld a, (.dmark+1)  
3472 32 78 fb			ld (debug_mark+1),a  
3475 3a 7f 34			ld a, (.dmark+2)  
3478 32 79 fb			ld (debug_mark+2),a  
347b 18 03			jr .pastdmark  
347d ..			.dmark: db "MIN"  
3480 f1			.pastdmark: pop af  
3481			endm  
# End of macro DMARK
3481						CALLMONITOR 
3481 cd 00 14			call break_point_state  
3484				endm  
# End of macro CALLMONITOR
3484					endif 
3484 cd 9a 19				call forth_push_numhl 
3487			 
3487				       NEXTW 
3487 c3 8b 1b			jp macro_next 
348a				endm 
# End of macro NEXTW
348a			 
348a			.mincont:  
348a c1				pop bc   ; tidy up 
348b eb				ex de , hl  
348c					if DEBUG_FORTH_WORDS 
348c						DMARK "MI1" 
348c f5				push af  
348d 3a a1 34			ld a, (.dmark)  
3490 32 77 fb			ld (debug_mark),a  
3493 3a a2 34			ld a, (.dmark+1)  
3496 32 78 fb			ld (debug_mark+1),a  
3499 3a a3 34			ld a, (.dmark+2)  
349c 32 79 fb			ld (debug_mark+2),a  
349f 18 03			jr .pastdmark  
34a1 ..			.dmark: db "MI1"  
34a4 f1			.pastdmark: pop af  
34a5			endm  
# End of macro DMARK
34a5						CALLMONITOR 
34a5 cd 00 14			call break_point_state  
34a8				endm  
# End of macro CALLMONITOR
34a8					endif 
34a8 cd 9a 19				call forth_push_numhl 
34ab			 
34ab				       NEXTW 
34ab c3 8b 1b			jp macro_next 
34ae				endm 
# End of macro NEXTW
34ae			.MAX: 
34ae				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
34ae 4a				db WORD_SYS_CORE+54             
34af 2f 35			dw .RND16            
34b1 04				db 3 + 1 
34b2 .. 00			db "MAX",0              
34b6				endm 
# End of macro CWHEAD
34b6			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
34b6					if DEBUG_FORTH_WORDS_KEY 
34b6						DMARK "MAX" 
34b6 f5				push af  
34b7 3a cb 34			ld a, (.dmark)  
34ba 32 77 fb			ld (debug_mark),a  
34bd 3a cc 34			ld a, (.dmark+1)  
34c0 32 78 fb			ld (debug_mark+1),a  
34c3 3a cd 34			ld a, (.dmark+2)  
34c6 32 79 fb			ld (debug_mark+2),a  
34c9 18 03			jr .pastdmark  
34cb ..			.dmark: db "MAX"  
34ce f1			.pastdmark: pop af  
34cf			endm  
# End of macro DMARK
34cf						CALLMONITOR 
34cf cd 00 14			call break_point_state  
34d2				endm  
# End of macro CALLMONITOR
34d2					endif 
34d2					; get u2 
34d2			 
34d2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d2 cd 35 1a			call macro_dsp_valuehl 
34d5				endm 
# End of macro FORTH_DSP_VALUEHL
34d5			 
34d5 e5					push hl   ; u2 
34d6			 
34d6					; destroy value TOS 
34d6			 
34d6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d6 cd d1 1a			call macro_forth_dsp_pop 
34d9				endm 
# End of macro FORTH_DSP_POP
34d9			 
34d9					; get u1 
34d9			 
34d9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d9 cd 35 1a			call macro_dsp_valuehl 
34dc				endm 
# End of macro FORTH_DSP_VALUEHL
34dc			 
34dc e5					push hl  ; u1 
34dd			 
34dd					; destroy value TOS 
34dd			 
34dd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34dd cd d1 1a			call macro_forth_dsp_pop 
34e0				endm 
# End of macro FORTH_DSP_POP
34e0			 
34e0 b7			 or a      ;clear carry flag 
34e1 e1			  pop hl    ; u1 
34e2 d1			  pop de    ; u2 
34e3 e5				push hl   ; saved in case hl is lowest 
34e4 ed 52		  sbc hl,de 
34e6 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
34e8			 
34e8 e1				pop hl 
34e9					if DEBUG_FORTH_WORDS 
34e9						DMARK "MAX" 
34e9 f5				push af  
34ea 3a fe 34			ld a, (.dmark)  
34ed 32 77 fb			ld (debug_mark),a  
34f0 3a ff 34			ld a, (.dmark+1)  
34f3 32 78 fb			ld (debug_mark+1),a  
34f6 3a 00 35			ld a, (.dmark+2)  
34f9 32 79 fb			ld (debug_mark+2),a  
34fc 18 03			jr .pastdmark  
34fe ..			.dmark: db "MAX"  
3501 f1			.pastdmark: pop af  
3502			endm  
# End of macro DMARK
3502						CALLMONITOR 
3502 cd 00 14			call break_point_state  
3505				endm  
# End of macro CALLMONITOR
3505					endif 
3505 cd 9a 19				call forth_push_numhl 
3508			 
3508				       NEXTW 
3508 c3 8b 1b			jp macro_next 
350b				endm 
# End of macro NEXTW
350b			 
350b			.maxcont:  
350b c1				pop bc   ; tidy up 
350c eb				ex de , hl  
350d					if DEBUG_FORTH_WORDS 
350d						DMARK "MA1" 
350d f5				push af  
350e 3a 22 35			ld a, (.dmark)  
3511 32 77 fb			ld (debug_mark),a  
3514 3a 23 35			ld a, (.dmark+1)  
3517 32 78 fb			ld (debug_mark+1),a  
351a 3a 24 35			ld a, (.dmark+2)  
351d 32 79 fb			ld (debug_mark+2),a  
3520 18 03			jr .pastdmark  
3522 ..			.dmark: db "MA1"  
3525 f1			.pastdmark: pop af  
3526			endm  
# End of macro DMARK
3526						CALLMONITOR 
3526 cd 00 14			call break_point_state  
3529				endm  
# End of macro CALLMONITOR
3529					endif 
3529 cd 9a 19				call forth_push_numhl 
352c				       NEXTW 
352c c3 8b 1b			jp macro_next 
352f				endm 
# End of macro NEXTW
352f			 
352f			.RND16: 
352f				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
352f 4e				db WORD_SYS_CORE+58             
3530 5e 35			dw .RND8            
3532 06				db 5 + 1 
3533 .. 00			db "RND16",0              
3539				endm 
# End of macro CWHEAD
3539			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
3539					if DEBUG_FORTH_WORDS_KEY 
3539						DMARK "R16" 
3539 f5				push af  
353a 3a 4e 35			ld a, (.dmark)  
353d 32 77 fb			ld (debug_mark),a  
3540 3a 4f 35			ld a, (.dmark+1)  
3543 32 78 fb			ld (debug_mark+1),a  
3546 3a 50 35			ld a, (.dmark+2)  
3549 32 79 fb			ld (debug_mark+2),a  
354c 18 03			jr .pastdmark  
354e ..			.dmark: db "R16"  
3551 f1			.pastdmark: pop af  
3552			endm  
# End of macro DMARK
3552						CALLMONITOR 
3552 cd 00 14			call break_point_state  
3555				endm  
# End of macro CALLMONITOR
3555					endif 
3555 cd 39 0b				call prng16  
3558 cd 9a 19				call forth_push_numhl 
355b				       NEXTW 
355b c3 8b 1b			jp macro_next 
355e				endm 
# End of macro NEXTW
355e			.RND8: 
355e				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
355e 60				db WORD_SYS_CORE+76             
355f 93 35			dw .RND            
3561 05				db 4 + 1 
3562 .. 00			db "RND8",0              
3567				endm 
# End of macro CWHEAD
3567			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
3567					if DEBUG_FORTH_WORDS_KEY 
3567						DMARK "RN8" 
3567 f5				push af  
3568 3a 7c 35			ld a, (.dmark)  
356b 32 77 fb			ld (debug_mark),a  
356e 3a 7d 35			ld a, (.dmark+1)  
3571 32 78 fb			ld (debug_mark+1),a  
3574 3a 7e 35			ld a, (.dmark+2)  
3577 32 79 fb			ld (debug_mark+2),a  
357a 18 03			jr .pastdmark  
357c ..			.dmark: db "RN8"  
357f f1			.pastdmark: pop af  
3580			endm  
# End of macro DMARK
3580						CALLMONITOR 
3580 cd 00 14			call break_point_state  
3583				endm  
# End of macro CALLMONITOR
3583					endif 
3583 2a b8 f8				ld hl,(xrandc) 
3586 23					inc hl 
3587 cd 53 0b				call xrnd 
358a 6f					ld l,a	 
358b 26 00				ld h,0 
358d cd 9a 19				call forth_push_numhl 
3590				       NEXTW 
3590 c3 8b 1b			jp macro_next 
3593				endm 
# End of macro NEXTW
3593			.RND: 
3593				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3593 60				db WORD_SYS_CORE+76             
3594 99 36			dw .ENDMATHS            
3596 04				db 3 + 1 
3597 .. 00			db "RND",0              
359b				endm 
# End of macro CWHEAD
359b			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
359b			 
359b					if DEBUG_FORTH_WORDS_KEY 
359b						DMARK "RND" 
359b f5				push af  
359c 3a b0 35			ld a, (.dmark)  
359f 32 77 fb			ld (debug_mark),a  
35a2 3a b1 35			ld a, (.dmark+1)  
35a5 32 78 fb			ld (debug_mark+1),a  
35a8 3a b2 35			ld a, (.dmark+2)  
35ab 32 79 fb			ld (debug_mark+2),a  
35ae 18 03			jr .pastdmark  
35b0 ..			.dmark: db "RND"  
35b3 f1			.pastdmark: pop af  
35b4			endm  
# End of macro DMARK
35b4						CALLMONITOR 
35b4 cd 00 14			call break_point_state  
35b7				endm  
# End of macro CALLMONITOR
35b7					endif 
35b7					 
35b7					FORTH_DSP_VALUEHL    ; upper range 
35b7 cd 35 1a			call macro_dsp_valuehl 
35ba				endm 
# End of macro FORTH_DSP_VALUEHL
35ba			 
35ba 22 bc f8				ld (LFSRSeed), hl	 
35bd			 
35bd					if DEBUG_FORTH_WORDS 
35bd						DMARK "RN1" 
35bd f5				push af  
35be 3a d2 35			ld a, (.dmark)  
35c1 32 77 fb			ld (debug_mark),a  
35c4 3a d3 35			ld a, (.dmark+1)  
35c7 32 78 fb			ld (debug_mark+1),a  
35ca 3a d4 35			ld a, (.dmark+2)  
35cd 32 79 fb			ld (debug_mark+2),a  
35d0 18 03			jr .pastdmark  
35d2 ..			.dmark: db "RN1"  
35d5 f1			.pastdmark: pop af  
35d6			endm  
# End of macro DMARK
35d6						CALLMONITOR 
35d6 cd 00 14			call break_point_state  
35d9				endm  
# End of macro CALLMONITOR
35d9					endif 
35d9					FORTH_DSP_POP 
35d9 cd d1 1a			call macro_forth_dsp_pop 
35dc				endm 
# End of macro FORTH_DSP_POP
35dc			 
35dc					FORTH_DSP_VALUEHL    ; low range 
35dc cd 35 1a			call macro_dsp_valuehl 
35df				endm 
# End of macro FORTH_DSP_VALUEHL
35df			 
35df					if DEBUG_FORTH_WORDS 
35df						DMARK "RN2" 
35df f5				push af  
35e0 3a f4 35			ld a, (.dmark)  
35e3 32 77 fb			ld (debug_mark),a  
35e6 3a f5 35			ld a, (.dmark+1)  
35e9 32 78 fb			ld (debug_mark+1),a  
35ec 3a f6 35			ld a, (.dmark+2)  
35ef 32 79 fb			ld (debug_mark+2),a  
35f2 18 03			jr .pastdmark  
35f4 ..			.dmark: db "RN2"  
35f7 f1			.pastdmark: pop af  
35f8			endm  
# End of macro DMARK
35f8						CALLMONITOR 
35f8 cd 00 14			call break_point_state  
35fb				endm  
# End of macro CALLMONITOR
35fb					endif 
35fb 22 be f8				ld (LFSRSeed+2), hl 
35fe			 
35fe					FORTH_DSP_POP 
35fe cd d1 1a			call macro_forth_dsp_pop 
3601				endm 
# End of macro FORTH_DSP_POP
3601			 
3601 e5					push hl 
3602			 
3602 e1			.inrange:	pop hl 
3603 cd 39 0b				call prng16  
3606					if DEBUG_FORTH_WORDS 
3606						DMARK "RN3" 
3606 f5				push af  
3607 3a 1b 36			ld a, (.dmark)  
360a 32 77 fb			ld (debug_mark),a  
360d 3a 1c 36			ld a, (.dmark+1)  
3610 32 78 fb			ld (debug_mark+1),a  
3613 3a 1d 36			ld a, (.dmark+2)  
3616 32 79 fb			ld (debug_mark+2),a  
3619 18 03			jr .pastdmark  
361b ..			.dmark: db "RN3"  
361e f1			.pastdmark: pop af  
361f			endm  
# End of macro DMARK
361f						CALLMONITOR 
361f cd 00 14			call break_point_state  
3622				endm  
# End of macro CALLMONITOR
3622					endif 
3622					 
3622					; if the range is 8bit knock out the high byte 
3622			 
3622 ed 5b bc f8			ld de, (LFSRSeed)     ; check high level 
3626			 
3626 3e 00				ld a, 0 
3628 ba					cp d  
3629 20 1e				jr nz, .hirange 
362b 26 00				ld h, 0   ; knock it down to 8bit 
362d			 
362d					if DEBUG_FORTH_WORDS 
362d						DMARK "RNk" 
362d f5				push af  
362e 3a 42 36			ld a, (.dmark)  
3631 32 77 fb			ld (debug_mark),a  
3634 3a 43 36			ld a, (.dmark+1)  
3637 32 78 fb			ld (debug_mark+1),a  
363a 3a 44 36			ld a, (.dmark+2)  
363d 32 79 fb			ld (debug_mark+2),a  
3640 18 03			jr .pastdmark  
3642 ..			.dmark: db "RNk"  
3645 f1			.pastdmark: pop af  
3646			endm  
# End of macro DMARK
3646						CALLMONITOR 
3646 cd 00 14			call break_point_state  
3649				endm  
# End of macro CALLMONITOR
3649					endif 
3649			.hirange:   
3649 e5					push hl  
364a b7					or a  
364b ed 52		                sbc hl, de 
364d			 
364d					;call cmp16 
364d			 
364d 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
364f e1					pop hl 
3650 e5					push hl 
3651			 
3651					if DEBUG_FORTH_WORDS 
3651						DMARK "RN4" 
3651 f5				push af  
3652 3a 66 36			ld a, (.dmark)  
3655 32 77 fb			ld (debug_mark),a  
3658 3a 67 36			ld a, (.dmark+1)  
365b 32 78 fb			ld (debug_mark+1),a  
365e 3a 68 36			ld a, (.dmark+2)  
3661 32 79 fb			ld (debug_mark+2),a  
3664 18 03			jr .pastdmark  
3666 ..			.dmark: db "RN4"  
3669 f1			.pastdmark: pop af  
366a			endm  
# End of macro DMARK
366a						CALLMONITOR 
366a cd 00 14			call break_point_state  
366d				endm  
# End of macro CALLMONITOR
366d					endif 
366d ed 5b be f8			ld de, (LFSRSeed+2)   ; check low range 
3671					;call cmp16 
3671				 
3671 b7					or a  
3672 ed 52		                sbc hl, de 
3674 38 8c				jr c, .inrange 
3676			 
3676 e1					pop hl 
3677					 
3677					if DEBUG_FORTH_WORDS 
3677						DMARK "RNd" 
3677 f5				push af  
3678 3a 8c 36			ld a, (.dmark)  
367b 32 77 fb			ld (debug_mark),a  
367e 3a 8d 36			ld a, (.dmark+1)  
3681 32 78 fb			ld (debug_mark+1),a  
3684 3a 8e 36			ld a, (.dmark+2)  
3687 32 79 fb			ld (debug_mark+2),a  
368a 18 03			jr .pastdmark  
368c ..			.dmark: db "RNd"  
368f f1			.pastdmark: pop af  
3690			endm  
# End of macro DMARK
3690						CALLMONITOR 
3690 cd 00 14			call break_point_state  
3693				endm  
# End of macro CALLMONITOR
3693					endif 
3693			 
3693			 
3693 cd 9a 19				call forth_push_numhl 
3696				       NEXTW 
3696 c3 8b 1b			jp macro_next 
3699				endm 
# End of macro NEXTW
3699			 
3699			.ENDMATHS: 
3699			 
3699			; eof 
3699			 
# End of file forth_words_maths.asm
3699			include "forth_words_display.asm" 
3699			 
3699			; | ## Display Words 
3699			 
3699			.ATP: 
3699				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3699 62				db WORD_SYS_CORE+78             
369a 10 37			dw .FB            
369c 04				db 3 + 1 
369d .. 00			db "AT?",0              
36a1				endm 
# End of macro CWHEAD
36a1			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
36a1					if DEBUG_FORTH_WORDS_KEY 
36a1						DMARK "AT?" 
36a1 f5				push af  
36a2 3a b6 36			ld a, (.dmark)  
36a5 32 77 fb			ld (debug_mark),a  
36a8 3a b7 36			ld a, (.dmark+1)  
36ab 32 78 fb			ld (debug_mark+1),a  
36ae 3a b8 36			ld a, (.dmark+2)  
36b1 32 79 fb			ld (debug_mark+2),a  
36b4 18 03			jr .pastdmark  
36b6 ..			.dmark: db "AT?"  
36b9 f1			.pastdmark: pop af  
36ba			endm  
# End of macro DMARK
36ba						CALLMONITOR 
36ba cd 00 14			call break_point_state  
36bd				endm  
# End of macro CALLMONITOR
36bd					endif 
36bd 3a 5b f8				ld a, (f_cursor_ptr) 
36c0			 
36c0			if DEBUG_FORTH_WORDS 
36c0				DMARK "AT?" 
36c0 f5				push af  
36c1 3a d5 36			ld a, (.dmark)  
36c4 32 77 fb			ld (debug_mark),a  
36c7 3a d6 36			ld a, (.dmark+1)  
36ca 32 78 fb			ld (debug_mark+1),a  
36cd 3a d7 36			ld a, (.dmark+2)  
36d0 32 79 fb			ld (debug_mark+2),a  
36d3 18 03			jr .pastdmark  
36d5 ..			.dmark: db "AT?"  
36d8 f1			.pastdmark: pop af  
36d9			endm  
# End of macro DMARK
36d9				CALLMONITOR 
36d9 cd 00 14			call break_point_state  
36dc				endm  
# End of macro CALLMONITOR
36dc			endif	 
36dc					; count the number of rows 
36dc			 
36dc 06 00				ld b, 0 
36de 4f			.atpr:		ld c, a    ; save in case we go below zero 
36df d6 28				sub display_cols 
36e1 f2 e7 36				jp p, .atprunder 
36e4 04					inc b 
36e5 18 f7				jr .atpr 
36e7			.atprunder:	 
36e7			if DEBUG_FORTH_WORDS 
36e7				DMARK "A?2" 
36e7 f5				push af  
36e8 3a fc 36			ld a, (.dmark)  
36eb 32 77 fb			ld (debug_mark),a  
36ee 3a fd 36			ld a, (.dmark+1)  
36f1 32 78 fb			ld (debug_mark+1),a  
36f4 3a fe 36			ld a, (.dmark+2)  
36f7 32 79 fb			ld (debug_mark+2),a  
36fa 18 03			jr .pastdmark  
36fc ..			.dmark: db "A?2"  
36ff f1			.pastdmark: pop af  
3700			endm  
# End of macro DMARK
3700				CALLMONITOR 
3700 cd 00 14			call break_point_state  
3703				endm  
# End of macro CALLMONITOR
3703			endif	 
3703 26 00				ld h, 0 
3705 69					ld l, c 
3706 cd 9a 19				call forth_push_numhl 
3709 68					ld l, b  
370a cd 9a 19				call forth_push_numhl 
370d			 
370d			 
370d				NEXTW 
370d c3 8b 1b			jp macro_next 
3710				endm 
# End of macro NEXTW
3710			 
3710			.FB: 
3710				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
3710 1b				db WORD_SYS_CORE+7             
3711 5e 37			dw .EMIT            
3713 03				db 2 + 1 
3714 .. 00			db "FB",0              
3717				endm 
# End of macro CWHEAD
3717			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
3717			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
3717			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
3717			; | | If automatic display is off then updates will not be shown until DRAW is used. 
3717					if DEBUG_FORTH_WORDS_KEY 
3717						DMARK "FB." 
3717 f5				push af  
3718 3a 2c 37			ld a, (.dmark)  
371b 32 77 fb			ld (debug_mark),a  
371e 3a 2d 37			ld a, (.dmark+1)  
3721 32 78 fb			ld (debug_mark+1),a  
3724 3a 2e 37			ld a, (.dmark+2)  
3727 32 79 fb			ld (debug_mark+2),a  
372a 18 03			jr .pastdmark  
372c ..			.dmark: db "FB."  
372f f1			.pastdmark: pop af  
3730			endm  
# End of macro DMARK
3730						CALLMONITOR 
3730 cd 00 14			call break_point_state  
3733				endm  
# End of macro CALLMONITOR
3733					endif 
3733			 
3733					FORTH_DSP_VALUEHL 
3733 cd 35 1a			call macro_dsp_valuehl 
3736				endm 
# End of macro FORTH_DSP_VALUEHL
3736			 
3736 7d					ld a, l 
3737 fe 01				cp 1 
3739 20 05				jr nz, .fbn1 
373b 21 1c fa				ld hl, display_fb1 
373e 18 15				jr .fbset 
3740 fe 02		.fbn1:		cp 2 
3742 20 05				jr nz, .fbn2 
3744 21 da f8				ld hl, display_fb2 
3747 18 0c				jr .fbset 
3749 fe 03		.fbn2:		cp 3 
374b 20 05				jr nz, .fbn3 
374d 21 7b f9				ld hl, display_fb3 
3750 18 03				jr .fbset 
3752			.fbn3:		 ; if invalid number select first 
3752 21 1c fa				ld hl, display_fb1 
3755 22 d8 f8		.fbset:		ld (display_fb_active), hl 
3758			 
3758					FORTH_DSP_POP 
3758 cd d1 1a			call macro_forth_dsp_pop 
375b				endm 
# End of macro FORTH_DSP_POP
375b			 
375b					NEXTW 
375b c3 8b 1b			jp macro_next 
375e				endm 
# End of macro NEXTW
375e			 
375e			 
375e			.EMIT: 
375e				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
375e 1b				db WORD_SYS_CORE+7             
375f af 37			dw .DOTH            
3761 05				db 4 + 1 
3762 .. 00			db "EMIT",0              
3767				endm 
# End of macro CWHEAD
3767			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3767					; get value off TOS and display it 
3767			 
3767					if DEBUG_FORTH_WORDS_KEY 
3767						DMARK "EMT" 
3767 f5				push af  
3768 3a 7c 37			ld a, (.dmark)  
376b 32 77 fb			ld (debug_mark),a  
376e 3a 7d 37			ld a, (.dmark+1)  
3771 32 78 fb			ld (debug_mark+1),a  
3774 3a 7e 37			ld a, (.dmark+2)  
3777 32 79 fb			ld (debug_mark+2),a  
377a 18 03			jr .pastdmark  
377c ..			.dmark: db "EMT"  
377f f1			.pastdmark: pop af  
3780			endm  
# End of macro DMARK
3780						CALLMONITOR 
3780 cd 00 14			call break_point_state  
3783				endm  
# End of macro CALLMONITOR
3783					endif 
3783			 
3783					FORTH_DSP_VALUEHL 
3783 cd 35 1a			call macro_dsp_valuehl 
3786				endm 
# End of macro FORTH_DSP_VALUEHL
3786			 
3786 7d					ld a,l 
3787			 
3787					; TODO write to display 
3787			 
3787 32 30 f0				ld (os_input), a 
378a 3e 00				ld a, 0 
378c 32 31 f0				ld (os_input+1), a 
378f					 
378f 3a 5b f8				ld a, (f_cursor_ptr) 
3792 11 30 f0				ld de, os_input 
3795 cd cc 0a				call str_at_display 
3798			 
3798			 
3798 3a 39 f8				ld a,(cli_autodisplay) 
379b fe 00				cp 0 
379d 28 03				jr z, .enoupdate 
379f cd dc 0a						call update_display 
37a2					.enoupdate: 
37a2			 
37a2 3a 5b f8				ld a, (f_cursor_ptr) 
37a5 3c					inc a 
37a6 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
37a9			 
37a9			 
37a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
37a9 cd d1 1a			call macro_forth_dsp_pop 
37ac				endm 
# End of macro FORTH_DSP_POP
37ac			  
37ac			 
37ac					NEXTW 
37ac c3 8b 1b			jp macro_next 
37af				endm 
# End of macro NEXTW
37af			.DOTH: 
37af				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
37af 1c				db WORD_SYS_CORE+8             
37b0 df 37			dw .DOTF            
37b2 03				db 2 + 1 
37b3 .. 00			db ".-",0              
37b6				endm 
# End of macro CWHEAD
37b6			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
37b6					; get value off TOS and display it 
37b6					if DEBUG_FORTH_WORDS_KEY 
37b6						DMARK "DTD" 
37b6 f5				push af  
37b7 3a cb 37			ld a, (.dmark)  
37ba 32 77 fb			ld (debug_mark),a  
37bd 3a cc 37			ld a, (.dmark+1)  
37c0 32 78 fb			ld (debug_mark+1),a  
37c3 3a cd 37			ld a, (.dmark+2)  
37c6 32 79 fb			ld (debug_mark+2),a  
37c9 18 03			jr .pastdmark  
37cb ..			.dmark: db "DTD"  
37ce f1			.pastdmark: pop af  
37cf			endm  
# End of macro DMARK
37cf						CALLMONITOR 
37cf cd 00 14			call break_point_state  
37d2				endm  
# End of macro CALLMONITOR
37d2					endif 
37d2 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
37d4 3e 00			ld a, 0 
37d6 32 3a f8			ld (cli_mvdot), a 
37d9 c3 36 38			jp .dotgo 
37dc				NEXTW 
37dc c3 8b 1b			jp macro_next 
37df				endm 
# End of macro NEXTW
37df			.DOTF: 
37df				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
37df 1c				db WORD_SYS_CORE+8             
37e0 0d 38			dw .DOT            
37e2 03				db 2 + 1 
37e3 .. 00			db ".>",0              
37e6				endm 
# End of macro CWHEAD
37e6			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
37e6					; get value off TOS and display it 
37e6			        ; TODO BUG adds extra spaces 
37e6			        ; TODO BUG handle numerics? 
37e6					if DEBUG_FORTH_WORDS_KEY 
37e6						DMARK "DTC" 
37e6 f5				push af  
37e7 3a fb 37			ld a, (.dmark)  
37ea 32 77 fb			ld (debug_mark),a  
37ed 3a fc 37			ld a, (.dmark+1)  
37f0 32 78 fb			ld (debug_mark+1),a  
37f3 3a fd 37			ld a, (.dmark+2)  
37f6 32 79 fb			ld (debug_mark+2),a  
37f9 18 03			jr .pastdmark  
37fb ..			.dmark: db "DTC"  
37fe f1			.pastdmark: pop af  
37ff			endm  
# End of macro DMARK
37ff						CALLMONITOR 
37ff cd 00 14			call break_point_state  
3802				endm  
# End of macro CALLMONITOR
3802					endif 
3802 3e 01			ld a, 1 
3804 32 3a f8			ld (cli_mvdot), a 
3807 c3 36 38			jp .dotgo 
380a				NEXTW 
380a c3 8b 1b			jp macro_next 
380d				endm 
# End of macro NEXTW
380d			 
380d			.DOT: 
380d				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
380d 1c				db WORD_SYS_CORE+8             
380e 99 38			dw .CLS            
3810 02				db 1 + 1 
3811 .. 00			db ".",0              
3813				endm 
# End of macro CWHEAD
3813			        ; | . ( u -- ) Display TOS | DONE 
3813					; get value off TOS and display it 
3813			 
3813					if DEBUG_FORTH_WORDS_KEY 
3813						DMARK "DOT" 
3813 f5				push af  
3814 3a 28 38			ld a, (.dmark)  
3817 32 77 fb			ld (debug_mark),a  
381a 3a 29 38			ld a, (.dmark+1)  
381d 32 78 fb			ld (debug_mark+1),a  
3820 3a 2a 38			ld a, (.dmark+2)  
3823 32 79 fb			ld (debug_mark+2),a  
3826 18 03			jr .pastdmark  
3828 ..			.dmark: db "DOT"  
382b f1			.pastdmark: pop af  
382c			endm  
# End of macro DMARK
382c						CALLMONITOR 
382c cd 00 14			call break_point_state  
382f				endm  
# End of macro CALLMONITOR
382f					endif 
382f 3e 00			ld a, 0 
3831 32 3a f8			ld (cli_mvdot), a 
3834 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
3836				 
3836			 
3836			.dotgo: 
3836			 
3836			; move up type to on stack for parserv5 
3836					FORTH_DSP 
3836 cd 1a 1a			call macro_forth_dsp 
3839				endm 
# End of macro FORTH_DSP
3839				;FORTH_DSP_VALUE  
3839			 
3839			if DEBUG_FORTH_DOT 
3839				DMARK "DOT" 
3839				CALLMONITOR 
3839			endif	 
3839			;		.print: 
3839			 
3839 7e				ld a,(hl)  ; work out what type of value is on the TOS 
383a 23				inc hl   ; position to the actual value 
383b fe 01			cp DS_TYPE_STR 
383d 20 06			jr nz, .dotnum1  
383f			 
383f			; display string 
383f				FORTH_DSP_VALUE  
383f cd 1e 1a			call macro_forth_dsp_value 
3842				endm 
# End of macro FORTH_DSP_VALUE
3842 eb				ex de,hl 
3843 18 11			jr .dotwrite 
3845			 
3845			.dotnum1: 
3845 fe 02			cp DS_TYPE_INUM 
3847 20 0c			jr nz, .dotflot 
3849			 
3849			 
3849			; display number 
3849			 
3849			;	push hl 
3849			;	call clear_display 
3849			;	pop hl 
3849			 
3849 5e				ld e, (hl) 
384a 23				inc hl 
384b 56				ld d, (hl) 
384c 21 32 ee			ld hl, scratch 
384f			if DEBUG_FORTH_DOT 
384f				DMARK "DT1" 
384f				CALLMONITOR 
384f			endif	 
384f			 
384f cd 1f 10			call uitoa_16 
3852 eb				ex de,hl 
3853			 
3853			if DEBUG_FORTH_DOT 
3853				DMARK "DT2" 
3853				CALLMONITOR 
3853			endif	 
3853			 
3853			;	ld de, os_word_scratch 
3853 18 01			jr .dotwrite 
3855			 
3855 00			.dotflot:   nop 
3856			; TODO print floating point number 
3856			 
3856			.dotwrite:		 
3856			 
3856					; if c is set then set all '-' to spaces 
3856					; need to also take into account .>  
3856			 
3856 3e 01				ld a, 1 
3858 b9					cp c 
3859 20 13				jr nz, .nodashswap 
385b			 
385b					; DE has the string to write, working with HL 
385b			 
385b 06 ff				ld b, 255 
385d d5					push de 
385e e1					pop hl 
385f			 
385f			if DEBUG_FORTH_DOT 
385f				DMARK "DT-" 
385f				CALLMONITOR 
385f			endif	 
385f 7e			.dashscan:	ld a, (hl) 
3860 fe 00				cp 0 
3862 28 0a				jr z, .nodashswap 
3864 fe 2d				cp '-' 
3866 20 03				jr nz, .dashskip 
3868 3e 20				ld a, ' ' 
386a 77					ld (hl), a 
386b 23			.dashskip:	inc hl 
386c			if DEBUG_FORTH_DOT 
386c				DMARK "D-2" 
386c				CALLMONITOR 
386c			endif	 
386c 10 f1				djnz .dashscan 
386e			 
386e			if DEBUG_FORTH_DOT 
386e				DMARK "D-1" 
386e				CALLMONITOR 
386e			endif	 
386e			 
386e			.nodashswap: 
386e			 
386e e5					push hl   ; save string start in case we need to advance print 
386f			 
386f 3a 5b f8				ld a, (f_cursor_ptr) 
3872 cd cc 0a				call str_at_display 
3875 3a 39 f8				ld a,(cli_autodisplay) 
3878 fe 00				cp 0 
387a 28 03				jr z, .noupdate 
387c cd dc 0a						call update_display 
387f					.noupdate: 
387f			 
387f			 
387f					; see if we need to advance the print position 
387f			 
387f e1					pop hl   ; get back string 
3880			 
3880 3a 3a f8				ld a, (cli_mvdot) 
3883			if DEBUG_FORTH_DOT 
3883					ld e,a 
3883				DMARK "D>1" 
3883				CALLMONITOR 
3883			endif	 
3883 fe 00				cp 0 
3885 28 0c				jr z, .noadv 
3887					; yes, lets advance the print position 
3887 3e 00				ld a, 0 
3889 cd 7b 10				call strlent 
388c 3a 5b f8				ld a, (f_cursor_ptr) 
388f 85					add a,l 
3890					;call addatohl 
3890					;ld a, l 
3890 32 5b f8				ld (f_cursor_ptr), a   ; save new pos 
3893			 
3893			if DEBUG_FORTH_DOT 
3893				DMARK "D->" 
3893				CALLMONITOR 
3893			endif	 
3893			 
3893			.noadv:	 
3893			 
3893					if DEBUG_FORTH_DOT_WAIT 
3893							call next_page_prompt 
3893					endif	 
3893			; TODO this pop off the stack causes a crash. i dont know why 
3893			 
3893			 
3893			if DEBUG_FORTH_DOT 
3893				DMARK "DTh" 
3893				CALLMONITOR 
3893			endif	 
3893			 
3893					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3893 cd d1 1a			call macro_forth_dsp_pop 
3896				endm 
# End of macro FORTH_DSP_POP
3896			 
3896			if DEBUG_FORTH_DOT 
3896				DMARK "DTi" 
3896				CALLMONITOR 
3896			endif	 
3896			 
3896			 
3896					NEXTW 
3896 c3 8b 1b			jp macro_next 
3899				endm 
# End of macro NEXTW
3899			 
3899			.CLS: 
3899				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3899 35				db WORD_SYS_CORE+33             
389a c6 38			dw .DRAW            
389c 04				db 3 + 1 
389d .. 00			db "CLS",0              
38a1				endm 
# End of macro CWHEAD
38a1			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
38a1					if DEBUG_FORTH_WORDS_KEY 
38a1						DMARK "CLS" 
38a1 f5				push af  
38a2 3a b6 38			ld a, (.dmark)  
38a5 32 77 fb			ld (debug_mark),a  
38a8 3a b7 38			ld a, (.dmark+1)  
38ab 32 78 fb			ld (debug_mark+1),a  
38ae 3a b8 38			ld a, (.dmark+2)  
38b1 32 79 fb			ld (debug_mark+2),a  
38b4 18 03			jr .pastdmark  
38b6 ..			.dmark: db "CLS"  
38b9 f1			.pastdmark: pop af  
38ba			endm  
# End of macro DMARK
38ba						CALLMONITOR 
38ba cd 00 14			call break_point_state  
38bd				endm  
# End of macro CALLMONITOR
38bd					endif 
38bd cd b9 0a				call clear_display 
38c0 c3 d4 39				jp .home		; and home cursor 
38c3					NEXTW 
38c3 c3 8b 1b			jp macro_next 
38c6				endm 
# End of macro NEXTW
38c6			 
38c6			.DRAW: 
38c6				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
38c6 36				db WORD_SYS_CORE+34             
38c7 f1 38			dw .DUMP            
38c9 05				db 4 + 1 
38ca .. 00			db "DRAW",0              
38cf				endm 
# End of macro CWHEAD
38cf			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
38cf					if DEBUG_FORTH_WORDS_KEY 
38cf						DMARK "DRW" 
38cf f5				push af  
38d0 3a e4 38			ld a, (.dmark)  
38d3 32 77 fb			ld (debug_mark),a  
38d6 3a e5 38			ld a, (.dmark+1)  
38d9 32 78 fb			ld (debug_mark+1),a  
38dc 3a e6 38			ld a, (.dmark+2)  
38df 32 79 fb			ld (debug_mark+2),a  
38e2 18 03			jr .pastdmark  
38e4 ..			.dmark: db "DRW"  
38e7 f1			.pastdmark: pop af  
38e8			endm  
# End of macro DMARK
38e8						CALLMONITOR 
38e8 cd 00 14			call break_point_state  
38eb				endm  
# End of macro CALLMONITOR
38eb					endif 
38eb cd dc 0a				call update_display 
38ee					NEXTW 
38ee c3 8b 1b			jp macro_next 
38f1				endm 
# End of macro NEXTW
38f1			 
38f1			.DUMP: 
38f1				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
38f1 37				db WORD_SYS_CORE+35             
38f2 29 39			dw .CDUMP            
38f4 05				db 4 + 1 
38f5 .. 00			db "DUMP",0              
38fa				endm 
# End of macro CWHEAD
38fa			; | DUMP ( x -- ) With address x display dump   | DONE 
38fa			; TODO pop address to use off of the stack 
38fa					if DEBUG_FORTH_WORDS_KEY 
38fa						DMARK "DUM" 
38fa f5				push af  
38fb 3a 0f 39			ld a, (.dmark)  
38fe 32 77 fb			ld (debug_mark),a  
3901 3a 10 39			ld a, (.dmark+1)  
3904 32 78 fb			ld (debug_mark+1),a  
3907 3a 11 39			ld a, (.dmark+2)  
390a 32 79 fb			ld (debug_mark+2),a  
390d 18 03			jr .pastdmark  
390f ..			.dmark: db "DUM"  
3912 f1			.pastdmark: pop af  
3913			endm  
# End of macro DMARK
3913						CALLMONITOR 
3913 cd 00 14			call break_point_state  
3916				endm  
# End of macro CALLMONITOR
3916					endif 
3916 cd b9 0a				call clear_display 
3919			 
3919					; get address 
3919			 
3919					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3919 cd 35 1a			call macro_dsp_valuehl 
391c				endm 
# End of macro FORTH_DSP_VALUEHL
391c				 
391c					; save it for cdump 
391c			 
391c 22 55 f1				ld (os_cur_ptr),hl 
391f			 
391f					; destroy value TOS 
391f			 
391f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
391f cd d1 1a			call macro_forth_dsp_pop 
3922				endm 
# End of macro FORTH_DSP_POP
3922			 
3922 cd 1a 18				call dumpcont	; skip old style of param parsing	 
3925 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3926					NEXTW 
3926 c3 8b 1b			jp macro_next 
3929				endm 
# End of macro NEXTW
3929			.CDUMP: 
3929				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3929 38				db WORD_SYS_CORE+36             
392a 59 39			dw .DAT            
392c 06				db 5 + 1 
392d .. 00			db "CDUMP",0              
3933				endm 
# End of macro CWHEAD
3933			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3933					if DEBUG_FORTH_WORDS_KEY 
3933						DMARK "CDP" 
3933 f5				push af  
3934 3a 48 39			ld a, (.dmark)  
3937 32 77 fb			ld (debug_mark),a  
393a 3a 49 39			ld a, (.dmark+1)  
393d 32 78 fb			ld (debug_mark+1),a  
3940 3a 4a 39			ld a, (.dmark+2)  
3943 32 79 fb			ld (debug_mark+2),a  
3946 18 03			jr .pastdmark  
3948 ..			.dmark: db "CDP"  
394b f1			.pastdmark: pop af  
394c			endm  
# End of macro DMARK
394c						CALLMONITOR 
394c cd 00 14			call break_point_state  
394f				endm  
# End of macro CALLMONITOR
394f					endif 
394f cd b9 0a				call clear_display 
3952 cd 1a 18				call dumpcont	 
3955 c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3956					NEXTW 
3956 c3 8b 1b			jp macro_next 
3959				endm 
# End of macro NEXTW
3959			 
3959			 
3959			 
3959			 
3959			.DAT: 
3959				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3959 3d				db WORD_SYS_CORE+41             
395a af 39			dw .HOME            
395c 03				db 2 + 1 
395d .. 00			db "AT",0              
3960				endm 
# End of macro CWHEAD
3960			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3960					if DEBUG_FORTH_WORDS_KEY 
3960						DMARK "AT." 
3960 f5				push af  
3961 3a 75 39			ld a, (.dmark)  
3964 32 77 fb			ld (debug_mark),a  
3967 3a 76 39			ld a, (.dmark+1)  
396a 32 78 fb			ld (debug_mark+1),a  
396d 3a 77 39			ld a, (.dmark+2)  
3970 32 79 fb			ld (debug_mark+2),a  
3973 18 03			jr .pastdmark  
3975 ..			.dmark: db "AT."  
3978 f1			.pastdmark: pop af  
3979			endm  
# End of macro DMARK
3979						CALLMONITOR 
3979 cd 00 14			call break_point_state  
397c				endm  
# End of macro CALLMONITOR
397c					endif 
397c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
397c cd 35 1a			call macro_dsp_valuehl 
397f				endm 
# End of macro FORTH_DSP_VALUEHL
397f			 
397f			 
397f					; TODO save cursor row 
397f 7d					ld a,l 
3980 fe 02				cp 2 
3982 20 04				jr nz, .crow3 
3984 3e 28				ld a, display_row_2 
3986 18 12				jr .ccol1 
3988 fe 03		.crow3:		cp 3 
398a 20 04				jr nz, .crow4 
398c 3e 50				ld a, display_row_3 
398e 18 0a				jr .ccol1 
3990 fe 04		.crow4:		cp 4 
3992 20 04				jr nz, .crow1 
3994 3e 78				ld a, display_row_4 
3996 18 02				jr .ccol1 
3998 3e 00		.crow1:		ld a,display_row_1 
399a f5			.ccol1:		push af			; got row offset 
399b 6f					ld l,a 
399c 26 00				ld h,0 
399e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
399e cd d1 1a			call macro_forth_dsp_pop 
39a1				endm 
# End of macro FORTH_DSP_POP
39a1					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
39a1 cd 35 1a			call macro_dsp_valuehl 
39a4				endm 
# End of macro FORTH_DSP_VALUEHL
39a4					; TODO save cursor col 
39a4 f1					pop af 
39a5 85					add l		; add col offset 
39a6 32 5b f8				ld (f_cursor_ptr), a 
39a9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
39a9 cd d1 1a			call macro_forth_dsp_pop 
39ac				endm 
# End of macro FORTH_DSP_POP
39ac			 
39ac					; calculate  
39ac			 
39ac					NEXTW 
39ac c3 8b 1b			jp macro_next 
39af				endm 
# End of macro NEXTW
39af			 
39af			 
39af			.HOME: 
39af				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
39af 41				db WORD_SYS_CORE+45             
39b0 dc 39			dw .SPACE            
39b2 05				db 4 + 1 
39b3 .. 00			db "HOME",0              
39b8				endm 
# End of macro CWHEAD
39b8			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
39b8					if DEBUG_FORTH_WORDS_KEY 
39b8						DMARK "HOM" 
39b8 f5				push af  
39b9 3a cd 39			ld a, (.dmark)  
39bc 32 77 fb			ld (debug_mark),a  
39bf 3a ce 39			ld a, (.dmark+1)  
39c2 32 78 fb			ld (debug_mark+1),a  
39c5 3a cf 39			ld a, (.dmark+2)  
39c8 32 79 fb			ld (debug_mark+2),a  
39cb 18 03			jr .pastdmark  
39cd ..			.dmark: db "HOM"  
39d0 f1			.pastdmark: pop af  
39d1			endm  
# End of macro DMARK
39d1						CALLMONITOR 
39d1 cd 00 14			call break_point_state  
39d4				endm  
# End of macro CALLMONITOR
39d4					endif 
39d4 3e 00		.home:		ld a, 0		; and home cursor 
39d6 32 5b f8				ld (f_cursor_ptr), a 
39d9					NEXTW 
39d9 c3 8b 1b			jp macro_next 
39dc				endm 
# End of macro NEXTW
39dc			 
39dc			 
39dc			.SPACE: 
39dc				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
39dc 46				db WORD_SYS_CORE+50             
39dd 0a 3a			dw .SPACES            
39df 03				db 2 + 1 
39e0 .. 00			db "BL",0              
39e3				endm 
# End of macro CWHEAD
39e3			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
39e3					if DEBUG_FORTH_WORDS_KEY 
39e3						DMARK "BL." 
39e3 f5				push af  
39e4 3a f8 39			ld a, (.dmark)  
39e7 32 77 fb			ld (debug_mark),a  
39ea 3a f9 39			ld a, (.dmark+1)  
39ed 32 78 fb			ld (debug_mark+1),a  
39f0 3a fa 39			ld a, (.dmark+2)  
39f3 32 79 fb			ld (debug_mark+2),a  
39f6 18 03			jr .pastdmark  
39f8 ..			.dmark: db "BL."  
39fb f1			.pastdmark: pop af  
39fc			endm  
# End of macro DMARK
39fc						CALLMONITOR 
39fc cd 00 14			call break_point_state  
39ff				endm  
# End of macro CALLMONITOR
39ff					endif 
39ff 21 08 3a				ld hl, .blstr 
3a02 cd ac 19				call forth_push_str 
3a05					 
3a05				       NEXTW 
3a05 c3 8b 1b			jp macro_next 
3a08				endm 
# End of macro NEXTW
3a08			 
3a08 .. 00		.blstr: db " ", 0 
3a0a			 
3a0a			.SPACES: 
3a0a				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3a0a 47				db WORD_SYS_CORE+51             
3a0b a5 3a			dw .SCROLL            
3a0d 07				db 6 + 1 
3a0e .. 00			db "SPACES",0              
3a15				endm 
# End of macro CWHEAD
3a15			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3a15					if DEBUG_FORTH_WORDS_KEY 
3a15						DMARK "SPS" 
3a15 f5				push af  
3a16 3a 2a 3a			ld a, (.dmark)  
3a19 32 77 fb			ld (debug_mark),a  
3a1c 3a 2b 3a			ld a, (.dmark+1)  
3a1f 32 78 fb			ld (debug_mark+1),a  
3a22 3a 2c 3a			ld a, (.dmark+2)  
3a25 32 79 fb			ld (debug_mark+2),a  
3a28 18 03			jr .pastdmark  
3a2a ..			.dmark: db "SPS"  
3a2d f1			.pastdmark: pop af  
3a2e			endm  
# End of macro DMARK
3a2e						CALLMONITOR 
3a2e cd 00 14			call break_point_state  
3a31				endm  
# End of macro CALLMONITOR
3a31					endif 
3a31			 
3a31			 
3a31					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3a31 cd 35 1a			call macro_dsp_valuehl 
3a34				endm 
# End of macro FORTH_DSP_VALUEHL
3a34			 
3a34			;		push hl    ; u 
3a34					if DEBUG_FORTH_WORDS 
3a34						DMARK "SPA" 
3a34 f5				push af  
3a35 3a 49 3a			ld a, (.dmark)  
3a38 32 77 fb			ld (debug_mark),a  
3a3b 3a 4a 3a			ld a, (.dmark+1)  
3a3e 32 78 fb			ld (debug_mark+1),a  
3a41 3a 4b 3a			ld a, (.dmark+2)  
3a44 32 79 fb			ld (debug_mark+2),a  
3a47 18 03			jr .pastdmark  
3a49 ..			.dmark: db "SPA"  
3a4c f1			.pastdmark: pop af  
3a4d			endm  
# End of macro DMARK
3a4d						CALLMONITOR 
3a4d cd 00 14			call break_point_state  
3a50				endm  
# End of macro CALLMONITOR
3a50					endif 
3a50			 
3a50					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a50 cd d1 1a			call macro_forth_dsp_pop 
3a53				endm 
# End of macro FORTH_DSP_POP
3a53			;		pop hl 
3a53 4d					ld c, l 
3a54 06 00				ld b, 0 
3a56 21 32 ee				ld hl, scratch  
3a59			 
3a59					if DEBUG_FORTH_WORDS 
3a59						DMARK "SP2" 
3a59 f5				push af  
3a5a 3a 6e 3a			ld a, (.dmark)  
3a5d 32 77 fb			ld (debug_mark),a  
3a60 3a 6f 3a			ld a, (.dmark+1)  
3a63 32 78 fb			ld (debug_mark+1),a  
3a66 3a 70 3a			ld a, (.dmark+2)  
3a69 32 79 fb			ld (debug_mark+2),a  
3a6c 18 03			jr .pastdmark  
3a6e ..			.dmark: db "SP2"  
3a71 f1			.pastdmark: pop af  
3a72			endm  
# End of macro DMARK
3a72						CALLMONITOR 
3a72 cd 00 14			call break_point_state  
3a75				endm  
# End of macro CALLMONITOR
3a75					endif 
3a75 3e 20				ld a, ' ' 
3a77 c5			.spaces1:	push bc 
3a78 77					ld (hl),a 
3a79 23					inc hl 
3a7a c1					pop bc 
3a7b 10 fa				djnz .spaces1 
3a7d 3e 00				ld a,0 
3a7f 77					ld (hl),a 
3a80 21 32 ee				ld hl, scratch 
3a83					if DEBUG_FORTH_WORDS 
3a83						DMARK "SP3" 
3a83 f5				push af  
3a84 3a 98 3a			ld a, (.dmark)  
3a87 32 77 fb			ld (debug_mark),a  
3a8a 3a 99 3a			ld a, (.dmark+1)  
3a8d 32 78 fb			ld (debug_mark+1),a  
3a90 3a 9a 3a			ld a, (.dmark+2)  
3a93 32 79 fb			ld (debug_mark+2),a  
3a96 18 03			jr .pastdmark  
3a98 ..			.dmark: db "SP3"  
3a9b f1			.pastdmark: pop af  
3a9c			endm  
# End of macro DMARK
3a9c						CALLMONITOR 
3a9c cd 00 14			call break_point_state  
3a9f				endm  
# End of macro CALLMONITOR
3a9f					endif 
3a9f cd e2 19				call forth_apush 
3aa2			 
3aa2				       NEXTW 
3aa2 c3 8b 1b			jp macro_next 
3aa5				endm 
# End of macro NEXTW
3aa5			 
3aa5			 
3aa5			 
3aa5			.SCROLL: 
3aa5				CWHEAD .ATQ 63 "SCROLL" 6 WORD_FLAG_CODE 
3aa5 53				db WORD_SYS_CORE+63             
3aa6 d2 3a			dw .ATQ            
3aa8 07				db 6 + 1 
3aa9 .. 00			db "SCROLL",0              
3ab0				endm 
# End of macro CWHEAD
3ab0			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3ab0					if DEBUG_FORTH_WORDS_KEY 
3ab0						DMARK "SCR" 
3ab0 f5				push af  
3ab1 3a c5 3a			ld a, (.dmark)  
3ab4 32 77 fb			ld (debug_mark),a  
3ab7 3a c6 3a			ld a, (.dmark+1)  
3aba 32 78 fb			ld (debug_mark+1),a  
3abd 3a c7 3a			ld a, (.dmark+2)  
3ac0 32 79 fb			ld (debug_mark+2),a  
3ac3 18 03			jr .pastdmark  
3ac5 ..			.dmark: db "SCR"  
3ac8 f1			.pastdmark: pop af  
3ac9			endm  
# End of macro DMARK
3ac9						CALLMONITOR 
3ac9 cd 00 14			call break_point_state  
3acc				endm  
# End of macro CALLMONITOR
3acc					endif 
3acc			 
3acc cd 51 0a			call scroll_up 
3acf			;	call update_display 
3acf			 
3acf					NEXTW 
3acf c3 8b 1b			jp macro_next 
3ad2				endm 
# End of macro NEXTW
3ad2			 
3ad2			 
3ad2			 
3ad2			;		; get dir 
3ad2			; 
3ad2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad2			; 
3ad2			;		push hl 
3ad2			; 
3ad2			;		; destroy value TOS 
3ad2			; 
3ad2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad2			; 
3ad2			;		; get count 
3ad2			; 
3ad2			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ad2			; 
3ad2			;		push hl 
3ad2			; 
3ad2			;		; destroy value TOS 
3ad2			; 
3ad2			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ad2			; 
3ad2			;		; one value on hl get other one back 
3ad2			; 
3ad2			;		pop bc    ; count 
3ad2			; 
3ad2			;		pop de   ; dir 
3ad2			; 
3ad2			; 
3ad2			;		ld b, c 
3ad2			; 
3ad2			;.scrolldir:     push bc 
3ad2			;		push de 
3ad2			; 
3ad2			;		ld a, 0 
3ad2			;		cp e 
3ad2			;		jr z, .scrollup  
3ad2			;		call scroll_down 
3ad2			;		jr .scrollnext 
3ad2			;.scrollup:	call scroll_up 
3ad2			; 
3ad2			;		 
3ad2			;.scrollnext: 
3ad2			;		pop de 
3ad2			;		pop bc 
3ad2			;		djnz .scrolldir 
3ad2			; 
3ad2			; 
3ad2			; 
3ad2			; 
3ad2			; 
3ad2			;		NEXTW 
3ad2			 
3ad2			 
3ad2			 
3ad2			 
3ad2			.ATQ: 
3ad2				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3ad2 62				db WORD_SYS_CORE+78             
3ad3 30 3b			dw .AUTODSP            
3ad5 04				db 3 + 1 
3ad6 .. 00			db "AT@",0              
3ada				endm 
# End of macro CWHEAD
3ada			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3ada					if DEBUG_FORTH_WORDS_KEY 
3ada						DMARK "ATA" 
3ada f5				push af  
3adb 3a ef 3a			ld a, (.dmark)  
3ade 32 77 fb			ld (debug_mark),a  
3ae1 3a f0 3a			ld a, (.dmark+1)  
3ae4 32 78 fb			ld (debug_mark+1),a  
3ae7 3a f1 3a			ld a, (.dmark+2)  
3aea 32 79 fb			ld (debug_mark+2),a  
3aed 18 03			jr .pastdmark  
3aef ..			.dmark: db "ATA"  
3af2 f1			.pastdmark: pop af  
3af3			endm  
# End of macro DMARK
3af3						CALLMONITOR 
3af3 cd 00 14			call break_point_state  
3af6				endm  
# End of macro CALLMONITOR
3af6					endif 
3af6			 
3af6			 
3af6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3af6 cd 35 1a			call macro_dsp_valuehl 
3af9				endm 
# End of macro FORTH_DSP_VALUEHL
3af9			 
3af9					; TODO save cursor row 
3af9 7d					ld a,l 
3afa fe 02				cp 2 
3afc 20 04				jr nz, .crow3aq 
3afe 3e 28				ld a, display_row_2 
3b00 18 12				jr .ccol1aq 
3b02 fe 03		.crow3aq:		cp 3 
3b04 20 04				jr nz, .crow4aq 
3b06 3e 50				ld a, display_row_3 
3b08 18 0a				jr .ccol1aq 
3b0a fe 04		.crow4aq:		cp 4 
3b0c 20 04				jr nz, .crow1aq 
3b0e 3e 78				ld a, display_row_4 
3b10 18 02				jr .ccol1aq 
3b12 3e 00		.crow1aq:		ld a,display_row_1 
3b14 f5			.ccol1aq:		push af			; got row offset 
3b15 6f					ld l,a 
3b16 26 00				ld h,0 
3b18					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b18 cd d1 1a			call macro_forth_dsp_pop 
3b1b				endm 
# End of macro FORTH_DSP_POP
3b1b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b1b cd 35 1a			call macro_dsp_valuehl 
3b1e				endm 
# End of macro FORTH_DSP_VALUEHL
3b1e					; TODO save cursor col 
3b1e f1					pop af 
3b1f 85					add l		; add col offset 
3b20			 
3b20					; add current frame buffer address 
3b20 2a d8 f8				ld hl, (display_fb_active) 
3b23 cd 12 0c				call addatohl 
3b26			 
3b26			 
3b26			 
3b26			 
3b26					; get char frame buffer location offset in hl 
3b26			 
3b26 7e					ld a,(hl) 
3b27 26 00				ld h, 0 
3b29 6f					ld l, a 
3b2a			 
3b2a cd 9a 19				call forth_push_numhl 
3b2d			 
3b2d			 
3b2d					NEXTW 
3b2d c3 8b 1b			jp macro_next 
3b30				endm 
# End of macro NEXTW
3b30			 
3b30			.AUTODSP: 
3b30				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3b30 63				db WORD_SYS_CORE+79             
3b31 46 3b			dw .MENU            
3b33 05				db 4 + 1 
3b34 .. 00			db "ADSP",0              
3b39				endm 
# End of macro CWHEAD
3b39			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3b39			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3b39			 
3b39					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b39 cd 35 1a			call macro_dsp_valuehl 
3b3c				endm 
# End of macro FORTH_DSP_VALUEHL
3b3c			 
3b3c			;		push hl 
3b3c			 
3b3c					; destroy value TOS 
3b3c			 
3b3c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b3c cd d1 1a			call macro_forth_dsp_pop 
3b3f				endm 
# End of macro FORTH_DSP_POP
3b3f			 
3b3f			;		pop hl 
3b3f			 
3b3f 7d					ld a,l 
3b40 32 39 f8				ld (cli_autodisplay), a 
3b43				       NEXTW 
3b43 c3 8b 1b			jp macro_next 
3b46				endm 
# End of macro NEXTW
3b46			 
3b46			.MENU: 
3b46				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3b46 70				db WORD_SYS_CORE+92             
3b47 52 3b			dw .ENDDISPLAY            
3b49 05				db 4 + 1 
3b4a .. 00			db "MENU",0              
3b4f				endm 
# End of macro CWHEAD
3b4f			; | MENU ( u1....ux n ut -- n ) Create a menu. Ut is the title, n is the number of menu items on stack. Push number selection to TOS | TODO 
3b4f			 
3b4f					; get the title address and save it 
3b4f			 
3b4f			;		FORTH_DSP_VALUEHL 
3b4f			;		push hl 
3b4f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4f			; 
3b4f			;		; get number of items on the stack 
3b4f			; 
3b4f			;	 
3b4f			;		FORTH_DSP_VALUEHL 
3b4f			;		push hl 
3b4f			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b4f			 
3b4f			 
3b4f			 
3b4f			 
3b4f				       NEXTW 
3b4f c3 8b 1b			jp macro_next 
3b52				endm 
# End of macro NEXTW
3b52			 
3b52			 
3b52			.ENDDISPLAY: 
3b52			 
3b52			; eof 
# End of file forth_words_display.asm
3b52			include "forth_words_str.asm" 
3b52			 
3b52			; | ## String Words 
3b52			 
3b52			.PTR:   
3b52			 
3b52				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3b52 48				db WORD_SYS_CORE+52             
3b53 7f 3b			dw .STYPE            
3b55 04				db 3 + 1 
3b56 .. 00			db "PTR",0              
3b5a				endm 
# End of macro CWHEAD
3b5a			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3b5a			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3b5a			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3b5a			 
3b5a					if DEBUG_FORTH_WORDS_KEY 
3b5a						DMARK "PTR" 
3b5a f5				push af  
3b5b 3a 6f 3b			ld a, (.dmark)  
3b5e 32 77 fb			ld (debug_mark),a  
3b61 3a 70 3b			ld a, (.dmark+1)  
3b64 32 78 fb			ld (debug_mark+1),a  
3b67 3a 71 3b			ld a, (.dmark+2)  
3b6a 32 79 fb			ld (debug_mark+2),a  
3b6d 18 03			jr .pastdmark  
3b6f ..			.dmark: db "PTR"  
3b72 f1			.pastdmark: pop af  
3b73			endm  
# End of macro DMARK
3b73						CALLMONITOR 
3b73 cd 00 14			call break_point_state  
3b76				endm  
# End of macro CALLMONITOR
3b76					endif 
3b76					FORTH_DSP_VALUEHL 
3b76 cd 35 1a			call macro_dsp_valuehl 
3b79				endm 
# End of macro FORTH_DSP_VALUEHL
3b79 cd 9a 19				call forth_push_numhl 
3b7c			 
3b7c			 
3b7c					NEXTW 
3b7c c3 8b 1b			jp macro_next 
3b7f				endm 
# End of macro NEXTW
3b7f			.STYPE: 
3b7f				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3b7f 48				db WORD_SYS_CORE+52             
3b80 ce 3b			dw .UPPER            
3b82 06				db 5 + 1 
3b83 .. 00			db "STYPE",0              
3b89				endm 
# End of macro CWHEAD
3b89			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3b89					if DEBUG_FORTH_WORDS_KEY 
3b89						DMARK "STY" 
3b89 f5				push af  
3b8a 3a 9e 3b			ld a, (.dmark)  
3b8d 32 77 fb			ld (debug_mark),a  
3b90 3a 9f 3b			ld a, (.dmark+1)  
3b93 32 78 fb			ld (debug_mark+1),a  
3b96 3a a0 3b			ld a, (.dmark+2)  
3b99 32 79 fb			ld (debug_mark+2),a  
3b9c 18 03			jr .pastdmark  
3b9e ..			.dmark: db "STY"  
3ba1 f1			.pastdmark: pop af  
3ba2			endm  
# End of macro DMARK
3ba2						CALLMONITOR 
3ba2 cd 00 14			call break_point_state  
3ba5				endm  
# End of macro CALLMONITOR
3ba5					endif 
3ba5					FORTH_DSP 
3ba5 cd 1a 1a			call macro_forth_dsp 
3ba8				endm 
# End of macro FORTH_DSP
3ba8					;v5 FORTH_DSP_VALUE 
3ba8			 
3ba8 7e					ld a, (hl) 
3ba9			 
3ba9 f5					push af 
3baa			 
3baa			; Dont destroy TOS		FORTH_DSP_POP 
3baa			 
3baa f1					pop af 
3bab			 
3bab fe 01				cp DS_TYPE_STR 
3bad 28 09				jr z, .typestr 
3baf			 
3baf fe 02				cp DS_TYPE_INUM 
3bb1 28 0a				jr z, .typeinum 
3bb3			 
3bb3 21 cc 3b				ld hl, .tna 
3bb6 18 0a				jr .tpush 
3bb8			 
3bb8 21 c8 3b		.typestr:	ld hl, .tstr 
3bbb 18 05				jr .tpush 
3bbd 21 ca 3b		.typeinum:	ld hl, .tinum 
3bc0 18 00				jr .tpush 
3bc2			 
3bc2			.tpush: 
3bc2			 
3bc2 cd ac 19				call forth_push_str 
3bc5			 
3bc5					NEXTW 
3bc5 c3 8b 1b			jp macro_next 
3bc8				endm 
# End of macro NEXTW
3bc8 .. 00		.tstr:	db "s",0 
3bca .. 00		.tinum:  db "i",0 
3bcc .. 00		.tna:   db "?", 0 
3bce			 
3bce			 
3bce			.UPPER: 
3bce				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3bce 48				db WORD_SYS_CORE+52             
3bcf 09 3c			dw .LOWER            
3bd1 06				db 5 + 1 
3bd2 .. 00			db "UPPER",0              
3bd8				endm 
# End of macro CWHEAD
3bd8			; | UPPER ( s -- s ) Upper case string s  | DONE 
3bd8					if DEBUG_FORTH_WORDS_KEY 
3bd8						DMARK "UPR" 
3bd8 f5				push af  
3bd9 3a ed 3b			ld a, (.dmark)  
3bdc 32 77 fb			ld (debug_mark),a  
3bdf 3a ee 3b			ld a, (.dmark+1)  
3be2 32 78 fb			ld (debug_mark+1),a  
3be5 3a ef 3b			ld a, (.dmark+2)  
3be8 32 79 fb			ld (debug_mark+2),a  
3beb 18 03			jr .pastdmark  
3bed ..			.dmark: db "UPR"  
3bf0 f1			.pastdmark: pop af  
3bf1			endm  
# End of macro DMARK
3bf1						CALLMONITOR 
3bf1 cd 00 14			call break_point_state  
3bf4				endm  
# End of macro CALLMONITOR
3bf4					endif 
3bf4			 
3bf4					FORTH_DSP 
3bf4 cd 1a 1a			call macro_forth_dsp 
3bf7				endm 
# End of macro FORTH_DSP
3bf7					 
3bf7			; TODO check is string type 
3bf7			 
3bf7					FORTH_DSP_VALUEHL 
3bf7 cd 35 1a			call macro_dsp_valuehl 
3bfa				endm 
# End of macro FORTH_DSP_VALUEHL
3bfa			; get pointer to string in hl 
3bfa			 
3bfa 7e			.toup:		ld a, (hl) 
3bfb fe 00				cp 0 
3bfd 28 07				jr z, .toupdone 
3bff			 
3bff cd 7f 0f				call to_upper 
3c02			 
3c02 77					ld (hl), a 
3c03 23					inc hl 
3c04 18 f4				jr .toup 
3c06			 
3c06					 
3c06			 
3c06			 
3c06			; for each char convert to upper 
3c06					 
3c06			.toupdone: 
3c06			 
3c06			 
3c06					NEXTW 
3c06 c3 8b 1b			jp macro_next 
3c09				endm 
# End of macro NEXTW
3c09			.LOWER: 
3c09				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3c09 48				db WORD_SYS_CORE+52             
3c0a 44 3c			dw .TCASE            
3c0c 06				db 5 + 1 
3c0d .. 00			db "LOWER",0              
3c13				endm 
# End of macro CWHEAD
3c13			; | LOWER ( s -- s ) Lower case string s  | DONE 
3c13					if DEBUG_FORTH_WORDS_KEY 
3c13						DMARK "LWR" 
3c13 f5				push af  
3c14 3a 28 3c			ld a, (.dmark)  
3c17 32 77 fb			ld (debug_mark),a  
3c1a 3a 29 3c			ld a, (.dmark+1)  
3c1d 32 78 fb			ld (debug_mark+1),a  
3c20 3a 2a 3c			ld a, (.dmark+2)  
3c23 32 79 fb			ld (debug_mark+2),a  
3c26 18 03			jr .pastdmark  
3c28 ..			.dmark: db "LWR"  
3c2b f1			.pastdmark: pop af  
3c2c			endm  
# End of macro DMARK
3c2c						CALLMONITOR 
3c2c cd 00 14			call break_point_state  
3c2f				endm  
# End of macro CALLMONITOR
3c2f					endif 
3c2f			 
3c2f					FORTH_DSP 
3c2f cd 1a 1a			call macro_forth_dsp 
3c32				endm 
# End of macro FORTH_DSP
3c32					 
3c32			; TODO check is string type 
3c32			 
3c32					FORTH_DSP_VALUEHL 
3c32 cd 35 1a			call macro_dsp_valuehl 
3c35				endm 
# End of macro FORTH_DSP_VALUEHL
3c35			; get pointer to string in hl 
3c35			 
3c35 7e			.tolow:		ld a, (hl) 
3c36 fe 00				cp 0 
3c38 28 07				jr z, .tolowdone 
3c3a			 
3c3a cd 88 0f				call to_lower 
3c3d			 
3c3d 77					ld (hl), a 
3c3e 23					inc hl 
3c3f 18 f4				jr .tolow 
3c41			 
3c41					 
3c41			 
3c41			 
3c41			; for each char convert to low 
3c41					 
3c41			.tolowdone: 
3c41					NEXTW 
3c41 c3 8b 1b			jp macro_next 
3c44				endm 
# End of macro NEXTW
3c44			.TCASE: 
3c44				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3c44 48				db WORD_SYS_CORE+52             
3c45 7a 3d			dw .SUBSTR            
3c47 06				db 5 + 1 
3c48 .. 00			db "TCASE",0              
3c4e				endm 
# End of macro CWHEAD
3c4e			; | TCASE ( s -- s ) Title case string s  | DONE 
3c4e					if DEBUG_FORTH_WORDS_KEY 
3c4e						DMARK "TCS" 
3c4e f5				push af  
3c4f 3a 63 3c			ld a, (.dmark)  
3c52 32 77 fb			ld (debug_mark),a  
3c55 3a 64 3c			ld a, (.dmark+1)  
3c58 32 78 fb			ld (debug_mark+1),a  
3c5b 3a 65 3c			ld a, (.dmark+2)  
3c5e 32 79 fb			ld (debug_mark+2),a  
3c61 18 03			jr .pastdmark  
3c63 ..			.dmark: db "TCS"  
3c66 f1			.pastdmark: pop af  
3c67			endm  
# End of macro DMARK
3c67						CALLMONITOR 
3c67 cd 00 14			call break_point_state  
3c6a				endm  
# End of macro CALLMONITOR
3c6a					endif 
3c6a			 
3c6a					FORTH_DSP 
3c6a cd 1a 1a			call macro_forth_dsp 
3c6d				endm 
# End of macro FORTH_DSP
3c6d					 
3c6d			; TODO check is string type 
3c6d			 
3c6d					FORTH_DSP_VALUEHL 
3c6d cd 35 1a			call macro_dsp_valuehl 
3c70				endm 
# End of macro FORTH_DSP_VALUEHL
3c70			; get pointer to string in hl 
3c70			 
3c70					if DEBUG_FORTH_WORDS 
3c70						DMARK "TC1" 
3c70 f5				push af  
3c71 3a 85 3c			ld a, (.dmark)  
3c74 32 77 fb			ld (debug_mark),a  
3c77 3a 86 3c			ld a, (.dmark+1)  
3c7a 32 78 fb			ld (debug_mark+1),a  
3c7d 3a 87 3c			ld a, (.dmark+2)  
3c80 32 79 fb			ld (debug_mark+2),a  
3c83 18 03			jr .pastdmark  
3c85 ..			.dmark: db "TC1"  
3c88 f1			.pastdmark: pop af  
3c89			endm  
# End of macro DMARK
3c89						CALLMONITOR 
3c89 cd 00 14			call break_point_state  
3c8c				endm  
# End of macro CALLMONITOR
3c8c					endif 
3c8c			 
3c8c					; first time in turn to upper case first char 
3c8c			 
3c8c 7e					ld a, (hl) 
3c8d c3 17 3d				jp .totsiptou 
3c90			 
3c90			 
3c90 7e			.tot:		ld a, (hl) 
3c91 fe 00				cp 0 
3c93 ca 5b 3d				jp z, .totdone 
3c96			 
3c96					if DEBUG_FORTH_WORDS 
3c96						DMARK "TC2" 
3c96 f5				push af  
3c97 3a ab 3c			ld a, (.dmark)  
3c9a 32 77 fb			ld (debug_mark),a  
3c9d 3a ac 3c			ld a, (.dmark+1)  
3ca0 32 78 fb			ld (debug_mark+1),a  
3ca3 3a ad 3c			ld a, (.dmark+2)  
3ca6 32 79 fb			ld (debug_mark+2),a  
3ca9 18 03			jr .pastdmark  
3cab ..			.dmark: db "TC2"  
3cae f1			.pastdmark: pop af  
3caf			endm  
# End of macro DMARK
3caf						CALLMONITOR 
3caf cd 00 14			call break_point_state  
3cb2				endm  
# End of macro CALLMONITOR
3cb2					endif 
3cb2					; check to see if current char is a space 
3cb2			 
3cb2 fe 20				cp ' ' 
3cb4 28 21				jr z, .totsp 
3cb6 cd 88 0f				call to_lower 
3cb9					if DEBUG_FORTH_WORDS 
3cb9						DMARK "TC3" 
3cb9 f5				push af  
3cba 3a ce 3c			ld a, (.dmark)  
3cbd 32 77 fb			ld (debug_mark),a  
3cc0 3a cf 3c			ld a, (.dmark+1)  
3cc3 32 78 fb			ld (debug_mark+1),a  
3cc6 3a d0 3c			ld a, (.dmark+2)  
3cc9 32 79 fb			ld (debug_mark+2),a  
3ccc 18 03			jr .pastdmark  
3cce ..			.dmark: db "TC3"  
3cd1 f1			.pastdmark: pop af  
3cd2			endm  
# End of macro DMARK
3cd2						CALLMONITOR 
3cd2 cd 00 14			call break_point_state  
3cd5				endm  
# End of macro CALLMONITOR
3cd5					endif 
3cd5 18 63				jr .totnxt 
3cd7			 
3cd7			.totsp:         ; on a space, find next char which should be upper 
3cd7			 
3cd7					if DEBUG_FORTH_WORDS 
3cd7						DMARK "TC4" 
3cd7 f5				push af  
3cd8 3a ec 3c			ld a, (.dmark)  
3cdb 32 77 fb			ld (debug_mark),a  
3cde 3a ed 3c			ld a, (.dmark+1)  
3ce1 32 78 fb			ld (debug_mark+1),a  
3ce4 3a ee 3c			ld a, (.dmark+2)  
3ce7 32 79 fb			ld (debug_mark+2),a  
3cea 18 03			jr .pastdmark  
3cec ..			.dmark: db "TC4"  
3cef f1			.pastdmark: pop af  
3cf0			endm  
# End of macro DMARK
3cf0						CALLMONITOR 
3cf0 cd 00 14			call break_point_state  
3cf3				endm  
# End of macro CALLMONITOR
3cf3					endif 
3cf3					;; 
3cf3			 
3cf3 fe 20				cp ' ' 
3cf5 20 20				jr nz, .totsiptou 
3cf7 23					inc hl 
3cf8 7e					ld a, (hl) 
3cf9					if DEBUG_FORTH_WORDS 
3cf9						DMARK "TC5" 
3cf9 f5				push af  
3cfa 3a 0e 3d			ld a, (.dmark)  
3cfd 32 77 fb			ld (debug_mark),a  
3d00 3a 0f 3d			ld a, (.dmark+1)  
3d03 32 78 fb			ld (debug_mark+1),a  
3d06 3a 10 3d			ld a, (.dmark+2)  
3d09 32 79 fb			ld (debug_mark+2),a  
3d0c 18 03			jr .pastdmark  
3d0e ..			.dmark: db "TC5"  
3d11 f1			.pastdmark: pop af  
3d12			endm  
# End of macro DMARK
3d12						CALLMONITOR 
3d12 cd 00 14			call break_point_state  
3d15				endm  
# End of macro CALLMONITOR
3d15					endif 
3d15 18 c0				jr .totsp 
3d17 fe 00		.totsiptou:    cp 0 
3d19 28 40				jr z, .totdone 
3d1b					; not space and not zero term so upper case it 
3d1b cd 7f 0f				call to_upper 
3d1e			 
3d1e					if DEBUG_FORTH_WORDS 
3d1e						DMARK "TC6" 
3d1e f5				push af  
3d1f 3a 33 3d			ld a, (.dmark)  
3d22 32 77 fb			ld (debug_mark),a  
3d25 3a 34 3d			ld a, (.dmark+1)  
3d28 32 78 fb			ld (debug_mark+1),a  
3d2b 3a 35 3d			ld a, (.dmark+2)  
3d2e 32 79 fb			ld (debug_mark+2),a  
3d31 18 03			jr .pastdmark  
3d33 ..			.dmark: db "TC6"  
3d36 f1			.pastdmark: pop af  
3d37			endm  
# End of macro DMARK
3d37						CALLMONITOR 
3d37 cd 00 14			call break_point_state  
3d3a				endm  
# End of macro CALLMONITOR
3d3a					endif 
3d3a			 
3d3a			 
3d3a			.totnxt: 
3d3a			 
3d3a 77					ld (hl), a 
3d3b 23					inc hl 
3d3c					if DEBUG_FORTH_WORDS 
3d3c						DMARK "TC7" 
3d3c f5				push af  
3d3d 3a 51 3d			ld a, (.dmark)  
3d40 32 77 fb			ld (debug_mark),a  
3d43 3a 52 3d			ld a, (.dmark+1)  
3d46 32 78 fb			ld (debug_mark+1),a  
3d49 3a 53 3d			ld a, (.dmark+2)  
3d4c 32 79 fb			ld (debug_mark+2),a  
3d4f 18 03			jr .pastdmark  
3d51 ..			.dmark: db "TC7"  
3d54 f1			.pastdmark: pop af  
3d55			endm  
# End of macro DMARK
3d55						CALLMONITOR 
3d55 cd 00 14			call break_point_state  
3d58				endm  
# End of macro CALLMONITOR
3d58					endif 
3d58 c3 90 3c				jp .tot 
3d5b			 
3d5b					 
3d5b			 
3d5b			 
3d5b			; for each char convert to low 
3d5b					 
3d5b			.totdone: 
3d5b					if DEBUG_FORTH_WORDS 
3d5b						DMARK "TCd" 
3d5b f5				push af  
3d5c 3a 70 3d			ld a, (.dmark)  
3d5f 32 77 fb			ld (debug_mark),a  
3d62 3a 71 3d			ld a, (.dmark+1)  
3d65 32 78 fb			ld (debug_mark+1),a  
3d68 3a 72 3d			ld a, (.dmark+2)  
3d6b 32 79 fb			ld (debug_mark+2),a  
3d6e 18 03			jr .pastdmark  
3d70 ..			.dmark: db "TCd"  
3d73 f1			.pastdmark: pop af  
3d74			endm  
# End of macro DMARK
3d74						CALLMONITOR 
3d74 cd 00 14			call break_point_state  
3d77				endm  
# End of macro CALLMONITOR
3d77					endif 
3d77					NEXTW 
3d77 c3 8b 1b			jp macro_next 
3d7a				endm 
# End of macro NEXTW
3d7a			 
3d7a			.SUBSTR: 
3d7a				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3d7a 48				db WORD_SYS_CORE+52             
3d7b d8 3d			dw .LEFT            
3d7d 07				db 6 + 1 
3d7e .. 00			db "SUBSTR",0              
3d85				endm 
# End of macro CWHEAD
3d85			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3d85			 
3d85					if DEBUG_FORTH_WORDS_KEY 
3d85						DMARK "SST" 
3d85 f5				push af  
3d86 3a 9a 3d			ld a, (.dmark)  
3d89 32 77 fb			ld (debug_mark),a  
3d8c 3a 9b 3d			ld a, (.dmark+1)  
3d8f 32 78 fb			ld (debug_mark+1),a  
3d92 3a 9c 3d			ld a, (.dmark+2)  
3d95 32 79 fb			ld (debug_mark+2),a  
3d98 18 03			jr .pastdmark  
3d9a ..			.dmark: db "SST"  
3d9d f1			.pastdmark: pop af  
3d9e			endm  
# End of macro DMARK
3d9e						CALLMONITOR 
3d9e cd 00 14			call break_point_state  
3da1				endm  
# End of macro CALLMONITOR
3da1					endif 
3da1			; TODO check string type 
3da1					FORTH_DSP_VALUEHL 
3da1 cd 35 1a			call macro_dsp_valuehl 
3da4				endm 
# End of macro FORTH_DSP_VALUEHL
3da4			 
3da4 e5					push hl      ; string length 
3da5			 
3da5					FORTH_DSP_POP 
3da5 cd d1 1a			call macro_forth_dsp_pop 
3da8				endm 
# End of macro FORTH_DSP_POP
3da8			 
3da8					FORTH_DSP_VALUEHL 
3da8 cd 35 1a			call macro_dsp_valuehl 
3dab				endm 
# End of macro FORTH_DSP_VALUEHL
3dab			 
3dab e5					push hl     ; start char 
3dac			 
3dac					FORTH_DSP_POP 
3dac cd d1 1a			call macro_forth_dsp_pop 
3daf				endm 
# End of macro FORTH_DSP_POP
3daf			 
3daf			 
3daf					FORTH_DSP_VALUE 
3daf cd 1e 1a			call macro_forth_dsp_value 
3db2				endm 
# End of macro FORTH_DSP_VALUE
3db2			 
3db2 d1					pop de    ; get start post offset 
3db3			 
3db3 19					add hl, de    ; starting offset 
3db4			 
3db4 c1					pop bc 
3db5 c5					push bc      ; grab size of string 
3db6			 
3db6 e5					push hl    ; save string start  
3db7			 
3db7 26 00				ld h, 0 
3db9 69					ld l, c 
3dba 23					inc hl 
3dbb 23					inc hl 
3dbc			 
3dbc cd d9 10				call malloc 
3dbf				if DEBUG_FORTH_MALLOC_GUARD 
3dbf cc fc 4e				call z,malloc_error 
3dc2				endif 
3dc2			 
3dc2 eb					ex de, hl      ; save malloc area for string copy 
3dc3 e1					pop hl    ; get back source 
3dc4 c1					pop bc    ; get length of string back 
3dc5			 
3dc5 d5					push de    ; save malloc area for after we push 
3dc6 ed b0				ldir     ; copy substr 
3dc8			 
3dc8			 
3dc8 eb					ex de, hl 
3dc9 3e 00				ld a, 0 
3dcb 77					ld (hl), a   ; term substr 
3dcc			 
3dcc					 
3dcc e1					pop hl    ; get malloc so we can push it 
3dcd e5					push hl   ; save so we can free it afterwards 
3dce			 
3dce cd ac 19				call forth_push_str 
3dd1			 
3dd1 e1					pop hl 
3dd2 cd a3 11				call free 
3dd5			 
3dd5					 
3dd5					 
3dd5			 
3dd5			 
3dd5					NEXTW 
3dd5 c3 8b 1b			jp macro_next 
3dd8				endm 
# End of macro NEXTW
3dd8			 
3dd8			.LEFT: 
3dd8				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
3dd8 48				db WORD_SYS_CORE+52             
3dd9 00 3e			dw .RIGHT            
3ddb 05				db 4 + 1 
3ddc .. 00			db "LEFT",0              
3de1				endm 
# End of macro CWHEAD
3de1			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
3de1					if DEBUG_FORTH_WORDS_KEY 
3de1						DMARK "LEF" 
3de1 f5				push af  
3de2 3a f6 3d			ld a, (.dmark)  
3de5 32 77 fb			ld (debug_mark),a  
3de8 3a f7 3d			ld a, (.dmark+1)  
3deb 32 78 fb			ld (debug_mark+1),a  
3dee 3a f8 3d			ld a, (.dmark+2)  
3df1 32 79 fb			ld (debug_mark+2),a  
3df4 18 03			jr .pastdmark  
3df6 ..			.dmark: db "LEF"  
3df9 f1			.pastdmark: pop af  
3dfa			endm  
# End of macro DMARK
3dfa						CALLMONITOR 
3dfa cd 00 14			call break_point_state  
3dfd				endm  
# End of macro CALLMONITOR
3dfd					endif 
3dfd			 
3dfd					NEXTW 
3dfd c3 8b 1b			jp macro_next 
3e00				endm 
# End of macro NEXTW
3e00			.RIGHT: 
3e00				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
3e00 48				db WORD_SYS_CORE+52             
3e01 29 3e			dw .STR2NUM            
3e03 06				db 5 + 1 
3e04 .. 00			db "RIGHT",0              
3e0a				endm 
# End of macro CWHEAD
3e0a			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
3e0a					if DEBUG_FORTH_WORDS_KEY 
3e0a						DMARK "RIG" 
3e0a f5				push af  
3e0b 3a 1f 3e			ld a, (.dmark)  
3e0e 32 77 fb			ld (debug_mark),a  
3e11 3a 20 3e			ld a, (.dmark+1)  
3e14 32 78 fb			ld (debug_mark+1),a  
3e17 3a 21 3e			ld a, (.dmark+2)  
3e1a 32 79 fb			ld (debug_mark+2),a  
3e1d 18 03			jr .pastdmark  
3e1f ..			.dmark: db "RIG"  
3e22 f1			.pastdmark: pop af  
3e23			endm  
# End of macro DMARK
3e23						CALLMONITOR 
3e23 cd 00 14			call break_point_state  
3e26				endm  
# End of macro CALLMONITOR
3e26					endif 
3e26			 
3e26					NEXTW 
3e26 c3 8b 1b			jp macro_next 
3e29				endm 
# End of macro NEXTW
3e29			 
3e29			 
3e29			.STR2NUM: 
3e29				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
3e29 48				db WORD_SYS_CORE+52             
3e2a b5 3e			dw .NUM2STR            
3e2c 08				db 7 + 1 
3e2d .. 00			db "STR2NUM",0              
3e35				endm 
# End of macro CWHEAD
3e35			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
3e35			 
3e35			 
3e35			; TODO STR type check to do 
3e35					if DEBUG_FORTH_WORDS_KEY 
3e35						DMARK "S2N" 
3e35 f5				push af  
3e36 3a 4a 3e			ld a, (.dmark)  
3e39 32 77 fb			ld (debug_mark),a  
3e3c 3a 4b 3e			ld a, (.dmark+1)  
3e3f 32 78 fb			ld (debug_mark+1),a  
3e42 3a 4c 3e			ld a, (.dmark+2)  
3e45 32 79 fb			ld (debug_mark+2),a  
3e48 18 03			jr .pastdmark  
3e4a ..			.dmark: db "S2N"  
3e4d f1			.pastdmark: pop af  
3e4e			endm  
# End of macro DMARK
3e4e						CALLMONITOR 
3e4e cd 00 14			call break_point_state  
3e51				endm  
# End of macro CALLMONITOR
3e51					endif 
3e51			 
3e51					;FORTH_DSP 
3e51					FORTH_DSP_VALUE 
3e51 cd 1e 1a			call macro_forth_dsp_value 
3e54				endm 
# End of macro FORTH_DSP_VALUE
3e54					;inc hl 
3e54			 
3e54 eb					ex de, hl 
3e55					if DEBUG_FORTH_WORDS 
3e55						DMARK "S2a" 
3e55 f5				push af  
3e56 3a 6a 3e			ld a, (.dmark)  
3e59 32 77 fb			ld (debug_mark),a  
3e5c 3a 6b 3e			ld a, (.dmark+1)  
3e5f 32 78 fb			ld (debug_mark+1),a  
3e62 3a 6c 3e			ld a, (.dmark+2)  
3e65 32 79 fb			ld (debug_mark+2),a  
3e68 18 03			jr .pastdmark  
3e6a ..			.dmark: db "S2a"  
3e6d f1			.pastdmark: pop af  
3e6e			endm  
# End of macro DMARK
3e6e						CALLMONITOR 
3e6e cd 00 14			call break_point_state  
3e71				endm  
# End of macro CALLMONITOR
3e71					endif 
3e71 cd 07 10				call string_to_uint16 
3e74			 
3e74					if DEBUG_FORTH_WORDS 
3e74						DMARK "S2b" 
3e74 f5				push af  
3e75 3a 89 3e			ld a, (.dmark)  
3e78 32 77 fb			ld (debug_mark),a  
3e7b 3a 8a 3e			ld a, (.dmark+1)  
3e7e 32 78 fb			ld (debug_mark+1),a  
3e81 3a 8b 3e			ld a, (.dmark+2)  
3e84 32 79 fb			ld (debug_mark+2),a  
3e87 18 03			jr .pastdmark  
3e89 ..			.dmark: db "S2b"  
3e8c f1			.pastdmark: pop af  
3e8d			endm  
# End of macro DMARK
3e8d						CALLMONITOR 
3e8d cd 00 14			call break_point_state  
3e90				endm  
# End of macro CALLMONITOR
3e90					endif 
3e90			;		push hl 
3e90					FORTH_DSP_POP 
3e90 cd d1 1a			call macro_forth_dsp_pop 
3e93				endm 
# End of macro FORTH_DSP_POP
3e93			;		pop hl 
3e93					 
3e93					if DEBUG_FORTH_WORDS 
3e93						DMARK "S2b" 
3e93 f5				push af  
3e94 3a a8 3e			ld a, (.dmark)  
3e97 32 77 fb			ld (debug_mark),a  
3e9a 3a a9 3e			ld a, (.dmark+1)  
3e9d 32 78 fb			ld (debug_mark+1),a  
3ea0 3a aa 3e			ld a, (.dmark+2)  
3ea3 32 79 fb			ld (debug_mark+2),a  
3ea6 18 03			jr .pastdmark  
3ea8 ..			.dmark: db "S2b"  
3eab f1			.pastdmark: pop af  
3eac			endm  
# End of macro DMARK
3eac						CALLMONITOR 
3eac cd 00 14			call break_point_state  
3eaf				endm  
# End of macro CALLMONITOR
3eaf					endif 
3eaf cd 9a 19				call forth_push_numhl	 
3eb2			 
3eb2				 
3eb2				       NEXTW 
3eb2 c3 8b 1b			jp macro_next 
3eb5				endm 
# End of macro NEXTW
3eb5			.NUM2STR: 
3eb5				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
3eb5 48				db WORD_SYS_CORE+52             
3eb6 c4 3e			dw .CONCAT            
3eb8 08				db 7 + 1 
3eb9 .. 00			db "NUM2STR",0              
3ec1				endm 
# End of macro CWHEAD
3ec1			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
3ec1			 
3ec1			;		; malloc a string to target 
3ec1			;		ld hl, 10     ; TODO max string size should be fine 
3ec1			;		call malloc 
3ec1			;		push hl    ; save malloc location 
3ec1			; 
3ec1			; 
3ec1			;; TODO check int type 
3ec1			;		FORTH_DSP_VALUEHL 
3ec1			;		ld a, l 
3ec1			;		call DispAToASCII   
3ec1			;;TODO need to chage above call to dump into string 
3ec1			; 
3ec1			; 
3ec1			 
3ec1				       NEXTW 
3ec1 c3 8b 1b			jp macro_next 
3ec4				endm 
# End of macro NEXTW
3ec4			 
3ec4			.CONCAT: 
3ec4				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
3ec4 48				db WORD_SYS_CORE+52             
3ec5 77 3f			dw .FIND            
3ec7 07				db 6 + 1 
3ec8 .. 00			db "CONCAT",0              
3ecf				endm 
# End of macro CWHEAD
3ecf			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
3ecf			 
3ecf			; TODO check string type 
3ecf			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
3ecf			 
3ecf					if DEBUG_FORTH_WORDS_KEY 
3ecf						DMARK "CON" 
3ecf f5				push af  
3ed0 3a e4 3e			ld a, (.dmark)  
3ed3 32 77 fb			ld (debug_mark),a  
3ed6 3a e5 3e			ld a, (.dmark+1)  
3ed9 32 78 fb			ld (debug_mark+1),a  
3edc 3a e6 3e			ld a, (.dmark+2)  
3edf 32 79 fb			ld (debug_mark+2),a  
3ee2 18 03			jr .pastdmark  
3ee4 ..			.dmark: db "CON"  
3ee7 f1			.pastdmark: pop af  
3ee8			endm  
# End of macro DMARK
3ee8						CALLMONITOR 
3ee8 cd 00 14			call break_point_state  
3eeb				endm  
# End of macro CALLMONITOR
3eeb					endif 
3eeb			 
3eeb			 
3eeb					FORTH_DSP_VALUE 
3eeb cd 1e 1a			call macro_forth_dsp_value 
3eee				endm 
# End of macro FORTH_DSP_VALUE
3eee e5					push hl   ; s2 
3eef			 
3eef					FORTH_DSP_POP 
3eef cd d1 1a			call macro_forth_dsp_pop 
3ef2				endm 
# End of macro FORTH_DSP_POP
3ef2			 
3ef2					FORTH_DSP_VALUE 
3ef2 cd 1e 1a			call macro_forth_dsp_value 
3ef5				endm 
# End of macro FORTH_DSP_VALUE
3ef5			 
3ef5 e5					push hl   ; s1 
3ef6			 
3ef6					FORTH_DSP_POP 
3ef6 cd d1 1a			call macro_forth_dsp_pop 
3ef9				endm 
# End of macro FORTH_DSP_POP
3ef9					 
3ef9			 
3ef9					; copy s1 
3ef9			 
3ef9				 
3ef9					; save ptr 
3ef9 e1					pop hl  
3efa e5					push hl 
3efb 3e 00				ld a, 0 
3efd cd 7b 10				call strlent 
3f00					;inc hl    ; zer0 
3f00 06 00				ld b, 0 
3f02 4d					ld c, l 
3f03 e1					pop hl		 
3f04 11 32 ee				ld de, scratch	 
3f07					if DEBUG_FORTH_WORDS 
3f07						DMARK "CO1" 
3f07 f5				push af  
3f08 3a 1c 3f			ld a, (.dmark)  
3f0b 32 77 fb			ld (debug_mark),a  
3f0e 3a 1d 3f			ld a, (.dmark+1)  
3f11 32 78 fb			ld (debug_mark+1),a  
3f14 3a 1e 3f			ld a, (.dmark+2)  
3f17 32 79 fb			ld (debug_mark+2),a  
3f1a 18 03			jr .pastdmark  
3f1c ..			.dmark: db "CO1"  
3f1f f1			.pastdmark: pop af  
3f20			endm  
# End of macro DMARK
3f20						CALLMONITOR 
3f20 cd 00 14			call break_point_state  
3f23				endm  
# End of macro CALLMONITOR
3f23					endif 
3f23 ed b0				ldir 
3f25			 
3f25 e1					pop hl 
3f26 e5					push hl 
3f27 d5					push de 
3f28			 
3f28			 
3f28 3e 00				ld a, 0 
3f2a cd 7b 10				call strlent 
3f2d 23					inc hl    ; zer0 
3f2e 23					inc hl 
3f2f 06 00				ld b, 0 
3f31 4d					ld c, l 
3f32 d1					pop de 
3f33 e1					pop hl		 
3f34					if DEBUG_FORTH_WORDS 
3f34						DMARK "CO2" 
3f34 f5				push af  
3f35 3a 49 3f			ld a, (.dmark)  
3f38 32 77 fb			ld (debug_mark),a  
3f3b 3a 4a 3f			ld a, (.dmark+1)  
3f3e 32 78 fb			ld (debug_mark+1),a  
3f41 3a 4b 3f			ld a, (.dmark+2)  
3f44 32 79 fb			ld (debug_mark+2),a  
3f47 18 03			jr .pastdmark  
3f49 ..			.dmark: db "CO2"  
3f4c f1			.pastdmark: pop af  
3f4d			endm  
# End of macro DMARK
3f4d						CALLMONITOR 
3f4d cd 00 14			call break_point_state  
3f50				endm  
# End of macro CALLMONITOR
3f50					endif 
3f50 ed b0				ldir 
3f52			 
3f52			 
3f52			 
3f52 21 32 ee				ld hl, scratch 
3f55					if DEBUG_FORTH_WORDS 
3f55						DMARK "CO5" 
3f55 f5				push af  
3f56 3a 6a 3f			ld a, (.dmark)  
3f59 32 77 fb			ld (debug_mark),a  
3f5c 3a 6b 3f			ld a, (.dmark+1)  
3f5f 32 78 fb			ld (debug_mark+1),a  
3f62 3a 6c 3f			ld a, (.dmark+2)  
3f65 32 79 fb			ld (debug_mark+2),a  
3f68 18 03			jr .pastdmark  
3f6a ..			.dmark: db "CO5"  
3f6d f1			.pastdmark: pop af  
3f6e			endm  
# End of macro DMARK
3f6e						CALLMONITOR 
3f6e cd 00 14			call break_point_state  
3f71				endm  
# End of macro CALLMONITOR
3f71					endif 
3f71			 
3f71 cd ac 19				call forth_push_str 
3f74			 
3f74			 
3f74			 
3f74			 
3f74				       NEXTW 
3f74 c3 8b 1b			jp macro_next 
3f77				endm 
# End of macro NEXTW
3f77			 
3f77			 
3f77			.FIND: 
3f77				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
3f77 4b				db WORD_SYS_CORE+55             
3f78 35 40			dw .LEN            
3f7a 05				db 4 + 1 
3f7b .. 00			db "FIND",0              
3f80				endm 
# End of macro CWHEAD
3f80			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
3f80			 
3f80					if DEBUG_FORTH_WORDS_KEY 
3f80						DMARK "FND" 
3f80 f5				push af  
3f81 3a 95 3f			ld a, (.dmark)  
3f84 32 77 fb			ld (debug_mark),a  
3f87 3a 96 3f			ld a, (.dmark+1)  
3f8a 32 78 fb			ld (debug_mark+1),a  
3f8d 3a 97 3f			ld a, (.dmark+2)  
3f90 32 79 fb			ld (debug_mark+2),a  
3f93 18 03			jr .pastdmark  
3f95 ..			.dmark: db "FND"  
3f98 f1			.pastdmark: pop af  
3f99			endm  
# End of macro DMARK
3f99						CALLMONITOR 
3f99 cd 00 14			call break_point_state  
3f9c				endm  
# End of macro CALLMONITOR
3f9c					endif 
3f9c			 
3f9c			; TODO check string type 
3f9c					FORTH_DSP_VALUE 
3f9c cd 1e 1a			call macro_forth_dsp_value 
3f9f				endm 
# End of macro FORTH_DSP_VALUE
3f9f			 
3f9f e5					push hl    
3fa0 7e					ld a,(hl)    ; char to find   
3fa1			; TODO change char to substr 
3fa1			 
3fa1 f5					push af 
3fa2					 
3fa2			 
3fa2			 
3fa2					if DEBUG_FORTH_WORDS 
3fa2						DMARK "FN1" 
3fa2 f5				push af  
3fa3 3a b7 3f			ld a, (.dmark)  
3fa6 32 77 fb			ld (debug_mark),a  
3fa9 3a b8 3f			ld a, (.dmark+1)  
3fac 32 78 fb			ld (debug_mark+1),a  
3faf 3a b9 3f			ld a, (.dmark+2)  
3fb2 32 79 fb			ld (debug_mark+2),a  
3fb5 18 03			jr .pastdmark  
3fb7 ..			.dmark: db "FN1"  
3fba f1			.pastdmark: pop af  
3fbb			endm  
# End of macro DMARK
3fbb						CALLMONITOR 
3fbb cd 00 14			call break_point_state  
3fbe				endm  
# End of macro CALLMONITOR
3fbe					endif 
3fbe			 
3fbe					FORTH_DSP_POP 
3fbe cd d1 1a			call macro_forth_dsp_pop 
3fc1				endm 
# End of macro FORTH_DSP_POP
3fc1			 
3fc1					; string to search 
3fc1			 
3fc1					FORTH_DSP_VALUE 
3fc1 cd 1e 1a			call macro_forth_dsp_value 
3fc4				endm 
# End of macro FORTH_DSP_VALUE
3fc4			 
3fc4 d1					pop de  ; d is char to find  
3fc5			 
3fc5					if DEBUG_FORTH_WORDS 
3fc5						DMARK "FN2" 
3fc5 f5				push af  
3fc6 3a da 3f			ld a, (.dmark)  
3fc9 32 77 fb			ld (debug_mark),a  
3fcc 3a db 3f			ld a, (.dmark+1)  
3fcf 32 78 fb			ld (debug_mark+1),a  
3fd2 3a dc 3f			ld a, (.dmark+2)  
3fd5 32 79 fb			ld (debug_mark+2),a  
3fd8 18 03			jr .pastdmark  
3fda ..			.dmark: db "FN2"  
3fdd f1			.pastdmark: pop af  
3fde			endm  
# End of macro DMARK
3fde						CALLMONITOR 
3fde cd 00 14			call break_point_state  
3fe1				endm  
# End of macro CALLMONITOR
3fe1					endif 
3fe1					 
3fe1 01 00 00				ld bc, 0 
3fe4 7e			.findchar:      ld a,(hl) 
3fe5 fe 00				cp 0   		 
3fe7 28 27				jr z, .finddone     
3fe9 ba					cp d 
3fea 28 20				jr z, .foundchar 
3fec 03					inc bc 
3fed 23					inc hl 
3fee					if DEBUG_FORTH_WORDS 
3fee						DMARK "FN3" 
3fee f5				push af  
3fef 3a 03 40			ld a, (.dmark)  
3ff2 32 77 fb			ld (debug_mark),a  
3ff5 3a 04 40			ld a, (.dmark+1)  
3ff8 32 78 fb			ld (debug_mark+1),a  
3ffb 3a 05 40			ld a, (.dmark+2)  
3ffe 32 79 fb			ld (debug_mark+2),a  
4001 18 03			jr .pastdmark  
4003 ..			.dmark: db "FN3"  
4006 f1			.pastdmark: pop af  
4007			endm  
# End of macro DMARK
4007						CALLMONITOR 
4007 cd 00 14			call break_point_state  
400a				endm  
# End of macro CALLMONITOR
400a					endif 
400a 18 d8				jr .findchar 
400c			 
400c			 
400c c5			.foundchar:	push bc 
400d e1					pop hl 
400e 18 03				jr .findexit 
4010			 
4010			 
4010							 
4010			 
4010			.finddone:     ; got to end of string with no find 
4010 21 00 00				ld hl, 0 
4013			.findexit: 
4013			 
4013					if DEBUG_FORTH_WORDS 
4013						DMARK "FNd" 
4013 f5				push af  
4014 3a 28 40			ld a, (.dmark)  
4017 32 77 fb			ld (debug_mark),a  
401a 3a 29 40			ld a, (.dmark+1)  
401d 32 78 fb			ld (debug_mark+1),a  
4020 3a 2a 40			ld a, (.dmark+2)  
4023 32 79 fb			ld (debug_mark+2),a  
4026 18 03			jr .pastdmark  
4028 ..			.dmark: db "FNd"  
402b f1			.pastdmark: pop af  
402c			endm  
# End of macro DMARK
402c						CALLMONITOR 
402c cd 00 14			call break_point_state  
402f				endm  
# End of macro CALLMONITOR
402f					endif 
402f cd 9a 19			call forth_push_numhl 
4032			 
4032				       NEXTW 
4032 c3 8b 1b			jp macro_next 
4035				endm 
# End of macro NEXTW
4035			 
4035			.LEN: 
4035				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
4035 4c				db WORD_SYS_CORE+56             
4036 6a 40			dw .CHAR            
4038 06				db 5 + 1 
4039 .. 00			db "COUNT",0              
403f				endm 
# End of macro CWHEAD
403f			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
403f			 
403f					if DEBUG_FORTH_WORDS_KEY 
403f						DMARK "CNT" 
403f f5				push af  
4040 3a 54 40			ld a, (.dmark)  
4043 32 77 fb			ld (debug_mark),a  
4046 3a 55 40			ld a, (.dmark+1)  
4049 32 78 fb			ld (debug_mark+1),a  
404c 3a 56 40			ld a, (.dmark+2)  
404f 32 79 fb			ld (debug_mark+2),a  
4052 18 03			jr .pastdmark  
4054 ..			.dmark: db "CNT"  
4057 f1			.pastdmark: pop af  
4058			endm  
# End of macro DMARK
4058						CALLMONITOR 
4058 cd 00 14			call break_point_state  
405b				endm  
# End of macro CALLMONITOR
405b					endif 
405b			; TODO check string type 
405b					FORTH_DSP 
405b cd 1a 1a			call macro_forth_dsp 
405e				endm 
# End of macro FORTH_DSP
405e					;v5FORTH_DSP_VALUE 
405e			 
405e 23					inc hl 
405f			 
405f 3e 00				ld a, 0 
4061 cd 7b 10				call strlent 
4064			 
4064 cd 9a 19				call forth_push_numhl 
4067			 
4067			 
4067			 
4067				       NEXTW 
4067 c3 8b 1b			jp macro_next 
406a				endm 
# End of macro NEXTW
406a			.CHAR: 
406a				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
406a 4d				db WORD_SYS_CORE+57             
406b a0 40			dw .ENDSTR            
406d 05				db 4 + 1 
406e .. 00			db "CHAR",0              
4073				endm 
# End of macro CWHEAD
4073			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
4073					if DEBUG_FORTH_WORDS_KEY 
4073						DMARK "CHR" 
4073 f5				push af  
4074 3a 88 40			ld a, (.dmark)  
4077 32 77 fb			ld (debug_mark),a  
407a 3a 89 40			ld a, (.dmark+1)  
407d 32 78 fb			ld (debug_mark+1),a  
4080 3a 8a 40			ld a, (.dmark+2)  
4083 32 79 fb			ld (debug_mark+2),a  
4086 18 03			jr .pastdmark  
4088 ..			.dmark: db "CHR"  
408b f1			.pastdmark: pop af  
408c			endm  
# End of macro DMARK
408c						CALLMONITOR 
408c cd 00 14			call break_point_state  
408f				endm  
# End of macro CALLMONITOR
408f					endif 
408f					FORTH_DSP 
408f cd 1a 1a			call macro_forth_dsp 
4092				endm 
# End of macro FORTH_DSP
4092					;v5 FORTH_DSP_VALUE 
4092 23					inc hl      ; now at start of numeric as string 
4093			 
4093			;		push hl 
4093			 
4093					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4093 cd d1 1a			call macro_forth_dsp_pop 
4096				endm 
# End of macro FORTH_DSP_POP
4096			 
4096			;		pop hl 
4096			 
4096					; push the content of a onto the stack as a value 
4096			 
4096 7e					ld a,(hl)   ; get char 
4097 26 00				ld h,0 
4099 6f					ld l,a 
409a cd 9a 19				call forth_push_numhl 
409d			 
409d				       NEXTW 
409d c3 8b 1b			jp macro_next 
40a0				endm 
# End of macro NEXTW
40a0			 
40a0			 
40a0			 
40a0			 
40a0			.ENDSTR: 
40a0			; eof 
40a0			 
# End of file forth_words_str.asm
40a0			include "forth_words_key.asm" 
40a0			 
40a0			; | ## Keyboard Words 
40a0			 
40a0			.KEY: 
40a0				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
40a0 3e				db WORD_SYS_CORE+42             
40a1 d0 40			dw .WAITK            
40a3 04				db 3 + 1 
40a4 .. 00			db "KEY",0              
40a8				endm 
# End of macro CWHEAD
40a8			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
40a8			 
40a8					if DEBUG_FORTH_WORDS_KEY 
40a8						DMARK "KEY" 
40a8 f5				push af  
40a9 3a bd 40			ld a, (.dmark)  
40ac 32 77 fb			ld (debug_mark),a  
40af 3a be 40			ld a, (.dmark+1)  
40b2 32 78 fb			ld (debug_mark+1),a  
40b5 3a bf 40			ld a, (.dmark+2)  
40b8 32 79 fb			ld (debug_mark+2),a  
40bb 18 03			jr .pastdmark  
40bd ..			.dmark: db "KEY"  
40c0 f1			.pastdmark: pop af  
40c1			endm  
# End of macro DMARK
40c1						CALLMONITOR 
40c1 cd 00 14			call break_point_state  
40c4				endm  
# End of macro CALLMONITOR
40c4					endif 
40c4			; TODO currently waits 
40c4 cd 06 65				call cin 
40c7					;call cin_wait 
40c7 6f					ld l, a 
40c8 26 00				ld h, 0 
40ca cd 9a 19				call forth_push_numhl 
40cd					NEXTW 
40cd c3 8b 1b			jp macro_next 
40d0				endm 
# End of macro NEXTW
40d0			.WAITK: 
40d0				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
40d0 3f				db WORD_SYS_CORE+43             
40d1 02 41			dw .ACCEPT            
40d3 06				db 5 + 1 
40d4 .. 00			db "WAITK",0              
40da				endm 
# End of macro CWHEAD
40da			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
40da					if DEBUG_FORTH_WORDS_KEY 
40da						DMARK "WAI" 
40da f5				push af  
40db 3a ef 40			ld a, (.dmark)  
40de 32 77 fb			ld (debug_mark),a  
40e1 3a f0 40			ld a, (.dmark+1)  
40e4 32 78 fb			ld (debug_mark+1),a  
40e7 3a f1 40			ld a, (.dmark+2)  
40ea 32 79 fb			ld (debug_mark+2),a  
40ed 18 03			jr .pastdmark  
40ef ..			.dmark: db "WAI"  
40f2 f1			.pastdmark: pop af  
40f3			endm  
# End of macro DMARK
40f3						CALLMONITOR 
40f3 cd 00 14			call break_point_state  
40f6				endm  
# End of macro CALLMONITOR
40f6					endif 
40f6 cd f5 64				call cin_wait 
40f9 6f					ld l, a 
40fa 26 00				ld h, 0 
40fc cd 9a 19				call forth_push_numhl 
40ff					NEXTW 
40ff c3 8b 1b			jp macro_next 
4102				endm 
# End of macro NEXTW
4102			.ACCEPT: 
4102				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4102 40				db WORD_SYS_CORE+44             
4103 60 41			dw .EDIT            
4105 07				db 6 + 1 
4106 .. 00			db "ACCEPT",0              
410d				endm 
# End of macro CWHEAD
410d			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
410d					; TODO crashes on push 
410d					if DEBUG_FORTH_WORDS_KEY 
410d						DMARK "ACC" 
410d f5				push af  
410e 3a 22 41			ld a, (.dmark)  
4111 32 77 fb			ld (debug_mark),a  
4114 3a 23 41			ld a, (.dmark+1)  
4117 32 78 fb			ld (debug_mark+1),a  
411a 3a 24 41			ld a, (.dmark+2)  
411d 32 79 fb			ld (debug_mark+2),a  
4120 18 03			jr .pastdmark  
4122 ..			.dmark: db "ACC"  
4125 f1			.pastdmark: pop af  
4126			endm  
# End of macro DMARK
4126						CALLMONITOR 
4126 cd 00 14			call break_point_state  
4129				endm  
# End of macro CALLMONITOR
4129					endif 
4129 21 30 f0				ld hl, os_input 
412c 3e 00				ld a, 0 
412e 77					ld (hl),a 
412f 3a 5b f8				ld a,(f_cursor_ptr) 
4132 16 64				ld d, 100 
4134 0e 00				ld c, 0 
4136 1e 28				ld e, 40 
4138 cd 3f 0c				call input_str 
413b					; TODO perhaps do a type check and wrap in quotes if not a number 
413b 21 30 f0				ld hl, os_input 
413e					if DEBUG_FORTH_WORDS 
413e						DMARK "AC1" 
413e f5				push af  
413f 3a 53 41			ld a, (.dmark)  
4142 32 77 fb			ld (debug_mark),a  
4145 3a 54 41			ld a, (.dmark+1)  
4148 32 78 fb			ld (debug_mark+1),a  
414b 3a 55 41			ld a, (.dmark+2)  
414e 32 79 fb			ld (debug_mark+2),a  
4151 18 03			jr .pastdmark  
4153 ..			.dmark: db "AC1"  
4156 f1			.pastdmark: pop af  
4157			endm  
# End of macro DMARK
4157						CALLMONITOR 
4157 cd 00 14			call break_point_state  
415a				endm  
# End of macro CALLMONITOR
415a					endif 
415a cd ac 19				call forth_push_str 
415d					NEXTW 
415d c3 8b 1b			jp macro_next 
4160				endm 
# End of macro NEXTW
4160			 
4160			.EDIT: 
4160				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
4160 40				db WORD_SYS_CORE+44             
4161 e9 41			dw .ENDKEY            
4163 05				db 4 + 1 
4164 .. 00			db "EDIT",0              
4169				endm 
# End of macro CWHEAD
4169			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
4169			 
4169					; TODO does not copy from stack 
4169					if DEBUG_FORTH_WORDS_KEY 
4169						DMARK "EDT" 
4169 f5				push af  
416a 3a 7e 41			ld a, (.dmark)  
416d 32 77 fb			ld (debug_mark),a  
4170 3a 7f 41			ld a, (.dmark+1)  
4173 32 78 fb			ld (debug_mark+1),a  
4176 3a 80 41			ld a, (.dmark+2)  
4179 32 79 fb			ld (debug_mark+2),a  
417c 18 03			jr .pastdmark  
417e ..			.dmark: db "EDT"  
4181 f1			.pastdmark: pop af  
4182			endm  
# End of macro DMARK
4182						CALLMONITOR 
4182 cd 00 14			call break_point_state  
4185				endm  
# End of macro CALLMONITOR
4185					endif 
4185			 
4185					FORTH_DSP 
4185 cd 1a 1a			call macro_forth_dsp 
4188				endm 
# End of macro FORTH_DSP
4188					;v5 FORTH_DSP_VALUE 
4188 23					inc hl    ; TODO do type check 
4189			 
4189 e5					push hl 
418a 3e 00				ld a, 0 
418c cd 7b 10				call strlent 
418f 23					inc hl 
4190			 
4190 06 00				ld b, 0 
4192 4d					ld c, l 
4193			 
4193 e1					pop hl 
4194 11 30 f0				ld de, os_input 
4197					if DEBUG_FORTH_WORDS_KEY 
4197						DMARK "EDc" 
4197 f5				push af  
4198 3a ac 41			ld a, (.dmark)  
419b 32 77 fb			ld (debug_mark),a  
419e 3a ad 41			ld a, (.dmark+1)  
41a1 32 78 fb			ld (debug_mark+1),a  
41a4 3a ae 41			ld a, (.dmark+2)  
41a7 32 79 fb			ld (debug_mark+2),a  
41aa 18 03			jr .pastdmark  
41ac ..			.dmark: db "EDc"  
41af f1			.pastdmark: pop af  
41b0			endm  
# End of macro DMARK
41b0						CALLMONITOR 
41b0 cd 00 14			call break_point_state  
41b3				endm  
# End of macro CALLMONITOR
41b3					endif 
41b3 ed b0				ldir 
41b5			 
41b5			 
41b5 21 30 f0				ld hl, os_input 
41b8					;ld a, 0 
41b8					;ld (hl),a 
41b8 3a 5b f8				ld a,(f_cursor_ptr) 
41bb 16 64				ld d, 100 
41bd 0e 00				ld c, 0 
41bf 1e 28				ld e, 40 
41c1 cd 3f 0c				call input_str 
41c4					; TODO perhaps do a type check and wrap in quotes if not a number 
41c4 21 30 f0				ld hl, os_input 
41c7					if DEBUG_FORTH_WORDS 
41c7						DMARK "ED1" 
41c7 f5				push af  
41c8 3a dc 41			ld a, (.dmark)  
41cb 32 77 fb			ld (debug_mark),a  
41ce 3a dd 41			ld a, (.dmark+1)  
41d1 32 78 fb			ld (debug_mark+1),a  
41d4 3a de 41			ld a, (.dmark+2)  
41d7 32 79 fb			ld (debug_mark+2),a  
41da 18 03			jr .pastdmark  
41dc ..			.dmark: db "ED1"  
41df f1			.pastdmark: pop af  
41e0			endm  
# End of macro DMARK
41e0						CALLMONITOR 
41e0 cd 00 14			call break_point_state  
41e3				endm  
# End of macro CALLMONITOR
41e3					endif 
41e3 cd ac 19				call forth_push_str 
41e6					NEXTW 
41e6 c3 8b 1b			jp macro_next 
41e9				endm 
# End of macro NEXTW
41e9			 
41e9			 
41e9			 
41e9			.ENDKEY: 
41e9			; eof 
41e9			 
# End of file forth_words_key.asm
41e9			 
41e9			if STORAGE_SE 
41e9			   	include "forth_words_storage.asm" 
41e9			 
41e9			; | ## Fixed Storage Words 
41e9			 
41e9			 
41e9			.BREAD: 
41e9			  
41e9				CWHEAD .BWRITE 38 "BREAD" 5 WORD_FLAG_CODE 
41e9 3a				db WORD_SYS_CORE+38             
41ea 62 42			dw .BWRITE            
41ec 06				db 5 + 1 
41ed .. 00			db "BREAD",0              
41f3				endm 
# End of macro CWHEAD
41f3			; | BREAD ( u -- u ) With the current bank, read a block from block address u (1-512) and push to stack  | TO TEST 
41f3				 
41f3					if DEBUG_FORTH_WORDS_KEY 
41f3						DMARK "BRD" 
41f3 f5				push af  
41f4 3a 08 42			ld a, (.dmark)  
41f7 32 77 fb			ld (debug_mark),a  
41fa 3a 09 42			ld a, (.dmark+1)  
41fd 32 78 fb			ld (debug_mark+1),a  
4200 3a 0a 42			ld a, (.dmark+2)  
4203 32 79 fb			ld (debug_mark+2),a  
4206 18 03			jr .pastdmark  
4208 ..			.dmark: db "BRD"  
420b f1			.pastdmark: pop af  
420c			endm  
# End of macro DMARK
420c						CALLMONITOR 
420c cd 00 14			call break_point_state  
420f				endm  
# End of macro CALLMONITOR
420f					endif 
420f			 
420f				FORTH_DSP_VALUEHL 
420f cd 35 1a			call macro_dsp_valuehl 
4212				endm 
# End of macro FORTH_DSP_VALUEHL
4212			 
4212				FORTH_DSP_POP 
4212 cd d1 1a			call macro_forth_dsp_pop 
4215				endm 
# End of macro FORTH_DSP_POP
4215			 
4215				; calc block address 
4215			 
4215 eb				ex de, hl 
4216 3e 40			ld a, STORE_BLOCK_PHY 
4218 cd 95 0b			call Mult16 
421b			 
421b			 
421b 11 62 f8			ld de, store_page 
421e			 
421e					if DEBUG_FORTH_WORDS 
421e						DMARK "BR1" 
421e f5				push af  
421f 3a 33 42			ld a, (.dmark)  
4222 32 77 fb			ld (debug_mark),a  
4225 3a 34 42			ld a, (.dmark+1)  
4228 32 78 fb			ld (debug_mark+1),a  
422b 3a 35 42			ld a, (.dmark+2)  
422e 32 79 fb			ld (debug_mark+2),a  
4231 18 03			jr .pastdmark  
4233 ..			.dmark: db "BR1"  
4236 f1			.pastdmark: pop af  
4237			endm  
# End of macro DMARK
4237						CALLMONITOR 
4237 cd 00 14			call break_point_state  
423a				endm  
# End of macro CALLMONITOR
423a					endif 
423a			 
423a cd 0c 03			call storage_read_block 
423d			 
423d 21 64 f8		        ld hl, store_page+2 
4240					if DEBUG_FORTH_WORDS 
4240						DMARK "BR2" 
4240 f5				push af  
4241 3a 55 42			ld a, (.dmark)  
4244 32 77 fb			ld (debug_mark),a  
4247 3a 56 42			ld a, (.dmark+1)  
424a 32 78 fb			ld (debug_mark+1),a  
424d 3a 57 42			ld a, (.dmark+2)  
4250 32 79 fb			ld (debug_mark+2),a  
4253 18 03			jr .pastdmark  
4255 ..			.dmark: db "BR2"  
4258 f1			.pastdmark: pop af  
4259			endm  
# End of macro DMARK
4259						CALLMONITOR 
4259 cd 00 14			call break_point_state  
425c				endm  
# End of macro CALLMONITOR
425c					endif 
425c cd ac 19			call forth_push_str 
425f			 
425f			 
425f					NEXTW 
425f c3 8b 1b			jp macro_next 
4262				endm 
# End of macro NEXTW
4262			.BWRITE: 
4262				CWHEAD .BUPD 38 "BWRITE" 6 WORD_FLAG_CODE 
4262 3a				db WORD_SYS_CORE+38             
4263 f7 42			dw .BUPD            
4265 07				db 6 + 1 
4266 .. 00			db "BWRITE",0              
426d				endm 
# End of macro CWHEAD
426d			; | BWRITE ( s u -- ) With the current bank, write the string s to address u | TO TEST 
426d			 
426d					if DEBUG_FORTH_WORDS_KEY 
426d						DMARK "BWR" 
426d f5				push af  
426e 3a 82 42			ld a, (.dmark)  
4271 32 77 fb			ld (debug_mark),a  
4274 3a 83 42			ld a, (.dmark+1)  
4277 32 78 fb			ld (debug_mark+1),a  
427a 3a 84 42			ld a, (.dmark+2)  
427d 32 79 fb			ld (debug_mark+2),a  
4280 18 03			jr .pastdmark  
4282 ..			.dmark: db "BWR"  
4285 f1			.pastdmark: pop af  
4286			endm  
# End of macro DMARK
4286						CALLMONITOR 
4286 cd 00 14			call break_point_state  
4289				endm  
# End of macro CALLMONITOR
4289					endif 
4289			 
4289				FORTH_DSP_VALUEHL 
4289 cd 35 1a			call macro_dsp_valuehl 
428c				endm 
# End of macro FORTH_DSP_VALUEHL
428c			 
428c				; calc block address 
428c			 
428c eb				ex de, hl 
428d 3e 40			ld a, STORE_BLOCK_PHY 
428f cd 95 0b			call Mult16 
4292			 
4292 e5				push hl         ; address 
4293			 
4293				FORTH_DSP_POP 
4293 cd d1 1a			call macro_forth_dsp_pop 
4296				endm 
# End of macro FORTH_DSP_POP
4296			 
4296				FORTH_DSP_VALUEHL 
4296 cd 35 1a			call macro_dsp_valuehl 
4299				endm 
# End of macro FORTH_DSP_VALUEHL
4299			 
4299				FORTH_DSP_POP 
4299 cd d1 1a			call macro_forth_dsp_pop 
429c				endm 
# End of macro FORTH_DSP_POP
429c			 
429c cd 0d 0a			call storage_clear_page 
429f			 
429f				; copy string to store page 
429f			 
429f e5				push hl     ; save string address 
42a0			 
42a0 3e 00			ld a, 0 
42a2 cd 7b 10			call strlent 
42a5			 
42a5 23				inc hl 
42a6			 
42a6 4d				ld c, l 
42a7 06 00			ld b, 0 
42a9			 
42a9 e1				pop hl 
42aa 11 64 f8			ld de, store_page + 2 
42ad					if DEBUG_FORTH_WORDS 
42ad						DMARK "BW1" 
42ad f5				push af  
42ae 3a c2 42			ld a, (.dmark)  
42b1 32 77 fb			ld (debug_mark),a  
42b4 3a c3 42			ld a, (.dmark+1)  
42b7 32 78 fb			ld (debug_mark+1),a  
42ba 3a c4 42			ld a, (.dmark+2)  
42bd 32 79 fb			ld (debug_mark+2),a  
42c0 18 03			jr .pastdmark  
42c2 ..			.dmark: db "BW1"  
42c5 f1			.pastdmark: pop af  
42c6			endm  
# End of macro DMARK
42c6						CALLMONITOR 
42c6 cd 00 14			call break_point_state  
42c9				endm  
# End of macro CALLMONITOR
42c9					endif 
42c9 ed b0			ldir 
42cb			 
42cb			 
42cb				; poke the start of the block with flags to prevent high level file ops hitting the block 
42cb			 
42cb 21 ff ff			ld hl, $ffff 
42ce			 
42ce 22 62 f8			ld (store_page), hl	 
42d1				 
42d1 e1				pop hl    ; get address 
42d2 11 62 f8			ld de, store_page 
42d5			 
42d5					if DEBUG_FORTH_WORDS 
42d5						DMARK "BW2" 
42d5 f5				push af  
42d6 3a ea 42			ld a, (.dmark)  
42d9 32 77 fb			ld (debug_mark),a  
42dc 3a eb 42			ld a, (.dmark+1)  
42df 32 78 fb			ld (debug_mark+1),a  
42e2 3a ec 42			ld a, (.dmark+2)  
42e5 32 79 fb			ld (debug_mark+2),a  
42e8 18 03			jr .pastdmark  
42ea ..			.dmark: db "BW2"  
42ed f1			.pastdmark: pop af  
42ee			endm  
# End of macro DMARK
42ee						CALLMONITOR 
42ee cd 00 14			call break_point_state  
42f1				endm  
# End of macro CALLMONITOR
42f1					endif 
42f1			 
42f1 cd 71 03			call storage_write_block 
42f4			 
42f4					NEXTW 
42f4 c3 8b 1b			jp macro_next 
42f7				endm 
# End of macro NEXTW
42f7			 
42f7			.BUPD: 
42f7				CWHEAD .BYID 38 "BUPD" 4 WORD_FLAG_CODE 
42f7 3a				db WORD_SYS_CORE+38             
42f8 4d 43			dw .BYID            
42fa 05				db 4 + 1 
42fb .. 00			db "BUPD",0              
4300				endm 
# End of macro CWHEAD
4300			; | BUPD ( u -- ) Write the contents of the current file system storage buffer directly to address u | TO TEST 
4300			; | | Coupled with the use of the BREAD, BWRITE and STOREPAGE words it is possible to implement a direct 
4300			; | | or completely different file system structure. 
4300			 
4300					if DEBUG_FORTH_WORDS_KEY 
4300						DMARK "BUD" 
4300 f5				push af  
4301 3a 15 43			ld a, (.dmark)  
4304 32 77 fb			ld (debug_mark),a  
4307 3a 16 43			ld a, (.dmark+1)  
430a 32 78 fb			ld (debug_mark+1),a  
430d 3a 17 43			ld a, (.dmark+2)  
4310 32 79 fb			ld (debug_mark+2),a  
4313 18 03			jr .pastdmark  
4315 ..			.dmark: db "BUD"  
4318 f1			.pastdmark: pop af  
4319			endm  
# End of macro DMARK
4319						CALLMONITOR 
4319 cd 00 14			call break_point_state  
431c				endm  
# End of macro CALLMONITOR
431c					endif 
431c			 
431c				FORTH_DSP_VALUEHL 
431c cd 35 1a			call macro_dsp_valuehl 
431f				endm 
# End of macro FORTH_DSP_VALUEHL
431f			 
431f				; calc block address 
431f			 
431f eb				ex de, hl 
4320 3e 40			ld a, STORE_BLOCK_PHY 
4322 cd 95 0b			call Mult16 
4325			 
4325				FORTH_DSP_POP 
4325 cd d1 1a			call macro_forth_dsp_pop 
4328				endm 
# End of macro FORTH_DSP_POP
4328			 
4328			 
4328 11 62 f8			ld de, store_page 
432b			 
432b					if DEBUG_FORTH_WORDS 
432b						DMARK "BUe" 
432b f5				push af  
432c 3a 40 43			ld a, (.dmark)  
432f 32 77 fb			ld (debug_mark),a  
4332 3a 41 43			ld a, (.dmark+1)  
4335 32 78 fb			ld (debug_mark+1),a  
4338 3a 42 43			ld a, (.dmark+2)  
433b 32 79 fb			ld (debug_mark+2),a  
433e 18 03			jr .pastdmark  
4340 ..			.dmark: db "BUe"  
4343 f1			.pastdmark: pop af  
4344			endm  
# End of macro DMARK
4344						CALLMONITOR 
4344 cd 00 14			call break_point_state  
4347				endm  
# End of macro CALLMONITOR
4347					endif 
4347			 
4347 cd 71 03			call storage_write_block 
434a			 
434a					NEXTW 
434a c3 8b 1b			jp macro_next 
434d				endm 
# End of macro NEXTW
434d			 
434d			.BYID: 
434d				CWHEAD .BYNAME 38 "BYID" 4 WORD_FLAG_CODE 
434d 3a				db WORD_SYS_CORE+38             
434e 59 43			dw .BYNAME            
4350 05				db 4 + 1 
4351 .. 00			db "BYID",0              
4356				endm 
# End of macro CWHEAD
4356			; | BYID ( u -- s ) Get the name of the file in the current BANK using the file ID u | TODO 
4356					NEXTW 
4356 c3 8b 1b			jp macro_next 
4359				endm 
# End of macro NEXTW
4359			.BYNAME: 
4359				CWHEAD .DIR 38 "BYNAME" 6 WORD_FLAG_CODE 
4359 3a				db WORD_SYS_CORE+38             
435a 67 43			dw .DIR            
435c 07				db 6 + 1 
435d .. 00			db "BYNAME",0              
4364				endm 
# End of macro CWHEAD
4364			; | BYNAME ( s -- u ) Get the file ID in the current BANK of the file named s | TODO 
4364					NEXTW 
4364 c3 8b 1b			jp macro_next 
4367				endm 
# End of macro NEXTW
4367			 
4367			.DIR: 
4367				CWHEAD .SAVE 38 "DIR" 3 WORD_FLAG_CODE 
4367 3a				db WORD_SYS_CORE+38             
4368 6b 44			dw .SAVE            
436a 04				db 3 + 1 
436b .. 00			db "DIR",0              
436f				endm 
# End of macro CWHEAD
436f			; | DIR ( u -- lab id ... c t ) Using bank number u push directory entries from persistent storage as w with count u  | DONE 
436f			 
436f					if DEBUG_FORTH_WORDS_KEY 
436f						DMARK "DIR" 
436f f5				push af  
4370 3a 84 43			ld a, (.dmark)  
4373 32 77 fb			ld (debug_mark),a  
4376 3a 85 43			ld a, (.dmark+1)  
4379 32 78 fb			ld (debug_mark+1),a  
437c 3a 86 43			ld a, (.dmark+2)  
437f 32 79 fb			ld (debug_mark+2),a  
4382 18 03			jr .pastdmark  
4384 ..			.dmark: db "DIR"  
4387 f1			.pastdmark: pop af  
4388			endm  
# End of macro DMARK
4388						CALLMONITOR 
4388 cd 00 14			call break_point_state  
438b				endm  
# End of macro CALLMONITOR
438b					endif 
438b cd bd 03			call storage_get_block_0 
438e			 
438e 21 62 f8			ld hl, store_page     ; get current id count 
4391 46				ld b, (hl) 
4392 0e 00			ld c, 0    ; count of files   
4394					if DEBUG_FORTH_WORDS 
4394						DMARK "DI1" 
4394 f5				push af  
4395 3a a9 43			ld a, (.dmark)  
4398 32 77 fb			ld (debug_mark),a  
439b 3a aa 43			ld a, (.dmark+1)  
439e 32 78 fb			ld (debug_mark+1),a  
43a1 3a ab 43			ld a, (.dmark+2)  
43a4 32 79 fb			ld (debug_mark+2),a  
43a7 18 03			jr .pastdmark  
43a9 ..			.dmark: db "DI1"  
43ac f1			.pastdmark: pop af  
43ad			endm  
# End of macro DMARK
43ad						CALLMONITOR 
43ad cd 00 14			call break_point_state  
43b0				endm  
# End of macro CALLMONITOR
43b0					endif 
43b0			 
43b0				; check for empty drive 
43b0			 
43b0 3e 00			ld a, 0 
43b2 b8				cp b 
43b3 ca 21 44			jp z, .dirdone 
43b6			 
43b6				; for each of the current ids do a search for them and if found push to stack 
43b6			 
43b6 c5			.diritem:	push bc 
43b7 21 40 00				ld hl, STORE_BLOCK_PHY 
43ba 16 00				ld d, 0		 ; look for extent 0 of block id as this contains file name 
43bc 58					ld e,b 
43bd			 
43bd			;		if DEBUG_FORTH_WORDS 
43bd			;			DMARK "DI2" 
43bd			;			CALLMONITOR 
43bd			;		endif 
43bd			 
43bd cd 22 06				call storage_findnextid 
43c0			 
43c0			;		if DEBUG_FORTH_WORDS 
43c0			;			DMARK "DI3" 
43c0			;			CALLMONITOR 
43c0			;		endif 
43c0			 
43c0					; if found hl will be non zero 
43c0			 
43c0 cd 3b 0c				call ishlzero 
43c3			;		ld a, l 
43c3			;		add h 
43c3			; 
43c3			;		cp 0 
43c3 28 59				jr z, .dirnotfound 
43c5			 
43c5					; increase count 
43c5			 
43c5 c1					pop bc	 
43c6 0c					inc c 
43c7 c5					push bc 
43c8					 
43c8			 
43c8					; get file header and push the file name 
43c8			 
43c8 11 62 f8				ld de, store_page 
43cb cd 0c 03				call storage_read_block 
43ce			 
43ce					; push file id to stack 
43ce				 
43ce 3a 62 f8				ld a, (store_page) 
43d1 26 00				ld h, 0 
43d3 6f					ld l, a 
43d4 cd 9a 19				call forth_push_numhl 
43d7			 
43d7					; push extent count to stack  
43d7				 
43d7 3a 64 f8				ld a, (store_page+2) 
43da 26 00				ld h, 0 
43dc 6f					ld l, a 
43dd cd 9a 19				call forth_push_numhl 
43e0			 
43e0					; push file name 
43e0			 
43e0 21 65 f8				ld hl, store_page+3 
43e3					if DEBUG_FORTH_WORDS 
43e3						DMARK "DI5" 
43e3 f5				push af  
43e4 3a f8 43			ld a, (.dmark)  
43e7 32 77 fb			ld (debug_mark),a  
43ea 3a f9 43			ld a, (.dmark+1)  
43ed 32 78 fb			ld (debug_mark+1),a  
43f0 3a fa 43			ld a, (.dmark+2)  
43f3 32 79 fb			ld (debug_mark+2),a  
43f6 18 03			jr .pastdmark  
43f8 ..			.dmark: db "DI5"  
43fb f1			.pastdmark: pop af  
43fc			endm  
# End of macro DMARK
43fc						CALLMONITOR 
43fc cd 00 14			call break_point_state  
43ff				endm  
# End of macro CALLMONITOR
43ff					endif 
43ff cd ac 19				call forth_push_str 
4402					if DEBUG_FORTH_WORDS 
4402						DMARK "DI6" 
4402 f5				push af  
4403 3a 17 44			ld a, (.dmark)  
4406 32 77 fb			ld (debug_mark),a  
4409 3a 18 44			ld a, (.dmark+1)  
440c 32 78 fb			ld (debug_mark+1),a  
440f 3a 19 44			ld a, (.dmark+2)  
4412 32 79 fb			ld (debug_mark+2),a  
4415 18 03			jr .pastdmark  
4417 ..			.dmark: db "DI6"  
441a f1			.pastdmark: pop af  
441b			endm  
# End of macro DMARK
441b						CALLMONITOR 
441b cd 00 14			call break_point_state  
441e				endm  
# End of macro CALLMONITOR
441e					endif 
441e			.dirnotfound: 
441e c1					pop bc     
441f 10 95				djnz .diritem 
4421				 
4421			.dirdone:	 
4421					if DEBUG_FORTH_WORDS 
4421						DMARK "DI7" 
4421 f5				push af  
4422 3a 36 44			ld a, (.dmark)  
4425 32 77 fb			ld (debug_mark),a  
4428 3a 37 44			ld a, (.dmark+1)  
442b 32 78 fb			ld (debug_mark+1),a  
442e 3a 38 44			ld a, (.dmark+2)  
4431 32 79 fb			ld (debug_mark+2),a  
4434 18 03			jr .pastdmark  
4436 ..			.dmark: db "DI7"  
4439 f1			.pastdmark: pop af  
443a			endm  
# End of macro DMARK
443a						CALLMONITOR 
443a cd 00 14			call break_point_state  
443d				endm  
# End of macro CALLMONITOR
443d					endif 
443d			 
443d					; push a count of the dir items found 
443d			 
443d 26 00				ld h, 0 
443f 69					ld l, c 
4440 cd 9a 19				call forth_push_numhl 
4443			 
4443					; push the bank label 
4443			 
4443 cd bd 03				call storage_get_block_0 
4446			 
4446				 
4446 21 65 f8		 		ld hl, store_page+3 
4449			 
4449					if DEBUG_FORTH_WORDS 
4449						DMARK "DI8" 
4449 f5				push af  
444a 3a 5e 44			ld a, (.dmark)  
444d 32 77 fb			ld (debug_mark),a  
4450 3a 5f 44			ld a, (.dmark+1)  
4453 32 78 fb			ld (debug_mark+1),a  
4456 3a 60 44			ld a, (.dmark+2)  
4459 32 79 fb			ld (debug_mark+2),a  
445c 18 03			jr .pastdmark  
445e ..			.dmark: db "DI8"  
4461 f1			.pastdmark: pop af  
4462			endm  
# End of macro DMARK
4462						CALLMONITOR 
4462 cd 00 14			call break_point_state  
4465				endm  
# End of macro CALLMONITOR
4465					endif 
4465 cd ac 19				call forth_push_str 
4468			 
4468			 
4468				 
4468					NEXTW 
4468 c3 8b 1b			jp macro_next 
446b				endm 
# End of macro NEXTW
446b			.SAVE: 
446b				CWHEAD .LOAD 39 "SAVE" 4 WORD_FLAG_CODE 
446b 3b				db WORD_SYS_CORE+39             
446c 77 44			dw .LOAD            
446e 05				db 4 + 1 
446f .. 00			db "SAVE",0              
4474				endm 
# End of macro CWHEAD
4474			; | SAVE  ( w u -- )    Save user word memory to file name w on bank u | TODO 
4474					NEXTW 
4474 c3 8b 1b			jp macro_next 
4477				endm 
# End of macro NEXTW
4477			.LOAD: 
4477				CWHEAD .BSAVE 40 "LOAD" 4 WORD_FLAG_CODE 
4477 3c				db WORD_SYS_CORE+40             
4478 d9 45			dw .BSAVE            
447a 05				db 4 + 1 
447b .. 00			db "LOAD",0              
4480				endm 
# End of macro CWHEAD
4480			; | LOAD ( u -- )    Load user word memory from file id on current bank | TODO 
4480			; | | The indivdual records being loaded can be both uword word difintions or interactive commands. 
4480			; | | The LOAD command can not be used in any user words or compound lines. 
4480			 
4480					; store_openext use it. If zero it is EOF 
4480			 
4480					; read block from current stream id 
4480					; if the block does not contain zero term keep reading blocks until zero found 
4480					; push the block to stack 
4480					; save the block id to stream 
4480			 
4480			 
4480					FORTH_DSP_VALUEHL 
4480 cd 35 1a			call macro_dsp_valuehl 
4483				endm 
# End of macro FORTH_DSP_VALUEHL
4483			 
4483			;		push hl 
4483			 
4483				if DEBUG_STORESE 
4483					DMARK "LOA" 
4483 f5				push af  
4484 3a 98 44			ld a, (.dmark)  
4487 32 77 fb			ld (debug_mark),a  
448a 3a 99 44			ld a, (.dmark+1)  
448d 32 78 fb			ld (debug_mark+1),a  
4490 3a 9a 44			ld a, (.dmark+2)  
4493 32 79 fb			ld (debug_mark+2),a  
4496 18 03			jr .pastdmark  
4498 ..			.dmark: db "LOA"  
449b f1			.pastdmark: pop af  
449c			endm  
# End of macro DMARK
449c					CALLMONITOR 
449c cd 00 14			call break_point_state  
449f				endm  
# End of macro CALLMONITOR
449f				endif 
449f					FORTH_DSP_POP 
449f cd d1 1a			call macro_forth_dsp_pop 
44a2				endm 
# End of macro FORTH_DSP_POP
44a2			 
44a2			;		pop hl 
44a2			 
44a2 65					ld h, l 
44a3 2e 00				ld l, 0 
44a5			 
44a5 e5					push hl     ; stack holds current file id and extent to work with 
44a6			 
44a6			 
44a6 11 62 f8				ld de, store_page      ; get block zero of file 
44a9				if DEBUG_STORESE 
44a9					DMARK "LO0" 
44a9 f5				push af  
44aa 3a be 44			ld a, (.dmark)  
44ad 32 77 fb			ld (debug_mark),a  
44b0 3a bf 44			ld a, (.dmark+1)  
44b3 32 78 fb			ld (debug_mark+1),a  
44b6 3a c0 44			ld a, (.dmark+2)  
44b9 32 79 fb			ld (debug_mark+2),a  
44bc 18 03			jr .pastdmark  
44be ..			.dmark: db "LO0"  
44c1 f1			.pastdmark: pop af  
44c2			endm  
# End of macro DMARK
44c2					CALLMONITOR 
44c2 cd 00 14			call break_point_state  
44c5				endm  
# End of macro CALLMONITOR
44c5				endif 
44c5 cd 46 08				call storage_read 
44c8			 
44c8 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
44cb 32 58 f8				ld  (store_openmaxext),a   ; get our limit 
44ce			 
44ce				if DEBUG_STORESE 
44ce					DMARK "LOE" 
44ce f5				push af  
44cf 3a e3 44			ld a, (.dmark)  
44d2 32 77 fb			ld (debug_mark),a  
44d5 3a e4 44			ld a, (.dmark+1)  
44d8 32 78 fb			ld (debug_mark+1),a  
44db 3a e5 44			ld a, (.dmark+2)  
44de 32 79 fb			ld (debug_mark+2),a  
44e1 18 03			jr .pastdmark  
44e3 ..			.dmark: db "LOE"  
44e6 f1			.pastdmark: pop af  
44e7			endm  
# End of macro DMARK
44e7					CALLMONITOR 
44e7 cd 00 14			call break_point_state  
44ea				endm  
# End of macro CALLMONITOR
44ea				endif 
44ea			 
44ea			; TODO dont know why max extents are not present 
44ea			;		cp 0 
44ea			;		jp z, .loadeof     ; dont read past eof 
44ea			 
44ea			;		ld a, 1   ; start from the head of the file 
44ea			 
44ea e1			.loadline:	pop hl 
44eb 23					inc hl 
44ec 3a 58 f8				ld  a, (store_openmaxext)   ; get our limit 
44ef				if DEBUG_STORESE 
44ef					DMARK "LOx" 
44ef f5				push af  
44f0 3a 04 45			ld a, (.dmark)  
44f3 32 77 fb			ld (debug_mark),a  
44f6 3a 05 45			ld a, (.dmark+1)  
44f9 32 78 fb			ld (debug_mark+1),a  
44fc 3a 06 45			ld a, (.dmark+2)  
44ff 32 79 fb			ld (debug_mark+2),a  
4502 18 03			jr .pastdmark  
4504 ..			.dmark: db "LOx"  
4507 f1			.pastdmark: pop af  
4508			endm  
# End of macro DMARK
4508					CALLMONITOR 
4508 cd 00 14			call break_point_state  
450b				endm  
# End of macro CALLMONITOR
450b				endif 
450b 3c					inc a 
450c bd					cp l 
450d ca b7 45				jp z, .loadeof 
4510 e5					push hl    ; save current extent 
4511			 
4511 11 62 f8				ld de, store_page 
4514			 
4514				if DEBUG_STORESE 
4514					DMARK "LO1" 
4514 f5				push af  
4515 3a 29 45			ld a, (.dmark)  
4518 32 77 fb			ld (debug_mark),a  
451b 3a 2a 45			ld a, (.dmark+1)  
451e 32 78 fb			ld (debug_mark+1),a  
4521 3a 2b 45			ld a, (.dmark+2)  
4524 32 79 fb			ld (debug_mark+2),a  
4527 18 03			jr .pastdmark  
4529 ..			.dmark: db "LO1"  
452c f1			.pastdmark: pop af  
452d			endm  
# End of macro DMARK
452d					CALLMONITOR 
452d cd 00 14			call break_point_state  
4530				endm  
# End of macro CALLMONITOR
4530				endif 
4530 cd 46 08				call storage_read 
4533			 
4533				if DEBUG_STORESE 
4533					DMARK "LO2" 
4533 f5				push af  
4534 3a 48 45			ld a, (.dmark)  
4537 32 77 fb			ld (debug_mark),a  
453a 3a 49 45			ld a, (.dmark+1)  
453d 32 78 fb			ld (debug_mark+1),a  
4540 3a 4a 45			ld a, (.dmark+2)  
4543 32 79 fb			ld (debug_mark+2),a  
4546 18 03			jr .pastdmark  
4548 ..			.dmark: db "LO2"  
454b f1			.pastdmark: pop af  
454c			endm  
# End of macro DMARK
454c					CALLMONITOR 
454c cd 00 14			call break_point_state  
454f				endm  
# End of macro CALLMONITOR
454f				endif 
454f cd 3b 0c			call ishlzero 
4552			;	ld a, l 
4552			;	add h 
4552			;	cp 0 
4552 28 63			jr z, .loadeof 
4554			 
4554				; not eof so hl should point to data to exec 
4554			 
4554				; will need to add the FORTH_END_BUFFER flag 
4554			  
4554 21 64 f8			ld hl, store_page+2 
4557 01 ff 00			ld bc, 255 
455a 3e 00			ld a, 0 
455c ed b1			cpir 
455e				if DEBUG_STORESE 
455e					DMARK "LOt" 
455e f5				push af  
455f 3a 73 45			ld a, (.dmark)  
4562 32 77 fb			ld (debug_mark),a  
4565 3a 74 45			ld a, (.dmark+1)  
4568 32 78 fb			ld (debug_mark+1),a  
456b 3a 75 45			ld a, (.dmark+2)  
456e 32 79 fb			ld (debug_mark+2),a  
4571 18 03			jr .pastdmark  
4573 ..			.dmark: db "LOt"  
4576 f1			.pastdmark: pop af  
4577			endm  
# End of macro DMARK
4577					CALLMONITOR 
4577 cd 00 14			call break_point_state  
457a				endm  
# End of macro CALLMONITOR
457a				endif 
457a 2b				dec hl 
457b 3e 20			ld a, ' ' 
457d 77				ld (hl), a 
457e 23				inc hl 
457f 77				ld (hl), a 
4580 23				inc hl 
4581 77				ld (hl), a 
4582 23				inc hl 
4583 3e 7f			ld a, FORTH_END_BUFFER 
4585 77				ld (hl), a 
4586			 
4586				; TODO handle more than a single block read 
4586			 
4586			 
4586 21 64 f8			ld hl, store_page+2 
4589			 
4589 22 33 f1			ld (os_tok_ptr), hl 
458c			 
458c				if DEBUG_STORESE 
458c					DMARK "LO3" 
458c f5				push af  
458d 3a a1 45			ld a, (.dmark)  
4590 32 77 fb			ld (debug_mark),a  
4593 3a a2 45			ld a, (.dmark+1)  
4596 32 78 fb			ld (debug_mark+1),a  
4599 3a a3 45			ld a, (.dmark+2)  
459c 32 79 fb			ld (debug_mark+2),a  
459f 18 03			jr .pastdmark  
45a1 ..			.dmark: db "LO3"  
45a4 f1			.pastdmark: pop af  
45a5			endm  
# End of macro DMARK
45a5					CALLMONITOR 
45a5 cd 00 14			call break_point_state  
45a8				endm  
# End of macro CALLMONITOR
45a8				endif 
45a8			 
45a8 cd d9 1b			call forthparse 
45ab cd 19 1c			call forthexec 
45ae cd 30 1b			call forthexec_cleanup 
45b1			 
45b1				; go to next extent 
45b1			 
45b1				; get next block  or mark as eof 
45b1 c3 ea 44			jp .loadline 
45b4			 
45b4			 
45b4			 
45b4				       NEXTW 
45b4 c3 8b 1b			jp macro_next 
45b7				endm 
# End of macro NEXTW
45b7 3e 00		.loadeof:	ld a, 0 
45b9 32 59 f8				ld (store_openext), a 
45bc			 
45bc				if DEBUG_STORESE 
45bc					DMARK "LOF" 
45bc f5				push af  
45bd 3a d1 45			ld a, (.dmark)  
45c0 32 77 fb			ld (debug_mark),a  
45c3 3a d2 45			ld a, (.dmark+1)  
45c6 32 78 fb			ld (debug_mark+1),a  
45c9 3a d3 45			ld a, (.dmark+2)  
45cc 32 79 fb			ld (debug_mark+2),a  
45cf 18 03			jr .pastdmark  
45d1 ..			.dmark: db "LOF"  
45d4 f1			.pastdmark: pop af  
45d5			endm  
# End of macro DMARK
45d5					CALLMONITOR 
45d5 cd 00 14			call break_point_state  
45d8				endm  
# End of macro CALLMONITOR
45d8				endif 
45d8 c9					ret 
45d9					;NEXTW 
45d9			.BSAVE:   
45d9			 
45d9				CWHEAD .BLOAD 70 "BSAVE" 5 WORD_FLAG_CODE 
45d9 5a				db WORD_SYS_CORE+70             
45da e6 45			dw .BLOAD            
45dc 06				db 5 + 1 
45dd .. 00			db "BSAVE",0              
45e3				endm 
# End of macro CWHEAD
45e3			; | BSAVE  ( w u a s -- )    Save binary file to file name w on bank u starting at address a for s bytes | TODO 
45e3					NEXTW 
45e3 c3 8b 1b			jp macro_next 
45e6				endm 
# End of macro NEXTW
45e6			.BLOAD: 
45e6				CWHEAD .SEO 71 "BLOAD" 5 WORD_FLAG_CODE 
45e6 5b				db WORD_SYS_CORE+71             
45e7 f3 45			dw .SEO            
45e9 06				db 5 + 1 
45ea .. 00			db "BLOAD",0              
45f0				endm 
# End of macro CWHEAD
45f0			; | BLOAD ( w u a -- )    Load binary file from file name w on bank u into address u | TODO 
45f0					NEXTW 
45f0 c3 8b 1b			jp macro_next 
45f3				endm 
# End of macro NEXTW
45f3			;;;; counter gap 
45f3			 
45f3			 
45f3			.SEO: 
45f3				CWHEAD .SEI 80 "SEO" 3 WORD_FLAG_CODE 
45f3 64				db WORD_SYS_CORE+80             
45f4 12 46			dw .SEI            
45f6 04				db 3 + 1 
45f7 .. 00			db "SEO",0              
45fb				endm 
# End of macro CWHEAD
45fb			; | SEO ( u1 u2 -- ) Send byte u1 to Serial EEPROM device at address u2 | DONE 
45fb			 
45fb					; get port 
45fb			 
45fb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
45fb cd 35 1a			call macro_dsp_valuehl 
45fe				endm 
# End of macro FORTH_DSP_VALUEHL
45fe			 
45fe e5					push hl    ; u2 - byte 
45ff			 
45ff					; destroy value TOS 
45ff			 
45ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
45ff cd d1 1a			call macro_forth_dsp_pop 
4602				endm 
# End of macro FORTH_DSP_POP
4602			 
4602					; get byte to send 
4602			 
4602					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4602 cd 35 1a			call macro_dsp_valuehl 
4605				endm 
# End of macro FORTH_DSP_VALUEHL
4605			 
4605 e5					push hl    ; u1 - addr 
4606			 
4606					; destroy value TOS 
4606			 
4606					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4606 cd d1 1a			call macro_forth_dsp_pop 
4609				endm 
# End of macro FORTH_DSP_POP
4609			 
4609					; one value on hl get other one back 
4609			 
4609 d1					pop de   ; u1 - byte 
460a			 
460a e1					pop hl   ; u2 - addr 
460b			 
460b					; TODO Send SPI byte 
460b			 
460b			 
460b 7b					ld a, e 
460c cd ea 01				call se_writebyte 
460f			 
460f					 
460f			 
460f					NEXTW 
460f c3 8b 1b			jp macro_next 
4612				endm 
# End of macro NEXTW
4612			 
4612			.SEI: 
4612				CWHEAD .SFREE 81 "SEI" 3 WORD_FLAG_CODE 
4612 65				db WORD_SYS_CORE+81             
4613 2c 46			dw .SFREE            
4615 04				db 3 + 1 
4616 .. 00			db "SEI",0              
461a				endm 
# End of macro CWHEAD
461a			; | SEI ( u2 -- u1 ) Get a byte from Serial EEPROM device at address u2 | DONE 
461a			 
461a					; get port 
461a			 
461a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
461a cd 35 1a			call macro_dsp_valuehl 
461d				endm 
# End of macro FORTH_DSP_VALUEHL
461d			 
461d			;		push hl 
461d			 
461d					; destroy value TOS 
461d			 
461d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
461d cd d1 1a			call macro_forth_dsp_pop 
4620				endm 
# End of macro FORTH_DSP_POP
4620			 
4620					; one value on hl get other one back 
4620			 
4620			;		pop hl 
4620			 
4620			 
4620					; TODO Get SPI byte 
4620			 
4620 cd 8c 02				call se_readbyte 
4623			 
4623 26 00				ld h, 0 
4625 6f					ld l, a 
4626 cd 9a 19				call forth_push_numhl 
4629			 
4629					NEXTW 
4629 c3 8b 1b			jp macro_next 
462c				endm 
# End of macro NEXTW
462c			 
462c			.SFREE: 
462c				CWHEAD .SIZE 83 "FFREE" 5 WORD_FLAG_CODE 
462c 67				db WORD_SYS_CORE+83             
462d 5b 46			dw .SIZE            
462f 06				db 5 + 1 
4630 .. 00			db "FFREE",0              
4636				endm 
# End of macro CWHEAD
4636			; | FFREE ( -- n )  Gets number of free file blocks on current storage bank | DONE 
4636					if DEBUG_FORTH_WORDS_KEY 
4636						DMARK "FFR" 
4636 f5				push af  
4637 3a 4b 46			ld a, (.dmark)  
463a 32 77 fb			ld (debug_mark),a  
463d 3a 4c 46			ld a, (.dmark+1)  
4640 32 78 fb			ld (debug_mark+1),a  
4643 3a 4d 46			ld a, (.dmark+2)  
4646 32 79 fb			ld (debug_mark+2),a  
4649 18 03			jr .pastdmark  
464b ..			.dmark: db "FFR"  
464e f1			.pastdmark: pop af  
464f			endm  
# End of macro DMARK
464f						CALLMONITOR 
464f cd 00 14			call break_point_state  
4652				endm  
# End of macro CALLMONITOR
4652					endif 
4652			 
4652 cd bc 06				call storage_freeblocks 
4655			 
4655 cd 9a 19				call forth_push_numhl 
4658			 
4658				       NEXTW 
4658 c3 8b 1b			jp macro_next 
465b				endm 
# End of macro NEXTW
465b			.SIZE: 
465b				CWHEAD .CREATE 83 "SIZE" 4 WORD_FLAG_CODE 
465b 67				db WORD_SYS_CORE+83             
465c 8f 46			dw .CREATE            
465e 05				db 4 + 1 
465f .. 00			db "SIZE",0              
4664				endm 
# End of macro CWHEAD
4664			; | SIZE ( u -- n )  Gets number of blocks used by file id u and push to stack | DONE 
4664					if DEBUG_FORTH_WORDS_KEY 
4664						DMARK "SIZ" 
4664 f5				push af  
4665 3a 79 46			ld a, (.dmark)  
4668 32 77 fb			ld (debug_mark),a  
466b 3a 7a 46			ld a, (.dmark+1)  
466e 32 78 fb			ld (debug_mark+1),a  
4671 3a 7b 46			ld a, (.dmark+2)  
4674 32 79 fb			ld (debug_mark+2),a  
4677 18 03			jr .pastdmark  
4679 ..			.dmark: db "SIZ"  
467c f1			.pastdmark: pop af  
467d			endm  
# End of macro DMARK
467d						CALLMONITOR 
467d cd 00 14			call break_point_state  
4680				endm  
# End of macro CALLMONITOR
4680					endif 
4680			 
4680					FORTH_DSP_VALUEHL 
4680 cd 35 1a			call macro_dsp_valuehl 
4683				endm 
# End of macro FORTH_DSP_VALUEHL
4683			;		push hl 
4683					FORTH_DSP_POP 
4683 cd d1 1a			call macro_forth_dsp_pop 
4686				endm 
# End of macro FORTH_DSP_POP
4686			;		pop hl 
4686 cd 3b 03				call storage_file_size 
4689			 
4689 cd 9a 19				call forth_push_numhl 
468c			  
468c			 
468c				       NEXTW 
468c c3 8b 1b			jp macro_next 
468f				endm 
# End of macro NEXTW
468f			 
468f			.CREATE: 
468f				CWHEAD .APPEND 84 "CREATE" 6 WORD_FLAG_CODE 
468f 68				db WORD_SYS_CORE+84             
4690 fd 46			dw .APPEND            
4692 07				db 6 + 1 
4693 .. 00			db "CREATE",0              
469a				endm 
# End of macro CWHEAD
469a			; | CREATE ( u -- n )  Creates a file with name u on current storage bank and pushes the file id number to TOS | TO TEST 
469a			; | | e.g.  
469a			; | | TestProgram CREATE 
469a			; | | Top of stack will then be the file ID which needs to be used in all file handling words 
469a			; | |  
469a			; | | Max file IDs are 255. 
469a			; | |  
469a					 
469a					if DEBUG_FORTH_WORDS_KEY 
469a						DMARK "CRT" 
469a f5				push af  
469b 3a af 46			ld a, (.dmark)  
469e 32 77 fb			ld (debug_mark),a  
46a1 3a b0 46			ld a, (.dmark+1)  
46a4 32 78 fb			ld (debug_mark+1),a  
46a7 3a b1 46			ld a, (.dmark+2)  
46aa 32 79 fb			ld (debug_mark+2),a  
46ad 18 03			jr .pastdmark  
46af ..			.dmark: db "CRT"  
46b2 f1			.pastdmark: pop af  
46b3			endm  
# End of macro DMARK
46b3						CALLMONITOR 
46b3 cd 00 14			call break_point_state  
46b6				endm  
# End of macro CALLMONITOR
46b6					endif 
46b6			;		call storage_get_block_0 
46b6			 
46b6					; TODO pop hl 
46b6			 
46b6					;v5 FORTH_DSP_VALUE 
46b6					FORTH_DSP_VALUE 
46b6 cd 1e 1a			call macro_forth_dsp_value 
46b9				endm 
# End of macro FORTH_DSP_VALUE
46b9			 
46b9				if DEBUG_STORESE 
46b9					DMARK "CR1" 
46b9 f5				push af  
46ba 3a ce 46			ld a, (.dmark)  
46bd 32 77 fb			ld (debug_mark),a  
46c0 3a cf 46			ld a, (.dmark+1)  
46c3 32 78 fb			ld (debug_mark+1),a  
46c6 3a d0 46			ld a, (.dmark+2)  
46c9 32 79 fb			ld (debug_mark+2),a  
46cc 18 03			jr .pastdmark  
46ce ..			.dmark: db "CR1"  
46d1 f1			.pastdmark: pop af  
46d2			endm  
# End of macro DMARK
46d2					CALLMONITOR 
46d2 cd 00 14			call break_point_state  
46d5				endm  
# End of macro CALLMONITOR
46d5				endif 
46d5			;		push hl 
46d5			;		FORTH_DSP_POP 
46d5			;		pop hl 
46d5			 
46d5			;		inc hl   ; move past the type marker 
46d5			 
46d5 cd f2 06				call storage_create 
46d8			 
46d8				if DEBUG_STORESE 
46d8					DMARK "CT1" 
46d8 f5				push af  
46d9 3a ed 46			ld a, (.dmark)  
46dc 32 77 fb			ld (debug_mark),a  
46df 3a ee 46			ld a, (.dmark+1)  
46e2 32 78 fb			ld (debug_mark+1),a  
46e5 3a ef 46			ld a, (.dmark+2)  
46e8 32 79 fb			ld (debug_mark+2),a  
46eb 18 03			jr .pastdmark  
46ed ..			.dmark: db "CT1"  
46f0 f1			.pastdmark: pop af  
46f1			endm  
# End of macro DMARK
46f1					CALLMONITOR 
46f1 cd 00 14			call break_point_state  
46f4				endm  
# End of macro CALLMONITOR
46f4				endif 
46f4			;		push hl 
46f4					FORTH_DSP_POP 
46f4 cd d1 1a			call macro_forth_dsp_pop 
46f7				endm 
# End of macro FORTH_DSP_POP
46f7			;		pop hl 
46f7					; push file id to stack 
46f7 cd 9a 19				call forth_push_numhl 
46fa			 
46fa			 
46fa			 
46fa				       NEXTW 
46fa c3 8b 1b			jp macro_next 
46fd				endm 
# End of macro NEXTW
46fd			 
46fd			.APPEND: 
46fd				CWHEAD .SDEL 85 "APPEND" 6 WORD_FLAG_CODE 
46fd 69				db WORD_SYS_CORE+85             
46fe 8e 47			dw .SDEL            
4700 07				db 6 + 1 
4701 .. 00			db "APPEND",0              
4708				endm 
# End of macro CWHEAD
4708			; | APPEND ( u n --  )  Appends data u to file id on current storage bank | TO TEST 
4708			; | | e.g. 
4708			; | | Test CREATE      -> $01 
4708			; | | "A string to add to file" $01 APPEND 
4708			; | |  
4708			; | | The maximum file size currently using 32k serial EEPROMS using 64 byte blocks is 15k. 
4708					if DEBUG_FORTH_WORDS_KEY 
4708						DMARK "APP" 
4708 f5				push af  
4709 3a 1d 47			ld a, (.dmark)  
470c 32 77 fb			ld (debug_mark),a  
470f 3a 1e 47			ld a, (.dmark+1)  
4712 32 78 fb			ld (debug_mark+1),a  
4715 3a 1f 47			ld a, (.dmark+2)  
4718 32 79 fb			ld (debug_mark+2),a  
471b 18 03			jr .pastdmark  
471d ..			.dmark: db "APP"  
4720 f1			.pastdmark: pop af  
4721			endm  
# End of macro DMARK
4721						CALLMONITOR 
4721 cd 00 14			call break_point_state  
4724				endm  
# End of macro CALLMONITOR
4724					endif 
4724			 
4724					FORTH_DSP_VALUEHL 
4724 cd 35 1a			call macro_dsp_valuehl 
4727				endm 
# End of macro FORTH_DSP_VALUEHL
4727 e5					push hl 	; save file id 
4728			 
4728				if DEBUG_STORESE 
4728					DMARK "AP1" 
4728 f5				push af  
4729 3a 3d 47			ld a, (.dmark)  
472c 32 77 fb			ld (debug_mark),a  
472f 3a 3e 47			ld a, (.dmark+1)  
4732 32 78 fb			ld (debug_mark+1),a  
4735 3a 3f 47			ld a, (.dmark+2)  
4738 32 79 fb			ld (debug_mark+2),a  
473b 18 03			jr .pastdmark  
473d ..			.dmark: db "AP1"  
4740 f1			.pastdmark: pop af  
4741			endm  
# End of macro DMARK
4741					CALLMONITOR 
4741 cd 00 14			call break_point_state  
4744				endm  
# End of macro CALLMONITOR
4744				endif 
4744					FORTH_DSP_POP 
4744 cd d1 1a			call macro_forth_dsp_pop 
4747				endm 
# End of macro FORTH_DSP_POP
4747			 
4747					FORTH_DSP_VALUEHL 
4747 cd 35 1a			call macro_dsp_valuehl 
474a				endm 
# End of macro FORTH_DSP_VALUEHL
474a					;v5 FORTH_DSP_VALUE 
474a e5					push hl 	; save ptr to string to save 
474b			 
474b				if DEBUG_STORESE 
474b					DMARK "AP1" 
474b f5				push af  
474c 3a 60 47			ld a, (.dmark)  
474f 32 77 fb			ld (debug_mark),a  
4752 3a 61 47			ld a, (.dmark+1)  
4755 32 78 fb			ld (debug_mark+1),a  
4758 3a 62 47			ld a, (.dmark+2)  
475b 32 79 fb			ld (debug_mark+2),a  
475e 18 03			jr .pastdmark  
4760 ..			.dmark: db "AP1"  
4763 f1			.pastdmark: pop af  
4764			endm  
# End of macro DMARK
4764					CALLMONITOR 
4764 cd 00 14			call break_point_state  
4767				endm  
# End of macro CALLMONITOR
4767				endif 
4767					FORTH_DSP_POP 
4767 cd d1 1a			call macro_forth_dsp_pop 
476a				endm 
# End of macro FORTH_DSP_POP
476a			 
476a d1					pop de 
476b e1					pop hl 
476c				if DEBUG_STORESE 
476c					DMARK "AP2" 
476c f5				push af  
476d 3a 81 47			ld a, (.dmark)  
4770 32 77 fb			ld (debug_mark),a  
4773 3a 82 47			ld a, (.dmark+1)  
4776 32 78 fb			ld (debug_mark+1),a  
4779 3a 83 47			ld a, (.dmark+2)  
477c 32 79 fb			ld (debug_mark+2),a  
477f 18 03			jr .pastdmark  
4781 ..			.dmark: db "AP2"  
4784 f1			.pastdmark: pop af  
4785			endm  
# End of macro DMARK
4785					CALLMONITOR 
4785 cd 00 14			call break_point_state  
4788				endm  
# End of macro CALLMONITOR
4788				endif 
4788					;inc de ; skip var type indicator 
4788			 
4788					; TODO how to append numerics???? 
4788			 
4788 cd cc 08				call storage_append		 
478b			 
478b				       NEXTW 
478b c3 8b 1b			jp macro_next 
478e				endm 
# End of macro NEXTW
478e			.SDEL: 
478e				CWHEAD .OPEN 86 "ERA" 4 WORD_FLAG_CODE 
478e 6a				db WORD_SYS_CORE+86             
478f da 47			dw .OPEN            
4791 05				db 4 + 1 
4792 .. 00			db "ERA",0              
4796				endm 
# End of macro CWHEAD
4796			; | ERA ( n --  )  Deletes all data for file id n on current storage bank | DONE 
4796					FORTH_DSP_VALUEHL 
4796 cd 35 1a			call macro_dsp_valuehl 
4799				endm 
# End of macro FORTH_DSP_VALUEHL
4799			;		push hl 	; save file id 
4799			 
4799					if DEBUG_FORTH_WORDS_KEY 
4799						DMARK "ERA" 
4799 f5				push af  
479a 3a ae 47			ld a, (.dmark)  
479d 32 77 fb			ld (debug_mark),a  
47a0 3a af 47			ld a, (.dmark+1)  
47a3 32 78 fb			ld (debug_mark+1),a  
47a6 3a b0 47			ld a, (.dmark+2)  
47a9 32 79 fb			ld (debug_mark+2),a  
47ac 18 03			jr .pastdmark  
47ae ..			.dmark: db "ERA"  
47b1 f1			.pastdmark: pop af  
47b2			endm  
# End of macro DMARK
47b2						CALLMONITOR 
47b2 cd 00 14			call break_point_state  
47b5				endm  
# End of macro CALLMONITOR
47b5					endif 
47b5				if DEBUG_STORESE 
47b5					DMARK "ER1" 
47b5 f5				push af  
47b6 3a ca 47			ld a, (.dmark)  
47b9 32 77 fb			ld (debug_mark),a  
47bc 3a cb 47			ld a, (.dmark+1)  
47bf 32 78 fb			ld (debug_mark+1),a  
47c2 3a cc 47			ld a, (.dmark+2)  
47c5 32 79 fb			ld (debug_mark+2),a  
47c8 18 03			jr .pastdmark  
47ca ..			.dmark: db "ER1"  
47cd f1			.pastdmark: pop af  
47ce			endm  
# End of macro DMARK
47ce					CALLMONITOR 
47ce cd 00 14			call break_point_state  
47d1				endm  
# End of macro CALLMONITOR
47d1				endif 
47d1					FORTH_DSP_POP 
47d1 cd d1 1a			call macro_forth_dsp_pop 
47d4				endm 
# End of macro FORTH_DSP_POP
47d4			 
47d4			;		pop hl 
47d4			 
47d4 cd 41 05				call storage_erase 
47d7				       NEXTW 
47d7 c3 8b 1b			jp macro_next 
47da				endm 
# End of macro NEXTW
47da			 
47da			.OPEN: 
47da				CWHEAD .READ 87 "OPEN" 4 WORD_FLAG_CODE 
47da 6b				db WORD_SYS_CORE+87             
47db 61 48			dw .READ            
47dd 05				db 4 + 1 
47de .. 00			db "OPEN",0              
47e3				endm 
# End of macro CWHEAD
47e3			; | OPEN ( n -- n )  Sets file id to point to first data page for subsequent READs. Pushes the max number of blocks for this file | DONE 
47e3			; | | e.g. 
47e3			; | | $01 OPEN $01 DO $01 READ . LOOP 
47e3			 
47e3					if DEBUG_FORTH_WORDS_KEY 
47e3						DMARK "OPN" 
47e3 f5				push af  
47e4 3a f8 47			ld a, (.dmark)  
47e7 32 77 fb			ld (debug_mark),a  
47ea 3a f9 47			ld a, (.dmark+1)  
47ed 32 78 fb			ld (debug_mark+1),a  
47f0 3a fa 47			ld a, (.dmark+2)  
47f3 32 79 fb			ld (debug_mark+2),a  
47f6 18 03			jr .pastdmark  
47f8 ..			.dmark: db "OPN"  
47fb f1			.pastdmark: pop af  
47fc			endm  
# End of macro DMARK
47fc						CALLMONITOR 
47fc cd 00 14			call break_point_state  
47ff				endm  
# End of macro CALLMONITOR
47ff					endif 
47ff					; TODO handle multiple file opens 
47ff			 
47ff 3e 01			       	ld a, 1 
4801 32 59 f8				ld (store_openext), a 
4804			 
4804					; get max extents for this file 
4804				 
4804								 
4804					FORTH_DSP_VALUEHL 
4804 cd 35 1a			call macro_dsp_valuehl 
4807				endm 
# End of macro FORTH_DSP_VALUEHL
4807			 
4807 65					ld h, l 
4808 2e 00				ld l, 0 
480a			 
480a				if DEBUG_STORESE 
480a					DMARK "OPN" 
480a f5				push af  
480b 3a 1f 48			ld a, (.dmark)  
480e 32 77 fb			ld (debug_mark),a  
4811 3a 20 48			ld a, (.dmark+1)  
4814 32 78 fb			ld (debug_mark+1),a  
4817 3a 21 48			ld a, (.dmark+2)  
481a 32 79 fb			ld (debug_mark+2),a  
481d 18 03			jr .pastdmark  
481f ..			.dmark: db "OPN"  
4822 f1			.pastdmark: pop af  
4823			endm  
# End of macro DMARK
4823					CALLMONITOR 
4823 cd 00 14			call break_point_state  
4826				endm  
# End of macro CALLMONITOR
4826				endif 
4826			;		push hl 
4826					FORTH_DSP_POP     ; TODO for now just get rid of stream id 
4826 cd d1 1a			call macro_forth_dsp_pop 
4829				endm 
# End of macro FORTH_DSP_POP
4829			;		pop hl 
4829						 
4829 11 62 f8				ld de, store_page      ; get block zero of file 
482c cd 46 08				call storage_read 
482f			 
482f			 
482f 3a 64 f8				ld a, (store_page+2)    ; max extents for this file 
4832 32 58 f8				ld  (store_openmaxext), a   ; get our limit and push 
4835					 
4835				if DEBUG_STORESE 
4835					DMARK "OPx" 
4835 f5				push af  
4836 3a 4a 48			ld a, (.dmark)  
4839 32 77 fb			ld (debug_mark),a  
483c 3a 4b 48			ld a, (.dmark+1)  
483f 32 78 fb			ld (debug_mark+1),a  
4842 3a 4c 48			ld a, (.dmark+2)  
4845 32 79 fb			ld (debug_mark+2),a  
4848 18 03			jr .pastdmark  
484a ..			.dmark: db "OPx"  
484d f1			.pastdmark: pop af  
484e			endm  
# End of macro DMARK
484e					CALLMONITOR 
484e cd 00 14			call break_point_state  
4851				endm  
# End of macro CALLMONITOR
4851				endif 
4851 fe 00				cp 0 
4853 20 03				jr nz, .skipopeneof 
4855					; have opened an empty file 
4855					 
4855 32 59 f8				ld (store_openext), a 
4858			 
4858			.skipopeneof: 
4858			 
4858 6f					ld l, a 
4859 26 00				ld h, 0 
485b cd 9a 19				call forth_push_numhl 
485e			 
485e			 
485e				       NEXTW 
485e c3 8b 1b			jp macro_next 
4861				endm 
# End of macro NEXTW
4861			.READ: 
4861				CWHEAD .EOF 88 "READ" 4 WORD_FLAG_CODE 
4861 6c				db WORD_SYS_CORE+88             
4862 a8 49			dw .EOF            
4864 05				db 4 + 1 
4865 .. 00			db "READ",0              
486a				endm 
# End of macro CWHEAD
486a			; | READ ( n -- n  )  Reads next page of file id and push to stack | DONE 
486a			; | | e.g. 
486a			; | | $01 OPEN $01 DO $01 READ . LOOP 
486a			 
486a					if DEBUG_FORTH_WORDS_KEY 
486a						DMARK "REA" 
486a f5				push af  
486b 3a 7f 48			ld a, (.dmark)  
486e 32 77 fb			ld (debug_mark),a  
4871 3a 80 48			ld a, (.dmark+1)  
4874 32 78 fb			ld (debug_mark+1),a  
4877 3a 81 48			ld a, (.dmark+2)  
487a 32 79 fb			ld (debug_mark+2),a  
487d 18 03			jr .pastdmark  
487f ..			.dmark: db "REA"  
4882 f1			.pastdmark: pop af  
4883			endm  
# End of macro DMARK
4883						CALLMONITOR 
4883 cd 00 14			call break_point_state  
4886				endm  
# End of macro CALLMONITOR
4886					endif 
4886					; store_openext use it. If zero it is EOF 
4886			 
4886					; read block from current stream id 
4886					; if the block does not contain zero term keep reading blocks until zero found 
4886					; push the block to stack 
4886					; save the block id to stream 
4886			 
4886			 
4886					FORTH_DSP_VALUEHL 
4886 cd 35 1a			call macro_dsp_valuehl 
4889				endm 
# End of macro FORTH_DSP_VALUEHL
4889			 
4889			;		push hl 
4889			 
4889				if DEBUG_STORESE 
4889					DMARK "REA" 
4889 f5				push af  
488a 3a 9e 48			ld a, (.dmark)  
488d 32 77 fb			ld (debug_mark),a  
4890 3a 9f 48			ld a, (.dmark+1)  
4893 32 78 fb			ld (debug_mark+1),a  
4896 3a a0 48			ld a, (.dmark+2)  
4899 32 79 fb			ld (debug_mark+2),a  
489c 18 03			jr .pastdmark  
489e ..			.dmark: db "REA"  
48a1 f1			.pastdmark: pop af  
48a2			endm  
# End of macro DMARK
48a2					CALLMONITOR 
48a2 cd 00 14			call break_point_state  
48a5				endm  
# End of macro CALLMONITOR
48a5				endif 
48a5					FORTH_DSP_POP 
48a5 cd d1 1a			call macro_forth_dsp_pop 
48a8				endm 
# End of macro FORTH_DSP_POP
48a8			 
48a8			;		pop hl 
48a8				 
48a8 65					ld h,l 
48a9			 
48a9 3a 59 f8				ld a, (store_openext) 
48ac 6f					ld l, a 
48ad					 
48ad fe 00				cp 0 
48af ca 7a 49				jp z, .ateof     ; dont read past eof 
48b2			 
48b2			 
48b2 11 62 f8				ld de, store_page 
48b5				if DEBUG_STORESE 
48b5					DMARK "RE1" 
48b5 f5				push af  
48b6 3a ca 48			ld a, (.dmark)  
48b9 32 77 fb			ld (debug_mark),a  
48bc 3a cb 48			ld a, (.dmark+1)  
48bf 32 78 fb			ld (debug_mark+1),a  
48c2 3a cc 48			ld a, (.dmark+2)  
48c5 32 79 fb			ld (debug_mark+2),a  
48c8 18 03			jr .pastdmark  
48ca ..			.dmark: db "RE1"  
48cd f1			.pastdmark: pop af  
48ce			endm  
# End of macro DMARK
48ce					CALLMONITOR 
48ce cd 00 14			call break_point_state  
48d1				endm  
# End of macro CALLMONITOR
48d1				endif 
48d1 cd 46 08				call storage_read 
48d4			 
48d4				if DEBUG_STORESE 
48d4					DMARK "RE2" 
48d4 f5				push af  
48d5 3a e9 48			ld a, (.dmark)  
48d8 32 77 fb			ld (debug_mark),a  
48db 3a ea 48			ld a, (.dmark+1)  
48de 32 78 fb			ld (debug_mark+1),a  
48e1 3a eb 48			ld a, (.dmark+2)  
48e4 32 79 fb			ld (debug_mark+2),a  
48e7 18 03			jr .pastdmark  
48e9 ..			.dmark: db "RE2"  
48ec f1			.pastdmark: pop af  
48ed			endm  
# End of macro DMARK
48ed					CALLMONITOR 
48ed cd 00 14			call break_point_state  
48f0				endm  
# End of macro CALLMONITOR
48f0				endif 
48f0 cd 3b 0c			call ishlzero 
48f3			;	ld a, l 
48f3			;	add h 
48f3			;	cp 0 
48f3 ca 80 49			jp z, .readeof 
48f6			 
48f6				; not eof so hl should point to data to push to stack 
48f6			 
48f6				if DEBUG_STORESE 
48f6					DMARK "RE3" 
48f6 f5				push af  
48f7 3a 0b 49			ld a, (.dmark)  
48fa 32 77 fb			ld (debug_mark),a  
48fd 3a 0c 49			ld a, (.dmark+1)  
4900 32 78 fb			ld (debug_mark+1),a  
4903 3a 0d 49			ld a, (.dmark+2)  
4906 32 79 fb			ld (debug_mark+2),a  
4909 18 03			jr .pastdmark  
490b ..			.dmark: db "RE3"  
490e f1			.pastdmark: pop af  
490f			endm  
# End of macro DMARK
490f					CALLMONITOR 
490f cd 00 14			call break_point_state  
4912				endm  
# End of macro CALLMONITOR
4912				endif 
4912 cd ac 19			call forth_push_str 
4915			 
4915				if DEBUG_STORESE 
4915					DMARK "RE4" 
4915 f5				push af  
4916 3a 2a 49			ld a, (.dmark)  
4919 32 77 fb			ld (debug_mark),a  
491c 3a 2b 49			ld a, (.dmark+1)  
491f 32 78 fb			ld (debug_mark+1),a  
4922 3a 2c 49			ld a, (.dmark+2)  
4925 32 79 fb			ld (debug_mark+2),a  
4928 18 03			jr .pastdmark  
492a ..			.dmark: db "RE4"  
492d f1			.pastdmark: pop af  
492e			endm  
# End of macro DMARK
492e					CALLMONITOR 
492e cd 00 14			call break_point_state  
4931				endm  
# End of macro CALLMONITOR
4931				endif 
4931				; get next block  or mark as eof 
4931			 
4931 3a 58 f8			ld a, (store_openmaxext)   ; get our limit 
4934 4f				ld c, a	 
4935 3a 59 f8			ld a, (store_openext) 
4938			 
4938				if DEBUG_STORESE 
4938					DMARK "RE5" 
4938 f5				push af  
4939 3a 4d 49			ld a, (.dmark)  
493c 32 77 fb			ld (debug_mark),a  
493f 3a 4e 49			ld a, (.dmark+1)  
4942 32 78 fb			ld (debug_mark+1),a  
4945 3a 4f 49			ld a, (.dmark+2)  
4948 32 79 fb			ld (debug_mark+2),a  
494b 18 03			jr .pastdmark  
494d ..			.dmark: db "RE5"  
4950 f1			.pastdmark: pop af  
4951			endm  
# End of macro DMARK
4951					CALLMONITOR 
4951 cd 00 14			call break_point_state  
4954				endm  
# End of macro CALLMONITOR
4954				endif 
4954 b9				cp c 
4955 28 29			jr z, .readeof     ; at last extent 
4957			 
4957 3c					inc a 
4958 32 59 f8				ld (store_openext), a 
495b			 
495b				if DEBUG_STORESE 
495b					DMARK "RE6" 
495b f5				push af  
495c 3a 70 49			ld a, (.dmark)  
495f 32 77 fb			ld (debug_mark),a  
4962 3a 71 49			ld a, (.dmark+1)  
4965 32 78 fb			ld (debug_mark+1),a  
4968 3a 72 49			ld a, (.dmark+2)  
496b 32 79 fb			ld (debug_mark+2),a  
496e 18 03			jr .pastdmark  
4970 ..			.dmark: db "RE6"  
4973 f1			.pastdmark: pop af  
4974			endm  
# End of macro DMARK
4974					CALLMONITOR 
4974 cd 00 14			call break_point_state  
4977				endm  
# End of macro CALLMONITOR
4977				endif 
4977			 
4977			 
4977				       NEXTW 
4977 c3 8b 1b			jp macro_next 
497a				endm 
# End of macro NEXTW
497a			.ateof: 
497a 21 a4 49				ld hl, .showeof 
497d cd ac 19				call forth_push_str 
4980 3e 00		.readeof:	ld a, 0 
4982 32 59 f8				ld (store_openext), a 
4985			 
4985					 
4985				if DEBUG_STORESE 
4985					DMARK "REF" 
4985 f5				push af  
4986 3a 9a 49			ld a, (.dmark)  
4989 32 77 fb			ld (debug_mark),a  
498c 3a 9b 49			ld a, (.dmark+1)  
498f 32 78 fb			ld (debug_mark+1),a  
4992 3a 9c 49			ld a, (.dmark+2)  
4995 32 79 fb			ld (debug_mark+2),a  
4998 18 03			jr .pastdmark  
499a ..			.dmark: db "REF"  
499d f1			.pastdmark: pop af  
499e			endm  
# End of macro DMARK
499e					CALLMONITOR 
499e cd 00 14			call break_point_state  
49a1				endm  
# End of macro CALLMONITOR
49a1				endif 
49a1				       NEXTW 
49a1 c3 8b 1b			jp macro_next 
49a4				endm 
# End of macro NEXTW
49a4			 
49a4 .. 00		.showeof:   db "eof", 0 
49a8			 
49a8			 
49a8			.EOF: 
49a8				CWHEAD .FORMAT 89 "EOF" 3 WORD_FLAG_CODE 
49a8 6d				db WORD_SYS_CORE+89             
49a9 e9 49			dw .FORMAT            
49ab 04				db 3 + 1 
49ac .. 00			db "EOF",0              
49b0				endm 
# End of macro CWHEAD
49b0			; | EOF ( n -- u )  Returns EOF logical state of file id n - CURRENTLY n IS IGNORED AND ONLY ONE STREAM IS SUPPORTED | DONE 
49b0			; | | e.g. 
49b0			; | | $01 OPEN REPEAT $01 READ $01 EOF $00 IF LOOP 
49b0					; TODO if current block id for stream is zero then push true else false 
49b0			 
49b0					if DEBUG_FORTH_WORDS_KEY 
49b0						DMARK "EOF" 
49b0 f5				push af  
49b1 3a c5 49			ld a, (.dmark)  
49b4 32 77 fb			ld (debug_mark),a  
49b7 3a c6 49			ld a, (.dmark+1)  
49ba 32 78 fb			ld (debug_mark+1),a  
49bd 3a c7 49			ld a, (.dmark+2)  
49c0 32 79 fb			ld (debug_mark+2),a  
49c3 18 03			jr .pastdmark  
49c5 ..			.dmark: db "EOF"  
49c8 f1			.pastdmark: pop af  
49c9			endm  
# End of macro DMARK
49c9						CALLMONITOR 
49c9 cd 00 14			call break_point_state  
49cc				endm  
# End of macro CALLMONITOR
49cc					endif 
49cc			 
49cc					; TODO handlue multiple file streams 
49cc			 
49cc					FORTH_DSP_POP     ; for now just get rid of stream id 
49cc cd d1 1a			call macro_forth_dsp_pop 
49cf				endm 
# End of macro FORTH_DSP_POP
49cf			 
49cf 2e 01				ld l, 1 
49d1 3a 58 f8				ld a, (store_openmaxext) 
49d4 fe 00				cp 0 
49d6 28 09				jr  z, .eofdone   ; empty file 
49d8 3a 59 f8				ld a, (store_openext) 
49db fe 00				cp 0 
49dd 28 02				jr  z, .eofdone 
49df 2e 00				ld l, 0 
49e1 26 00		.eofdone:	ld h, 0 
49e3 cd 9a 19				call forth_push_numhl 
49e6			 
49e6			 
49e6				       NEXTW 
49e6 c3 8b 1b			jp macro_next 
49e9				endm 
# End of macro NEXTW
49e9			 
49e9			.FORMAT: 
49e9				CWHEAD .LABEL 89 "FORMAT" 6 WORD_FLAG_CODE 
49e9 6d				db WORD_SYS_CORE+89             
49ea 3a 4a			dw .LABEL            
49ec 07				db 6 + 1 
49ed .. 00			db "FORMAT",0              
49f4				endm 
# End of macro CWHEAD
49f4			; | FORMAT (  --  )  Formats the current bank selected (NO PROMPT!) | DONE 
49f4					; TODO if current block id for stream is zero then push true else false 
49f4				 
49f4				if DEBUG_STORESE 
49f4					DMARK "FOR" 
49f4 f5				push af  
49f5 3a 09 4a			ld a, (.dmark)  
49f8 32 77 fb			ld (debug_mark),a  
49fb 3a 0a 4a			ld a, (.dmark+1)  
49fe 32 78 fb			ld (debug_mark+1),a  
4a01 3a 0b 4a			ld a, (.dmark+2)  
4a04 32 79 fb			ld (debug_mark+2),a  
4a07 18 03			jr .pastdmark  
4a09 ..			.dmark: db "FOR"  
4a0c f1			.pastdmark: pop af  
4a0d			endm  
# End of macro DMARK
4a0d					CALLMONITOR 
4a0d cd 00 14			call break_point_state  
4a10				endm  
# End of macro CALLMONITOR
4a10				endif 
4a10					; Wipes the bank check flags to cause a reformat on next block 0 read 
4a10			 
4a10 21 01 00				ld hl, 1 
4a13 3e 00				ld a, 0 
4a15 cd ea 01				call se_writebyte 
4a18			 
4a18				if DEBUG_STORESE 
4a18					DMARK "FO0" 
4a18 f5				push af  
4a19 3a 2d 4a			ld a, (.dmark)  
4a1c 32 77 fb			ld (debug_mark),a  
4a1f 3a 2e 4a			ld a, (.dmark+1)  
4a22 32 78 fb			ld (debug_mark+1),a  
4a25 3a 2f 4a			ld a, (.dmark+2)  
4a28 32 79 fb			ld (debug_mark+2),a  
4a2b 18 03			jr .pastdmark  
4a2d ..			.dmark: db "FO0"  
4a30 f1			.pastdmark: pop af  
4a31			endm  
# End of macro DMARK
4a31					CALLMONITOR 
4a31 cd 00 14			call break_point_state  
4a34				endm  
# End of macro CALLMONITOR
4a34				endif 
4a34					; force bank init 
4a34			 
4a34 cd bd 03				call storage_get_block_0 
4a37					 
4a37				       NEXTW 
4a37 c3 8b 1b			jp macro_next 
4a3a				endm 
# End of macro NEXTW
4a3a			.LABEL: 
4a3a				CWHEAD .STOREPAGE 89 "LABEL" 5 WORD_FLAG_CODE 
4a3a 6d				db WORD_SYS_CORE+89             
4a3b 88 4a			dw .STOREPAGE            
4a3d 06				db 5 + 1 
4a3e .. 00			db "LABEL",0              
4a44				endm 
# End of macro CWHEAD
4a44			; | LABEL ( u --  )  Sets the storage bank label to string on top of stack  | DONE 
4a44					; TODO test to see if bank is selected 
4a44				 
4a44					if DEBUG_FORTH_WORDS_KEY 
4a44						DMARK "LBL" 
4a44 f5				push af  
4a45 3a 59 4a			ld a, (.dmark)  
4a48 32 77 fb			ld (debug_mark),a  
4a4b 3a 5a 4a			ld a, (.dmark+1)  
4a4e 32 78 fb			ld (debug_mark+1),a  
4a51 3a 5b 4a			ld a, (.dmark+2)  
4a54 32 79 fb			ld (debug_mark+2),a  
4a57 18 03			jr .pastdmark  
4a59 ..			.dmark: db "LBL"  
4a5c f1			.pastdmark: pop af  
4a5d			endm  
# End of macro DMARK
4a5d						CALLMONITOR 
4a5d cd 00 14			call break_point_state  
4a60				endm  
# End of macro CALLMONITOR
4a60					endif 
4a60			;	if DEBUG_STORESE 
4a60			;		DMARK "LBL" 
4a60			;		CALLMONITOR 
4a60			;	endif 
4a60					FORTH_DSP_VALUEHL 
4a60 cd 35 1a			call macro_dsp_valuehl 
4a63				endm 
# End of macro FORTH_DSP_VALUEHL
4a63					;v5FORTH_DSP_VALUE 
4a63					 
4a63			;		push hl 
4a63					FORTH_DSP_POP 
4a63 cd d1 1a			call macro_forth_dsp_pop 
4a66				endm 
# End of macro FORTH_DSP_POP
4a66			;		pop hl 
4a66			 
4a66			;v5		inc hl   ; move past the type marker 
4a66			 
4a66				if DEBUG_STORESE 
4a66					DMARK "LBl" 
4a66 f5				push af  
4a67 3a 7b 4a			ld a, (.dmark)  
4a6a 32 77 fb			ld (debug_mark),a  
4a6d 3a 7c 4a			ld a, (.dmark+1)  
4a70 32 78 fb			ld (debug_mark+1),a  
4a73 3a 7d 4a			ld a, (.dmark+2)  
4a76 32 79 fb			ld (debug_mark+2),a  
4a79 18 03			jr .pastdmark  
4a7b ..			.dmark: db "LBl"  
4a7e f1			.pastdmark: pop af  
4a7f			endm  
# End of macro DMARK
4a7f					CALLMONITOR 
4a7f cd 00 14			call break_point_state  
4a82				endm  
# End of macro CALLMONITOR
4a82				endif 
4a82 cd d6 04				call storage_label 
4a85			 
4a85				       NEXTW 
4a85 c3 8b 1b			jp macro_next 
4a88				endm 
# End of macro NEXTW
4a88			.STOREPAGE: 
4a88				CWHEAD .LABELS 89 "STOREPAGE" 9 WORD_FLAG_CODE 
4a88 6d				db WORD_SYS_CORE+89             
4a89 bb 4a			dw .LABELS            
4a8b 0a				db 9 + 1 
4a8c .. 00			db "STOREPAGE",0              
4a96				endm 
# End of macro CWHEAD
4a96			; | STOREPAGE ( -- addr )  Pushes the address of the file system record buffer to stack for direct access  | DONE 
4a96					; TODO test to see if bank is selected 
4a96				 
4a96					if DEBUG_FORTH_WORDS_KEY 
4a96						DMARK "STP" 
4a96 f5				push af  
4a97 3a ab 4a			ld a, (.dmark)  
4a9a 32 77 fb			ld (debug_mark),a  
4a9d 3a ac 4a			ld a, (.dmark+1)  
4aa0 32 78 fb			ld (debug_mark+1),a  
4aa3 3a ad 4a			ld a, (.dmark+2)  
4aa6 32 79 fb			ld (debug_mark+2),a  
4aa9 18 03			jr .pastdmark  
4aab ..			.dmark: db "STP"  
4aae f1			.pastdmark: pop af  
4aaf			endm  
# End of macro DMARK
4aaf						CALLMONITOR 
4aaf cd 00 14			call break_point_state  
4ab2				endm  
# End of macro CALLMONITOR
4ab2					endif 
4ab2			;	if DEBUG_STORESE 
4ab2			;		DMARK "STP" 
4ab2			;		CALLMONITOR 
4ab2			;	endif 
4ab2			 
4ab2 21 62 f8			ld hl, store_page 
4ab5 cd 9a 19			call forth_push_numhl 
4ab8			 
4ab8			 
4ab8				       NEXTW 
4ab8 c3 8b 1b			jp macro_next 
4abb				endm 
# End of macro NEXTW
4abb			.LABELS: 
4abb				CWHEAD .ENDSTORAGE 89 "LABELS" 6 WORD_FLAG_CODE 
4abb 6d				db WORD_SYS_CORE+89             
4abc 45 4b			dw .ENDSTORAGE            
4abe 07				db 6 + 1 
4abf .. 00			db "LABELS",0              
4ac6				endm 
# End of macro CWHEAD
4ac6			; | LABELS (  -- b n .... c  )  Pushes each storage bank labels (n) along with id (b) onto the stack giving count (c) of banks  | TO TEST 
4ac6					;  
4ac6			 
4ac6					; save the current device selected to restore afterwards 
4ac6				 
4ac6 3a 5c f8				ld a, (spi_device) 
4ac9 f5					push af 
4aca			 
4aca			 
4aca					; run through each of the banks 
4aca			 
4aca 21 01 00				ld hl, 1 
4acd cd 9a 19				call forth_push_numhl 
4ad0 3e ff				ld a, SPI_CE_HIGH 
4ad2 cb 87				res SPI_CE0, a 
4ad4 32 5c f8				ld (spi_device), a 
4ad7 cd bd 03				call storage_get_block_0 
4ada 21 65 f8				ld hl, store_page+3 
4add cd ac 19				call forth_push_str 
4ae0			 
4ae0					 
4ae0 21 02 00				ld hl, 2 
4ae3 cd 9a 19				call forth_push_numhl 
4ae6 3e ff				ld a, SPI_CE_HIGH 
4ae8 cb 8f				res SPI_CE1, a 
4aea 32 5c f8				ld (spi_device), a 
4aed cd bd 03				call storage_get_block_0 
4af0 21 65 f8				ld hl, store_page+3 
4af3 cd ac 19				call forth_push_str 
4af6			 
4af6					 
4af6 21 03 00				ld hl, 3 
4af9 cd 9a 19				call forth_push_numhl 
4afc 3e ff				ld a, SPI_CE_HIGH 
4afe cb 97				res SPI_CE2, a 
4b00 32 5c f8				ld (spi_device), a 
4b03 cd bd 03				call storage_get_block_0 
4b06 21 65 f8				ld hl, store_page+3 
4b09 cd ac 19				call forth_push_str 
4b0c			 
4b0c			 
4b0c 21 04 00				ld hl, 4 
4b0f cd 9a 19				call forth_push_numhl 
4b12 3e ff				ld a, SPI_CE_HIGH 
4b14 cb 9f				res SPI_CE3, a 
4b16 32 5c f8				ld (spi_device), a 
4b19 cd bd 03				call storage_get_block_0 
4b1c 21 65 f8				ld hl, store_page+3 
4b1f cd ac 19				call forth_push_str 
4b22			 
4b22					 
4b22			 
4b22 21 05 00				ld hl, 5 
4b25 cd 9a 19				call forth_push_numhl 
4b28 3e ff				ld a, SPI_CE_HIGH 
4b2a cb a7				res SPI_CE4, a 
4b2c 32 5c f8				ld (spi_device), a 
4b2f cd bd 03				call storage_get_block_0 
4b32 21 65 f8				ld hl, store_page+3 
4b35 cd ac 19				call forth_push_str 
4b38			 
4b38					 
4b38					; push fixed count of storage devices (on board) for now 
4b38			 
4b38 21 05 00				ld hl, 5 
4b3b cd 9a 19				call forth_push_numhl 
4b3e			 
4b3e					; restore selected device  
4b3e				 
4b3e f1					pop af 
4b3f 32 5c f8				ld (spi_device), a 
4b42			 
4b42				       NEXTW 
4b42 c3 8b 1b			jp macro_next 
4b45				endm 
# End of macro NEXTW
4b45			 
4b45			.ENDSTORAGE: 
4b45			; eof 
# End of file forth_words_storage.asm
4b45			endif 
4b45				include "forth_words_device.asm" 
4b45			; Device related words 
4b45			 
4b45			; | ## Device Words 
4b45			 
4b45			if SOUND_ENABLE 
4b45			.NOTE: 
4b45				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4b45 33				db WORD_SYS_CORE+31             
4b46 6d 4b			dw .AFTERSOUND            
4b48 05				db 4 + 1 
4b49 .. 00			db "NOTE",0              
4b4e				endm 
# End of macro CWHEAD
4b4e			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4b4e					if DEBUG_FORTH_WORDS_KEY 
4b4e						DMARK "NTE" 
4b4e f5				push af  
4b4f 3a 63 4b			ld a, (.dmark)  
4b52 32 77 fb			ld (debug_mark),a  
4b55 3a 64 4b			ld a, (.dmark+1)  
4b58 32 78 fb			ld (debug_mark+1),a  
4b5b 3a 65 4b			ld a, (.dmark+2)  
4b5e 32 79 fb			ld (debug_mark+2),a  
4b61 18 03			jr .pastdmark  
4b63 ..			.dmark: db "NTE"  
4b66 f1			.pastdmark: pop af  
4b67			endm  
# End of macro DMARK
4b67						CALLMONITOR 
4b67 cd 00 14			call break_point_state  
4b6a				endm  
# End of macro CALLMONITOR
4b6a					endif 
4b6a			 
4b6a				 
4b6a			 
4b6a					NEXTW 
4b6a c3 8b 1b			jp macro_next 
4b6d				endm 
# End of macro NEXTW
4b6d			.AFTERSOUND: 
4b6d			endif 
4b6d			 
4b6d			 
4b6d			USE_GPIO: equ 0 
4b6d			 
4b6d			if USE_GPIO 
4b6d			.GP1: 
4b6d				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4b6d			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4b6d					NEXTW 
4b6d			.GP2: 
4b6d				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4b6d			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4b6d			 
4b6d					NEXTW 
4b6d			 
4b6d			.GP3: 
4b6d				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4b6d			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4b6d			 
4b6d					NEXTW 
4b6d			 
4b6d			.GP4: 
4b6d				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4b6d			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4b6d			 
4b6d					NEXTW 
4b6d			.SIN: 
4b6d			 
4b6d			 
4b6d			endif 
4b6d			 
4b6d			 
4b6d				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4b6d 33				db WORD_SYS_CORE+31             
4b6e a2 4b			dw .SOUT            
4b70 03				db 2 + 1 
4b71 .. 00			db "IN",0              
4b74				endm 
# End of macro CWHEAD
4b74			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
4b74					if DEBUG_FORTH_WORDS_KEY 
4b74						DMARK "IN." 
4b74 f5				push af  
4b75 3a 89 4b			ld a, (.dmark)  
4b78 32 77 fb			ld (debug_mark),a  
4b7b 3a 8a 4b			ld a, (.dmark+1)  
4b7e 32 78 fb			ld (debug_mark+1),a  
4b81 3a 8b 4b			ld a, (.dmark+2)  
4b84 32 79 fb			ld (debug_mark+2),a  
4b87 18 03			jr .pastdmark  
4b89 ..			.dmark: db "IN."  
4b8c f1			.pastdmark: pop af  
4b8d			endm  
# End of macro DMARK
4b8d						CALLMONITOR 
4b8d cd 00 14			call break_point_state  
4b90				endm  
# End of macro CALLMONITOR
4b90					endif 
4b90					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4b90 cd 35 1a			call macro_dsp_valuehl 
4b93				endm 
# End of macro FORTH_DSP_VALUEHL
4b93			 
4b93 e5					push hl 
4b94			 
4b94					; destroy value TOS 
4b94			 
4b94					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4b94 cd d1 1a			call macro_forth_dsp_pop 
4b97				endm 
# End of macro FORTH_DSP_POP
4b97			 
4b97					; one value on hl get other one back 
4b97			 
4b97 c1					pop bc 
4b98			 
4b98					; do the sub 
4b98			;		ex de, hl 
4b98			 
4b98 ed 68				in l,(c) 
4b9a			 
4b9a					; save it 
4b9a			 
4b9a 26 00				ld h,0 
4b9c			 
4b9c					; TODO push value back onto stack for another op etc 
4b9c			 
4b9c cd 9a 19				call forth_push_numhl 
4b9f					NEXTW 
4b9f c3 8b 1b			jp macro_next 
4ba2				endm 
# End of macro NEXTW
4ba2			.SOUT: 
4ba2				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
4ba2 34				db WORD_SYS_CORE+32             
4ba3 f5 4b			dw .SPIO            
4ba5 04				db 3 + 1 
4ba6 .. 00			db "OUT",0              
4baa				endm 
# End of macro CWHEAD
4baa			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
4baa					if DEBUG_FORTH_WORDS_KEY 
4baa						DMARK "OUT" 
4baa f5				push af  
4bab 3a bf 4b			ld a, (.dmark)  
4bae 32 77 fb			ld (debug_mark),a  
4bb1 3a c0 4b			ld a, (.dmark+1)  
4bb4 32 78 fb			ld (debug_mark+1),a  
4bb7 3a c1 4b			ld a, (.dmark+2)  
4bba 32 79 fb			ld (debug_mark+2),a  
4bbd 18 03			jr .pastdmark  
4bbf ..			.dmark: db "OUT"  
4bc2 f1			.pastdmark: pop af  
4bc3			endm  
# End of macro DMARK
4bc3						CALLMONITOR 
4bc3 cd 00 14			call break_point_state  
4bc6				endm  
# End of macro CALLMONITOR
4bc6					endif 
4bc6			 
4bc6					; get port 
4bc6			 
4bc6					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bc6 cd 35 1a			call macro_dsp_valuehl 
4bc9				endm 
# End of macro FORTH_DSP_VALUEHL
4bc9			 
4bc9 e5					push hl 
4bca			 
4bca					; destroy value TOS 
4bca			 
4bca					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bca cd d1 1a			call macro_forth_dsp_pop 
4bcd				endm 
# End of macro FORTH_DSP_POP
4bcd			 
4bcd					; get byte to send 
4bcd			 
4bcd					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4bcd cd 35 1a			call macro_dsp_valuehl 
4bd0				endm 
# End of macro FORTH_DSP_VALUEHL
4bd0			 
4bd0			;		push hl 
4bd0			 
4bd0					; destroy value TOS 
4bd0			 
4bd0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4bd0 cd d1 1a			call macro_forth_dsp_pop 
4bd3				endm 
# End of macro FORTH_DSP_POP
4bd3			 
4bd3					; one value on hl get other one back 
4bd3			 
4bd3			;		pop hl 
4bd3			 
4bd3 c1					pop bc 
4bd4			 
4bd4					if DEBUG_FORTH_WORDS 
4bd4						DMARK "OUT" 
4bd4 f5				push af  
4bd5 3a e9 4b			ld a, (.dmark)  
4bd8 32 77 fb			ld (debug_mark),a  
4bdb 3a ea 4b			ld a, (.dmark+1)  
4bde 32 78 fb			ld (debug_mark+1),a  
4be1 3a eb 4b			ld a, (.dmark+2)  
4be4 32 79 fb			ld (debug_mark+2),a  
4be7 18 03			jr .pastdmark  
4be9 ..			.dmark: db "OUT"  
4bec f1			.pastdmark: pop af  
4bed			endm  
# End of macro DMARK
4bed						CALLMONITOR 
4bed cd 00 14			call break_point_state  
4bf0				endm  
# End of macro CALLMONITOR
4bf0					endif 
4bf0			 
4bf0 ed 69				out (c), l 
4bf2			 
4bf2					NEXTW 
4bf2 c3 8b 1b			jp macro_next 
4bf5				endm 
# End of macro NEXTW
4bf5			 
4bf5			 
4bf5			.SPIO: 
4bf5			 
4bf5			if STORAGE_SE 
4bf5				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
4bf5 51				db WORD_SYS_CORE+61             
4bf6 06 4c			dw .SPICEH            
4bf8 07				db 6 + 1 
4bf9 .. 00			db "SPICEL",0              
4c00				endm 
# End of macro CWHEAD
4c00			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
4c00			 
4c00 cd 98 01				call spi_ce_low 
4c03			    NEXTW 
4c03 c3 8b 1b			jp macro_next 
4c06				endm 
# End of macro NEXTW
4c06			 
4c06			.SPICEH: 
4c06				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
4c06 51				db WORD_SYS_CORE+61             
4c07 17 4c			dw .SPIOb            
4c09 07				db 6 + 1 
4c0a .. 00			db "SPICEH",0              
4c11				endm 
# End of macro CWHEAD
4c11			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
4c11			 
4c11 cd 87 01				call spi_ce_high 
4c14			    NEXTW 
4c14 c3 8b 1b			jp macro_next 
4c17				endm 
# End of macro NEXTW
4c17			 
4c17			 
4c17			.SPIOb: 
4c17			 
4c17				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
4c17 51				db WORD_SYS_CORE+61             
4c18 2d 4c			dw .SPII            
4c1a 05				db 4 + 1 
4c1b .. 00			db "SPIO",0              
4c20				endm 
# End of macro CWHEAD
4c20			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
4c20			 
4c20					; get port 
4c20			 
4c20			 
4c20					; get byte to send 
4c20			 
4c20					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c20 cd 35 1a			call macro_dsp_valuehl 
4c23				endm 
# End of macro FORTH_DSP_VALUEHL
4c23			 
4c23			;		push hl    ; u1  
4c23			 
4c23					; destroy value TOS 
4c23			 
4c23					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c23 cd d1 1a			call macro_forth_dsp_pop 
4c26				endm 
# End of macro FORTH_DSP_POP
4c26			 
4c26					; one value on hl get other one back 
4c26			 
4c26			;		pop hl   ; u2 - addr 
4c26			 
4c26					; TODO Send SPI byte 
4c26			 
4c26 7d					ld a, l 
4c27 cd bc 00				call spi_send_byte 
4c2a			 
4c2a					NEXTW 
4c2a c3 8b 1b			jp macro_next 
4c2d				endm 
# End of macro NEXTW
4c2d			 
4c2d			.SPII: 
4c2d				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
4c2d 52				db WORD_SYS_CORE+62             
4c2e 42 4c			dw .SESEL            
4c30 06				db 5 + 1 
4c31 .. 00			db "SPII",0              
4c36				endm 
# End of macro CWHEAD
4c36			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
4c36			 
4c36					; TODO Get SPI byte 
4c36			 
4c36 cd dd 00				call spi_read_byte 
4c39			 
4c39 26 00				ld h, 0 
4c3b 6f					ld l, a 
4c3c cd 9a 19				call forth_push_numhl 
4c3f			 
4c3f					NEXTW 
4c3f c3 8b 1b			jp macro_next 
4c42				endm 
# End of macro NEXTW
4c42			 
4c42			 
4c42			 
4c42			.SESEL: 
4c42				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
4c42 66				db WORD_SYS_CORE+82             
4c43 d6 4c			dw .CARTDEV            
4c45 05				db 4 + 1 
4c46 .. 00			db "BANK",0              
4c4b				endm 
# End of macro CWHEAD
4c4b			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
4c4b					if DEBUG_FORTH_WORDS_KEY 
4c4b						DMARK "BNK" 
4c4b f5				push af  
4c4c 3a 60 4c			ld a, (.dmark)  
4c4f 32 77 fb			ld (debug_mark),a  
4c52 3a 61 4c			ld a, (.dmark+1)  
4c55 32 78 fb			ld (debug_mark+1),a  
4c58 3a 62 4c			ld a, (.dmark+2)  
4c5b 32 79 fb			ld (debug_mark+2),a  
4c5e 18 03			jr .pastdmark  
4c60 ..			.dmark: db "BNK"  
4c63 f1			.pastdmark: pop af  
4c64			endm  
# End of macro DMARK
4c64						CALLMONITOR 
4c64 cd 00 14			call break_point_state  
4c67				endm  
# End of macro CALLMONITOR
4c67					endif 
4c67			 
4c67 3e ff				ld a, 255 
4c69 32 5f f8				ld (spi_cartdev), a 
4c6c			 
4c6c					; get bank 
4c6c			 
4c6c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4c6c cd 35 1a			call macro_dsp_valuehl 
4c6f				endm 
# End of macro FORTH_DSP_VALUEHL
4c6f			 
4c6f			;		push hl 
4c6f			 
4c6f					; destroy value TOS 
4c6f			 
4c6f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4c6f cd d1 1a			call macro_forth_dsp_pop 
4c72				endm 
# End of macro FORTH_DSP_POP
4c72			 
4c72					; one value on hl get other one back 
4c72			 
4c72			;		pop hl 
4c72			 
4c72			 
4c72 0e ff				ld c, SPI_CE_HIGH 
4c74			 
4c74 7d					ld a, l 
4c75			 
4c75					if DEBUG_FORTH_WORDS 
4c75						DMARK "BNK" 
4c75 f5				push af  
4c76 3a 8a 4c			ld a, (.dmark)  
4c79 32 77 fb			ld (debug_mark),a  
4c7c 3a 8b 4c			ld a, (.dmark+1)  
4c7f 32 78 fb			ld (debug_mark+1),a  
4c82 3a 8c 4c			ld a, (.dmark+2)  
4c85 32 79 fb			ld (debug_mark+2),a  
4c88 18 03			jr .pastdmark  
4c8a ..			.dmark: db "BNK"  
4c8d f1			.pastdmark: pop af  
4c8e			endm  
# End of macro DMARK
4c8e						CALLMONITOR 
4c8e cd 00 14			call break_point_state  
4c91				endm  
# End of macro CALLMONITOR
4c91					endif 
4c91			 
4c91					; active low 
4c91			 
4c91 fe 00				cp 0 
4c93 28 1e				jr z, .bset 
4c95 fe 01				cp 1 
4c97 20 02				jr nz, .b2 
4c99 cb 81				res 0, c 
4c9b fe 02		.b2:		cp 2 
4c9d 20 02				jr nz, .b3 
4c9f cb 89				res 1, c 
4ca1 fe 03		.b3:		cp 3 
4ca3 20 02				jr nz, .b4 
4ca5 cb 91				res 2, c 
4ca7 fe 04		.b4:		cp 4 
4ca9 20 02				jr nz, .b5 
4cab cb 99				res 3, c 
4cad fe 05		.b5:		cp 5 
4caf 20 02				jr nz, .bset 
4cb1 cb a1				res 4, c 
4cb3			 
4cb3			.bset: 
4cb3 79					ld a, c 
4cb4 32 5c f8				ld (spi_device),a 
4cb7					if DEBUG_FORTH_WORDS 
4cb7						DMARK "BN2" 
4cb7 f5				push af  
4cb8 3a cc 4c			ld a, (.dmark)  
4cbb 32 77 fb			ld (debug_mark),a  
4cbe 3a cd 4c			ld a, (.dmark+1)  
4cc1 32 78 fb			ld (debug_mark+1),a  
4cc4 3a ce 4c			ld a, (.dmark+2)  
4cc7 32 79 fb			ld (debug_mark+2),a  
4cca 18 03			jr .pastdmark  
4ccc ..			.dmark: db "BN2"  
4ccf f1			.pastdmark: pop af  
4cd0			endm  
# End of macro DMARK
4cd0						CALLMONITOR 
4cd0 cd 00 14			call break_point_state  
4cd3				endm  
# End of macro CALLMONITOR
4cd3					endif 
4cd3			 
4cd3					NEXTW 
4cd3 c3 8b 1b			jp macro_next 
4cd6				endm 
# End of macro NEXTW
4cd6			 
4cd6			.CARTDEV: 
4cd6				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
4cd6 66				db WORD_SYS_CORE+82             
4cd7 7f 4d			dw .ENDDEVICE            
4cd9 08				db 7 + 1 
4cda .. 00			db "CARTDEV",0              
4ce2				endm 
# End of macro CWHEAD
4ce2			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
4ce2					if DEBUG_FORTH_WORDS_KEY 
4ce2						DMARK "CDV" 
4ce2 f5				push af  
4ce3 3a f7 4c			ld a, (.dmark)  
4ce6 32 77 fb			ld (debug_mark),a  
4ce9 3a f8 4c			ld a, (.dmark+1)  
4cec 32 78 fb			ld (debug_mark+1),a  
4cef 3a f9 4c			ld a, (.dmark+2)  
4cf2 32 79 fb			ld (debug_mark+2),a  
4cf5 18 03			jr .pastdmark  
4cf7 ..			.dmark: db "CDV"  
4cfa f1			.pastdmark: pop af  
4cfb			endm  
# End of macro DMARK
4cfb						CALLMONITOR 
4cfb cd 00 14			call break_point_state  
4cfe				endm  
# End of macro CALLMONITOR
4cfe					endif 
4cfe			 
4cfe					; disable se storage bank selection 
4cfe			 
4cfe 3e ff				ld a, SPI_CE_HIGH		; ce high 
4d00 32 5c f8				ld (spi_device), a 
4d03			 
4d03					; get bank 
4d03			 
4d03					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d03 cd 35 1a			call macro_dsp_valuehl 
4d06				endm 
# End of macro FORTH_DSP_VALUEHL
4d06			 
4d06			;		push hl 
4d06			 
4d06					; destroy value TOS 
4d06			 
4d06					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d06 cd d1 1a			call macro_forth_dsp_pop 
4d09				endm 
# End of macro FORTH_DSP_POP
4d09			 
4d09					; one value on hl get other one back 
4d09			 
4d09			;		pop hl 
4d09			 
4d09					; active low 
4d09			 
4d09 0e ff				ld c, 255 
4d0b			 
4d0b 7d					ld a, l 
4d0c					if DEBUG_FORTH_WORDS 
4d0c						DMARK "CDV" 
4d0c f5				push af  
4d0d 3a 21 4d			ld a, (.dmark)  
4d10 32 77 fb			ld (debug_mark),a  
4d13 3a 22 4d			ld a, (.dmark+1)  
4d16 32 78 fb			ld (debug_mark+1),a  
4d19 3a 23 4d			ld a, (.dmark+2)  
4d1c 32 79 fb			ld (debug_mark+2),a  
4d1f 18 03			jr .pastdmark  
4d21 ..			.dmark: db "CDV"  
4d24 f1			.pastdmark: pop af  
4d25			endm  
# End of macro DMARK
4d25						CALLMONITOR 
4d25 cd 00 14			call break_point_state  
4d28				endm  
# End of macro CALLMONITOR
4d28					endif 
4d28 fe 00				cp 0 
4d2a 28 30				jr z, .cset 
4d2c fe 01				cp 1 
4d2e 20 02				jr nz, .c2 
4d30 cb 81				res 0, c 
4d32 fe 02		.c2:		cp 2 
4d34 20 02				jr nz, .c3 
4d36 cb 89				res 1, c 
4d38 fe 03		.c3:		cp 3 
4d3a 20 02				jr nz, .c4 
4d3c cb 91				res 2, c 
4d3e fe 04		.c4:		cp 4 
4d40 20 02				jr nz, .c5 
4d42 cb 99				res 3, c 
4d44 fe 05		.c5:		cp 5 
4d46 20 02				jr nz, .c6 
4d48 cb a1				res 4, c 
4d4a fe 06		.c6:		cp 6 
4d4c 20 02				jr nz, .c7 
4d4e cb a9				res 5, c 
4d50 fe 07		.c7:		cp 7 
4d52 20 02				jr nz, .c8 
4d54 cb b1				res 6, c 
4d56 fe 08		.c8:		cp 8 
4d58 20 02				jr nz, .cset 
4d5a cb b9				res 7, c 
4d5c 79			.cset:		ld a, c 
4d5d 32 5f f8				ld (spi_cartdev),a 
4d60			 
4d60					if DEBUG_FORTH_WORDS 
4d60						DMARK "CD2" 
4d60 f5				push af  
4d61 3a 75 4d			ld a, (.dmark)  
4d64 32 77 fb			ld (debug_mark),a  
4d67 3a 76 4d			ld a, (.dmark+1)  
4d6a 32 78 fb			ld (debug_mark+1),a  
4d6d 3a 77 4d			ld a, (.dmark+2)  
4d70 32 79 fb			ld (debug_mark+2),a  
4d73 18 03			jr .pastdmark  
4d75 ..			.dmark: db "CD2"  
4d78 f1			.pastdmark: pop af  
4d79			endm  
# End of macro DMARK
4d79						CALLMONITOR 
4d79 cd 00 14			call break_point_state  
4d7c				endm  
# End of macro CALLMONITOR
4d7c					endif 
4d7c					NEXTW 
4d7c c3 8b 1b			jp macro_next 
4d7f				endm 
# End of macro NEXTW
4d7f			endif 
4d7f			 
4d7f			.ENDDEVICE: 
4d7f			; eof 
4d7f			 
# End of file forth_words_device.asm
4d7f			 
4d7f			; var handler 
4d7f			 
4d7f			 
4d7f			.VARS: 
4d7f				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
4d7f 78				db WORD_SYS_CORE+100             
4d80 97 4d			dw .V0Q            
4d82 04				db 3 + 1 
4d83 .. 00			db "V0!",0              
4d87				endm 
# End of macro CWHEAD
4d87			;| V0! ( u1 -- )  Store value to v0  | DONE 
4d87			 
4d87					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4d87 cd 35 1a			call macro_dsp_valuehl 
4d8a				endm 
# End of macro FORTH_DSP_VALUEHL
4d8a			 
4d8a 11 25 f8				ld de, cli_var_array 
4d8d			 
4d8d eb					ex de, hl 
4d8e 73					ld (hl), e 
4d8f 23					inc hl 
4d90 72					ld (hl), d 
4d91			 
4d91					; destroy value TOS 
4d91			 
4d91					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4d91 cd d1 1a			call macro_forth_dsp_pop 
4d94				endm 
# End of macro FORTH_DSP_POP
4d94			 
4d94				       NEXTW 
4d94 c3 8b 1b			jp macro_next 
4d97				endm 
# End of macro NEXTW
4d97			.V0Q: 
4d97				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4d97 79				db WORD_SYS_CORE+101             
4d98 a8 4d			dw .V1S            
4d9a 04				db 3 + 1 
4d9b .. 00			db "V0@",0              
4d9f				endm 
# End of macro CWHEAD
4d9f			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
4d9f 2a 25 f8				ld hl, (cli_var_array) 
4da2 cd 9a 19				call forth_push_numhl 
4da5			 
4da5				       NEXTW 
4da5 c3 8b 1b			jp macro_next 
4da8				endm 
# End of macro NEXTW
4da8			.V1S: 
4da8				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4da8 7a				db WORD_SYS_CORE+102             
4da9 c0 4d			dw .V1Q            
4dab 04				db 3 + 1 
4dac .. 00			db "V1!",0              
4db0				endm 
# End of macro CWHEAD
4db0			;| V1! ( u1 -- )  Store value to v1 | DONE 
4db0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4db0 cd 35 1a			call macro_dsp_valuehl 
4db3				endm 
# End of macro FORTH_DSP_VALUEHL
4db3			 
4db3 11 27 f8				ld de, cli_var_array+2 
4db6				 
4db6 eb					ex de, hl 
4db7 73					ld (hl), e 
4db8 23					inc hl 
4db9 72					ld (hl), d 
4dba			 
4dba					; destroy value TOS 
4dba			 
4dba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4dba cd d1 1a			call macro_forth_dsp_pop 
4dbd				endm 
# End of macro FORTH_DSP_POP
4dbd				       NEXTW 
4dbd c3 8b 1b			jp macro_next 
4dc0				endm 
# End of macro NEXTW
4dc0			.V1Q: 
4dc0				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4dc0 7b				db WORD_SYS_CORE+103             
4dc1 d1 4d			dw .V2S            
4dc3 04				db 3 + 1 
4dc4 .. 00			db "V1@",0              
4dc8				endm 
# End of macro CWHEAD
4dc8			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4dc8 2a 27 f8				ld hl, (cli_var_array+2) 
4dcb cd 9a 19				call forth_push_numhl 
4dce				       NEXTW 
4dce c3 8b 1b			jp macro_next 
4dd1				endm 
# End of macro NEXTW
4dd1			.V2S: 
4dd1				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4dd1 7c				db WORD_SYS_CORE+104             
4dd2 e9 4d			dw .V2Q            
4dd4 04				db 3 + 1 
4dd5 .. 00			db "V2!",0              
4dd9				endm 
# End of macro CWHEAD
4dd9			;| V2! ( u1 -- )  Store value to v2 | DONE 
4dd9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4dd9 cd 35 1a			call macro_dsp_valuehl 
4ddc				endm 
# End of macro FORTH_DSP_VALUEHL
4ddc			 
4ddc 11 29 f8				ld de, cli_var_array+4 
4ddf				 
4ddf eb					ex de, hl 
4de0 73					ld (hl), e 
4de1 23					inc hl 
4de2 72					ld (hl), d 
4de3			 
4de3					; destroy value TOS 
4de3			 
4de3					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4de3 cd d1 1a			call macro_forth_dsp_pop 
4de6				endm 
# End of macro FORTH_DSP_POP
4de6				       NEXTW 
4de6 c3 8b 1b			jp macro_next 
4de9				endm 
# End of macro NEXTW
4de9			.V2Q: 
4de9				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4de9 7d				db WORD_SYS_CORE+105             
4dea fa 4d			dw .V3S            
4dec 04				db 3 + 1 
4ded .. 00			db "V2@",0              
4df1				endm 
# End of macro CWHEAD
4df1			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4df1 2a 29 f8				ld hl, (cli_var_array+4) 
4df4 cd 9a 19				call forth_push_numhl 
4df7				       NEXTW 
4df7 c3 8b 1b			jp macro_next 
4dfa				endm 
# End of macro NEXTW
4dfa			.V3S: 
4dfa				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
4dfa 7c				db WORD_SYS_CORE+104             
4dfb 12 4e			dw .V3Q            
4dfd 04				db 3 + 1 
4dfe .. 00			db "V3!",0              
4e02				endm 
# End of macro CWHEAD
4e02			;| V3! ( u1 -- )  Store value to v3 | DONE 
4e02					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4e02 cd 35 1a			call macro_dsp_valuehl 
4e05				endm 
# End of macro FORTH_DSP_VALUEHL
4e05			 
4e05 11 2b f8				ld de, cli_var_array+6 
4e08				 
4e08 eb					ex de, hl 
4e09 73					ld (hl), e 
4e0a 23					inc hl 
4e0b 72					ld (hl), d 
4e0c			 
4e0c					; destroy value TOS 
4e0c			 
4e0c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4e0c cd d1 1a			call macro_forth_dsp_pop 
4e0f				endm 
# End of macro FORTH_DSP_POP
4e0f				       NEXTW 
4e0f c3 8b 1b			jp macro_next 
4e12				endm 
# End of macro NEXTW
4e12			.V3Q: 
4e12				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4e12 7d				db WORD_SYS_CORE+105             
4e13 23 4e			dw .END            
4e15 04				db 3 + 1 
4e16 .. 00			db "V3@",0              
4e1a				endm 
# End of macro CWHEAD
4e1a			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
4e1a 2a 2b f8				ld hl, (cli_var_array+6) 
4e1d cd 9a 19				call forth_push_numhl 
4e20				       NEXTW 
4e20 c3 8b 1b			jp macro_next 
4e23				endm 
# End of macro NEXTW
4e23			 
4e23			 
4e23			 
4e23			 
4e23			 
4e23			; end of dict marker 
4e23			 
4e23 00			.END:    db WORD_SYS_END 
4e24 00 00			dw 0 
4e26 00				db 0 
4e27			 
4e27			; use to jp here for user dict words to save on macro expansion  
4e27			 
4e27			user_dict_next: 
4e27				NEXTW 
4e27 c3 8b 1b			jp macro_next 
4e2a				endm 
# End of macro NEXTW
4e2a			 
4e2a			 
4e2a			user_exec: 
4e2a				;    ld hl, <word code> 
4e2a				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
4e2a				;    call forthexec 
4e2a				;    jp user_dict_next   (NEXT) 
4e2a			        ;    <word code bytes> 
4e2a eb				ex de, hl 
4e2b 2a 33 f1			ld hl,(os_tok_ptr) 
4e2e				 
4e2e				FORTH_RSP_NEXT 
4e2e cd 41 19			call macro_forth_rsp_next 
4e31				endm 
# End of macro FORTH_RSP_NEXT
4e31			 
4e31			if DEBUG_FORTH_UWORD 
4e31						DMARK "UEX" 
4e31 f5				push af  
4e32 3a 46 4e			ld a, (.dmark)  
4e35 32 77 fb			ld (debug_mark),a  
4e38 3a 47 4e			ld a, (.dmark+1)  
4e3b 32 78 fb			ld (debug_mark+1),a  
4e3e 3a 48 4e			ld a, (.dmark+2)  
4e41 32 79 fb			ld (debug_mark+2),a  
4e44 18 03			jr .pastdmark  
4e46 ..			.dmark: db "UEX"  
4e49 f1			.pastdmark: pop af  
4e4a			endm  
# End of macro DMARK
4e4a				CALLMONITOR 
4e4a cd 00 14			call break_point_state  
4e4d				endm  
# End of macro CALLMONITOR
4e4d			endif 
4e4d			 
4e4d			 
4e4d			 
4e4d eb				ex de, hl 
4e4e 22 33 f1			ld (os_tok_ptr), hl 
4e51				 
4e51				; Don't use next - Skips the first word in uword. 
4e51			 
4e51 c3 1c 1c			jp exec1 
4e54			;	NEXT 
4e54			 
4e54			 
4e54			; eof 
# End of file forth_wordsv4.asm
4e54			endif 
4e54			;;;;;;;;;;;;;; Debug code 
4e54			 
4e54			 
4e54			;if DEBUG_FORTH_PARSE 
4e54 .. 00		.nowordfound: db "No match",0 
4e5d .. 00		.compword:	db "Comparing word ",0 
4e6d .. 00		.nextwordat:	db "Next word at",0 
4e7a .. 00		.charmatch:	db "Char match",0 
4e85			;endif 
4e85			if DEBUG_FORTH_JP 
4e85			.foundword:	db "Word match. Exec..",0 
4e85			endif 
4e85			;if DEBUG_FORTH_PUSH 
4e85 .. 00		.enddict:	db "Dict end. Push.",0 
4e95 .. 00		.push_str:	db "Pushing string",0 
4ea4 .. 00		.push_num:	db "Pushing number",0 
4eb3 .. 00		.data_sp:	db "SP:",0 
4eb7 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4ec9 .. 00		.wordinde:	db "Word in DE (3/0):",0 
4edb .. 00		.wordinbc:	db "Word in BC (4/0):",0 
4eed			;endif 
4eed			;if DEBUG_FORTH_MALLOC 
4eed .. 00		.push_malloc:	db "Malloc address",0 
4efc			;endif 
4efc			 
4efc			 
4efc			 
4efc			; display malloc address and current data stack pointer  
4efc			 
4efc			malloc_error: 
4efc d5				push de 
4efd f5				push af 
4efe e5				push hl 
4eff cd b9 0a			call clear_display 
4f02 11 24 4f			ld de, .mallocerr 
4f05 3e 00			ld a,0 
4f07			;	ld de,os_word_scratch 
4f07 cd cc 0a			call str_at_display 
4f0a 3e 11			ld a, display_row_1+17 
4f0c 11 77 fb			ld de, debug_mark 
4f0f cd cc 0a			call str_at_display 
4f12 cd dc 0a			call update_display 
4f15				;call break_point_state 
4f15 cd f5 64			call cin_wait 
4f18			 
4f18 3e 20			ld a, ' ' 
4f1a 32 31 ee			ld (os_view_disable), a 
4f1d e1				pop hl 
4f1e f1				pop af 
4f1f d1				pop de	 
4f20				CALLMONITOR 
4f20 cd 00 14			call break_point_state  
4f23				endm  
# End of macro CALLMONITOR
4f23 c9				ret 
4f24			 
4f24 .. 00		.mallocerr: 	db "Malloc Error",0 
4f31			;if DEBUG_FORTH_PUSH 
4f31			display_data_sp: 
4f31 f5				push af 
4f32			 
4f32				; see if disabled 
4f32			 
4f32 3a 31 ee			ld a, (os_view_disable) 
4f35 fe 2a			cp '*' 
4f37 28 67			jr z, .skipdsp 
4f39			 
4f39 e5				push hl 
4f3a e5				push hl 
4f3b e5			push hl 
4f3c cd b9 0a			call clear_display 
4f3f e1			pop hl 
4f40 7c				ld a,h 
4f41 21 37 f1			ld hl, os_word_scratch 
4f44 cd 13 0f			call hexout 
4f47 e1				pop hl 
4f48 7d				ld a,l 
4f49 21 39 f1			ld hl, os_word_scratch+2 
4f4c cd 13 0f			call hexout 
4f4f 21 3b f1			ld hl, os_word_scratch+4 
4f52 3e 00			ld a,0 
4f54 77				ld (hl),a 
4f55 11 37 f1			ld de,os_word_scratch 
4f58 3e 28				ld a, display_row_2 
4f5a cd cc 0a				call str_at_display 
4f5d 11 b7 4e			ld de, .wordinhl 
4f60 3e 00			ld a, display_row_1 
4f62			 
4f62 cd cc 0a				call str_at_display 
4f65 11 77 fb			ld de, debug_mark 
4f68 3e 11			ld a, display_row_1+17 
4f6a			 
4f6a cd cc 0a				call str_at_display 
4f6d			 
4f6d				; display current data stack pointer 
4f6d 11 b3 4e			ld de,.data_sp 
4f70 3e 30				ld a, display_row_2 + 8 
4f72 cd cc 0a				call str_at_display 
4f75			 
4f75 2a 1f f8			ld hl,(cli_data_sp) 
4f78 e5				push hl 
4f79 7c				ld a,h 
4f7a 21 37 f1			ld hl, os_word_scratch 
4f7d cd 13 0f			call hexout 
4f80 e1				pop hl 
4f81 7d				ld a,l 
4f82 21 39 f1			ld hl, os_word_scratch+2 
4f85 cd 13 0f			call hexout 
4f88 21 3b f1			ld hl, os_word_scratch+4 
4f8b 3e 00			ld a,0 
4f8d 77				ld (hl),a 
4f8e 11 37 f1			ld de,os_word_scratch 
4f91 3e 33				ld a, display_row_2 + 11 
4f93 cd cc 0a				call str_at_display 
4f96			 
4f96			 
4f96 cd dc 0a			call update_display 
4f99 cd 3d 0a			call delay1s 
4f9c cd 3d 0a			call delay1s 
4f9f e1				pop hl 
4fa0			.skipdsp: 
4fa0 f1				pop af 
4fa1 c9				ret 
4fa2			 
4fa2			display_data_malloc: 
4fa2			 
4fa2 f5				push af 
4fa3 e5				push hl 
4fa4 e5				push hl 
4fa5 e5			push hl 
4fa6 cd b9 0a			call clear_display 
4fa9 e1			pop hl 
4faa 7c				ld a,h 
4fab 21 37 f1			ld hl, os_word_scratch 
4fae cd 13 0f			call hexout 
4fb1 e1				pop hl 
4fb2 7d				ld a,l 
4fb3 21 39 f1			ld hl, os_word_scratch+2 
4fb6 cd 13 0f			call hexout 
4fb9 21 3b f1			ld hl, os_word_scratch+4 
4fbc 3e 00			ld a,0 
4fbe 77				ld (hl),a 
4fbf 11 37 f1			ld de,os_word_scratch 
4fc2 3e 28				ld a, display_row_2 
4fc4 cd cc 0a				call str_at_display 
4fc7 11 ed 4e			ld de, .push_malloc 
4fca 3e 00			ld a, display_row_1 
4fcc			 
4fcc cd cc 0a				call str_at_display 
4fcf			 
4fcf				; display current data stack pointer 
4fcf 11 b3 4e			ld de,.data_sp 
4fd2 3e 30				ld a, display_row_2 + 8 
4fd4 cd cc 0a				call str_at_display 
4fd7			 
4fd7 2a 1f f8			ld hl,(cli_data_sp) 
4fda e5				push hl 
4fdb 7c				ld a,h 
4fdc 21 37 f1			ld hl, os_word_scratch 
4fdf cd 13 0f			call hexout 
4fe2 e1				pop hl 
4fe3 7d				ld a,l 
4fe4 21 39 f1			ld hl, os_word_scratch+2 
4fe7 cd 13 0f			call hexout 
4fea 21 3b f1			ld hl, os_word_scratch+4 
4fed 3e 00			ld a,0 
4fef 77				ld (hl),a 
4ff0 11 37 f1			ld de,os_word_scratch 
4ff3 3e 33				ld a, display_row_2 + 11 
4ff5 cd cc 0a				call str_at_display 
4ff8			 
4ff8 cd dc 0a			call update_display 
4ffb cd 3d 0a			call delay1s 
4ffe cd 3d 0a			call delay1s 
5001 e1				pop hl 
5002 f1				pop af 
5003 c9				ret 
5004			;endif 
5004			 
5004			include "forth_autostart.asm" 
5004			; list of commands to perform at system start up 
5004			 
5004			startcmds: 
5004			;	dw test11 
5004			;	dw test12 
5004			;	dw test13 
5004			;	dw test14 
5004			;	dw test15 
5004			;	dw test16 
5004			;	dw test17 
5004			;	dw ifthtest1 
5004			;	dw ifthtest2 
5004			;	dw ifthtest3 
5004			;	dw mmtest1 
5004			;	dw mmtest2 
5004			;	dw mmtest3 
5004			;	dw mmtest4 
5004			;	dw mmtest5 
5004			;	dw mmtest6 
5004			;	dw iftest1 
5004			;	dw iftest2 
5004			;	dw iftest3 
5004			;	dw looptest1 
5004			;	dw looptest2 
5004			;	dw test1 
5004			;	dw test2 
5004			;	dw test3 
5004			;	dw test4 
5004			;	dw game2r 
5004			;	dw game2b1 
5004			;	dw game2b2 
5004			 
5004				; start up words that are actually useful 
5004			 
5004 62 50			dw clrstack 
5006 95 50			dw type 
5008 56 52			dw stest 
500a b9 50			dw strncpy 
500c f7 51			dw list 
500e 1a 51			dw start1 
5010 2c 51			dw start2 
5012			;	dw start3 
5012 3f 51			dw start3b 
5014 97 51			dw start3c 
5016			 
5016				; (unit) testing words 
5016			 
5016 cd 52			dw mtesta 
5018 82 53			dw mtestb 
501a 25 54			dw mtestc 
501c da 54			dw mtestd 
501e 7e 55			dw mteste 
5020			 
5020				; demo/game words 
5020			 
5020 8a 5c		        dw game3w 
5022 b8 5c		        dw game3p 
5024 d6 5c		        dw game3sc 
5026 07 5d		        dw game3vsi 
5028 33 5d		        dw game3vs 
502a				 
502a 7d 5a			dw game2b 
502c eb 5a			dw game2bf 
502e 35 5b			dw game2mba 
5030 cb 5b			dw game2mbas 
5032 0d 5c			dw game2mb 
5034			 
5034 3e 57			dw game1 
5036 4f 57			dw game1a 
5038 b1 57			dw game1b 
503a e6 57			dw game1c 
503c 1c 58			dw game1d 
503e 4d 58			dw game1s 
5040 61 58			dw game1t 
5042 76 58			dw game1f 
5044 aa 58			dw game1z 
5046 ee 58			dw game1zz 
5048			 
5048 34 56			dw test5 
504a 6c 56			dw test6 
504c a4 56			dw test7 
504e b8 56			dw test8 
5050 e4 56			dw test9 
5052 fa 56			dw test10 
5054				 
5054 c5 59		        dw ssv5 
5056 a9 59		        dw ssv4 
5058 8d 59		        dw ssv3 
505a 57 59		        dw ssv2 
505c de 59		        dw ssv1 
505e 26 5a		        dw ssv1cpm 
5060			;	dw keyup 
5060			;	dw keydown 
5060			;	dw keyleft 
5060			;	dw keyright 
5060			;	dw 	keyf1 
5060			;	dw keyf2 
5060			;	dw keyf3 
5060			;	dw keyf4 
5060			;	dw keyf5 
5060			;	dw keyf6 
5060			;	dw keyf7 
5060			;	dw keyf8 
5060			;	dw keyf9 
5060			;	dw keyf10 
5060			;	dw keyf11 
5060			;	dw keyf12 
5060			;	dw keytab 
5060			;	dw keycr 
5060			;	dw keyhome 
5060			;	dw keyend 
5060			;	dw keybs 
5060 00 00			db 0, 0	 
5062			 
5062			 
5062			; clear stack  
5062			 
5062 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
5095			 
5095			; type ( addr count - ) 
5095 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
50b9			 
50b9			; some direct memory words 
50b9			; strncpy ( len t f -- t ) 
50b9			 
50b9 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
511a			 
511a .. 00		start1:     	db ": bpon $0000 bp ;",0 
512c .. 00		start2:     	db ": bpoff $0001 bp ;",0 
513f			;start3:         db ": dirlist ir cls drop dup $00 > if $01 do .> BL .> .> BL .> .> BL .> loop then nop ;",0 
513f .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 i at . $01 i at . $04 i at . loop then nop ;",0 
5197 .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
51f7			 
51f7			 
51f7			; a handy word to list items on the stack 
51f7			 
51f7 .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> accept drop depth 0= not until nop ;",0 
5256			 
5256			 
5256			; test stack  
5256			; rnd8 stest 
5256			 
5256 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
52cd			 
52cd			; random malloc and free cycles 
52cd			 
52cd .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5382			 
5382			; fixed malloc and free cycles 
5382			 
5382 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
5425			 
5425			; fixed double string push and drop cycle  
5425			 
5425 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
54da			 
54da			; consistent fixed string push and drop cycle  
54da			 
54da .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
557e			 
557e .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
5634			 
5634			;test1:		db ": aa 1 2 3 ;", 0 
5634			;test2:     	db "111 aa 888 999",0 
5634			;test3:     	db ": bb 77 ;",0 
5634			;test4:     	db "$02 $01 do i . loop bb",0 
5634			 
5634 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
566c .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
56a4 .. 00		test7:     	db ": box hline vline ;",0 
56b8 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
56e4 .. 00		test9:     	db ": sw $01 adsp world ;",0 
56fa .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
571f .. 00		test11:     	db "hello create .",0 
572e .. 00		test12:     	db "hello2 create .",0 
573e			 
573e			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
573e			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
573e			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
573e			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
573e			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
573e			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
573e			 
573e			;iftest1:     	db "$0001 IF cls .",0 
573e			;iftest2:     	db "$0000 IF cls .",0 
573e			;iftest3:     	db "$0002 $0003 - IF cls .",0 
573e			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
573e			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
573e			 
573e			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
573e			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
573e			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
573e			 
573e			 
573e			 
573e			; a small guess the number game 
573e			 
573e .. 00		game1:          db ": gsn rnd8 v1! ;",0 
574f .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
57b1			 
57b1 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
57e6 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
581c .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
584d .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5861 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5876 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
58aa .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
58ee			 
58ee			; Using 'ga' save a high score across multiple runs using external storage 
58ee			 
58ee .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5957			 
5957			 
5957			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5957			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5957			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5957			 
5957			; simple screen saver to test code memory reuse to destruction 
5957			 
5957 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
598d .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
59a9 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
59c5 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
59de .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a26 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
5a7d			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
5a7d			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
5a7d			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
5a7d			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
5a7d			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
5a7d			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
5a7d			 
5a7d			 
5a7d			 
5a7d			; minesweeper/battleship finding game 
5a7d			; draws a game board of random ship/mine positions 
5a7d			; user enters coords to see if it hits on 
5a7d			; game ends when all are hit 
5a7d			; when hit or miss says how many may be in the area 
5a7d			 
5a7d			; setup the game board and then hide it 
5a7d .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
5aeb .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
5b35			; prompt for where to target 
5b35 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
5bcb .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
5bf0			; TODO see if the entered coords hits or misses pushes char hit of miss 
5bf0 .. 00		game2mbht:      db ": mbckht nop ;",0 
5bff .. 00		game2mbms:      db ": mbcms nop ;",0 
5c0d			; TODO how many might be near by 
5c0d .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5c8a			 
5c8a			; Game 3 
5c8a			 
5c8a			; Vert scroller ski game - avoid the trees! 
5c8a			 
5c8a			; v0 score (ie turns) 
5c8a			; v1 player pos 
5c8a			; v2 left wall 
5c8a			; v3 right wall 
5c8a			 
5c8a			; Draw side walls randomly 
5c8a			 
5c8a .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5cb8			 
5cb8			; Draw player 
5cb8 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5cd6			 
5cd6			; TODO Get Key 
5cd6			 
5cd6			; TODO Move left right 
5cd6			 
5cd6			; scroll and move walls a bit 
5cd6			 
5cd6 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
5d07			 
5d07			; main game loop 
5d07			 
5d07 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
5d33 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5d72			 
5d72			; key board defs 
5d72			 
5d72 .. 00		keyup:       db ": keyup $05 ;",0 
5d80 .. 00		keydown:       db ": keydown $0a ;",0 
5d90 .. 00		keyleft:       db ": keyleft $0b ;",0 
5da0 .. 00		keyright:       db ": keyright $0c ;",0 
5db1 .. 00		keyf1:       db ": keyf1 $10 ;",0 
5dbf .. 00		keyf2:       db ": keyf2 $11 ;",0 
5dcd .. 00		keyf3:       db ": keyf3 $12 ;",0 
5ddb .. 00		keyf4:       db ": keyf4 $13 ;",0 
5de9 .. 00		keyf5:       db ": keyf5 $14 ;",0 
5df7 .. 00		keyf6:       db ": keyf6 $15 ;",0 
5e05 .. 00		keyf7:       db ": keyf7 $16 ;",0 
5e13 .. 00		keyf8:       db ": keyf8 $17 ;",0 
5e21 .. 00		keyf9:       db ": keyf9 $18 ;",0 
5e2f .. 00		keyf10:       db ": keyf10 $19 ;",0 
5e3e .. 00		keyf11:       db ": keyf11 $1a ;",0 
5e4d .. 00		keyf12:       db ": keyf12 $1b ;",0 
5e5c			 
5e5c .. 00		keytab:       db ": keytab $09 ;",0 
5e6b .. 00		keycr:       db ": keycr $0d ;",0 
5e79 .. 00		keyhome:       db ": keyhome $0e ;",0 
5e89 .. 00		keyend:       db ": keyend $0f ;",0 
5e98 .. 00		keybs:       db ": keybs $08 ;",0 
5ea6			 
5ea6			   
5ea6			 
5ea6			 
5ea6			 
5ea6			; eof 
# End of file forth_autostart.asm
5ea6			 
5ea6 .. 00		sprompt1: db "Startup load...",0 
5eb6 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
5ecc			 
5ecc			forth_startup: 
5ecc 21 04 50			ld hl, startcmds 
5ecf 3e 00			ld a, 0 
5ed1 32 58 f2			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5ed4			 
5ed4 e5			.start1:	push hl 
5ed5 cd b9 0a			call clear_display 
5ed8 11 a6 5e			ld de, sprompt1 
5edb 3e 00		        ld a, display_row_1 
5edd cd cc 0a			call str_at_display 
5ee0 11 b6 5e			ld de, sprompt2 
5ee3 3e 28		        ld a, display_row_2 
5ee5 cd cc 0a			call str_at_display 
5ee8 e1				pop hl 
5ee9 e5				push hl 
5eea 5e				ld e,(hl) 
5eeb 23				inc hl 
5eec 56				ld d,(hl) 
5eed 3e 50		        ld a, display_row_3 
5eef cd cc 0a			call str_at_display 
5ef2 cd dc 0a			call update_display 
5ef5			 
5ef5			 
5ef5 3a 58 f2			ld a, (os_last_cmd) 
5ef8 fe 00			cp 0 
5efa 28 05			jr z, .startprompt 
5efc cd 31 0a			call delay250ms 
5eff 18 24			jr .startdo 
5f01				 
5f01				 
5f01			 
5f01			.startprompt: 
5f01			 
5f01 3e 9f			ld a,display_row_4 + display_cols - 1 
5f03 11 10 19		        ld de, endprg 
5f06 cd cc 0a			call str_at_display 
5f09 cd dc 0a			call update_display 
5f0c cd 3d 0a			call delay1s 
5f0f cd f5 64			call cin_wait 
5f12						 
5f12 fe 2a			cp '*' 
5f14 28 5e			jr z, .startupend1 
5f16 fe 23			cp '#' 
5f18 20 07			jr nz, .startno 
5f1a 3e 01			ld a, 1 
5f1c 32 58 f2			ld (os_last_cmd),a 
5f1f 18 04			jr .startdo 
5f21 fe 31		.startno:	cp '1' 
5f23 28 3a			jr z,.startnxt  
5f25			 
5f25				; exec startup line 
5f25			.startdo:	 
5f25 e1				pop hl 
5f26 e5				push hl 
5f27				 
5f27 5e				ld e,(hl) 
5f28 23				inc hl 
5f29 56				ld d,(hl) 
5f2a eb				ex de,hl 
5f2b			 
5f2b e5				push hl 
5f2c			 
5f2c 3e 00			ld a, 0 
5f2e				;ld a, FORTH_END_BUFFER 
5f2e cd 7b 10			call strlent 
5f31 23				inc hl   ; include zero term to copy 
5f32 06 00			ld b,0 
5f34 4d				ld c,l 
5f35 e1				pop hl 
5f36 11 32 ee			ld de, scratch 
5f39 ed b0			ldir 
5f3b			 
5f3b			 
5f3b 21 32 ee			ld hl, scratch 
5f3e cd d9 1b			call forthparse 
5f41 cd 19 1c			call forthexec 
5f44 cd 30 1b			call forthexec_cleanup 
5f47			 
5f47 3e 78			ld a, display_row_4 
5f49 11 b4 16			ld de, endprog 
5f4c			 
5f4c cd dc 0a			call update_display		 
5f4f			 
5f4f 3a 58 f2			ld a, (os_last_cmd) 
5f52 fe 00			cp 0 
5f54 20 09			jr nz, .startnxt 
5f56 cd 12 19			call next_page_prompt 
5f59 cd b9 0a		        call clear_display 
5f5c cd dc 0a			call update_display		 
5f5f			 
5f5f				; move onto next startup line? 
5f5f			.startnxt: 
5f5f			 
5f5f cd 31 0a			call delay250ms 
5f62 e1				pop hl 
5f63			 
5f63 23				inc hl 
5f64 23				inc hl 
5f65			 
5f65 e5				push hl 
5f66 5e				ld e, (hl) 
5f67 23				inc hl 
5f68 56				ld d, (hl) 
5f69 e1				pop hl 
5f6a				; TODO replace 0 test 
5f6a			 
5f6a eb				ex de, hl 
5f6b cd 3b 0c			call ishlzero 
5f6e			;	ld a,e 
5f6e			;	add d 
5f6e			;	cp 0    ; any left to do? 
5f6e eb				ex de, hl 
5f6f c2 d4 5e			jp nz, .start1 
5f72 18 01			jr .startupend 
5f74			 
5f74 e1			.startupend1: pop hl 
5f75			.startupend: 
5f75			 
5f75 cd b9 0a			call clear_display 
5f78 cd dc 0a			call update_display 
5f7b c9				ret 
5f7c			 
5f7c			 
5f7c			; stack over and underflow checks 
5f7c			 
5f7c			; init the words to detect the under/overflow 
5f7c			 
5f7c			chk_stk_init: 
5f7c				; a vague random number to check so we dont get any "lucky" hits 
5f7c 3e 2d			ld a, 45 
5f7e 6f				ld l, a 
5f7f 00				nop 
5f80 3e 17			ld a, 23 
5f82 67				ld h, a 
5f83			 
5f83 22 27 ee			ld (chk_word), hl     ; the word we need to check against 
5f86			 
5f86			;	ld (chk_stund), hl	; stack points.... 
5f86 22 fd fb			ld (chk_stovr), hl 
5f89 22 1d f8			ld (chk_ret_und), hl 
5f8c 22 9b f7			ld (chk_ret_ovr), hl 
5f8f 22 99 f5			ld (chk_loop_ovr), hl 
5f92 22 97 f3			ld (chk_data_ovr), hl 
5f95 c9				ret 
5f96				 
5f96			check_stacks: 
5f96				; check all stack words 
5f96			 
5f96 e5				push hl 
5f97 d5				push de 
5f98			 
5f98			;	ld de,(chk_word) 
5f98			;	ld hl, (chk_stund)	; stack points.... 
5f98			;	if DEBUG_STK_FAULT 
5f98			;		DMARK "FAa" 
5f98			;		CALLMONITOR 
5f98			;	endif 
5f98			;	call cmp16 
5f98			;	jp z, .chk_faulta 
5f98			; 
5f98			;	ld de, sfaultsu 
5f98			;	jp .chk_fault 
5f98			 
5f98 2a fd fb		.chk_faulta: ld hl, (chk_stovr) 
5f9b ed 5b 27 ee		ld de,(chk_word) 
5f9f				if DEBUG_STK_FAULT 
5f9f					DMARK "FAb" 
5f9f					CALLMONITOR 
5f9f				endif 
5f9f cd 30 0c			call cmp16 
5fa2 28 06			jr z, .chk_fault1 
5fa4 11 45 60			ld de, sfaultso 
5fa7 c3 f9 5f			jp .chk_fault 
5faa			.chk_fault1:  
5faa 2a 1d f8			ld hl, (chk_ret_und) 
5fad ed 5b 27 ee		ld de,(chk_word) 
5fb1				if DEBUG_STK_FAULT 
5fb1					DMARK "FAU" 
5fb1					CALLMONITOR 
5fb1				endif 
5fb1 cd 30 0c			call cmp16 
5fb4 ca bd 5f			jp z, .chk_fault2 
5fb7 11 55 60			ld de, sfaultru 
5fba c3 f9 5f			jp .chk_fault 
5fbd			.chk_fault2:  
5fbd 2a 9b f7			ld hl, (chk_ret_ovr) 
5fc0 ed 5b 27 ee		ld de,(chk_word) 
5fc4				if DEBUG_STK_FAULT 
5fc4					DMARK "FA1" 
5fc4					CALLMONITOR 
5fc4				endif 
5fc4 cd 30 0c			call cmp16 
5fc7 ca d0 5f			jp z, .chk_fault3 
5fca 11 63 60			ld de, sfaultro 
5fcd c3 f9 5f			jp .chk_fault 
5fd0			.chk_fault3:  
5fd0 2a 99 f5			ld hl, (chk_loop_ovr) 
5fd3 ed 5b 27 ee		ld de,(chk_word) 
5fd7				if DEBUG_STK_FAULT 
5fd7					DMARK "FA2" 
5fd7					CALLMONITOR 
5fd7				endif 
5fd7 cd 30 0c			call cmp16 
5fda ca e3 5f			jp z, .chk_fault4 
5fdd 11 7d 60			ld de, sfaultlo 
5fe0 c3 f9 5f			jp .chk_fault 
5fe3			.chk_fault4:  
5fe3 2a 97 f3			ld hl, (chk_data_ovr) 
5fe6 ed 5b 27 ee		ld de,(chk_word) 
5fea				if DEBUG_STK_FAULT 
5fea					DMARK "FA3" 
5fea					CALLMONITOR 
5fea				endif 
5fea cd 30 0c			call cmp16 
5fed ca f6 5f			jp z, .chk_fault5 
5ff0 11 97 60			ld de, sfaultdo 
5ff3 c3 f9 5f			jp .chk_fault 
5ff6			 
5ff6			 
5ff6			.chk_fault5:  
5ff6 d1				pop de 
5ff7 e1				pop hl 
5ff8			 
5ff8 c9				ret 
5ff9			 
5ff9 cd b9 0a		.chk_fault: 	call clear_display 
5ffc 3e 28				ld a, display_row_2 
5ffe cd cc 0a				call str_at_display 
6001 11 27 60				   ld de, .stackfault 
6004 3e 00				ld a, display_row_1 
6006 cd cc 0a				call str_at_display 
6009 11 77 fb				    ld de, debug_mark 
600c 3e 11				ld a, display_row_1+17 
600e cd cc 0a				call str_at_display 
6011 cd dc 0a				call update_display 
6014			 
6014				; prompt before entering montior for investigating issue 
6014			 
6014 3e 78			ld a, display_row_4 
6016 11 b4 16			ld de, endprog 
6019			 
6019 cd dc 0a			call update_display		 
601c			 
601c cd 12 19			call next_page_prompt 
601f			 
601f d1				pop de 
6020 e1				pop hl 
6021 cd 08 17				call monitor 
6024 c3 f5 15				jp warmstart 
6027					;jp 0 
6027					;halt 
6027			 
6027			 
6027			 
6027 .. 00		.stackfault: 	db "Stack fault:",0 
6034			 
6034 .. 00		sfaultsu: 	db	"Stack under flow",0 
6045 .. 00		sfaultso: 	db	"Stack over flow",0 
6055 .. 00		sfaultru:	db "RTS underflow",0 
6063 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
607d .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
6097 .. 00		sfaultdo:	db "DTS overflow", 0 
60a4			 
60a4			 
60a4			fault_dsp_under: 
60a4 11 b6 60			ld de, .dsp_under 
60a7 c3 66 61			jp .show_fault 
60aa			 
60aa			fault_rsp_under: 
60aa 11 c4 60			ld de, .rsp_under 
60ad c3 66 61			jp .show_fault 
60b0			fault_loop_under: 
60b0 11 d2 60			ld de, .loop_under 
60b3 c3 66 61			jp .show_fault 
60b6			 
60b6 .. 00		.dsp_under: db "DSP Underflow",0 
60c4 .. 00		.rsp_under: db "RSP Underflow",0 
60d2 .. 00		.loop_under: db "LOOP Underflow",0 
60e1			 
60e1			 
60e1 d5			type_faultn: 	push de 
60e2 e5					push hl 
60e3 cd b9 0a				call clear_display 
60e6 11 0d 61				   ld de, .typefaultn 
60e9 3e 00				ld a, display_row_1 
60eb cd cc 0a				call str_at_display 
60ee 11 77 fb				    ld de, debug_mark 
60f1 3e 11				ld a, display_row_1+17 
60f3 cd cc 0a				call str_at_display 
60f6 cd dc 0a				call update_display 
60f9			 
60f9				; prompt before entering montior for investigating issue 
60f9			 
60f9 3e 78			ld a, display_row_4 
60fb 11 b4 16			ld de, endprog 
60fe			 
60fe cd dc 0a			call update_display		 
6101			 
6101 cd 12 19			call next_page_prompt 
6104			 
6104 e5					push hl 
6105 d5					push de 
6106 cd 08 17				call monitor 
6109 c3 f5 15				jp warmstart 
610c 76					halt 
610d			 
610d			 
610d .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
6124			 
6124 d5			type_faults: 	push de 
6125 e5					push hl 
6126 cd b9 0a				call clear_display 
6129 11 4f 61				   ld de, .typefaults 
612c 3e 00				ld a, display_row_1 
612e cd cc 0a				call str_at_display 
6131 11 77 fb				    ld de, debug_mark 
6134 3e 11				ld a, display_row_1+17 
6136 cd cc 0a				call str_at_display 
6139 cd dc 0a				call update_display 
613c			 
613c				; prompt before entering montior for investigating issue 
613c			 
613c 3e 78			ld a, display_row_4 
613e 11 b4 16			ld de, endprog 
6141			 
6141 cd dc 0a			call update_display		 
6144			 
6144 cd 12 19			call next_page_prompt 
6147			 
6147 e1					pop hl 
6148 d1					pop de 
6149 cd 08 17				call monitor 
614c c3 f5 15				jp warmstart 
614f			 
614f			 
614f .. 00		.typefaults: db "STR Type Expected TOS!",0 
6166			 
6166			.show_fault: 	 
6166 d5					push de 
6167 cd b9 0a				call clear_display 
616a d1					pop de 
616b 3e 00				ld a, display_row_1 
616d cd cc 0a				call str_at_display 
6170 11 77 fb				    ld de, debug_mark 
6173 3e 11				ld a, display_row_1+17 
6175 cd cc 0a				call str_at_display 
6178 cd dc 0a				call update_display 
617b			 
617b				; prompt before entering montior for investigating issue 
617b			 
617b 3e 78			ld a, display_row_4 
617d 11 b4 16			ld de, endprog 
6180			 
6180 cd dc 0a			call update_display		 
6183			 
6183 cd 12 19			call next_page_prompt 
6186			 
6186 e1					pop hl 
6187 d1					pop de 
6188 cd 08 17				call monitor 
618b			; do a dump to cli and not warmstart so we preserve all of the uwords.  
618b			; TODO Make optional fault restart to cli or warm boot? 
618b					;jp warmstart 
618b c3 4d 16				jp cli 
618e 76					halt 
618f			; eof 
# End of file forth_kernel.asm
618f			;include "nascombasic.asm" 
618f			 
618f			 
618f			; find out where the code ends if loaded into RAM (for SC114) 
618f			;endofcode:  
618f			;	nop 
618f			 
618f			 
618f			; eof 
618f			 
# End of file main.asm
618f			include "firmware_lcd_4x40.asm" 
618f			; **********************************************************************  
618f			; **  Alphanumeric LCD example                  by Stephen C Cousins  **  
618f			; **********************************************************************  
618f			;  
618f			; **  Written as a Small Computer Monitor App  
618f			; **  www.scc.me.uk  
618f			;  
618f			; History  
618f			; 2018-05-20  v0.2.0  SCC  Example for LiNC80 SBC1 only  
618f			; 2018-06-28  v0.3.0  SCC  Added support for RC2014 and Z280RC  
618f			; 2019-09-14  v0.4.0  SCC  Added support for SC129 digital I/O module  
618f			;  
618f			; **********************************************************************  
618f			;  
618f			; This program is an example of one of the methods of interfacing an   
618f			; alphanumeric LCD module.   
618f			;  
618f			; In this example the display is connected to either a Z80 PIO or a   
618f			; simple 8-bit output port.   
618f			;  
618f			; This interfacing method uses 4-bit data mode and uses time delays  
618f			; rather than polling the display's ready status. As a result the   
618f			; interface only requires 6 simple output lines:  
618f			;   Output bit 0 = not used  
618f			;   Output bit 1 = not used  
618f			;   Output bit 2 = RS         High = data, Low = instruction  
618f			;   Output bit 3 = E          Active high  
618f			;   Output bit 4 = DB4  
618f			;   Output bit 5 = DB5  
618f			;   Output bit 6 = DB6  
618f			;   Output bit 7 = DB7  
618f			; Display's R/W is connected to 0v so it is always in write mode  
618f			;  
618f			; This set up should work with any system supporting the RC2014 bus  
618f			  
618f			; To set up PIO port A in mode 3 (control) using LiNC80 as example  
618f			;   I/O address 0x1A = 0b11001111 (0xCF)   Select mode 3 (control)  
618f			;   I/O address 0x1A = 0b00000000 (0x00)   All pins are output  
618f			;  
618f			; **********************************************************************  
618f			  
618f			; Additonal for 4x40. E1 and E2 instead of just E   
618f			; TODO swipe vidout signal on port a to activate E2  
618f			  
618f			; **********************************************************************  
618f			; **  Constants  
618f			; **********************************************************************  
618f			; LCD constants required by LCD support module  
618f			kLCDPrt:    EQU kDataReg       ;LCD port is the PIO port A data reg  
618f			kLCDBitRS:  EQU 2              ;Port bit for LCD RS signal  
618f			kLCDBitE:   EQU 3              ;Port bit for LCD E signal             
618f			kLCDBitE2:   EQU 0              ;Port bit for LCD E2 signal            VIDOUT  
618f			; TODO Decide which E is being set  
618f			kLCDWidth:  EQU display_cols             ;Width in characters  
618f			  
618f			; **********************************************************************  
618f			; **  Code library usage  
618f			; **********************************************************************  
618f			  
618f			; send character to current cursor position  
618f			; wraps and/or scrolls screen automatically  
618f			  
618f			  
618f			  
618f			lcd_init:  
618f			  
618f			; SCMonAPI functions used  
618f			  
618f			; Alphanumeric LCD functions used  
618f			; no need to specify specific functions for this module  
618f			  
618f 3e cf		            LD   A, 11001111b  
6191 d3 c2		            OUT  (kContReg), A  ;Port A = PIO 'control' mode  
6193 3e 00		            LD   A, 00000000b  
6195 d3 c2		            OUT  (kContReg),A   ;Port A = all lines are outputs  
6197			  
6197			; Initialise alphanumeric LCD module  
6197 3e 00				ld a, 0  
6199 32 d7 f8				ld (display_lcde1e2), a  
619c cd 1d 62		            CALL fLCD_Init      ;Initialise LCD module  
619f 3e 01				ld a, 1  
61a1 32 d7 f8				ld (display_lcde1e2), a  
61a4 cd 1d 62		            CALL fLCD_Init      ;Initialise LCD module  
61a7			  
61a7 c9				ret  
61a8			  
61a8			;  
61a8			;;  
61a8			; lcd functions  
61a8			;  
61a8			;  
61a8			  
61a8			; what is at cursor position   
61a8			  
61a8			;get_cursor:	ld de, (cursor_row)   ;  row + col  
61a8			;		call curptr  
61a8			;		ret  
61a8			  
61a8			  
61a8			; take current custor pos in de (d=row,e=col) and return a pointer to the frame buffer  
61a8			  
61a8			curptr:  
61a8 c5				push bc  
61a9 21 bd fa			ld hl, display_fb0  
61ac			cpr:	  
61ac				; loop for cursor whole row  
61ac 0e 28			ld c, display_cols  
61ae 23			cpr1:	inc hl  
61af 0d				dec c  
61b0 20 fc			jr nz, cpr1  
61b2 05				dec b  
61b3 20 f7			jr nz, cpr  
61b5			  
61b5				; add col	  
61b5			  
61b5 23			cpr2:	inc hl  
61b6 1d				dec e  
61b7 20 fc			jr nz, cpr2  
61b9			  
61b9 c1				pop bc  
61ba c9				ret  
61bb				  
61bb			  
61bb			  
61bb			  
61bb			  
61bb			; write the frame buffer given in hl to hardware   
61bb 22 d5 f8		write_display: ld (display_write_tmp), hl 	   
61be 3e 00			ld a, kLCD_Line1  
61c0 cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61c3 06 28			ld b, display_cols  
61c5 ed 5b d5 f8		ld de, (display_write_tmp)  
61c9 cd 15 62			call write_len_string  
61cc				  
61cc				  
61cc 2a d5 f8			ld hl, (display_write_tmp)  
61cf 11 28 00			ld de, display_cols  
61d2 19				add hl,de  
61d3 22 d5 f8			ld (display_write_tmp),hl  
61d6			  
61d6				  
61d6 3e 28			ld a, kLCD_Line2  
61d8 cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61db 06 28			ld b, display_cols  
61dd ed 5b d5 f8		ld de, (display_write_tmp)  
61e1 cd 15 62			call write_len_string  
61e4				  
61e4 2a d5 f8			ld hl, (display_write_tmp)  
61e7 11 28 00			ld de, display_cols  
61ea 19				add hl,de  
61eb 22 d5 f8			ld (display_write_tmp),hl  
61ee			  
61ee				  
61ee 3e 50			ld a, kLCD_Line3  
61f0 cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
61f3 06 28			ld b, display_cols  
61f5 ed 5b d5 f8		ld de, (display_write_tmp)  
61f9 cd 15 62			call write_len_string  
61fc				  
61fc 2a d5 f8			ld hl, (display_write_tmp)  
61ff 11 28 00			ld de, display_cols  
6202 19				add hl,de  
6203 22 d5 f8			ld (display_write_tmp),hl  
6206			  
6206				  
6206 3e 78			ld a, kLCD_Line4  
6208 cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
620b 06 28			ld b, display_cols  
620d ed 5b d5 f8		ld de, (display_write_tmp)  
6211 cd 15 62			call write_len_string  
6214 c9					ret  
6215				  
6215				; write out a fixed length string given in b from de  
6215			  
6215 1a			write_len_string:   LD   A, (DE)        ;Get character from string  
6216 cd 82 62		            CALL fLCD_Data      ;Write character to display  
6219 13				inc de  
621a 10 f9			djnz write_len_string  
621c c9				ret  
621d			  
621d			; Some other things to do  
621d			;            LD   A, kLCD_Clear ;Display clear  
621d			;            LD   A, kLCD_Blink ;Display on with blinking block cursor  
621d			;            LD   A, kLCD_Under ;Display on with underscore cursor  
621d			;            LD   A, kLCD_On     ;Display on with no cursor  
621d			;            ;LD   A, kLCD_Off   ;Display off  
621d			;            CALL fLCD_Inst      ;Send instruction to display  
621d			;  
621d			;  
621d			;            halt  
621d			;  
621d			;  
621d			;MsgHello:   DB  "Hello World!",0  
621d			;MsgLiNC80:   DB  "From my Z80-homebrew",0  
621d			  
621d			; Custom characters 5 pixels wide by 8 pixels high  
621d			; Up to 8 custom characters can be defined  
621d			;BitMaps:      
621d			;; Character 0x00 = Battery icon  
621d			;            DB  01110b  
621d			;            DB  11011b  
621d			;            DB  10001b  
621d			;            DB  10001b  
621d			;            DB  11111b  
621d			;            DB  11111b  
621d			;            DB  11111b  
621d			;            DB  11111b  
621d			;; Character 0x01 = Bluetooth icon  
621d			;            DB  01100b  
621d			;            DB  01010b  
621d			;            DB  11100b  
621d			;            DB  01000b  
621d			;            DB  11100b  
621d			;            DB  01010b  
621d			;            DB  01100b  
621d			;            DB  00000b  
621d			;  
621d			  
621d			  
621d			; **********************************************************************  
621d			; **  Alphanumeric LCD support                  by Stephen C Cousins  **  
621d			; **********************************************************************  
621d			;  
621d			; **  Written as a Small Computer Monitor App   
621d			; **  Version 0.1 SCC 2018-05-16  
621d			; **  www.scc.me.uk  
621d			;  
621d			; **********************************************************************  
621d			;  
621d			; This module provides support for alphanumeric LCD modules using with  
621d			; *  HD44780 (or compatible) controller  
621d			; *  5 x 7 pixel fonts  
621d			; *  Up to 80 characters in total (eg. 4 lines of 20 characters)  
621d			; *  Interface via six digital outputs to the display (see below)  
621d			;  
621d			; LCD module pinout:  
621d			;   1  Vss   0v supply  
621d			;   2  Vdd   5v supply  
621d			;   3  Vo    LCD input voltage (near zero volts via potentiometer)  
621d			;   4  RS    High = data, Low = instruction  
621d			;   5  R/W   High = Read, Low = Write  
621d			;   6  E     Enable signal (active high)  
621d			;   7  DB0   Data bit 0  
621d			;   8  DB1   Data bit 1  
621d			;   9  DB2   Data bit 2  
621d			;  10  DB3   Data bit 3  
621d			;  11  DB4   Data bit 4  
621d			;  12  DB5   Data bit 5  
621d			;  13  DB6   Data bit 6  
621d			;  14  DB7   Data bit 7  
621d			;  15  A     Backlight anode (+)  
621d			;  16  K     Backlight cathode (-)  
621d			;  
621d			; This interfacing method uses 4-bit data mode and uses time delays  
621d			; rather than polling the display's ready status. As a result the   
621d			; interface only requires 6 simple output lines:  
621d			;   LCD E   = Microcomputer output port bit <kLCDBitE>  
621d			;   LCD RS  = Microcomputer output port bit <kLCDBitRS>  
621d			;   LCD DB4 = Microcomputer output port bit 4  
621d			;   LCD DB5 = Microcomputer output port bit 5  
621d			;   LCD DB6 = Microcomputer output port bit 6  
621d			;   LCD DB7 = Microcomputer output port bit 7  
621d			; Display's R/W is connected to 0v so it is always in write mode  
621d			; All 6 connections must be on the same port address <kLCDPrt>  
621d			; This method also allows a decent length of cable from micro to LCD  
621d			;  
621d			; **********************************************************************  
621d			;  
621d			; To include the code for any given function provided by this module,   
621d			; add the appropriate #REQUIRES <FunctionName> statement at the top of   
621d			; the parent source file.  
621d			; For example:  #REQUIRES   uHexPrefix  
621d			;  
621d			; Also #INCLUDE this file at some point after the #REQUIRES statements  
621d			; in the parent source file.  
621d			; For example:  #INCLUDE    ..\_CodeLibrary\Utilities.asm  
621d			;  
621d			; These are the function names provided by this module:  
621d			; fLCD_Init                     ;Initialise LCD  
621d			; fLCD_Inst                     ;Send instruction to LCD  
621d			; fLCD_Data                     ;Send data byte to LCD  
621d			; fLCD_Pos                      ;Position cursor  
621d			; fLCD_Str                      ;Display string  
621d			; fLCD_Def                      ;Define custom character  
621d			;  
621d			; **********************************************************************  
621d			;  
621d			; Requires SCMonAPI.asm to also be included in the project  
621d			;  
621d			  
621d			  
621d			; **********************************************************************  
621d			; **  Constants  
621d			; **********************************************************************  
621d			  
621d			; Constants that must be defined externally  
621d			;kLCDPrt:   EQU 0xc0           ;Port address used for LCD  
621d			;kLCDBitRS: EQU 2              ;Port bit for LCD RS signal  
621d			;kLCDBitE:  EQU 3              ;Port bit for LCD E signal  
621d			;kLCDWidth: EQU 20             ;Width in characters  
621d			  
621d			; general line offsets in any frame buffer  
621d			  
621d			  
621d			display_row_1: equ 0  
621d			display_row_2: equ display_row_1+display_cols  
621d			display_row_3: equ display_row_2 + display_cols  
621d			display_row_4: equ display_row_3 + display_cols  
621d			;display_row_4_eol:   
621d			  
621d			  
621d			; Cursor position values for the start of each line  
621d			  
621d			; E  
621d			kLCD_Line1: EQU 0x00   
621d			kLCD_Line2: EQU kLCD_Line1+kLCDWidth  
621d			; E1  
621d			kLCD_Line3: EQU kLCD_Line2+kLCDWidth  
621d			kLCD_Line4: EQU kLCD_Line3+kLCDWidth   
621d			  
621d			; Instructions to send as A register to fLCD_Inst  
621d			kLCD_Clear: EQU 00000001b     ;LCD clear  
621d			kLCD_Off:   EQU 00001000b     ;LCD off  
621d			kLCD_On:    EQU 00001100b     ;LCD on, no cursor or blink  
621d			kLCD_Under: EQU 00001110b     ;LCD on, cursor = underscore  
621d			kLCD_Blink: EQU 00001101b     ;LCD on, cursor = blink block  
621d			kLCD_Both:  EQU 00001111b     ;LCD on, cursor = under+blink  
621d			  
621d			; Constants used by this code module  
621d			kLCD_Clr:   EQU 00000001b     ;LCD command: Clear display  
621d			kLCD_Pos:   EQU 10000000b     ;LCD command: Position cursor  
621d			kLCD_Def:   EQU 01000000b     ;LCD command: Define character  
621d			  
621d			  
621d			  
621d			; **********************************************************************  
621d			; **  LCD support functions  
621d			; **********************************************************************  
621d			  
621d			; Initialise alphanumeric LCD module  
621d			; LCD control register codes:  
621d			;   DL   0 = 4-bit mode        1 = 8-bit mode  
621d			;   N    0 = 1-line mode       1 = 2-line mode  
621d			;   F    0 = Font 5 x 8        1 = Font 5 x 11  
621d			;   D    0 = Display off       1 = Display on  
621d			;   C    0 = Cursor off        1 = Cursor on  
621d			;   B    0 = Blinking off      1 = Blinking on  
621d			;   ID   0 = Decrement mode    1 = Increment mode  
621d			;   SH   0 = Entire shift off  1 = Entire shift on  
621d 3e 28		fLCD_Init:  LD   A, 40  
621f cd 44 63		            CALL LCDDelay       ;Delay 40ms after power up  
6222			; For reliable reset set 8-bit mode - 3 times  
6222 cd 14 63		            CALL WrFn8bit       ;Function = 8-bit mode  
6225 cd 14 63		            CALL WrFn8bit       ;Function = 8-bit mode  
6228 cd 14 63		            CALL WrFn8bit       ;Function = 8-bit mode  
622b			; Set 4-bit mode  
622b cd 10 63		            CALL WrFn4bit       ;Function = 4-bit mode  
622e cd 42 63		            CALL LCDDelay1      ;Delay 37 us or more  
6231			; Function set  
6231 3e 28		            LD   A, 00101000b  ;Control reg:  0  0  1  DL N  F  x  x  
6233 cd 46 62		            CALL fLCD_Inst      ;2 line, display on  
6236			; Display On/Off control  
6236 3e 0c		            LD   A, 00001100b  ;Control reg:  0  0  0  0  1  D  C  B   
6238 cd 46 62		            CALL fLCD_Inst      ;Display on, cursor on, blink off  
623b			; Display Clear  
623b 3e 01		            LD   A, 00000001b  ;Control reg:  0  0  0  0  0  0  0  1  
623d cd 46 62		            CALL fLCD_Inst      ;Clear display  
6240			; Entry mode  
6240 3e 06		            LD   A, 00000110b  ;Control reg:  0  0  0  0  0  1  ID SH  
6242 cd 46 62		            CALL fLCD_Inst      ;Increment mode, shift off  
6245			; Display module now initialised  
6245 c9			            RET  
6246			; ok to here  
6246			  
6246			; Write instruction to LCD  
6246			;   On entry: A = Instruction byte to be written  
6246			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6246 f5			fLCD_Inst:  PUSH AF  
6247 f5			            PUSH AF  
6248 cd 5a 62		            CALL Wr4bits       ;Write bits 4 to 7 of instruction  
624b f1			            POP  AF  
624c 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
624d 17			            RLA  
624e 17			            RLA  
624f 17			            RLA  
6250 cd 5a 62		            CALL Wr4bits       ;Write bits 0 to 3 of instruction  
6253 3e 02		            LD   A, 2  
6255 cd 44 63		            CALL LCDDelay       ;Delay 2 ms to complete   
6258 f1			            POP  AF  
6259 c9			            RET  
625a			Wr4bits:   
625a f5					push af  
625b 3a d7 f8				ld a, (display_lcde1e2)  
625e fe 00				cp 0     ; e  
6260 20 10				jr nz, .wea2	  
6262 f1					pop af  
6263 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6265 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6267 cb df		            SET  kLCDBitE, A	    ; TODO decide which E is being set  
6269 cb 87		            res  kLCDBitE2, A	    ; TODO decide which E is being set  
626b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
626d cb 9f		            RES  kLCDBitE, A        ; TODO decide which E is being set  
626f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6271 c9			            RET  
6272 f1			.wea2:		pop af  
6273 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
6275 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6277 cb c7		            SET  kLCDBitE2, A	    ; TODO decide which E is being set  
6279 cb 9f		            res  kLCDBitE, A	    ; TODO decide which E is being set  
627b d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
627d cb 87		            RES  kLCDBitE2, A        ; TODO decide which E is being set  
627f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6281 c9			            RET  
6282			  
6282			  
6282			; Write data to LCD  
6282			;   On entry: A = Data byte to be written  
6282			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6282 f5			fLCD_Data:  PUSH AF  
6283 f5			            PUSH AF  
6284 cd 96 62		            CALL Wr4bitsa       ;Write bits 4 to 7 of data byte  
6287 f1			            POP  AF  
6288 17			            RLA                 ;Rotate bits 0-3 into bits 4-7...  
6289 17			            RLA  
628a 17			            RLA  
628b 17			            RLA  
628c cd 96 62		            CALL Wr4bitsa       ;Write bits 0 to 3 of data byte  
628f 3e 96		            LD   A, 150  
6291 3d			Wait:      DEC  A              ;Wait a while to allow data   
6292 20 fd		            JR   NZ, Wait      ;  write to complete  
6294 f1			            POP  AF  
6295 c9			            RET  
6296			Wr4bitsa:     
6296 f5					push af  
6297 3a d7 f8				ld a, (display_lcde1e2)  
629a fe 00				cp 0     ; e1  
629c 20 16				jr nz, .we2	  
629e f1					pop af  
629f e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
62a1 cb d7		            SET  kLCDBitRS, A  
62a3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62a5 cb df		            SET  kLCDBitE, A      ; TODO Decide which E is being set  
62a7 cb 87		            res  kLCDBitE2, A      ; TODO Decide which E is being set  
62a9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
62ab cb 9f		            RES  kLCDBitE, A       ; TODO Decide which E is being set  
62ad d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62af cb 97		            RES  kLCDBitRS, A  
62b1 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62b3 c9			            RET  
62b4 f1			.we2:		pop af  
62b5 e6 f0			    AND  0xF0           ;Mask so we only have D4 to D7  
62b7 cb d7		            SET  kLCDBitRS, A  
62b9 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62bb cb c7		            SET  kLCDBitE2, A      ; TODO Decide which E is being set  
62bd cb 9f		            res  kLCDBitE, A      ; TODO Decide which E is being set  
62bf d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=High  
62c1 cb 87		            RES  kLCDBitE2, A       ; TODO Decide which E is being set  
62c3 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=High  
62c5 cb 97		            RES  kLCDBitRS, A  
62c7 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
62c9 c9			            RET  
62ca			  
62ca			  
62ca			; Position cursor to specified location  
62ca			;   On entry: A = Cursor position  
62ca			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
62ca f5			fLCD_Pos:   PUSH AF  
62cb					; at this point set the E1 or E2 flag depending on position  
62cb			  
62cb c5					push bc  
62cc			;		push af  
62cc 06 00				ld b, 0  
62ce 4f					ld c, a  
62cf 3e 4f				ld a, kLCD_Line3-1  
62d1 b7			 		or a      ;clear carry flag  
62d2 99					sbc a,c    ; TODO may need to sub 80 from a to put in context of current frame    
62d3 38 04				jr c, .pe1  
62d5			  
62d5					; E selection  
62d5 cb 80				res 0, b         ; bit 0 unset e  
62d7			;		pop af    ; before line 3 so recover orig pos  
62d7			;		ld c, a    ; save for poking back  
62d7 18 06				jr .peset	          
62d9			.pe1:          	; E2 selection  
62d9 cb c0				set 0, b         ; bit 0 set e1  
62db 79					ld a, c  
62dc de 4f				sbc a, kLCD_Line3-1  
62de 4f					ld c, a	         ; save caculated offset  
62df			;		pop af     ; bin this original value now we have calculated form  
62df			  
62df			.peset:		; set bit  
62df 78					ld a, b  
62e0 32 d7 f8				ld (display_lcde1e2), a 	  
62e3 79					ld a, c  
62e4 c1					pop bc  
62e5			  
62e5 f6 80		            OR   kLCD_Pos       ;Prepare position cursor instruction  
62e7 cd 46 62		            CALL fLCD_Inst      ;Write instruction to LCD  
62ea f1			            POP  AF  
62eb c9			            RET  
62ec			  
62ec			  
62ec			; Output text string to LCD  
62ec			;   On entry: DE = Pointer to null terminated text string  
62ec			;   On exit:  BC HL IX IY I AF' BC' DE' HL' preserved  
62ec 1a			fLCD_Str:   LD   A, (DE)        ;Get character from string  
62ed b7			            OR   A              ;Null terminator?  
62ee c8			            RET  Z              ;Yes, so finished  
62ef cd 82 62		            CALL fLCD_Data      ;Write character to display  
62f2 13			            INC  DE             ;Point to next character  
62f3 18 f7		            JR   fLCD_Str       ;Repeat  
62f5 c9					ret  
62f6			  
62f6			; Define custom character  
62f6			;   On entry: A = Character number (0 to 7)  
62f6			;             DE = Pointer to character bitmap data  
62f6			;   On exit:  A = Next character number  
62f6			;             DE = Next location following bitmap  
62f6			;             BC HL IX IY I AF' BC' DE' HL' preserved  
62f6			; Character is   
62f6 c5			fLCD_Def:   PUSH BC  
62f7 f5			            PUSH AF  
62f8 07			            RLCA                ;Calculate location  
62f9 07			            RLCA                ;  for bitmap data  
62fa 07			            RLCA                ;  = 8 x CharacterNumber  
62fb f6 40		            OR   kLCD_Def       ;Prepare define character instruction  
62fd cd 46 62		            CALL fLCD_Inst      ;Write instruction to LCD  
6300 06 00		            LD   B, 0  
6302 1a			Loop:      LD   A, (DE)        ;Get byte from bitmap  
6303 cd 82 62		            CALL fLCD_Data      ;Write byte to display  
6306 13			            INC  DE             ;Point to next byte  
6307 04			            INC  B              ;Count bytes  
6308 cb 58		            BIT  3, B           ;Finish all 8 bytes?  
630a 28 f6		            JR   Z, Loop       ;No, so repeat  
630c f1			            POP  AF  
630d 3c			            INC  A              ;Increment character number  
630e c1			            POP  BC  
630f c9			            RET  
6310			  
6310			  
6310			; **********************************************************************  
6310			; **  Private functions  
6310			; **********************************************************************  
6310			  
6310			; Write function to LCD  
6310			;   On entry: A = Function byte to be written  
6310			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6310 3e 20		WrFn4bit:   LD   A, 00100000b  ;4-bit mode  
6312 18 02		            JR   WrFunc  
6314 3e 30		WrFn8bit:   LD   A, 00110000b  ;8-bit mode  
6316 f5			WrFunc:     PUSH AF  
6317 f5					push af  
6318 3a d7 f8				ld a, (display_lcde1e2)  
631b fe 00				cp 0     ; e1  
631d 20 0f				jr nz, .wfea2	  
631f f1					pop af  
6320 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6322 cb df		            SET  kLCDBitE, A     ; TODO Decide which E is being set  
6324 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6326 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6328 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
632a d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
632c 18 0d			jr .wfskip  
632e f1			.wfea2:		pop af  
632f d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
6331 cb c7		            SET  kLCDBitE2, A     ; TODO Decide which E is being set  
6333 cb 9f		            RES  kLCDBitE, A      ; TODO Decide which E is being set  
6335 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=High and RS=Low  
6337 cb 87		            RES  kLCDBitE2, A      ; TODO Decide which E is being set  
6339 d3 c0		            OUT  (kLCDPrt), A   ;Output with E=Low and RS=Low  
633b 3e 05		.wfskip:            LD  A, 5  
633d cd 44 63		            CALL LCDDelay       ;Delay 5 ms to complete  
6340 f1			            POP  AF  
6341 c9			            RET  
6342			  
6342			  
6342			; Delay in milliseconds  
6342			;   On entry: A = Number of milliseconds delay  
6342			;   On exit:  AF BC DE HL IX IY I AF' BC' DE' HL' preserved  
6342 3e 01		LCDDelay1:  LD   A, 1           ;Delay by 1 ms  
6344 d5			LCDDelay:   PUSH DE  
6345 5f			            LD   E, A           ;Delay by 'A' ms  
6346 16 00		            LD   D, 0  
6348 cd 22 0a		            CALL aDelayInMS  
634b d1			            POP  DE  
634c c9			            RET  
634d			  
634d			  
634d			testlcd:  
634d 3e 00			ld a, kLCD_Line1  
634f cd ca 62			call fLCD_Pos  
6352 06 28			ld b, 40  
6354 11 82 63			ld de, .ttext1  
6357 cd 15 62			call write_len_string  
635a			  
635a 3e 28			ld a, kLCD_Line2  
635c cd ca 62			call fLCD_Pos  
635f 06 28			ld b, 40  
6361 11 ab 63			ld de, .ttext2  
6364 cd 15 62			call write_len_string  
6367 3e 50			ld a, kLCD_Line3  
6369 cd ca 62			call fLCD_Pos  
636c 06 28			ld b, 40  
636e 11 d4 63			ld de, .ttext3  
6371 cd 15 62			call write_len_string  
6374 3e 78			ld a, kLCD_Line4  
6376 cd ca 62			call fLCD_Pos  
6379 06 28			ld b, 40  
637b 11 fd 63			ld de, .ttext4  
637e cd 15 62			call write_len_string  
6381			  
6381 76				halt  
6382			  
6382			  
6382 .. 00		.ttext1: db "A234567890123456789012345678901234567890",0  
63ab .. 00		.ttext2: db "B234567890123456789012345678901234567890",0  
63d4 .. 00		.ttext3: db "C234567890123456789012345678901234567890",0  
63fd .. 00		.ttext4: db "D234567890123456789012345678901234567890",0  
6426			   
6426			  
6426			  
6426			; eof  
6426			  
# End of file firmware_lcd_4x40.asm
6426			;include "firmware_lcd_4x20.asm" 
6426			include "firmware_key_5x10.asm" 
6426			; 5 x 10 decade counter scanner  
6426			  
6426			  
6426			; TODO do cursor shape change for shift keys  
6426			; TODO hard coded positions for the shift keys. Change to work like 4x4 and detect and then hide them  
6426			  
6426			  
6426			; bit mask for each scan column and row for teing the matrix  
6426			  
6426			  
6426			key_init:  
6426			  
6426			; SCMonAPI functions used  
6426			  
6426			; Alphanumeric LCD functions used  
6426			; no need to specify specific functions for this module  
6426			  
6426			  
6426 3e cf		            LD   A, 11001111b  
6428 d3 c3		            OUT  (portbctl), A  ;Port A = PIO 'control' mode  
642a			;            LD   A, 00000000b  
642a 3e 1f		            LD   A, 00011111b  
642c d3 c3		            OUT  (portbctl),A   ;Port A = all lines are outputs  
642e			  
642e			  
642e				; TODO Configure cursor shapes  
642e			  
642e				; Load cursor shapes   
642e 3e 01		            LD   A, 1           ;First character to define (0 to 7)  
6430 11 40 64		            LD   DE, .cursor_shapes    ;Pointer to start of bitmap data  
6433 06 02		            LD   B, 2           ;Number of characters to define  
6435 cd f6 62		.DefLoop:   CALL fLCD_Def       ;Define custom character  
6438 10 fb		            DJNZ .DefLoop       ;Repeat for each character  
643a			  
643a 3e 01				ld a, 1  
643c 32 d0 f8			ld (cursor_shape),a  
643f c9				ret  
6440			  
6440			; Custom characters for cursor shapes 5 pixels wide by 8 pixels high  
6440			; Up to 8 custom characters can be defined  
6440			.cursor_shapes:      
6440			;; Character 0x00 = Normal  
6440 1f			            DB  11111b  
6441 1f			            DB  11111b  
6442 1f			            DB  11111b  
6443 1f			            DB  11111b  
6444 1f			            DB  11111b  
6445 1f			            DB  11111b  
6446 1f			            DB  11111b  
6447 1f			            DB  11111b  
6448			;; Character 0x01 = Modifier  
6448 1f			            DB  11111b  
6449 1b			            DB  11011b  
644a 1b			            DB  11011b  
644b 1b			            DB  11011b  
644c 1b			            DB  11011b  
644d 1f			            DB  11111b  
644e 1b			            DB  11011b  
644f 1f			            DB  11111b  
6450			  
6450			  
6450			  
6450			  
6450			; Display custom character 0  
6450			;            LD   A, kLCD_Line1+14  
6450			;            CALL fLCD_Pos       ;Position cursor to location in A  
6450			;            LD   A, 0  
6450			;            CALL fLCD_Data      ;Write character in A at cursor  
6450			  
6450			; Display custom character 1  
6450			;            LD   A, kLCD_Line2+14  
6450			;            CALL fLCD_Pos      ;Position cursor to location in A  
6450			;            LD   A, 1  
6450			;            CALL fLCD_Data     ;Write character in A at cursor  
6450			  
6450			; keyboard scanning   
6450			  
6450			; character in from keyboard  
6450			  
6450			; mapping for the pcb layout  
6450			  
6450			.matrix_to_char:  
6450 .. 08 05 0a 00			db "1357890",KEY_BS,KEY_UP,KEY_DOWN,0  
645b .. 0b 0c 00			db "qweryiop",KEY_LEFT,KEY_RIGHT,0  
6466 7e .. 0d 00			db KEY_SYMBOLSHIFT,"asdfghjk",KEY_CR,0  
6471 7e .. 7e 00			db KEY_SHIFT,"zxcvbnm ",KEY_SHIFT,0  
647c .. 10 11 12 .. 13 00			db "246tu",KEY_F1,KEY_F2,KEY_F3,"l",KEY_F4,0  
6487			.matrix_to_shift:  
6487			  
6487 .. 08 05 0a 00			db "!#%&*()",KEY_BS,KEY_UP,KEY_DOWN,0  
6492 .. 07 06 00			db "QWERYIOP",KEY_PREVWORD,KEY_NEXTWORD,0  
649d 7e .. 0d 00			db KEY_SYMBOLSHIFT,"ASDFGHJK",KEY_CR,0  
64a8 7e .. 7e 00			db KEY_SHIFT,"ZXCVBNM|",KEY_SHIFT,0  
64b3 .. .. 14 15 16 .. 17 00			db '"',"$^TU",KEY_F5,KEY_F6,KEY_F7,"L",KEY_F8,0  
64be			  
64be			.matrix_to_symbolshift:  
64be			  
64be fc ed .. f7 08 05 0a 00			db 252,237,"5789",247,KEY_BS,KEY_UP,KEY_DOWN,0  
64c9 .. b0 0e 0f 00			db "-+/=_?~",176,KEY_HOME,KEY_END,0  
64d4 7e .. a5 7c db ff 0d 00			db KEY_SYMBOLSHIFT,"[]{}",165,124,219,255,KEY_CR,0  
64df 7e .. 7e 00			db KEY_SHIFT,"<>,.:;'\\",KEY_SHIFT,0  
64ea .. f6 eb 7d 7e 18 19 1a df 1b 00			db "@",246,235,125,126,KEY_F9,KEY_F10,KEY_F11,223,KEY_F12,0  
64f5			  
64f5			  
64f5			  
64f5			; mapping for a simple straight through breadboard layout  
64f5			  
64f5			;.matrix_to_char:  
64f5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
64f5			;		db KEY_SHIFT,"zxcvbnm ",KEY_SYMBOLSHIFT,0  
64f5			;		db "asdfghjkl",KEY_CR,0  
64f5			;		db "qwertyuiop",0  
64f5			;		 db "1234567890",0  
64f5			;.matrix_to_shift:  
64f5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_HOME, KEY_END,0  
64f5			;		db KEY_SHIFT,"ZXCVBNM",KEY_BS,KEY_SYMBOLSHIFT,0  
64f5			;		db "ASDFGHJKL",KEY_CR,0  
64f5			;		db "QWERTYUIOP",0  
64f5			;		 db "!",'"',"#$%^&*()",0  
64f5			;.matrix_to_symbolshift:  
64f5			;		db KEY_SHIFT,"zxcv",KEY_UP,KEY_DOWN,"m",KEY_LEFT, KEY_RIGHT,0  
64f5			;		db KEY_SHIFT,"<>:;b,.",KEY_BS,KEY_SYMBOLSHIFT,0  
64f5			;		db "_?*fghjk=",KEY_CR,0  
64f5			;		db "-/+*[]{}@#",0  
64f5			;		 db "1234567890",0  
64f5			  
64f5			;.matrix_to_char: db "D#0*C987B654A321"  
64f5			  
64f5			  
64f5				  
64f5			  
64f5			; add cin and cin_wait  
64f5			  
64f5 cd 06 65		cin_wait: 	call cin  
64f8						if DEBUG_KEYCINWAIT  
64f8							push af  
64f8							  
64f8							ld hl,key_repeat_ct  
64f8							ld (hl),a  
64f8							inc hl  
64f8							call hexout  
64f8							ld hl,key_repeat_ct+3  
64f8							ld a,0  
64f8							ld (hl),a  
64f8			  
64f8							    LD   A, kLCD_Line1+11  
64f8							    CALL fLCD_Pos       ;Position cursor to location in A  
64f8							    LD   DE, key_repeat_ct  
64f8							    ;LD   DE, MsgHello  
64f8							    CALL fLCD_Str       ;Display string pointed to by DE  
64f8			  
64f8			  
64f8			  
64f8							pop af  
64f8						endif  
64f8 fe 00			cp 0  
64fa 28 f9			jr z, cin_wait   ; block until key press  
64fc			  
64fc							if DEBUG_KEYCINWAIT  
64fc								push af  
64fc			  
64fc								ld a, 'A'	  
64fc								ld hl,key_repeat_ct  
64fc								ld (hl),a  
64fc								inc hl  
64fc								ld a,0  
64fc								ld (hl),a  
64fc			  
64fc								    LD   A, kLCD_Line2+11  
64fc								    CALL fLCD_Pos       ;Position cursor to location in A  
64fc								    LD   DE, key_repeat_ct  
64fc								    ;LD   DE, MsgHello  
64fc								    CALL fLCD_Str       ;Display string pointed to by DE  
64fc			  
64fc							call delay500ms  
64fc			  
64fc								pop af  
64fc							endif  
64fc f5				push af   ; save key pressed  
64fd			  
64fd			.cin_wait1:	  
64fd							if DEBUG_KEYCINWAIT  
64fd								push af  
64fd			  
64fd								ld a, 'b'	  
64fd								ld hl,key_repeat_ct  
64fd								ld (hl),a  
64fd								inc hl  
64fd								ld a,0  
64fd								ld (hl),a  
64fd			  
64fd								    LD   A, kLCD_Line2+11  
64fd								    CALL fLCD_Pos       ;Position cursor to location in A  
64fd								    LD   DE, key_repeat_ct  
64fd								    ;LD   DE, MsgHello  
64fd								    CALL fLCD_Str       ;Display string pointed to by DE  
64fd			  
64fd			  
64fd							call delay500ms  
64fd			  
64fd								pop af  
64fd							endif  
64fd			  
64fd cd 06 65		call cin  
6500 fe 00			cp 0  
6502 20 f9			jr nz, .cin_wait1  	; wait for key release  
6504			if DEBUG_KEYCINWAIT  
6504				push af  
6504			  
6504				ld a, '3'	  
6504				ld hl,key_repeat_ct  
6504				ld (hl),a  
6504				inc hl  
6504				ld a,0  
6504				ld (hl),a  
6504			  
6504			            LD   A, kLCD_Line2+11  
6504			            CALL fLCD_Pos       ;Position cursor to location in A  
6504			            LD   DE, key_repeat_ct  
6504			            ;LD   DE, MsgHello  
6504			            CALL fLCD_Str       ;Display string pointed to by DE  
6504			  
6504			  
6504			call delay500ms  
6504			  
6504				pop af  
6504			endif  
6504			  
6504 f1				pop af   ; get key  
6505 c9				ret  
6506			  
6506			  
6506 cd 1a 65		cin: 	call .mtoc  
6509			  
6509			if DEBUG_KEYCIN  
6509				push af  
6509				  
6509				ld hl,key_repeat_ct  
6509				ld (hl),a  
6509				inc hl  
6509				call hexout  
6509				ld hl,key_repeat_ct+3  
6509				ld a,0  
6509				ld (hl),a  
6509			  
6509			            LD   A, kLCD_Line3+15  
6509			            CALL fLCD_Pos       ;Position cursor to location in A  
6509			            LD   DE, key_repeat_ct  
6509			            ;LD   DE, MsgHello  
6509			            CALL fLCD_Str       ;Display string pointed to by DE  
6509			  
6509			  
6509			call delay500ms  
6509			  
6509				pop af  
6509			endif  
6509			  
6509			  
6509				; no key held  
6509 fe 00			cp 0  
650b c8				ret z  
650c			  
650c			if DEBUG_KEYCIN  
650c				push af  
650c			  
650c				ld a, '1'	  
650c				ld hl,key_repeat_ct  
650c				ld (hl),a  
650c				inc hl  
650c				ld a,0  
650c				ld (hl),a  
650c			  
650c			            LD   A, kLCD_Line4+15  
650c			            CALL fLCD_Pos       ;Position cursor to location in A  
650c			            LD   DE, key_repeat_ct  
650c			            ;LD   DE, MsgHello  
650c			            CALL fLCD_Str       ;Display string pointed to by DE  
650c			  
650c			  
650c			call delay500ms  
650c			  
650c				pop af  
650c			endif  
650c			  
650c				; stop key bounce  
650c			  
650c 32 88 fb			ld (key_held),a		 ; save it  
650f 47				ld b, a  
6510			  
6510 c5			.cina1:	push bc  
6511			if DEBUG_KEYCIN  
6511				push af  
6511			  
6511				ld hl,key_repeat_ct  
6511				inc hl  
6511				call hexout  
6511				ld hl,key_repeat_ct+3  
6511				ld a,0  
6511				ld (hl),a  
6511				ld hl,key_repeat_ct  
6511				ld a, '2'	  
6511				ld (hl),a  
6511			  
6511			            LD   A, kLCD_Line4+15  
6511			            CALL fLCD_Pos       ;Position cursor to location in A  
6511			            LD   DE, key_repeat_ct  
6511			            ;LD   DE, MsgHello  
6511			            CALL fLCD_Str       ;Display string pointed to by DE  
6511			  
6511				pop af  
6511			endif  
6511 cd 1a 65			call .mtoc  
6514 c1				pop bc  
6515 b8				cp b  
6516 28 f8			jr z, .cina1  
6518 78				ld a,b		  
6519			if DEBUG_KEYCIN  
6519				push af  
6519			  
6519				ld hl,key_repeat_ct  
6519				inc hl  
6519				call hexout  
6519				ld hl,key_repeat_ct+3  
6519				ld a,0  
6519				ld (hl),a  
6519				ld hl,key_repeat_ct  
6519				ld a, '3'	  
6519				ld (hl),a  
6519			  
6519			            LD   A, kLCD_Line4+15  
6519			            CALL fLCD_Pos       ;Position cursor to location in A  
6519			            LD   DE, key_repeat_ct  
6519			            ;LD   DE, MsgHello  
6519			            CALL fLCD_Str       ;Display string pointed to by DE  
6519			  
6519				pop af  
6519			endif  
6519 c9				ret  
651a			  
651a			; detect keyboard modifier key press and apply new overlay to the face key held  
651a			; hl is the key modifer flag, de map to apply to key_face_held and store in key_actual_pressed  
651a			  
651a			;.cin_map_modifier:   
651a			;	ld a, (hl)  
651a			;	and 255  
651a			;	ret NZ		; modifier key not flagged  
651a			;  
651a			;	; get key face  
651a			;  
651a			;	ld b,(key_face_held)  
651a			;  
651a			;	ld b, key_cols * key_rows  
651a			;  
651a			;	push de  
651a			;	pop hl  
651a			;  
651a			;.mmod1: ld a,(hl)   ; get map test  
651a			;	cp b  
651a			;	jr z, .mmod2  
651a			;  
651a			;  
651a			;  
651a			;.mmod2: inc hl    ;   
651a			;  
651a			;	  
651a			;  
651a			;	  
651a			;  
651a			;	ld hl,key_actual_pressed  
651a			;	ld (hl),a,  
651a			;	ret  
651a			  
651a			; map matrix key held to char on face of key  
651a			  
651a			.mtoc:  
651a			  
651a			; test decade counter strobes  
651a			  
651a			;.decadetest1:  
651a			  
651a			; reset counter  
651a			;ld a, 128  
651a			;out (portbdata),a  
651a			  
651a			  
651a			;ld b, 5  
651a			;.dec1:  
651a			;ld a, 0  
651a			;out (portbdata),a  
651a			;call delay1s  
651a			  
651a			;ld a, 32  
651a			;out (portbdata),a  
651a			;call delay1s  
651a			;call delay1s  
651a			;call delay1s  
651a			;  
651a			;ld a, 64+32  
651a			;out (portbdata),a  
651a			;call delay1s  
651a			;;djnz .dec1  
651a			;  
651a			;jp .decadetest1  
651a			  
651a			  
651a			  
651a			  
651a			  
651a			  
651a			  
651a			  
651a			  
651a			  
651a				; scan keyboard matrix and generate raw scan map  
651a cd ad 65			call matrix  
651d			  
651d				; reuse c bit 0 left modifer button - ie shift  
651d			        ; reuse c bit 1 for right modifer button - ie symbol shift  
651d				; both can be used with their other mappings and if seen together can do extra mappings (forth keywords????)  
651d			  
651d 0e 00			ld c, 0  
651f			  
651f				; TODO set flags for modifer key presses   
651f				; TODO do a search for modifer key...  
651f			  
651f				;ld hl,keyscan_table_row4  
651f 21 e7 fb			ld hl,keyscan_table_row2  
6522			  
6522 7e				ld a, (hl)  
6523 fe 23			cp '#'  
6525 20 07			jr nz, .nextmodcheck  
6527 cb c1			set 0, c  
6529 21 87 64			ld hl, .matrix_to_shift  
652c 18 21			jr .dokeymap  
652e				; TODO for now igonre  
652e			.nextmodcheck:  
652e 21 dc fb			ld hl,keyscan_table_row3  
6531			  
6531 7e				ld a, (hl)  
6532 fe 23			cp '#'  
6534 20 07			jr nz, .nextmodcheck2  
6536 cb c9			set 1, c   
6538 21 be 64			ld hl, .matrix_to_symbolshift  
653b 18 12			jr .dokeymap  
653d			.nextmodcheck2:  
653d 21 f0 fb			ld hl,keyscan_table_row2+9    ; right shift  
6540			  
6540 7e				ld a, (hl)  
6541 fe 23			cp '#'  
6543 20 07			jr nz, .donemodcheck  
6545 cb c9			set 1, c   
6547 21 87 64			ld hl, .matrix_to_shift  
654a 18 03			jr .dokeymap  
654c			  
654c				; no modifer found so just map to normal keys  
654c				; get mtoc map matrix to respective keys  
654c			;	ld hl, .matrix_to_char  
654c			;	ld hl, .matrix_to_char  
654c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
654c			;	ld a, KEY_SHIFT  
654c			;	call findchar  
654c			;  
654c			;	; got offset to key modifer in b  
654c			;  
654c			;	ld hl,keyscan_table_row5  
654c			;  
654c			;	ld a,b  
654c			;	call addatohl  
654c			;	ld a,(hl)  
654c			;  
654c			;	cp '#'  
654c			;	jr nz, .nextmodcheck  
654c			;	set 0, c  
654c			;	ld hl, .matrix_to_char  
654c			;	jr .dokeymap  
654c			;	; TODO for now igonre  
654c			;.nextmodcheck:  
654c			;	ld hl, .matrix_to_symbolshift  
654c			;	ld b, ((key_cols+1)*key_rows)    ; 30 keys to remap + 8 nulls   
654c			;	ld a, KEY_SYMBOLSHIFT  
654c			;	call findchar  
654c			;  
654c			;  
654c			;	; got offset to key modifer in b  
654c			;  
654c			;	ld hl,keyscan_table_row5  
654c			;  
654c			;	ld a,b  
654c			;	call addatohl  
654c			;	ld a,(hl)  
654c			;  
654c			;	cp '#'  
654c			;	jr nz, .donemodcheck  
654c			;	set 1, c   
654c			;	ld hl, .matrix_to_symbolshift  
654c			;	jr .dokeymap  
654c			  
654c			  
654c			  
654c			.donemodcheck:  
654c				; no modifer found so just map to normal keys  
654c				; get mtoc map matrix to respective keys  
654c 21 50 64			ld hl, .matrix_to_char  
654f			  
654f			.dokeymap:  
654f				;ld (key_fa), c   
654f cd 68 65			call .mapkeys  
6552			  
6552			  
6552			if DEBUG_KEY  
6552			  
6552			; Display text on first line  
6552			            LD   A, kLCD_Line1  
6552			            CALL fLCD_Pos       ;Position cursor to location in A  
6552			            LD   DE, keyscan_table_row1  
6552			            ;LD   DE, MsgHello  
6552			            CALL fLCD_Str       ;Display string pointed to by DE  
6552			  
6552			; Display text on second line  
6552			            LD   A, kLCD_Line2  
6552			            CALL fLCD_Pos       ;Position cursor to location in A  
6552			            LD   DE, keyscan_table_row2  
6552			            CALL fLCD_Str       ;Display string pointed to by DE  
6552			            LD   A, kLCD_Line3  
6552			            CALL fLCD_Pos       ;Position cursor to location in A  
6552			            LD   DE, keyscan_table_row3  
6552			            CALL fLCD_Str       ;Display string pointed to by DE  
6552			            LD   A, kLCD_Line4  
6552			            CALL fLCD_Pos       ;Position cursor to location in A  
6552			            LD   DE, keyscan_table_row4  
6552			            CALL fLCD_Str       ;Display string pointed to by DE  
6552			            LD   A, kLCD_Line1+10  
6552			            CALL fLCD_Pos       ;Position cursor to location in A  
6552			            LD   DE, keyscan_table_row5  
6552			            CALL fLCD_Str       ;Display string pointed to by DE  
6552			  
6552				;call delay250ms  
6552			endif  
6552			;	jp testkey  
6552			  
6552			; get first char reported  
6552			  
6552 21 c6 fb			ld hl,keyscan_table_row5  
6555			  
6555				;ld b, 46   ; 30 keys to remap + 8 nulls   
6555 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
6557			.findkey:  
6557 7e				ld a,(hl)  
6558 fe 00			cp 0  
655a 28 04			jr z, .nextkey  
655c fe 7e			cp KEY_MATRIX_NO_PRESS  
655e 20 06			jr nz, .foundkey  
6560			.nextkey:  
6560 23				inc hl  
6561 10 f4			djnz .findkey  
6563 3e 00			ld a,0  
6565 c9				ret  
6566			.foundkey:  
6566 7e				ld a,(hl)  
6567 c9				ret  
6568				  
6568			  
6568			; convert the raw key map given hl for destination key  
6568			.mapkeys:  
6568 11 c6 fb			ld de,keyscan_table_row5  
656b			  
656b 06 37			ld b, (key_cols+1)*key_rows    ; 30 keys to remap + 8 nulls   
656d			.remap:  
656d 1a				ld a,(de)  
656e fe 23			cp '#'  
6570 20 02			jr nz, .remapnext  
6572				;CALLMONITOR  
6572 7e				ld a,(hl)  
6573 12				ld (de),a  
6574			  
6574			  
6574			  
6574			.remapnext:  
6574 23				inc hl  
6575 13				inc de  
6576 10 f5			djnz .remap  
6578				  
6578 c9				ret  
6579			  
6579			  
6579			  
6579			.mtocold2:  
6579			  
6579			;	; flag if key D is held down and remove from reporting  
6579			;	ld bc, .key_map_fd    
6579			;	ld hl, keyscan_table  
6579			;	ld de, key_fd  
6579			;	call .key_shift_hold  
6579			;	cp 255  
6579			;	jr z, .cinmap  
6579			;	; flag if key C is held down and remove from reporting  
6579			;	ld bc, .key_map_fc    
6579			;	ld hl, keyscan_table+key_cols  
6579			;	ld de, key_fc  
6579			;	call .key_shift_hold  
6579			;	cp 255  
6579			;	jr z, .cinmap  
6579			;	; flag if key B is held down and remove from reporting  
6579			;	ld bc, .key_map_fb    
6579			;	ld hl, keyscan_table+(key_cols*2)  
6579			;	ld de, key_fb  
6579			;	call .key_shift_hold  
6579			;	cp 255  
6579			;	jr z, .cinmap  
6579			;	; flag if key A is held down and remove from reporting  
6579			;	ld bc, .key_map_fa    
6579			;	ld hl, keyscan_table+(key_cols*3)  
6579			;	ld de, key_fa  
6579			;	call .key_shift_hold  
6579			;	cp 255  
6579			;	jr z, .cinmap  
6579			  
6579 11 50 64			ld de, .matrix_to_char  
657c			  
657c			  
657c			.cinmap1:   
657c				if DEBUG_KEY  
657c			            LD   A, kLCD_Line4  
657c			            CALL fLCD_Pos       ;Position cursor to location in A  
657c					push de  
657c			            LD   DE, keyscan_table  
657c			            CALL fLCD_Str       ;Display string pointed to by DE  
657c					pop de  
657c				endif  
657c			  
657c				; scan key matrix table for any held key  
657c			  
657c				; de holds either the default matrix or one selected above  
657c			  
657c 21 93 fb			ld hl, keyscan_table  
657f 06 32			ld b,key_cols*key_rows  
6581			  
6581 7e			.cin11:	ld a,(hl)  
6582 fe 23			cp '#'  
6584 28 08			jr z, .cinhit1  
6586 23				inc hl  
6587 13				inc de  
6588 05				dec b  
6589 20 f6			jr nz, .cin11  
658b				; no key found held  
658b 3e 00			ld a,0  
658d c9				ret  
658e d5			.cinhit1: push de  
658f e1				pop hl  
6590 7e				ld a,(hl)  
6591 c9				ret  
6592			  
6592			; flag a control key is held   
6592			; hl is key pin, de is flag indicator  
6592			  
6592			.key_shift_hold1:  
6592 c5				push bc  
6593 3e 01			ld a, 1  
6595 32 d0 f8			ld (cursor_shape),a  
6598 06 00			ld b, 0  
659a 7e				ld a, (hl)  
659b fe 2e			cp '.'  
659d 28 0a			jr z, .key_shift11  
659f 06 ff			ld b, 255  
65a1 3e 2b			ld a, '+'    ; hide key from later scans  
65a3 77				ld (hl),a  
65a4 3e 02			ld a, 2  
65a6 32 d0 f8			ld (cursor_shape),a  
65a9			.key_shift11:  
65a9				; write flag indicator  
65a9 78				ld a,b  
65aa 12				ld (de),a  
65ab			  
65ab d1				pop de    ; de now holds the key map ptr  
65ac c9				ret  
65ad			  
65ad				  
65ad			  
65ad			; scans keyboard matrix and flags key press in memory array	  
65ad				  
65ad			matrix:  
65ad				;call matrix  
65ad				; TODO optimise the code....  
65ad			  
65ad			  
65ad			;ld hl, keyscan_table_row1  
65ad			;ld de, keyscan_table_row1+1  
65ad			;ld bc,46  
65ad			;ld a,KEY_MATRIX_NO_PRESS  
65ad			;ldir  
65ad			  
65ad			  
65ad			  
65ad			; reset counter  
65ad 3e 80		ld a, 128  
65af d3 c1		out (portbdata),a  
65b1			  
65b1 06 0a		ld b, 10  
65b3 0e 00		ld c, 0       ; current clock toggle  
65b5			  
65b5			.colscan:  
65b5			  
65b5			; set current column  
65b5			; disable clock enable and set clock low  
65b5			  
65b5			;ld a, 0  
65b5			;out (portbdata),a  
65b5			  
65b5			; For each column scan for switches  
65b5			  
65b5 c5			push bc  
65b6 21 89 fb		ld hl, keyscan_scancol  
65b9 cd c2 66		call .rowscan  
65bc c1			pop bc  
65bd			  
65bd			  
65bd			; get back current column  
65bd			  
65bd			; translate the row scan  
65bd			  
65bd			;   
65bd			; row 1  
65bd			  
65bd 78			ld a,b  
65be			  
65be 21 fc fb		LD   hl, keyscan_table_row1+10  
65c1			  
65c1 cd 24 0c		call subafromhl  
65c4			;call addatohl  
65c4			  
65c4 11 89 fb		ld de, keyscan_scancol  
65c7			  
65c7 1a			ld a,(de)  
65c8 77			ld (hl),a  
65c9			  
65c9			  
65c9			  
65c9			  
65c9			; row 2  
65c9			  
65c9 78			ld a,b  
65ca			  
65ca 21 f1 fb		LD   hl, keyscan_table_row2+10  
65cd			  
65cd			;call addatohl  
65cd cd 24 0c		call subafromhl  
65d0			  
65d0			  
65d0 11 8a fb		ld de, keyscan_scancol+1  
65d3			  
65d3 1a			ld a,(de)  
65d4 77			ld (hl),a  
65d5			  
65d5			  
65d5			; row 3  
65d5			  
65d5 78			ld a,b  
65d6			  
65d6 21 e6 fb		LD   hl, keyscan_table_row3+10  
65d9			  
65d9			;call addatohl  
65d9 cd 24 0c		call subafromhl  
65dc			  
65dc 11 8b fb		ld de, keyscan_scancol+2  
65df			  
65df 1a			ld a,(de)  
65e0 77			ld (hl),a  
65e1			  
65e1			  
65e1			  
65e1			; row 4  
65e1			  
65e1 78			ld a,b  
65e2			  
65e2 21 db fb		LD   hl, keyscan_table_row4+10  
65e5			  
65e5			;call addatohl  
65e5 cd 24 0c		call subafromhl  
65e8			  
65e8 11 8c fb		ld de, keyscan_scancol+3  
65eb			  
65eb 1a			ld a,(de)  
65ec 77			ld (hl),a  
65ed			  
65ed			; row 5  
65ed			  
65ed 78			ld a,b  
65ee			  
65ee 21 d0 fb		LD   hl, keyscan_table_row5+10  
65f1			  
65f1			;call addatohl  
65f1 cd 24 0c		call subafromhl  
65f4			  
65f4 11 8d fb		ld de, keyscan_scancol+4  
65f7			  
65f7 1a			ld a,(de)  
65f8 77			ld (hl),a  
65f9			  
65f9			; handshake next column  
65f9			  
65f9			  
65f9 3e 40		ld a, 64  
65fb d3 c1		out (portbdata),a  
65fd			  
65fd 3e 00		ld a, 0  
65ff d3 c1		out (portbdata),a  
6601			  
6601			; toggle clk and move to next column  
6601			;ld a, 64  
6601			;cp c  
6601			;  
6601			;jr z, .coltoglow  
6601			;ld c, a  
6601			;jr .coltog  
6601			;.coltoglow:  
6601			;ld c, 0  
6601			;.coltog:  
6601			;ld a, c  
6601			;out (portbdata),a  
6601			  
6601 10 b2		djnz .colscan  
6603			  
6603 3e 0a		ld a,10  
6605 21 f2 fb		LD   hl, keyscan_table_row1  
6608 cd 12 0c		call addatohl  
660b 3e 00		ld a, 0  
660d 77			ld (hl), a  
660e			  
660e			  
660e 3e 0a		ld a,10  
6610 21 e7 fb		LD   hl, keyscan_table_row2  
6613 cd 12 0c		call addatohl  
6616 3e 00		ld a, 0  
6618 77			ld (hl), a  
6619			  
6619 3e 0a		ld a,10  
661b 21 dc fb		LD   hl, keyscan_table_row3  
661e cd 12 0c		call addatohl  
6621 3e 00		ld a, 0  
6623 77			ld (hl), a  
6624			  
6624 3e 0a		ld a,10  
6626 21 d1 fb		LD   hl, keyscan_table_row4  
6629 cd 12 0c		call addatohl  
662c 3e 00		ld a, 0  
662e 77			ld (hl), a  
662f			  
662f 3e 0a		ld a,10  
6631 21 c6 fb		LD   hl, keyscan_table_row5  
6634 cd 12 0c		call addatohl  
6637 3e 00		ld a, 0  
6639 77			ld (hl), a  
663a			  
663a			if DEBUG_KEY_MATRIX  
663a			  
663a			; Display text on first line  
663a			            LD   A, kLCD_Line1  
663a			            CALL fLCD_Pos       ;Position cursor to location in A  
663a			            LD   DE, keyscan_table_row1  
663a			            ;LD   DE, MsgHello  
663a			            CALL fLCD_Str       ;Display string pointed to by DE  
663a			  
663a			; Display text on second line  
663a			            LD   A, kLCD_Line2  
663a			            CALL fLCD_Pos       ;Position cursor to location in A  
663a			            LD   DE, keyscan_table_row2  
663a			            CALL fLCD_Str       ;Display string pointed to by DE  
663a			            LD   A, kLCD_Line3  
663a			            CALL fLCD_Pos       ;Position cursor to location in A  
663a			            LD   DE, keyscan_table_row3  
663a			            CALL fLCD_Str       ;Display string pointed to by DE  
663a			            LD   A, kLCD_Line4  
663a			            CALL fLCD_Pos       ;Position cursor to location in A  
663a			            LD   DE, keyscan_table_row4  
663a			            CALL fLCD_Str       ;Display string pointed to by DE  
663a			            LD   A, kLCD_Line4+10  
663a			            CALL fLCD_Pos       ;Position cursor to location in A  
663a			            LD   DE, keyscan_table_row5  
663a			            CALL fLCD_Str       ;Display string pointed to by DE  
663a			  
663a			;call delay250ms  
663a				jp matrix  
663a			endif  
663a c9			ret  
663b			  
663b			; using decade counter....  
663b			  
663b			  
663b			; TODO reset decade counter to start of scan  
663b			  
663b			; reset 15  
663b			; clock 14  
663b			; ce 13  
663b			  
663b			; 1 - q5  
663b			; 2 - q1  
663b			; 3 - q0  
663b			; 4 - q2  
663b			; 5 - q6  
663b			; 6 - q7  
663b			; 7 - q3  
663b			; 8 - vss  
663b			; 9 - q8  
663b			; 10 - q4  
663b			; 11 - q9  
663b			; 12 - cout  
663b			; 16 - vdd  
663b			  
663b			; clock      ce       reset     output  
663b			; 0          x        0         n  
663b			; x          1        0         n  
663b			; x          x        1         q0  
663b			; rising     0        0         n+1  
663b			; falling    x        0         n  
663b			; x          rising   0         n  
663b			; 1          falling  0         x+1  
663b			;  
663b			; x = dont care, if n < 5 carry = 1 otherwise 0  
663b			  
663b			;   
663b			; reset   
663b			; 13=0, 14=0, 15=1 .. 15=0  
663b			;  
663b			; handshake line  
663b			; 14=1.... read line 14=0  
663b			  
663b			  
663b			  
663b			  
663b			  
663b			; TODO hand shake clock for next column scan  
663b			; TODO detect each row  
663b			  
663b			  
663b			  
663b			  
663b			; reset 128  
663b			; clock 64  
663b			; ce 32  
663b			  
663b			  
663b			.cyclestart:  
663b			  
663b			; reset counter  
663b 3e 80		ld a, 128  
663d d3 c1		out (portbdata),a  
663f			  
663f			; loop leds  
663f 06 0a		ld b,10  
6641			  
6641			.cycle1:  
6641 c5			push bc  
6642 3e 00		ld a, 0  
6644 d3 c1		out (portbdata),a  
6646 cd 31 0a		call delay250ms  
6649			  
6649 3e 40		ld a, 64  
664b d3 c1		out (portbdata),a  
664d cd 31 0a		call delay250ms  
6650			  
6650 3e 00		ld a, 0  
6652 d3 c1		out (portbdata),a  
6654 cd 31 0a		call delay250ms  
6657			  
6657 c1			pop bc  
6658 10 e7		djnz .cycle1  
665a			  
665a			  
665a 18 df		jr .cyclestart  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			; map matrix key held to char on face of key  
665c			  
665c			;.mtocold:  
665c			;  
665c			;  
665c			;; reset counter  
665c			;ld a, 128  
665c			;out (portbdata),a  
665c			;  
665c			;  
665c			;; scan keyboard row 1  
665c			;ld a, 0  
665c			;out (portbdata),a  
665c			;;ld a, 64  
665c			;;out (portbdata),a  
665c			;  
665c			;  
665c			;	ld a, 128  
665c			;	ld hl, keyscan_table  
665c			;	call .rowscan  
665c			;  
665c			;;ld a, 0  
665c			;;out (portbdata),a  
665c			;ld a, 64  
665c			;out (portbdata),a  
665c			;  
665c			;	ld a, 64  
665c			;	ld hl, keyscan_table+key_cols  
665c			;	call .rowscan  
665c			;  
665c			;ld a, 0  
665c			;out (portbdata),a  
665c			;;ld a, 64  
665c			;;out (portbdata),a  
665c			;	ld a, 32  
665c			;	ld hl, keyscan_table+(key_cols*2)  
665c			;	call .rowscan  
665c			;  
665c			;  
665c			;;ld a, 0  
665c			;;out (portbdata),a  
665c			;ld a, 64  
665c			;out (portbdata),a  
665c			;  
665c			;	ld a, 16  
665c			;	ld hl, keyscan_table+(key_cols*3)  
665c			;	call .rowscan  
665c			;  
665c			;  
665c			;	; flag if key D is held down and remove from reporting  
665c			;	ld bc, .key_map_fd    
665c			;	ld hl, keyscan_table  
665c			;	ld de, key_fd  
665c			;	call .key_shift_hold  
665c			;	cp 255  
665c			;	jr z, .cinmap  
665c			;	; flag if key C is held down and remove from reporting  
665c			;	ld bc, .key_map_fc    
665c			;	ld hl, keyscan_table+key_cols  
665c			;	ld de, key_fc  
665c			;	call .key_shift_hold  
665c			;	cp 255  
665c			;	jr z, .cinmap  
665c			;	; flag if key B is held down and remove from reporting  
665c			;	ld bc, .key_map_fb    
665c			;	ld hl, keyscan_table+(key_cols*2)  
665c			;	ld de, key_fb  
665c			;	call .key_shift_hold  
665c			;	cp 255  
665c			;	jr z, .cinmap  
665c			;	; flag if key A is held down and remove from reporting  
665c			;	ld bc, .key_map_fa    
665c			;	ld hl, keyscan_table+(key_cols*3)  
665c			;	ld de, key_fa  
665c			;	call .key_shift_hold  
665c			;	cp 255  
665c			;	jr z, .cinmap  
665c			;  
665c			;	ld de, .matrix_to_char  
665c			;  
665c			;  
665c			;.cinmap:   
665c			;	if DEBUG_KEY  
665c			;            LD   A, kLCD_Line4  
665c			;            CALL fLCD_Pos       ;Position cursor to location in A  
665c			;		push de  
665c			;            LD   DE, keyscan_table  
665c			;            CALL fLCD_Str       ;Display string pointed to by DE  
665c			;		pop de  
665c			;	endif  
665c			  
665c				; scan key matrix table for any held key  
665c			  
665c				; de holds either the default matrix or one selected above  
665c			  
665c			;	ld hl, keyscan_table  
665c			;	ld b,key_cols*key_rows  
665c			;  
665c			;.cin1:	ld a,(hl)  
665c			;	cp '#'  
665c			;	jr z, .cinhit  
665c			;	inc hl  
665c			;	inc de  
665c			;	dec b  
665c			;	jr nz, .cin1  
665c			;	; no key found held  
665c			;	ld a,0  
665c			;	ret  
665c			;.cinhit: push de  
665c			;	pop hl  
665c			;	ld a,(hl)  
665c			;	ret  
665c			  
665c			; flag a control key is held   
665c			; hl is key pin, de is flag indicator  
665c			  
665c			;.key_shift_hold:  
665c			;	push bc  
665c			;	ld a, 1  
665c			;	ld (cursor_shape),a  
665c			;	ld b, 0  
665c			;	ld a, (hl)  
665c			;	cp '.'  
665c			;	jr z, .key_shift1  
665c			;	ld b, 255  
665c			;	ld a, '+'    ; hide key from later scans  
665c			;	ld (hl),a  
665c			;	ld a, 2  
665c			;	ld (cursor_shape),a  
665c			;.key_shift1:  
665c			;	; write flag indicator  
665c			;	ld a,b  
665c			;	ld (de),a  
665c			;  
665c			;	pop de    ; de now holds the key map ptr  
665c			;	ret  
665c			  
665c				  
665c				  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			  
665c			;	push hl  
665c			;	push de  
665c			;	push bc  
665c			;	call keyscan  
665c			;	; map key matrix to ascii value of key face  
665c			;  
665c			;	ld hl, key_face_map  
665c			;	ld de, keyscan_table  
665c			;  
665c			;	; get how many keys to look at  
665c			;	ld b, keyscan_table_len  
665c			;	  
665c			;  
665c			;	; at this stage fall out on first key hit  
665c			;	; TODO handle multiple key press  
665c			;  
665c			;map1:	ld a,(hl)  
665c			;	cp '#'  
665c			;	jr z, keyhit  
665c			;	inc hl  
665c			;	inc de  
665c			;	dec b  
665c			;	jr nz, map1  
665c			;nohit:	ld a, 0  
665c			;	jr keydone  
665c			;keyhit: push de  
665c			;	pop hl  
665c			;	ld a,(hl)  
665c			;keydone:  
665c			;	push bc  
665c			;	push de  
665c			; 	push hl  
665c			;	ret   
665c			;  
665c			  
665c			  
665c			  
665c			  
665c			; scan physical key matrix  
665c			  
665c			  
665c			;keyscan:  
665c			;  
665c			;; for each key_row use keyscanr bit mask for out  
665c			;; then read in for keyscanc bitmask  
665c			;; save result of row scan to keyscantable  
665c			;  
665c			;; scan keyboard row 1  
665c			;  
665c			;	ld b, key_rows  
665c			;	ld hl, key_scanr  
665c			;	ld de, keyscan_table  
665c			;  
665c			;rowloop:  
665c			;  
665c			;	ld a,(hl)		; out bit mask to energise keyboard row  
665c			;	call rowscan  
665c			;	inc hl  
665c			;	dec b  
665c			;	jr nz, rowloop  
665c			;  
665c			;	ret  
665c			;  
665c			;  
665c			;; pass a out bitmask, b row number  
665c			;arowscan:   
665c			;	push bc  
665c			;  
665c			;	ld d, b  
665c			;  
665c			;	; calculate buffer location for this row  
665c			;  
665c			;	ld hl, keyscan_table	  
665c			;kbufr:  ld e, key_cols  
665c			;kbufc:	inc hl  
665c			;	dec e  
665c			;	jr nz, kbufc  
665c			;	dec d  
665c			;	jr nz, kbufr  
665c			;  
665c			;	; energise row and read columns  
665c			;  
665c			;	out (portbdata),a  
665c			;	in a,(portbdata)  
665c			;	ld c,a  
665c			;  
665c			;  
665c			;	; save buffer loc  
665c			;  
665c			;	ld (keybufptr), hl  
665c			;  
665c			;	ld hl, key_scanc  
665c			;	ld d, key_cols  
665c			;  
665c			;	; for each column check each bit mask  
665c			;  
665c			;colloop:  
665c			;	  
665c			;  
665c			;	; reset flags for the row   
665c			;  
665c			;	ld b,'.'  
665c			;	and (hl)  
665c			;	jr z, maskskip  
665c			;	ld b,'#'  
665c			;maskskip:  
665c			;	; save  key state  
665c			;	push hl  
665c			;	ld hl, (keybufptr)  
665c			;	ld (hl), b  
665c			;	inc hl  
665c			;	ld (keybufptr), hl  
665c			;  
665c			;	; move to next bit mask  
665c			;	pop hl  
665c			;	inc hl  
665c			;  
665c			;	dec d  
665c			;	jr nz, colloop  
665c			;  
665c			;	ret  
665c			;  
665c			;  
665c			;;  
665c			; lcd functions  
665c			;  
665c			;  
665c			  
665c			;if DEBUG_KEY_MATRIX  
665c			  
665c			; test function to display hardware view of matrix state  
665c			  
665c			matrixold:  
665c			  
665c			  
665c			  
665c			; reset counter  
665c 3e 80		ld a, 128  
665e d3 c1		out (portbdata),a  
6660			; scan keyboard row 1  
6660 3e 00		ld a, 0  
6662 d3 c1		out (portbdata),a  
6664			;ld a, 64  
6664			;out (portbdata),a  
6664 3e 80			ld a, 128  
6666 21 f2 fb			ld hl, keyscan_table_row1  
6669 cd c2 66			call .rowscan  
666c			  
666c			;ld a, 0  
666c			;out (portbdata),a  
666c 3e 40		ld a, 64  
666e d3 c1		out (portbdata),a  
6670 3e 40			ld a, 64  
6672 21 e7 fb			ld hl, keyscan_table_row2  
6675 cd c2 66			call .rowscan  
6678			  
6678 3e 00		ld a, 0  
667a d3 c1		out (portbdata),a  
667c			;ld a, 64  
667c			;out (portbdata),a  
667c 3e 20			ld a, 32  
667e 21 dc fb			ld hl, keyscan_table_row3  
6681 cd c2 66			call .rowscan  
6684			  
6684			;ld a, 0  
6684			;out (portbdata),a  
6684 3e 40		ld a, 64  
6686 d3 c1		out (portbdata),a  
6688 3e 10			ld a, 16  
668a 21 d1 fb			ld hl, keyscan_table_row4  
668d cd c2 66			call .rowscan  
6690			  
6690			; Display text on first line  
6690 3e 00		            LD   A, kLCD_Line1  
6692 cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
6695 11 f2 fb		            LD   DE, keyscan_table_row1  
6698			            ;LD   DE, MsgHello  
6698 cd ec 62		            CALL fLCD_Str       ;Display string pointed to by DE  
669b			  
669b			; Display text on second line  
669b 3e 28		            LD   A, kLCD_Line2  
669d cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
66a0 11 e7 fb		            LD   DE, keyscan_table_row2  
66a3 cd ec 62		            CALL fLCD_Str       ;Display string pointed to by DE  
66a6 3e 50		            LD   A, kLCD_Line3  
66a8 cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
66ab 11 dc fb		            LD   DE, keyscan_table_row3  
66ae cd ec 62		            CALL fLCD_Str       ;Display string pointed to by DE  
66b1 3e 78		            LD   A, kLCD_Line4  
66b3 cd ca 62		            CALL fLCD_Pos       ;Position cursor to location in A  
66b6 11 d1 fb		            LD   DE, keyscan_table_row4  
66b9 cd ec 62		            CALL fLCD_Str       ;Display string pointed to by DE  
66bc			  
66bc cd 31 0a			call delay250ms  
66bf c3 ad 65			jp matrix  
66c2			  
66c2			; pass de as row display flags  
66c2			.rowscan:   
66c2			;	out (portbdata),a  
66c2 db c1			in a,(portbdata)  
66c4 4f				ld c,a  
66c5				; reset flags for the row   
66c5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66c7 e6 01			and 1  
66c9 28 02			jr z, .p1on  
66cb 06 23			ld b,'#'  
66cd			.p1on:  
66cd 70				ld (hl), b  
66ce 23				inc hl  
66cf			  
66cf 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66d1 79				ld a,c  
66d2 e6 02			and 2  
66d4			;	bit 0,a  
66d4 28 02			jr z, .p2on  
66d6 06 23			ld b,'#'  
66d8			.p2on:  
66d8 70				ld (hl), b  
66d9 23				inc hl  
66da			;  
66da 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66dc 79				ld a,c  
66dd e6 04			and 4  
66df			;;	bit 0,a  
66df 28 02			jr z, .p3on  
66e1 06 23			ld b,'#'  
66e3			.p3on:  
66e3 70				ld (hl), b  
66e4 23				inc hl  
66e5			;;  
66e5 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66e7			;;	bit 0,a  
66e7 79				ld a,c  
66e8 e6 08			and 8  
66ea 28 02			jr z, .p4on  
66ec 06 23			ld b,'#'  
66ee			.p4on:  
66ee 70				ld (hl), b  
66ef 23				inc hl  
66f0			  
66f0 06 7e			ld b,KEY_MATRIX_NO_PRESS  
66f2			;;	bit 0,a  
66f2 79				ld a,c  
66f3 e6 10			and 16  
66f5 28 02			jr z, .p5on  
66f7 06 23			ld b,'#'  
66f9			.p5on:  
66f9 70				ld (hl), b  
66fa 23				inc hl  
66fb			; zero term  
66fb 06 00			ld b,0  
66fd 70				ld (hl), b  
66fe			  
66fe c9			.rscandone: ret  
66ff			  
66ff			;addatohl:  
66ff			;  
66ff			 ;add   a, l    ; A = A+L  
66ff			  ;  ld    l, a    ; L = A+L  
66ff			   ; adc   a, h    ; A = A+L+H+carry  
66ff			   ; sub   l       ; A = H+carry  
66ff			   ; ld    h, a    ; H = H+carry  
66ff			  
66ff			;ret  
66ff			; eof  
# End of file firmware_key_5x10.asm
66ff			;include "firmware_key_4x10.asm" 
66ff			 
66ff			heap_size:    equ heap_end - heap_start 
66ff			;eof 
# End of file os_mega.asm
66ff
