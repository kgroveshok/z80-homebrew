# File os_mega_cpm.asm
0000			 
0000			; Hardware Platform 
0000			 
0000			BASE_SC114: equ 0 
0000			BASE_KEV: equ 0 
0000			BASE_CPM: equ 1 
0000			 
0000			ENABLE_BASIC: equ 0 
0000			 
0000			tos:	equ 0f000h 
0000			; Using SCM API instead 
0000			;SC114_SIO_1_OUT: equ 81 
0000			;SC114_SIO_1_IN: equ 80 
0000			; 
0000			; 
0000			; CPU clock 
0000			; 
0000			CPU_CLOCK_4MHZ: equ 1 
0000			CPU_CLOCK_8MHZ: equ  0 
0000			CPU_CLOCK_10MHZ: equ  0 
0000			 
0000			; Use this to tune the delay functions if your CPU is a bit quick. i.e. RunCPM on a PC 
0000			 
0000			CPM_DELAY_TUNE: equ 4000 
0000			 
0000			; use microchip serial eeprom for storage 
0000			 
0000			STORAGE_SE: equ 0 
0000			SOUND_ENABLE: equ 0 
0000			 
0000			; the port where the PIO using the SC103 card is located 
0000			 
0000			SC103_PIO: equ 068h 
0000			 
0000			; Full OS but with the 5x10 fullsized keyboard 
0000			 
0000			display_rows: equ 4     
0000			;display_cols: equ 20 
0000			display_cols: equ 40 
0000			 
0000			key_rows: equ 5      
0000			key_cols: equ 10    
0000			 
0000			 
0000			include "main.asm" 
0000			; z80 homebrew opperating system 
0000			; 
0000			 
0000			STARTUP_ENABLE: equ 1 
0000			 
0000			 
0000			; bios jump points via rst 
0000			 
0000			if BASE_SC114 = 1  
0000			 
0000				org 8000h 
0000			endif 
0000			 
0000			if BASE_KEV = 1  
0000			 
0000				org 0h 
0000			endif 
0000			 
0000			if BASE_CPM = 1  
0000			 
0000				org 100h 
0100			endif 
0100 c3 2a 17			jp coldstart     ; rst 0 - cold boot 
0103			 
0103			;        nop  
0103			;        nop 
0103			;;	org 05h		; null out bdos call 
0103			; 
0103			;        nop  
0103			;        nop  
0103			;        nop 
0103			;;	org 08h 
0103			;;; 
0103			;;	jp cin		; rst 8 - char in 
0103			;;; 
0103			; 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;        nop 
0103			;	org 010h 
0103			;; 
0103			;	jp cout		; rest 010h  - char out 
0103			;; 
0103			;	org 01bh   
0103			; 
0103			;	;jp  		; rst 01bh   - write string to display 
0103			;	jp str_at_display 
0103			; 
0103			; 
0103			;	org 020h 
0103			; 
0103			;	; jp		 ; rst 020h - read char at screen location 
0103			; 
0103			;	org 028h 
0103			 
0103				; jp		 ; rst 028h  - storage i/o 
0103			 
0103			; 	org 030h 
0103			;	jp break_point_state 
0103			  
0103			; $30  
0103			; org 038h 
0103			; $38 
0103			 
0103			; TODO any more important entry points to add to jump table for easier coding use? 
0103			 
0103			 
0103			include "firmware.asm" 
0103			  
0103			; main constants (used here and in firmware)  
0103			  
0103			; TODO have page 0 of storage as bios  
0103			  
0103			Device_A: equ 0h  
0103			Device_B: equ 040h          ; Sound  
0103			  
0103			if BASE_KEV  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_SC114  
0103			Device_C: equ  SC103_PIO          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			; TODO fixup for CPM  
0103			Device_C: equ 080h          ; Storage and ext cart devices  
0103			endif  
0103			  
0103			Device_D: equ 0c0h             ; Keyboard and LCD  
0103			  
0103			; Odd specific debug points for testing hardware dev  
0103			  
0103			DEBUG_SOUND: equ 1  
0103			DEBUG_STK_FAULT: equ 0  
0103			DEBUG_INPUT: equ 0     ; Debug input entry code  
0103			DEBUG_KEYCINWAIT: equ 0  
0103			DEBUG_KEYCIN: equ 0  
0103			DEBUG_KEY: equ 0  
0103			DEBUG_KEY_MATRIX: equ 0  
0103			DEBUG_STORECF: equ 0  
0103			DEBUG_STORESE: equ 1        ; TODO  w locks up, r returns.   
0103			DEBUG_SPI_HARD_CE0: equ 0    ; only handshake on CE0 on port A  
0103			DEBUG_SPI: equ 0    ; low level spi tests  
0103			  
0103			; Enable many break points  
0103			  
0103			DEBUG_FORTH_PARSE_EXEC: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_EXEC_SLOW: equ 0     ; 6  
0103			DEBUG_FORTH_PARSE_NEXTWORD: equ 0  
0103			DEBUG_FORTH_JP: equ 0    ; 4  
0103			DEBUG_FORTH_MALLOC: equ 0  
0103			DEBUG_FORTH_MALLOC_INT: equ 0  
0103			DEBUG_FORTH_DOT: equ 0  
0103			DEBUG_FORTH_DOT_WAIT: equ 0  
0103			DEBUG_FORTH_MATHS: equ 0  
0103			DEBUG_FORTH_TOK: equ 0    ; 4  
0103			DEBUG_FORTH_PARSE: equ 0    ; 3  
0103			DEBUG_FORTH: equ 0  ;2  
0103			DEBUG_FORTH_WORDS: equ 1   ; 1  
0103			DEBUG_FORTH_PUSH: equ 1   ; 1  
0103			DEBUG_FORTH_UWORD: equ 1   ; 1  
0103			  
0103			; Enable key point breakpoints  
0103			  
0103			DEBUG_FORTH_DOT_KEY: equ 0  
0103			DEBUG_FORTH_PARSE_KEY: equ 0   ; 5  
0103			DEBUG_FORTH_WORDS_KEY: equ 1   ; 1  
0103			  
0103			; Debug stack imbalances  
0103			  
0103			ON: equ 1  
0103			OFF: equ 0  
0103			  
0103			DEBUG_STACK_IMB: equ 0  
0103			STACK_IMB_STORE: equ 20  
0103			  
0103			; House keeping and protections  
0103			  
0103			DEBUG_FORTH_STACK_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_GUARD: equ 1  
0103			DEBUG_FORTH_MALLOC_HIGH: equ 0     ; warn only if more than 255 chars being allocated. would be highly unusual!  
0103			FORTH_ENABLE_FREE: equ 0  
0103			FORTH_ENABLE_MALLOCFREE: equ 1  
0103			FORTH_ENABLE_DSPPOPFREE: equ 1    ; TODO BUG Seems to be OK in some situations but with SW it crashes straight away  
0103			FORTH_ENABLE_FLOATMATH: equ 0  
0103			  
0103			  
0103			CALLMONITOR: macro  
0103				call break_point_state  
0103				endm  
0103			  
0103			MALLOC_1: equ 1        ; from dk88   
0103			MALLOC_2: equ 0           ; broke  
0103			MALLOC_3: equ 0           ; really broke  
0103			MALLOC_4: equ 0              ; mine pretty basic reuse and max of 250 chars  
0103			  
0103			if BASE_KEV   
0103			stacksize: equ 256  
0103			  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 128  
0103			STACK_DATA_SIZE: equ 512  
0103			endif  
0103			if BASE_SC114  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 128  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			if BASE_CPM  
0103			;tos:	equ 0f000h  
0103			stacksize: equ 256  
0103			STACK_RET_SIZE: equ 64  
0103			STACK_LOOP_SIZE: equ 128  
0103			STACK_DATA_SIZE: equ 256  
0103			endif  
0103			  
0103			;if STORAGE_SE == 0  
0103			STORE_BLOCK_PHY:   equ 64    ; physical block size on storage   64byte on 256k eeprom  
0103			STORE_DEVICE_MAXBLOCKS:  equ  255*2 ; how many blocks are there on this storage device  
0103			;endif  
0103			  
0103			; Block 0 at offset $3b is a flag to decide to offer auto start up - 0 = prompt 1-auto run no prompt 2 - dont run  
0103			  
0103			STORE_0_AUTORUN: equ $20  
0103			  
0103			; Block 0 at offset $20+ holds the file number to run at system startup after the display  
0103			  
0103			STORE_0_AUTOFILE: equ $21  
0103			STORE_0_BANKRUN: equ $23  
0103			STORE_0_FILERUN: equ $24  
0103			  
0103			; Block 0 offsets for settings  
0103			  
0103			; if set then skip prompt for start up and accept all  
0103			  
0103			STORE_0_QUICKSTART: equ $25  
0103			  
0103			; Blocks where directory table is held  
0103			  
0103			; Reducing the number of entries increases the max file size  
0103			  
0103			;STORE_DIR_START: equ 1  
0103			;STORE_DIR_END: equ 33  
0103			  
0103			; Blocks from where file data is stored  
0103			  
0103			;STORE_DATA_START: equ STORE_DIR_END + 1  
0103			  
0103			; Block indicators (<32 are data files)  
0103			  
0103			;STORE_BLOCK_CFG: equ $8f       ; config block  
0103			;STORE_BLOCK_DIRF: equ $8e       ; directory block free  
0103			;STORE_BLOCK_DIRU: equ $8d       ; directory block free  
0103			;STORE_BLOCK_FREE: equ $85       ; data block free  
0103			;STORE_BLOCK_AUTO: equ $89       ; auto start code  
0103			  
0103			  
0103			  
0103			; Directory entry flags  
0103			  
0103			;STORE_DIR_FREE: equ 0  
0103			;STORE_DIR_FILE:  equ 1  
0103			  
0103			; Structure offsets to directory entries  
0103			;STORE_DE_FLAG: equ 0  
0103			;STORE_DE_MAXEXT: equ 1  
0103			;STORE_DE_FILENAME: equ 2  
0103			  
0103			; Structure offsets to block 0  
0103			  
0103			;STORE_BK0_ISFOR: equ 1  
0103			;STORE_BK0_LABEL: equ 3  
0103			  
0103			; memory allocation   
0103			  
0103			chk_stund: equ tos+2           ; underflow check word  
0103			chk_stovr: equ chk_stund-stacksize -2; overflow check word  
0103			  
0103			; keyscan table needs rows x cols buffer  
0103			;key_rows: equ 5     ; TODO move out to mini and maxi + 1 null  
0103			;key_cols: equ 10    ; TODO move out to mini and maxi + 1 null  
0103			  
0103			keyscan_table_row1: equ chk_stovr -key_cols-1  
0103			keyscan_table_row2: equ keyscan_table_row1-key_cols-1  
0103			keyscan_table_row3: equ keyscan_table_row2-key_cols-1  
0103			keyscan_table_row4: equ keyscan_table_row3-key_cols-1  
0103			keyscan_table_row5: equ keyscan_table_row4-key_cols-1  
0103			keyscan_table: equ keyscan_table_row5-(key_cols*key_rows)-1  
0103			keyscan_scancol: equ keyscan_table-key_cols  
0103			;keyscan_table_len: equ key_rows*key_cols  
0103			;keybufptr: equ keyscan_table - 2  
0103			;keysymbol: equ keybufptr - 1  
0103			key_held: equ keyscan_scancol-1	; currently held  
0103			key_held_prev: equ key_held - 1   ; previously held (to detect bounce and cycle of key if required)  
0103			key_repeat_ct: equ key_held_prev - 4 ; timers (two words)  
0103			key_fa: equ key_repeat_ct -1 ;  
0103			key_fb: equ key_fa -1 ;  
0103			key_fc: equ key_fb -1 ;  
0103			key_fd: equ key_fc -1 ;  
0103			key_face_held: equ key_fd - 1   
0103			  
0103			; flag for enabling/disabling various hardware diag loading via block 0 on bank 1  
0103			  
0103			hardware_config: equ key_face_held - 10  
0103			  
0103			; hardware config switches  
0103			; TODO add bitmasks on includes for hardware  
0103			; high byte for expansion ids  
0103			;     0000 0000  no card inserted  
0103			;     0000 0001  storage card inserted  
0103			;     0000 0010  spi sd card active  
0103			  
0103			;       
0103			; low byte:  
0103			;     0000 0001   4x4 keypad  
0103			;     0000 0010   full keyboard  
0103			;     0000 0011   spi/ext keyboard  
0103			;     0000 0100   20x4 lcd  
0103			;     0000 1000   40x4 lcd  
0103			;     0000 1100   spi/ext display  
0103			;     0001 0000   ide interface available  
0103			  
0103			hardware_word: equ hardware_config - 2  
0103			  
0103			; debug marker - optional display of debug point on the debug screens  
0103			  
0103			debug_mark: equ hardware_word - 4  
0103			  
0103			; input_str vars  
0103			input_ptr:  equ debug_mark - 2    ; ptr to the current cursor position of string currently being edited  on entry starting   
0103			input_start:  equ input_ptr - 2    ; ptr to the start of string   
0103			input_size: equ input_start -1  ; number of chars  
0103			input_display_size: equ input_size -1  ; TODO number of chars that are displayable. if < input_size then scroll   
0103			input_at_pos: equ input_display_size - 1 ; frame buffer offset for start of input  
0103			input_under_cursor: equ input_at_pos - 1 ; char under the cursor so we can blink it  
0103			input_at_cursor: equ input_under_cursor - 1 ; offset of cursor to current start of string  
0103			input_cur_flash: equ input_at_cursor - 2 ;  timeout for cursor flash  
0103			input_cur_onoff: equ input_cur_flash - 1 ;  cursor blink on or off  
0103			input_len: equ input_cur_onoff - 5 ; length of current input  
0103			input_cursor: equ input_len - 5 ; offset of cursor to current start of string  
0103			  
0103			CUR_BLINK_RATE: equ 15  
0103			  
0103			key_actual_pressed: equ input_cursor - 1   
0103			key_symbol: equ key_actual_pressed - 1   
0103			key_shift: equ key_symbol - 1   
0103			  
0103			; Display allocation  
0103			  
0103			;display_rows: equ 4     ; move out to mini and mega files  
0103			;display_cols: equ 20  
0103			  
0103			display_fb_len: equ display_rows*display_cols  
0103			  
0103			; primary frame buffer     
0103			display_fb0: equ  key_shift-display_fb_len -1 ; -display_fb_len-1          ; cli input     TODO why is that doubling up?  
0103			; working frame buffers  
0103			display_fb1: equ  display_fb0-display_fb_len -1 ; -display_fb_len-1          ; default running program  
0103			display_fb3: equ  display_fb1-display_fb_len - 1  
0103			display_fb2: equ  display_fb3-display_fb_len - 1  
0103			;  
0103			; pointer to active frame buffer  
0103			display_fb_active: equ display_fb2 - 2  
0103			display_lcde1e2: equ display_fb_active - 1         ; 0=e1, 1=e2   For E1/E2 selection when using the lcd 4x40 display  
0103			display_write_tmp: equ display_lcde1e2 - 2  
0103			  
0103			  
0103			;  
0103			  
0103			;; can load into de directory  
0103			cursor_col: equ display_write_tmp-1  
0103			cursor_row: equ cursor_col-1  
0103			cursor_ptr: equ cursor_row - 1     ;  actual offset into lcd memory for row and col combo  
0103			cursor_shape: equ cursor_ptr - 2   ; char used for the current cursor   
0103			  
0103			; maths vars  
0103			  
0103			LFSRSeed: equ cursor_shape -20   
0103			randData: equ LFSRSeed - 2  
0103			xrandc: equ randData - 2  
0103			stackstore: equ xrandc - 2  
0103			seed1: equ  stackstore -2   
0103			seed2: equ seed1 - 2  
0103			  
0103			; cf storage vars  
0103			  
0103			iErrorNum:  equ seed2-1         ;Error number  
0103			iErrorReg:  equ iErrorNum -1              ;Error register  
0103			iErrorVer:  equ iErrorReg - 1              ;Verify error flag  
0103			  
0103			store_bank_active: equ iErrorVer - (5 + 8 ) 		; TODO not used.  indicator of which storage banks are available to use 5 on board and 8 in cart  
0103			  
0103			STORE_BLOCK_LOG:  equ   255      ; TODO remove.... Logical block size     
0103			  
0103			store_page: equ store_bank_active-STORE_BLOCK_PHY            ; page size for eeprom  
0103			;?????store_ffpage: equ store_page-STORE_BLOCK_LOG            ; page size for eeprom?????  
0103			store_tmp1: equ store_page - 2      ; temp pointer holders during ops  
0103			store_tmp2: equ store_tmp1 - 2        ; temp pointer holders during ops  
0103			store_tmp3: equ store_tmp2 - 2        ; temp pointer holders during ops  
0103			store_tmpid: equ store_tmp3 - 1		; page temp id  
0103			store_tmpext: equ store_tmpid - 1		; file extent temp  
0103			store_openext: equ store_tmpext - 1		; file extent of current opened file for read  
0103			store_openmaxext: equ store_openext - 1		; max extent of current opened file for read  
0103			store_filecache: equ store_openmaxext-(2*5)   ;  TODO (using just one for now)  file id + extent count cache * 5  
0103			store_tmppageid: equ store_filecache-2    ; phyical page id temp  
0103			;  
0103			; spi vars  
0103			  
0103			  
0103			spi_cartdev: equ store_tmppageid - 1      ; holds bit mask to send to portb (ext spi) devices  
0103			spi_cartdev2: equ spi_cartdev - 1      ; holds bit mask to send to portb's shift reg devices  
0103			spi_portbyte: equ spi_cartdev2 - 1      ; holds bit mask to send to spi bus   
0103			spi_device: equ spi_portbyte - 1    ; bit mask to send to porta (eeproms) devices  
0103			spi_device_id: equ spi_device - 1    ; human readable bank number  
0103			  
0103			;;;;; forth cli params  
0103			  
0103			; TODO use a different frame buffer for forth???  
0103			  
0103			f_cursor_ptr:  equ spi_device_id - 1  ; offset into frame buffer for any . or EMIT output  
0103			cli_buffer: equ f_cursor_ptr - 20     ; temp hold - maybe not needed  
0103			cli_origtoken: equ cli_buffer - 2     ; pointer to the text of token for this word being checked  
0103			cli_token: equ cli_origtoken - 2     ; pointer to the text of token for this word being checked  
0103			cli_execword: equ cli_token - 2      ; pointer to start of code for this word  
0103			cli_nextword: equ cli_execword - 2      ; pointer to start of next word in dict  
0103			cli_ptr: equ cli_nextword - 2           ; pointer to start of word to parse by forth kernel (working)  
0103			cli_origptr: equ cli_ptr - 2           ; pointer to start of word to parse which resets cli_ptr on each word test  
0103			  
0103			cli_mvdot: equ cli_origptr - 1 ;     ; true will move the cursor once something is displayed  
0103			cli_autodisplay: equ cli_mvdot - 1 ;     ; true will auto update the display (slow) otherwise need to use DRAW  
0103			cli_var_array: equ cli_autodisplay - ( 10 * 2 ) ; word or string pointer variables using V@0-V@9  
0103			cli_ret_sp: equ cli_var_array - 2    ; ret stack pointer  
0103			cli_loop_sp: equ cli_ret_sp - 2   ; data stack pointer  
0103			cli_data_sp: equ cli_loop_sp - 2   ; data stack pointer  
0103			  
0103			chk_ret_und: equ cli_data_sp-2           ; underflow check word  
0103			cli_ret_stack: equ chk_ret_und - STACK_RET_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_ret_ovr: equ cli_ret_stack -2; overflow check word  
0103			cli_loop_stack: equ chk_ret_ovr - STACK_LOOP_SIZE      ; TODO could I just use normal stack for this? - use linked list for looping  
0103			chk_loop_ovr: equ cli_loop_stack -2; overflow check word  
0103			cli_data_stack: equ chk_loop_ovr - STACK_DATA_SIZE		 ;   
0103			chk_data_ovr: equ cli_data_stack -2; overflow check word  
0103			  
0103			os_var_array: equ chk_data_ovr - (32 * 2)      ;   32 word array for use using the SCRATCH word  
0103			  
0103			; os/forth token vars  
0103			  
0103			os_last_cmd: equ os_var_array-255  
0103			os_cli_cmd: equ os_last_cmd-255              ; cli command entry line  
0103			os_current_i: equ os_cli_cmd-2  
0103			os_cur_ptr: equ os_current_i-2  
0103			os_word_scratch: equ os_cur_ptr-30  
0103			os_tok_len: equ os_word_scratch - 2  
0103			os_tok_ptr: equ os_tok_len - 2               ; our current PC ptr  
0103			os_tok_malloc: equ os_tok_ptr - 2  
0103			os_last_new_uword: equ os_tok_malloc - 2    ; hold start of last user word added  
0103			os_input: equ os_last_new_uword-255    ; buffer for EDIT word  
0103			execscratch: equ os_input-255        ; exec cmd eval buffer  
0103			scratch: equ execscratch-255  
0103			  
0103			  
0103			; temp locations for new word processing to save on adding more   
0103			  
0103			os_new_malloc: equ scratch-2  
0103			os_new_parse_len: equ os_new_malloc - 2  
0103			os_new_word_len: equ os_new_parse_len - 2  
0103			os_new_work_ptr: equ os_new_word_len - 2  
0103			os_new_src_ptr: equ os_new_work_ptr - 2  
0103			os_new_exec: equ os_new_src_ptr - 2  
0103			os_new_exec_ptr: equ os_new_exec - 2  
0103			  
0103			; resume memory alloocations....  
0103			  
0103			os_view_disable: equ os_new_exec_ptr - 1  
0103			os_view_af: equ os_view_disable - 2  
0103			os_view_hl: equ os_view_af -2  
0103			os_view_de: equ os_view_hl - 2  
0103			os_view_bc: equ os_view_de - 2  
0103			  
0103			; stack checksum word  
0103			if DEBUG_STACK_IMB  
0103				curframe: equ  os_view_de - 5  
0103				store_sp: equ curframe - (STACK_IMB_STORE*4)  
0103				chk_word: equ store_sp - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			else  
0103				chk_word: equ os_view_bc - 2		 ; this is the word to init and then check against to detect stack corruption. Held far away from all stacks  
0103			endif  
0103			  
0103			; with data stack could see memory filled with junk. need some memory management   
0103			; malloc and free entry points added  
0103			  
0103			;free_list:  equ chk_word - 4     ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  (free_list-08100h)      ; Number of bytes available in heap   TODO make all of user ram  
0103			;;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			;heap_end: equ free_list-1  ; Starting address of heap  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			  
0103			;heap_start: equ free_list - heap_size  ; Starting address of heap  
0103			heap_end: equ chk_word-1  ; Starting address of heap  
0103			  
0103			  
0103			;if BASE_KEV   
0103			;heap_start: equ 0800eh  ; Starting address of heap  
0103			;free_list:  equ 0800ah      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;heap_start: equ baseram+15  ; Starting address of heap  
0103			;free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes)  
0103			;endif  
0103			  
0103			  
0103			;;;;  
0103			  
0103			  
0103			; change below to point to last memory alloc above  
0103			topusermem:  equ   heap_start  
0103			  
0103			;if BASE_KEV   
0103			;baseusermem: equ 08000h  
0103			;endif  
0103			  
0103			;if BASE_SC114  
0103			;;aseusermem:     equ    12  
0103			;baseusermem:     equ    prompt  
0103			;;baseusermem:     equ    endofcode  
0103			;endif  
0103			  
0103			  
0103			; **********************************************************************  
0103			; **  Constants  
0103			; **********************************************************************  
0103			  
0103			; Constants used by this code module  
0103			kDataReg:   EQU Device_D           ;PIO port A data register  
0103			kContReg:   EQU Device_D+2           ;PIO port A control register  
0103			  
0103			  
0103			portbdata:  equ Device_D+1    ; port b data  
0103			portbctl:   equ Device_D+3    ; port b control  
0103			  
0103			  
0103			;KEY_SHIFT:   equ 5  
0103			;KEY_SYMBOLSHIFT:  equ 6  
0103			  
0103			KEY_SHIFTLOCK: equ 4  
0103			  
0103			  
0103			KEY_UP: equ 5  
0103			KEY_NEXTWORD: equ 6  
0103			KEY_PREVWORD: equ 7  
0103			KEY_BS: equ 8  
0103			KEY_TAB:  equ 9  
0103			KEY_DOWN: equ 10  
0103			KEY_LEFT: equ 11  
0103			KEY_RIGHT: equ 12  
0103			KEY_CR:   equ 13  
0103			KEY_HOME: equ 14  
0103			KEY_END: equ 15  
0103			  
0103			KEY_F1: equ 16  
0103			KEY_F2: equ 17  
0103			KEY_F3: equ 18  
0103			KEY_F4: equ 19  
0103			  
0103			KEY_F5: equ 20  
0103			KEY_F6: equ 21  
0103			KEY_F7: equ 22  
0103			KEY_F8: equ 23  
0103			  
0103			KEY_F9: equ 24  
0103			KEY_F10: equ 25  
0103			KEY_F11: equ 26  
0103			KEY_F12: equ 27  
0103			  
0103			;if DEBUG_KEY  
0103			;	KEY_MATRIX_NO_PRESS: equ '.'  
0103			;	KEY_SHIFT:   equ '.'  
0103			;	KEY_SYMBOLSHIFT:  equ '.'  
0103			;else  
0103				KEY_SHIFT:   equ '~'  
0103				KEY_SYMBOLSHIFT:  equ '~'  
0103				KEY_MATRIX_NO_PRESS: equ '~'  
0103			;endi  
0103			  
0103			  
0103			  
0103			  
0103			; Macro to make adding debug marks easier  
0103			  
0103			DMARK: macro str  
0103				push af  
0103				ld a, (.dmark)  
0103				ld (debug_mark),a  
0103				ld a, (.dmark+1)  
0103				ld (debug_mark+1),a  
0103				ld a, (.dmark+2)  
0103				ld (debug_mark+2),a  
0103				jr .pastdmark  
0103			.dmark: db str  
0103			.pastdmark: pop af  
0103			  
0103			endm  
0103			  
0103			  
0103			; macro to detect for stack imbalances  
0103			  
0103			include "stackimbal.asm"  
0103			; Macro and code to detect stock imbalances 
0103			 
0103			SPPUSH: equ 0 
0103			 
0103			; Add a stack frame which can be checked before return 
0103			 
0103			STACKFRAME: macro onoff frame1 frame2 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103						exx 
0103			 
0103						ld de, frame1 
0103						ld a, d 
0103						ld hl, curframe 
0103						call hexout 
0103						ld a, e 
0103						ld hl, curframe+2 
0103						call hexout 
0103			  
0103						ld hl, frame1 
0103						push hl 
0103						ld hl, frame2 
0103						push hl 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			endm 
0103			 
0103			STACKFRAMECHK: macro onoff frame1 frame2 
0103			 
0103					 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						exx 
0103						; check stack frame SP 
0103			 
0103						ld hl, frame2 
0103						pop de   ; frame2 
0103			 
0103						call cmp16 
0103						jr nz, .spnosame 
0103						 
0103			 
0103						ld hl, frame1 
0103						pop de   ; frame1 
0103			 
0103						call cmp16 
0103						jr z, .spfrsame 
0103			 
0103						.spnosame: call showsperror 
0103			 
0103						.spfrsame: nop 
0103			 
0103						exx 
0103					endif 
0103					 
0103				endif 
0103			 
0103			 
0103			endm 
0103			 
0103			 
0103			; for a sub routine, wrap SP collection and comparisons 
0103			 
0103			; Usage: 
0103			; 
0103			; SAVESP ON/OFF 0-STACK_IMB_STORE/4 
0103			; CHECKSP ON/OFF 0-STACK_IMB_STORE/4 
0103			 
0103			SAVESP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103						; save current SP 
0103			 
0103						ld (store_sp+(storeword*4)), sp 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			CHECKSP: macro onoff storeword 
0103			 
0103				if DEBUG_STACK_IMB 
0103					if onoff 
0103			 
0103						; save SP after last save 
0103				 
0103						ld (store_sp+(storeword*4)+2), sp 
0103			 
0103						push hl 
0103						ld hl, store_sp+(storeword*4) 
0103						call check_stack_sp  
0103						pop hl 
0103			 
0103			 
0103					endif 
0103					 
0103				endif 
0103			 
0103			endm 
0103			 
0103			if DEBUG_STACK_IMB 
0103			 
0103			check_stack_sp: 
0103					push de 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					push de 
0103			 
0103			 
0103					ld e, (hl) 
0103					inc hl 
0103					ld d, (hl) 
0103					inc hl 
0103			 
0103					pop hl 
0103			 
0103			 
0103					; check to see if the same 
0103			 
0103					call cmp16 
0103					jr z, .spsame 
0103			 
0103					; not same 
0103			 
0103					call showsperror 
0103			.spsame: 
0103			 
0103					pop de 
0103			 
0103					ret 
0103			 
0103			.sperr:  db "Stack imbalance",0 
0103			 
0103			 
0103			showsperror: 
0103			 
0103			 
0103				push hl 
0103				push af 
0103				push de 
0103				call clear_display 
0103				ld de, .sperr 
0103				ld a,0 
0103			;	ld de,os_word_scratch 
0103				call str_at_display 
0103				ld a, display_row_1+17 
0103				ld de, debug_mark 
0103				call str_at_display 
0103				ld a, 0 
0103				ld (curframe+4),a 
0103				ld hl, curframe 
0103				ld de, os_word_scratch 
0103				ld a, display_row_4 
0103				call str_at_display 
0103				call update_display 
0103				;call break_point_state 
0103				call cin_wait 
0103			 
0103				ld a, ' ' 
0103				ld (os_view_disable), a 
0103				pop de	 
0103				pop af 
0103				pop hl 
0103				CALLMONITOR 
0103				ret 
0103			 
0103			endif 
0103			 
0103			 
0103			 
0103			; eof 
# End of file stackimbal.asm
0103			  
0103			;TODO macro to calc col and row offset into screen  
0103			  
0103			  
0103			  
0103			hardware_init:  
0103			  
0103				  
0103			  
0103					;ld a, 0  
0103					;ld (hardware_diag), a  
0103			  
0103					; clear all the buffers  
0103			  
0103 21 16 ed				ld hl, display_fb1  
0106 22 d2 eb				ld (display_fb_active), hl  
0109			  
0109 cd 59 0a				call clear_display  
010c			  
010c 21 d4 eb				ld hl, display_fb2  
010f 22 d2 eb				ld (display_fb_active), hl  
0112			  
0112 cd 59 0a				call clear_display  
0115			  
0115					; init primary frame buffer area  
0115 21 b7 ed				ld hl, display_fb0  
0118 22 d2 eb				ld (display_fb_active), hl  
011b			  
011b cd 59 0a				call clear_display  
011e			  
011e			  
011e cd 3e 59				call lcd_init		; lcd hardware first as some screen functions called during key_init e.g. cursor shapes  
0121			  
0121 cd 2c 5a			call key_init  
0124 cd 86 01			call storage_init  
0127			  
0127				; setup malloc functions  
0127			  
0127				if MALLOC_1  
0127 cd 29 11				call  heap_init  
012a				endif  
012a				if MALLOC_4  
012a					call  heap_init  
012a				endif  
012a			  
012a				; init sound hardware if present  
012a			  
012a				if SOUND_ENABLE  
012a					call sound_init  
012a				endif  
012a			  
012a				; lcd test sequence  
012a					  
012a cd 7c 0a			call update_display  
012d cd cb 09			call delay1s  
0130 3e 2b			ld a,'+'  
0132 cd 5e 0a			call fill_display  
0135 cd 7c 0a			call update_display  
0138 cd cb 09			call delay1s  
013b 3e 2a			ld a,'*'  
013d cd 5e 0a			call fill_display  
0140 cd 7c 0a			call update_display  
0143 cd cb 09			call delay1s  
0146 3e 2d			ld a,'-'  
0148 cd 5e 0a			call fill_display  
014b cd 7c 0a			call update_display  
014e cd cb 09			call delay1s  
0151			  
0151			; boot splash screen  
0151			if display_cols == 20	  
0151			        ld a, display_row_1    
0151			else  
0151 3e 0a		        ld a, display_row_1 +10   
0153			endif  
0153 11 5d 16			ld de, prom_bootmsg  
0156 cd 6c 0a			call str_at_display  
0159 cd 7c 0a			call update_display  
015c			  
015c			  
015c cd cb 09			call delay1s  
015f cd cb 09			call delay1s  
0162			if display_cols == 20	  
0162			            LD   A, display_row_3+2  
0162			else  
0162 3e 5c		            LD   A, display_row_3+12  
0164			endif  
0164 11 72 16			ld de, prom_bootmsg1  
0167 cd 6c 0a			call str_at_display  
016a cd 7c 0a			call update_display  
016d cd cb 09			call delay1s  
0170 cd cb 09			call delay1s  
0173			  
0173			;	ld a, display_row_4+3  
0173			;	ld de, bootmsg2  
0173			;	call str_at_display  
0173			;	call update_display  
0173			;	call delay1s  
0173			;	call delay1s  
0173			  
0173			; debug mark setup  
0173			  
0173 3e 5f		ld a, '_'  
0175 32 71 ee		ld (debug_mark),a  
0178 32 72 ee		ld (debug_mark+1),a  
017b 32 73 ee		ld (debug_mark+2),a  
017e 3e 00		ld a,0  
0180 32 74 ee		ld (debug_mark+3),a  
0183			  
0183 c9					ret  
0184			  
0184			  
0184			;bootmsg2:	db "Firmware v0.1",0  
0184			  
0184			; a 4x20 lcd  
0184			; cout for display, low level positioning and writing functions (TODO) for hardware abstraction  
0184			  
0184			;if display_cols == 20  
0184			;	include "firmware_lcd_4x20.asm"  
0184			;endif  
0184			  
0184			;if display_cols == 40  
0184			;	include "firmware_lcd_4x40.asm"  
0184			;endif  
0184			  
0184			;  
0184			; TODO use the low spare two pins on port a of display pio to bit bang a serial out video display to an esp  
0184			; TODO abstract the bit bang video out interface for dual display  
0184			; TODO wire video out to tx pin on rc2014 bus  
0184			  
0184			; must supply cin, and cin_wait for low level hardware abstraction   
0184			; moved text_input entry points to here and leave the firmware hardware modules as abstraction layer  
0184			; test scancode  
0184			  
0184			;;;;;  
0184			;;;  
0184			; Moved out to mini and maxi versions  
0184			;  
0184			; include "firmware_key_4x4.asm"  
0184			; using existing 4 wire x 4 resistor array for input  
0184			;include "firmware_key_4x10.asm"  
0184			; need to mod the board for 5 rows due to resistor array  
0184			;include "firmware_key_5x10.asm"  
0184			  
0184			; storage hardware interface  
0184			  
0184			; use microchip serial eeprom for storage  
0184			  
0184			  
0184			if STORAGE_SE  
0184				include "firmware_spi.asm"  
0184				include "firmware_seeprom.asm"  
0184			else  
0184			   ; create some stubs for the labels  
0184 c9			se_readbyte: ret  
0185 c9			se_writebyte: ret  
0186 c9			storage_init: ret  
0187			  
0187			endif  
0187			  
0187			; use cf card for storage - throwing timeout errors. Hardware or software?????  
0187			;include "firmware_cf.asm"  
0187			  
0187			; load up high level storage hardward abstractions  
0187			include "firmware_storage.asm"  
0187			 
0187			; persisent storage hardware abstraction layer  
0187			 
0187			 
0187			 
0187			; Block 0 on storage is a config state 
0187			 
0187			 
0187			 
0187			; TODO add read phy block and write phy block functions 
0187			; TODO add presence check (i.e. read write byte 0 of block 0 for eeprom) 
0187			 
0187			; Abstraction layer  
0187			 
0187			; Logocial block size is same size as physical size - using tape concept 
0187			 
0187			;STORE_BLOCK_PHY2LOG: equ (STORE_BLOCK_LOG/STORE_BLOCK_PHY)       ; How many physical blocks make up a logical block 
0187			;STORE_BLOCK_MAX: equ (STORE_BLOCK_PHY*STORE_DEVICE_MAXBLOCKS)/255    ; Max number of logical blocks on the device 
0187			 
0187			 
0187			 
0187			; Filesystem layout (Logical layout) 
0187			; 
0187			; Block 0 - Bank config  
0187			; 
0187			;      Byte - 0 file id counter 
0187			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0187			;      Byte - 3-20 zero terminated bank label 
0187			; 
0187			; Block 1 > File storage 
0187			; 
0187			;      Byte 0 file id    - block 0 file details 
0187			;      Byte 1 block id - block 0 is file  
0187			;            Byte 2-15 - File name 
0187			; 
0187			;       - to end of block data 
0187			; 
0187			 
0187			; Get ID for the file named in pointer held HL 
0187			; Returns ID in HL = 255 if no file found 
0187			 
0187			storage_getid: 
0187			 
0187 22 5a eb			ld (store_tmp1), hl 
018a			 
018a				if DEBUG_STORESE 
018a					DMARK "SGI" 
018a f5				push af  
018b 3a 9f 01			ld a, (.dmark)  
018e 32 71 ee			ld (debug_mark),a  
0191 3a a0 01			ld a, (.dmark+1)  
0194 32 72 ee			ld (debug_mark+1),a  
0197 3a a1 01			ld a, (.dmark+2)  
019a 32 73 ee			ld (debug_mark+2),a  
019d 18 03			jr .pastdmark  
019f ..			.dmark: db "SGI"  
01a2 f1			.pastdmark: pop af  
01a3			endm  
# End of macro DMARK
01a3					CALLMONITOR 
01a3 cd 87 14			call break_point_state  
01a6				endm  
# End of macro CALLMONITOR
01a6				endif 
01a6				; get block 0 and set counter for number of files to scan 
01a6			 
01a6 cd 11 03			call storage_get_block_0 
01a9			 
01a9 3a 5c eb			ld a, (store_page) 
01ac 47				ld b, a 
01ad			 
01ad				; get extent 0 of each file id 
01ad			 
01ad				if DEBUG_STORESE 
01ad					DMARK "SGc" 
01ad f5				push af  
01ae 3a c2 01			ld a, (.dmark)  
01b1 32 71 ee			ld (debug_mark),a  
01b4 3a c3 01			ld a, (.dmark+1)  
01b7 32 72 ee			ld (debug_mark+1),a  
01ba 3a c4 01			ld a, (.dmark+2)  
01bd 32 73 ee			ld (debug_mark+2),a  
01c0 18 03			jr .pastdmark  
01c2 ..			.dmark: db "SGc"  
01c5 f1			.pastdmark: pop af  
01c6			endm  
# End of macro DMARK
01c6					CALLMONITOR 
01c6 cd 87 14			call break_point_state  
01c9				endm  
# End of macro CALLMONITOR
01c9				endif 
01c9 60			.getloop:	ld h, b 
01ca 2e 00				ld l, 0 
01cc c5					push bc 
01cd			 
01cd 11 5c eb				ld de, store_page 
01d0				if DEBUG_STORESE 
01d0					DMARK "SGr" 
01d0 f5				push af  
01d1 3a e5 01			ld a, (.dmark)  
01d4 32 71 ee			ld (debug_mark),a  
01d7 3a e6 01			ld a, (.dmark+1)  
01da 32 72 ee			ld (debug_mark+1),a  
01dd 3a e7 01			ld a, (.dmark+2)  
01e0 32 73 ee			ld (debug_mark+2),a  
01e3 18 03			jr .pastdmark  
01e5 ..			.dmark: db "SGr"  
01e8 f1			.pastdmark: pop af  
01e9			endm  
# End of macro DMARK
01e9					CALLMONITOR 
01e9 cd 87 14			call break_point_state  
01ec				endm  
# End of macro CALLMONITOR
01ec				endif 
01ec cd b9 07				call storage_read 
01ef cd af 0c				call ishlzero 
01f2 28 2d				jr z, .gap 
01f4					 
01f4					; have a file name read. Is it one we want. 
01f4			 
01f4 2a 5a eb				ld hl, (store_tmp1) 
01f7 11 5f eb				ld de, store_page+3   ; file name 
01fa			 
01fa				if DEBUG_STORESE 
01fa					DMARK "SGc" 
01fa f5				push af  
01fb 3a 0f 02			ld a, (.dmark)  
01fe 32 71 ee			ld (debug_mark),a  
0201 3a 10 02			ld a, (.dmark+1)  
0204 32 72 ee			ld (debug_mark+1),a  
0207 3a 11 02			ld a, (.dmark+2)  
020a 32 73 ee			ld (debug_mark+2),a  
020d 18 03			jr .pastdmark  
020f ..			.dmark: db "SGc"  
0212 f1			.pastdmark: pop af  
0213			endm  
# End of macro DMARK
0213					CALLMONITOR 
0213 cd 87 14			call break_point_state  
0216				endm  
# End of macro CALLMONITOR
0216				endif 
0216 cd 1c 11				call strcmp 
0219 20 06				jr nz, .gap   ; not this one 
021b			 
021b c1				        pop bc 
021c			 
021c 26 00				ld h, 0 
021e 68					ld l, b 
021f 18 22				jr .getdone 
0221						 
0221			 
0221			 
0221			 
0221			.gap: 
0221				if DEBUG_STORESE 
0221					DMARK "SGg" 
0221 f5				push af  
0222 3a 36 02			ld a, (.dmark)  
0225 32 71 ee			ld (debug_mark),a  
0228 3a 37 02			ld a, (.dmark+1)  
022b 32 72 ee			ld (debug_mark+1),a  
022e 3a 38 02			ld a, (.dmark+2)  
0231 32 73 ee			ld (debug_mark+2),a  
0234 18 03			jr .pastdmark  
0236 ..			.dmark: db "SGg"  
0239 f1			.pastdmark: pop af  
023a			endm  
# End of macro DMARK
023a					CALLMONITOR 
023a cd 87 14			call break_point_state  
023d				endm  
# End of macro CALLMONITOR
023d				endif 
023d			 
023d c1					pop bc 
023e 10 89				djnz .getloop 
0240 21 ff 00				ld hl, 255 
0243			.getdone: 
0243			 
0243				if DEBUG_STORESE 
0243					DMARK "SGe" 
0243 f5				push af  
0244 3a 58 02			ld a, (.dmark)  
0247 32 71 ee			ld (debug_mark),a  
024a 3a 59 02			ld a, (.dmark+1)  
024d 32 72 ee			ld (debug_mark+1),a  
0250 3a 5a 02			ld a, (.dmark+2)  
0253 32 73 ee			ld (debug_mark+2),a  
0256 18 03			jr .pastdmark  
0258 ..			.dmark: db "SGe"  
025b f1			.pastdmark: pop af  
025c			endm  
# End of macro DMARK
025c					CALLMONITOR 
025c cd 87 14			call break_point_state  
025f				endm  
# End of macro CALLMONITOR
025f				endif 
025f			 
025f c9				ret 
0260			 
0260			 
0260			 
0260			 
0260			 
0260			 
0260			 
0260			 
0260			; Read Block 
0260			; ---------- 
0260			; 
0260			; With current bank 
0260			;  
0260			; Get block number to read 
0260			; Load physical blocks starting at start block into buffer 
0260			 
0260			; de points to buffer to use 
0260			; hl holds logical block number  
0260			 
0260			storage_read_block: 
0260			 
0260				; TODO bank selection 
0260			 
0260				; for each of the physical blocks read it into the buffer 
0260 06 40			ld b, STORE_BLOCK_PHY 
0262			 
0262				if DEBUG_STORESE 
0262 d5					push de 
0263				endif 
0263				 
0263			.rl1:    
0263			 
0263				; read physical block at hl into de 
0263			        ; increment hl and de to next read position on exit 
0263			 
0263 e5				push hl 
0264 d5				push de	 
0265 c5				push bc 
0266			;	if DEBUG_STORESE 
0266			;		push af 
0266			;		ld a, 'R' 
0266			;		ld (debug_mark),a 
0266			;		pop af 
0266			;		CALLMONITOR 
0266			;	endif 
0266 cd 84 01			call se_readbyte 
0269			;	if DEBUG_STORESE 
0269			;		ld a,(spi_portbyte) 
0269			;		ld l, a 
0269			;		push af 
0269			;		ld a, '1' 
0269			;		ld (debug_mark),a 
0269			;		pop af 
0269			;		CALLMONITOR 
0269			;	endif 
0269 c1				pop bc 
026a d1				pop de 
026b e1				pop hl 
026c 12				ld (de),a 
026d 23				inc hl 
026e 13				inc de 
026f			 
026f			;	if DEBUG_STORESE 
026f			;		push af 
026f			;		ld a, 'r' 
026f			;		ld (debug_mark),a 
026f			;		pop af 
026f			;		CALLMONITOR 
026f			;	endif 
026f			 
026f 10 f2			djnz .rl1 
0271			 
0271				if DEBUG_STORESE 
0271					DMARK "SRB" 
0271 f5				push af  
0272 3a 86 02			ld a, (.dmark)  
0275 32 71 ee			ld (debug_mark),a  
0278 3a 87 02			ld a, (.dmark+1)  
027b 32 72 ee			ld (debug_mark+1),a  
027e 3a 88 02			ld a, (.dmark+2)  
0281 32 73 ee			ld (debug_mark+2),a  
0284 18 03			jr .pastdmark  
0286 ..			.dmark: db "SRB"  
0289 f1			.pastdmark: pop af  
028a			endm  
# End of macro DMARK
028a d1					pop de 
028b			; 
028b			;		push af 
028b			;		ld a, 'R' 
028b			;		ld (debug_mark),a 
028b			;		pop af 
028b					CALLMONITOR 
028b cd 87 14			call break_point_state  
028e				endm  
# End of macro CALLMONITOR
028e				endif 
028e c9				ret	 
028f				 
028f			 
028f			; File Size 
028f			; --------- 
028f			; 
028f			;   hl file id 
028f			; 
028f			;  returns in hl the number of blocks 
028f			 
028f			storage_file_size: 
028f 5d				ld e, l 
0290 16 00			ld d, 0 
0292 21 40 00			ld hl, STORE_BLOCK_PHY 
0295					if DEBUG_FORTH_WORDS 
0295						DMARK "SIZ" 
0295 f5				push af  
0296 3a aa 02			ld a, (.dmark)  
0299 32 71 ee			ld (debug_mark),a  
029c 3a ab 02			ld a, (.dmark+1)  
029f 32 72 ee			ld (debug_mark+1),a  
02a2 3a ac 02			ld a, (.dmark+2)  
02a5 32 73 ee			ld (debug_mark+2),a  
02a8 18 03			jr .pastdmark  
02aa ..			.dmark: db "SIZ"  
02ad f1			.pastdmark: pop af  
02ae			endm  
# End of macro DMARK
02ae						CALLMONITOR 
02ae cd 87 14			call break_point_state  
02b1				endm  
# End of macro CALLMONITOR
02b1					endif 
02b1 cd 93 05			call storage_findnextid 
02b4			 
02b4 cd af 0c			call ishlzero 
02b7			;	ld a, l 
02b7			;	add h 
02b7			;	cp 0 
02b7 c8				ret z			; block not found so EOF 
02b8			 
02b8 11 5c eb			ld de, store_page 
02bb cd 60 02			call storage_read_block 
02be			 
02be 3a 5e eb			ld a, (store_page+2)	 ; get extent count 
02c1 6f				ld l, a 
02c2 26 00			ld h, 0 
02c4 c9			 	ret 
02c5			 
02c5			 
02c5			; Write Block 
02c5			; ----------- 
02c5			; 
02c5			; With current bank 
02c5			;  
02c5			; Get block number to write 
02c5			; Write physical blocks starting at start block from buffer 
02c5			  
02c5			storage_write_block: 
02c5				; TODO bank selection 
02c5			 
02c5				; for each of the physical blocks read it into the buffer 
02c5 06 40			ld b, STORE_BLOCK_PHY 
02c7			 
02c7				if DEBUG_STORESE 
02c7					DMARK "SWB" 
02c7 f5				push af  
02c8 3a dc 02			ld a, (.dmark)  
02cb 32 71 ee			ld (debug_mark),a  
02ce 3a dd 02			ld a, (.dmark+1)  
02d1 32 72 ee			ld (debug_mark+1),a  
02d4 3a de 02			ld a, (.dmark+2)  
02d7 32 73 ee			ld (debug_mark+2),a  
02da 18 03			jr .pastdmark  
02dc ..			.dmark: db "SWB"  
02df f1			.pastdmark: pop af  
02e0			endm  
# End of macro DMARK
02e0			 
02e0					;push af 
02e0					;ld a, 'W' 
02e0					;ld (debug_mark),a 
02e0					;pop af 
02e0					CALLMONITOR 
02e0 cd 87 14			call break_point_state  
02e3				endm  
# End of macro CALLMONITOR
02e3				endif 
02e3			 
02e3			; might not be working 
02e3			;	call se_writepage 
02e3			 
02e3			;	ret 
02e3			; 
02e3			 
02e3			 
02e3			 
02e3			.wl1:    
02e3			 
02e3				; read physical block at hl into de 
02e3			        ; increment hl and de to next read position on exit 
02e3			 
02e3 e5				push hl 
02e4 d5				push de	 
02e5 c5				push bc 
02e6 1a				ld a,(de) 
02e7				;if DEBUG_STORESE 
02e7			;		push af 
02e7			;		ld a, 'W' 
02e7			;		ld (debug_mark),a 
02e7			;		pop af 
02e7			;		CALLMONITOR 
02e7			;	endif 
02e7 cd 85 01			call se_writebyte 
02ea			;	call delay250ms 
02ea 00				nop 
02eb 00				nop 
02ec 00				nop 
02ed			;	if DEBUG_STORESE 
02ed			;		push af 
02ed			;		ld a, 'w' 
02ed			;		ld (debug_mark),a 
02ed			;		pop af 
02ed			;		CALLMONITOR 
02ed			;	endif 
02ed c1				pop bc 
02ee d1				pop de 
02ef e1				pop hl 
02f0 23				inc hl 
02f1 13				inc de 
02f2			 
02f2			 
02f2 10 ef			djnz .wl1 
02f4			 
02f4				if DEBUG_STORESE 
02f4					DMARK "SW2" 
02f4 f5				push af  
02f5 3a 09 03			ld a, (.dmark)  
02f8 32 71 ee			ld (debug_mark),a  
02fb 3a 0a 03			ld a, (.dmark+1)  
02fe 32 72 ee			ld (debug_mark+1),a  
0301 3a 0b 03			ld a, (.dmark+2)  
0304 32 73 ee			ld (debug_mark+2),a  
0307 18 03			jr .pastdmark  
0309 ..			.dmark: db "SW2"  
030c f1			.pastdmark: pop af  
030d			endm  
# End of macro DMARK
030d			 
030d					;push af 
030d					;ld a, 'W' 
030d					;ld (debug_mark),a 
030d					;pop af 
030d					CALLMONITOR 
030d cd 87 14			call break_point_state  
0310				endm  
# End of macro CALLMONITOR
0310				endif 
0310 c9				ret	 
0311			 
0311			; Init bank 
0311			; --------- 
0311			; 
0311			; With current bank 
0311			; 
0311			; Setup block 0 config 
0311			;     Set 0 file id counter 
0311			;     Set formatted byte pattern 
0311			;     Zero out bank label 
0311			;      
0311			; For every logical block write 0-1 byte as null 
0311			 
0311			storage_get_block_0: 
0311			 
0311				; TODO check presence 
0311			 
0311				; get block 0 config 
0311			 
0311 21 00 00			ld hl, 0 
0314 11 5c eb			ld de, store_page 
0317 cd 60 02			call storage_read_block 
031a			 
031a				if DEBUG_STORESE 
031a					DMARK "SB0" 
031a f5				push af  
031b 3a 2f 03			ld a, (.dmark)  
031e 32 71 ee			ld (debug_mark),a  
0321 3a 30 03			ld a, (.dmark+1)  
0324 32 72 ee			ld (debug_mark+1),a  
0327 3a 31 03			ld a, (.dmark+2)  
032a 32 73 ee			ld (debug_mark+2),a  
032d 18 03			jr .pastdmark  
032f ..			.dmark: db "SB0"  
0332 f1			.pastdmark: pop af  
0333			endm  
# End of macro DMARK
0333 11 5c eb				ld de, store_page 
0336			;		push af 
0336			;		ld a, 'i' 
0336			;		ld (debug_mark),a 
0336			;		pop af 
0336					CALLMONITOR 
0336 cd 87 14			call break_point_state  
0339				endm  
# End of macro CALLMONITOR
0339				endif 
0339			 
0339				; is this area formatted? 
0339			 
0339			;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
0339 2a 5d eb			ld hl, (store_page+1) 
033c 3e 80			ld a,0x80 
033e bd				cp l 
033f 20 22			jr nz, .ininotformatted 
0341				; do a double check 
0341 3e 27			ld a, 0x27 
0343 bc				cp h 
0344 20 1d			jr nz, .ininotformatted 
0346			 
0346				; formatted then 
0346			 
0346				if DEBUG_STORESE 
0346					DMARK "SB1" 
0346 f5				push af  
0347 3a 5b 03			ld a, (.dmark)  
034a 32 71 ee			ld (debug_mark),a  
034d 3a 5c 03			ld a, (.dmark+1)  
0350 32 72 ee			ld (debug_mark+1),a  
0353 3a 5d 03			ld a, (.dmark+2)  
0356 32 73 ee			ld (debug_mark+2),a  
0359 18 03			jr .pastdmark  
035b ..			.dmark: db "SB1"  
035e f1			.pastdmark: pop af  
035f			endm  
# End of macro DMARK
035f					;push af 
035f					;ld a, 'I' 
035f					;ld (debug_mark),a 
035f					;pop af 
035f					CALLMONITOR 
035f cd 87 14			call break_point_state  
0362				endm  
# End of macro CALLMONITOR
0362				endif 
0362 c9				ret 
0363			 
0363			.ininotformatted: 
0363				; bank not formatted so poke various bits to make sure 
0363			 
0363				if DEBUG_STORESE 
0363					DMARK "SB2" 
0363 f5				push af  
0364 3a 78 03			ld a, (.dmark)  
0367 32 71 ee			ld (debug_mark),a  
036a 3a 79 03			ld a, (.dmark+1)  
036d 32 72 ee			ld (debug_mark+1),a  
0370 3a 7a 03			ld a, (.dmark+2)  
0373 32 73 ee			ld (debug_mark+2),a  
0376 18 03			jr .pastdmark  
0378 ..			.dmark: db "SB2"  
037b f1			.pastdmark: pop af  
037c			endm  
# End of macro DMARK
037c					;push af 
037c					;ld a, 'f' 
037c					;ld (debug_mark),a 
037c					;pop af 
037c					CALLMONITOR 
037c cd 87 14			call break_point_state  
037f				endm  
# End of macro CALLMONITOR
037f				endif 
037f			 
037f cd 8e 09			call storage_clear_page 
0382			 
0382 21 5c eb			ld hl, store_page 
0385 3e 00			ld a, 0 
0387				 
0387 77				ld (hl),a   ; reset file counter 
0388			 
0388 21 80 27			ld hl, 0x2780     ;      Byte - 1-2 formated: Byte pattern: 0x80 x27 
038b 22 5d eb		 	ld (store_page+1), hl	 
038e			 
038e				; set default label 
038e			 
038e 21 2a 04			ld hl, .defaultbanklabl 
0391 11 5f eb		 	ld de, store_page+3 
0394 01 0f 00			ld bc, 15 
0397 ed b0			ldir 
0399			 
0399				; Append the current bank id 
0399 21 68 eb			ld hl, store_page+3+9 
039c 3a 41 eb			ld a, (spi_device_id) 
039f 77				ld (hl), a 
03a0			 
03a0				; save default page 0 
03a0			 
03a0 21 00 00			ld hl, 0 
03a3 11 5c eb			ld de, store_page 
03a6				if DEBUG_STORESE 
03a6					DMARK "SB3" 
03a6 f5				push af  
03a7 3a bb 03			ld a, (.dmark)  
03aa 32 71 ee			ld (debug_mark),a  
03ad 3a bc 03			ld a, (.dmark+1)  
03b0 32 72 ee			ld (debug_mark+1),a  
03b3 3a bd 03			ld a, (.dmark+2)  
03b6 32 73 ee			ld (debug_mark+2),a  
03b9 18 03			jr .pastdmark  
03bb ..			.dmark: db "SB3"  
03be f1			.pastdmark: pop af  
03bf			endm  
# End of macro DMARK
03bf			;		push af 
03bf			;		ld a, 'F' 
03bf			;		ld (debug_mark),a 
03bf			;		pop af 
03bf					CALLMONITOR 
03bf cd 87 14			call break_point_state  
03c2				endm  
# End of macro CALLMONITOR
03c2				endif 
03c2 cd c5 02			call storage_write_block 
03c5				if DEBUG_STORESE 
03c5					DMARK "SB4" 
03c5 f5				push af  
03c6 3a da 03			ld a, (.dmark)  
03c9 32 71 ee			ld (debug_mark),a  
03cc 3a db 03			ld a, (.dmark+1)  
03cf 32 72 ee			ld (debug_mark+1),a  
03d2 3a dc 03			ld a, (.dmark+2)  
03d5 32 73 ee			ld (debug_mark+2),a  
03d8 18 03			jr .pastdmark  
03da ..			.dmark: db "SB4"  
03dd f1			.pastdmark: pop af  
03de			endm  
# End of macro DMARK
03de			;		push af 
03de			;		ld a, '>' 
03de			;		ld (debug_mark),a 
03de			;		pop af 
03de					CALLMONITOR 
03de cd 87 14			call break_point_state  
03e1				endm  
# End of macro CALLMONITOR
03e1				endif 
03e1			 
03e1 00				nop 
03e2 00				nop 
03e3 00				nop 
03e4			 
03e4				; now set 0 in every page to mark as a free block 
03e4			 
03e4 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
03e6 21 40 00			ld hl, STORE_BLOCK_PHY 
03e9			 
03e9 3e 00		.setmark1:   	ld a,0 
03eb e5					push hl 
03ec c5					push bc 
03ed cd 85 01				call se_writebyte 
03f0 3e 0a			ld a, 10 
03f2 cd b0 09			call aDelayInMS 
03f5 23				inc hl 
03f6 cd 85 01				call se_writebyte 
03f9 3e 0a			ld a, 10 
03fb cd b0 09			call aDelayInMS 
03fe 2b				dec hl 
03ff c1					pop bc 
0400 e1					pop hl 
0401 3e 40				ld a, STORE_BLOCK_PHY 
0403 cd 86 0c				call addatohl 
0406 10 e1				djnz .setmark1 
0408			 
0408 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
040a 3e 00		.setmark2:   	ld a,0 
040c e5					push hl 
040d c5					push bc 
040e cd 85 01				call se_writebyte 
0411 3e 0a			ld a, 10 
0413 cd b0 09			call aDelayInMS 
0416 23				inc hl 
0417 cd 85 01				call se_writebyte 
041a 3e 0a			ld a, 10 
041c cd b0 09			call aDelayInMS 
041f 2b				dec hl 
0420 c1					pop bc 
0421 e1					pop hl 
0422 3e 40				ld a, STORE_BLOCK_PHY 
0424 cd 86 0c				call addatohl 
0427 10 e1				djnz .setmark2 
0429			 
0429					 
0429			 
0429			 
0429 c9				ret 
042a			 
042a			 
042a			 
042a			 
042a .. 00		.defaultbanklabl:   db "BankLabel_",0 
0435			 
0435			 
0435			 
0435			; Label Bank 
0435			; ---------- 
0435			; 
0435			; With current bank 
0435			; Read block 0 
0435			; Set label 
0435			; Write block 0 
0435			 
0435			; label str pointer in hl 
0435			 
0435			storage_label:     
0435			 
0435				if DEBUG_STORESE 
0435					DMARK "LBL" 
0435 f5				push af  
0436 3a 4a 04			ld a, (.dmark)  
0439 32 71 ee			ld (debug_mark),a  
043c 3a 4b 04			ld a, (.dmark+1)  
043f 32 72 ee			ld (debug_mark+1),a  
0442 3a 4c 04			ld a, (.dmark+2)  
0445 32 73 ee			ld (debug_mark+2),a  
0448 18 03			jr .pastdmark  
044a ..			.dmark: db "LBL"  
044d f1			.pastdmark: pop af  
044e			endm  
# End of macro DMARK
044e					CALLMONITOR 
044e cd 87 14			call break_point_state  
0451				endm  
# End of macro CALLMONITOR
0451				endif 
0451			 
0451 e5				push hl 
0452			 
0452 cd 11 03			call storage_get_block_0 
0455			 
0455				; set default label 
0455			 
0455 e1				pop hl 
0456			 
0456 11 5f eb		 	ld de, store_page+3 
0459 01 0f 00			ld bc, 15 
045c				if DEBUG_STORESE 
045c					DMARK "LB3" 
045c f5				push af  
045d 3a 71 04			ld a, (.dmark)  
0460 32 71 ee			ld (debug_mark),a  
0463 3a 72 04			ld a, (.dmark+1)  
0466 32 72 ee			ld (debug_mark+1),a  
0469 3a 73 04			ld a, (.dmark+2)  
046c 32 73 ee			ld (debug_mark+2),a  
046f 18 03			jr .pastdmark  
0471 ..			.dmark: db "LB3"  
0474 f1			.pastdmark: pop af  
0475			endm  
# End of macro DMARK
0475					CALLMONITOR 
0475 cd 87 14			call break_point_state  
0478				endm  
# End of macro CALLMONITOR
0478				endif 
0478 ed b0			ldir 
047a				; save default page 0 
047a			 
047a 21 00 00			ld hl, 0 
047d 11 5c eb			ld de, store_page 
0480				if DEBUG_STORESE 
0480					DMARK "LBW" 
0480 f5				push af  
0481 3a 95 04			ld a, (.dmark)  
0484 32 71 ee			ld (debug_mark),a  
0487 3a 96 04			ld a, (.dmark+1)  
048a 32 72 ee			ld (debug_mark+1),a  
048d 3a 97 04			ld a, (.dmark+2)  
0490 32 73 ee			ld (debug_mark+2),a  
0493 18 03			jr .pastdmark  
0495 ..			.dmark: db "LBW"  
0498 f1			.pastdmark: pop af  
0499			endm  
# End of macro DMARK
0499					CALLMONITOR 
0499 cd 87 14			call break_point_state  
049c				endm  
# End of macro CALLMONITOR
049c				endif 
049c cd c5 02			call storage_write_block 
049f			 
049f c9				ret 
04a0			 
04a0			 
04a0			 
04a0			; Read Block 0 - Config 
04a0			; --------------------- 
04a0			; 
04a0			; With current bank 
04a0			; Call presence test 
04a0			;    If not present format/init bank  
04a0			; Read block 0  
04a0			;  
04a0			 
04a0			 
04a0			; Dir 
04a0			; --- 
04a0			; 
04a0			; With current bank 
04a0			; Load Block 0 Config 
04a0			; Get max file id number 
04a0			; For each logical block 
04a0			;    Read block read byte 2 
04a0			;      if first block of file 
04a0			;         Display file name 
04a0			;         Display type flags for file 
04a0			;        
04a0			 
04a0			; moving to words as this requires stack control 
04a0			 
04a0			 
04a0			; Delete File 
04a0			; ----------- 
04a0			; 
04a0			; With current bank 
04a0			; 
04a0			; Load Block 0 Config 
04a0			; Get max file id number 
04a0			; For each logical block 
04a0			;    Read block file id 
04a0			;      If first block of file and dont have file id 
04a0			;         if file to delete 
04a0			;         Save file id 
04a0			;         Null file id 
04a0			;         Write this block back 
04a0			;      If file id is one saved 
04a0			;         Null file id 
04a0			;         Write this block back 
04a0			 
04a0			 
04a0			.se_done: 
04a0 e1				pop hl 
04a1 c9				ret 
04a2			 
04a2			storage_erase: 
04a2			 
04a2				; hl contains the file id 
04a2			 
04a2 5d				ld e, l 
04a3 16 00			ld d, 0 
04a5 21 40 00			ld hl, STORE_BLOCK_PHY 
04a8					if DEBUG_FORTH_WORDS 
04a8						DMARK "ERA" 
04a8 f5				push af  
04a9 3a bd 04			ld a, (.dmark)  
04ac 32 71 ee			ld (debug_mark),a  
04af 3a be 04			ld a, (.dmark+1)  
04b2 32 72 ee			ld (debug_mark+1),a  
04b5 3a bf 04			ld a, (.dmark+2)  
04b8 32 73 ee			ld (debug_mark+2),a  
04bb 18 03			jr .pastdmark  
04bd ..			.dmark: db "ERA"  
04c0 f1			.pastdmark: pop af  
04c1			endm  
# End of macro DMARK
04c1						CALLMONITOR 
04c1 cd 87 14			call break_point_state  
04c4				endm  
# End of macro CALLMONITOR
04c4					endif 
04c4 cd 93 05			call storage_findnextid 
04c7 cd af 0c			call ishlzero 
04ca c8				ret z 
04cb			 
04cb e5				push hl 
04cc			 
04cc				; TODO check file not found 
04cc			 
04cc 11 5c eb			ld de, store_page 
04cf cd 60 02			call storage_read_block 
04d2			 
04d2 cd af 0c			call ishlzero 
04d5 ca a0 04			jp z,.se_done 
04d8			 
04d8					if DEBUG_FORTH_WORDS 
04d8						DMARK "ER1" 
04d8 f5				push af  
04d9 3a ed 04			ld a, (.dmark)  
04dc 32 71 ee			ld (debug_mark),a  
04df 3a ee 04			ld a, (.dmark+1)  
04e2 32 72 ee			ld (debug_mark+1),a  
04e5 3a ef 04			ld a, (.dmark+2)  
04e8 32 73 ee			ld (debug_mark+2),a  
04eb 18 03			jr .pastdmark  
04ed ..			.dmark: db "ER1"  
04f0 f1			.pastdmark: pop af  
04f1			endm  
# End of macro DMARK
04f1						CALLMONITOR 
04f1 cd 87 14			call break_point_state  
04f4				endm  
# End of macro CALLMONITOR
04f4					endif 
04f4 3a 5c eb			ld a, (store_page)	; get file id 
04f7 32 55 eb			ld (store_tmpid), a 
04fa			 
04fa 3a 5e eb			ld a, (store_page+2)    ; get count of extends 
04fd 32 54 eb			ld (store_tmpext), a 
0500			 
0500				; wipe file header 
0500			 
0500 e1				pop hl 
0501 3e 00			ld a, 0 
0503 32 5c eb			ld (store_page), a 
0506 32 5d eb			ld (store_page+1),a 
0509 11 5c eb			ld de, store_page 
050c					if DEBUG_FORTH_WORDS 
050c						DMARK "ER2" 
050c f5				push af  
050d 3a 21 05			ld a, (.dmark)  
0510 32 71 ee			ld (debug_mark),a  
0513 3a 22 05			ld a, (.dmark+1)  
0516 32 72 ee			ld (debug_mark+1),a  
0519 3a 23 05			ld a, (.dmark+2)  
051c 32 73 ee			ld (debug_mark+2),a  
051f 18 03			jr .pastdmark  
0521 ..			.dmark: db "ER2"  
0524 f1			.pastdmark: pop af  
0525			endm  
# End of macro DMARK
0525						CALLMONITOR 
0525 cd 87 14			call break_point_state  
0528				endm  
# End of macro CALLMONITOR
0528					endif 
0528 cd c5 02			call storage_write_block 
052b			 
052b			 
052b				; wipe file extents 
052b			 
052b 3a 54 eb			ld a, (store_tmpext) 
052e 47				ld b, a 
052f			 
052f			.eraext:	  
052f c5				push bc 
0530			 
0530 21 40 00			ld hl, STORE_BLOCK_PHY 
0533 3a 55 eb			ld a,(store_tmpid) 
0536 5f				ld e, a 
0537 50				ld d, b	 
0538					if DEBUG_FORTH_WORDS 
0538						DMARK "ER3" 
0538 f5				push af  
0539 3a 4d 05			ld a, (.dmark)  
053c 32 71 ee			ld (debug_mark),a  
053f 3a 4e 05			ld a, (.dmark+1)  
0542 32 72 ee			ld (debug_mark+1),a  
0545 3a 4f 05			ld a, (.dmark+2)  
0548 32 73 ee			ld (debug_mark+2),a  
054b 18 03			jr .pastdmark  
054d ..			.dmark: db "ER3"  
0550 f1			.pastdmark: pop af  
0551			endm  
# End of macro DMARK
0551						CALLMONITOR 
0551 cd 87 14			call break_point_state  
0554				endm  
# End of macro CALLMONITOR
0554					endif 
0554 cd 93 05			call storage_findnextid 
0557 cd af 0c			call ishlzero 
055a ca a0 04			jp z,.se_done 
055d			 
055d e5				push hl 
055e 11 5c eb			ld de, store_page 
0561 cd 60 02			call storage_read_block 
0564			 
0564				; free block	 
0564			 
0564 3e 00			ld a, 0 
0566 32 5c eb			ld (store_page), a 
0569 32 5d eb			ld (store_page+1),a 
056c 11 5c eb			ld de, store_page 
056f e1				pop hl 
0570					if DEBUG_FORTH_WORDS 
0570						DMARK "ER4" 
0570 f5				push af  
0571 3a 85 05			ld a, (.dmark)  
0574 32 71 ee			ld (debug_mark),a  
0577 3a 86 05			ld a, (.dmark+1)  
057a 32 72 ee			ld (debug_mark+1),a  
057d 3a 87 05			ld a, (.dmark+2)  
0580 32 73 ee			ld (debug_mark+2),a  
0583 18 03			jr .pastdmark  
0585 ..			.dmark: db "ER4"  
0588 f1			.pastdmark: pop af  
0589			endm  
# End of macro DMARK
0589						CALLMONITOR 
0589 cd 87 14			call break_point_state  
058c				endm  
# End of macro CALLMONITOR
058c					endif 
058c cd c5 02			call storage_write_block 
058f			 
058f c1				pop bc 
0590 10 9d			djnz .eraext 
0592			 
0592 c9				ret 
0593			 
0593			 
0593			; Find Free Block 
0593			; --------------- 
0593			; 
0593			; With current bank 
0593			;  
0593			; From given starting logical block 
0593			;    Read block  
0593			;    If no file id 
0593			;         Return block id 
0593			 
0593			 
0593			; hl starting page number 
0593			; hl contains free page number or zero if no pages free 
0593			; e contains the file id to locate 
0593			; d contains the block number 
0593			 
0593			; TODO change to find file id and use zero for free block 
0593			 
0593			storage_findnextid: 
0593			 
0593				; now locate first 0 page to mark as a free block 
0593			 
0593 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
0595			;	ld hl, STORE_BLOCK_PHY 
0595			 
0595					if DEBUG_FORTH_WORDS 
0595					DMARK "FNI" 
0595 f5				push af  
0596 3a aa 05			ld a, (.dmark)  
0599 32 71 ee			ld (debug_mark),a  
059c 3a ab 05			ld a, (.dmark+1)  
059f 32 72 ee			ld (debug_mark+1),a  
05a2 3a ac 05			ld a, (.dmark+2)  
05a5 32 73 ee			ld (debug_mark+2),a  
05a8 18 03			jr .pastdmark  
05aa ..			.dmark: db "FNI"  
05ad f1			.pastdmark: pop af  
05ae			endm  
# End of macro DMARK
05ae						CALLMONITOR 
05ae cd 87 14			call break_point_state  
05b1				endm  
# End of macro CALLMONITOR
05b1					endif 
05b1			.ff1:   	 
05b1 e5					push hl 
05b2 c5					push bc 
05b3 d5					push de 
05b4 cd 84 01				call se_readbyte 
05b7 5f					ld e,a 
05b8 23					inc hl 
05b9 cd 84 01				call se_readbyte 
05bc 57					ld d, a 
05bd e1					pop hl 
05be e5					push hl 
05bf cd a4 0c				call cmp16 
05c2 28 49				jr z, .fffound 
05c4			 
05c4 d1					pop de 
05c5 c1					pop bc 
05c6 e1					pop hl 
05c7			 
05c7					; is found? 
05c7					;cp e 
05c7					;ret z 
05c7			 
05c7 3e 40				ld a, STORE_BLOCK_PHY 
05c9 cd 86 0c				call addatohl 
05cc 10 e3				djnz .ff1 
05ce			 
05ce 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
05d0			.ff2:   	 
05d0			 
05d0 e5					push hl 
05d1 c5					push bc 
05d2 d5					push de 
05d3 cd 84 01				call se_readbyte 
05d6 5f					ld e,a 
05d7 23					inc hl 
05d8 cd 84 01				call se_readbyte 
05db 57					ld d, a 
05dc			 
05dc e1					pop hl 
05dd e5					push hl 
05de cd a4 0c				call cmp16 
05e1 28 2a				jr z, .fffound 
05e3			 
05e3 d1					pop de 
05e4 c1					pop bc 
05e5 e1					pop hl 
05e6					; is found? 
05e6					;cp e 
05e6					;ret z 
05e6			 
05e6 3e 40				ld a, STORE_BLOCK_PHY 
05e8 cd 86 0c				call addatohl 
05eb 10 e3				djnz .ff2 
05ed			 
05ed			 
05ed					if DEBUG_FORTH_WORDS 
05ed					DMARK "FN-" 
05ed f5				push af  
05ee 3a 02 06			ld a, (.dmark)  
05f1 32 71 ee			ld (debug_mark),a  
05f4 3a 03 06			ld a, (.dmark+1)  
05f7 32 72 ee			ld (debug_mark+1),a  
05fa 3a 04 06			ld a, (.dmark+2)  
05fd 32 73 ee			ld (debug_mark+2),a  
0600 18 03			jr .pastdmark  
0602 ..			.dmark: db "FN-"  
0605 f1			.pastdmark: pop af  
0606			endm  
# End of macro DMARK
0606					;	push af 
0606					;	ld a, 'n' 
0606					;	ld (debug_mark),a 
0606					;	pop af 
0606						CALLMONITOR 
0606 cd 87 14			call break_point_state  
0609				endm  
# End of macro CALLMONITOR
0609					endif 
0609				; no free marks! 
0609 21 00 00				ld hl, 0 
060c c9				ret 
060d			.fffound: 
060d				 
060d			 
060d d1					pop de 
060e c1					pop bc 
060f e1					pop hl 
0610					if DEBUG_FORTH_WORDS 
0610					DMARK "FNF" 
0610 f5				push af  
0611 3a 25 06			ld a, (.dmark)  
0614 32 71 ee			ld (debug_mark),a  
0617 3a 26 06			ld a, (.dmark+1)  
061a 32 72 ee			ld (debug_mark+1),a  
061d 3a 27 06			ld a, (.dmark+2)  
0620 32 73 ee			ld (debug_mark+2),a  
0623 18 03			jr .pastdmark  
0625 ..			.dmark: db "FNF"  
0628 f1			.pastdmark: pop af  
0629			endm  
# End of macro DMARK
0629					;	push af 
0629					;	ld a, 'n' 
0629					;	ld (debug_mark),a 
0629					;	pop af 
0629						CALLMONITOR 
0629 cd 87 14			call break_point_state  
062c				endm  
# End of macro CALLMONITOR
062c					endif 
062c c9				ret 
062d			 
062d			 
062d			 
062d			; Free Space 
062d			; ---------- 
062d			; 
062d			; With current bank 
062d			; 
062d			; Set block count to zero 
062d			; Starting with first logical block 
062d			;      Find free block  
062d			;      If block id given, increment block count 
062d			; 
062d			;  
062d			 
062d			 
062d			; hl contains count of free blocks 
062d			 
062d			storage_freeblocks: 
062d			 
062d				; now locate first 0 page to mark as a free block 
062d			 
062d 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
062f 21 40 00			ld hl, STORE_BLOCK_PHY 
0632 11 00 00			ld de, 0 
0635			 
0635			.fb1:   	 
0635 e5					push hl 
0636 c5					push bc 
0637 d5					push de 
0638 cd 84 01				call se_readbyte 
063b d1					pop de 
063c c1					pop bc 
063d e1					pop hl 
063e			 
063e					; is free? 
063e fe 00				cp 0 
0640 20 01				jr nz, .ff1cont 
0642 13					inc de 
0643			 
0643			.ff1cont: 
0643			 
0643			 
0643 3e 40				ld a, STORE_BLOCK_PHY 
0645 cd 86 0c				call addatohl 
0648 10 eb				djnz .fb1 
064a			 
064a 06 ff			ld b, STORE_DEVICE_MAXBLOCKS/2 
064c			.fb2:   	 
064c e5					push hl 
064d c5					push bc 
064e d5					push de 
064f cd 84 01				call se_readbyte 
0652 d1					pop de 
0653 c1					pop bc 
0654 e1					pop hl 
0655			 
0655					; is free? 
0655 fe 00				cp 0 
0657 20 01				jr nz, .ff2cont 
0659 13					inc de 
065a			 
065a			.ff2cont: 
065a			 
065a 3e 40				ld a, STORE_BLOCK_PHY 
065c cd 86 0c				call addatohl 
065f 10 eb				djnz .fb2 
0661			 
0661 eb				ex de, hl 
0662 c9				ret 
0663			 
0663			; Get File ID 
0663			; ----------- 
0663			; 
0663			; With current bank 
0663			;  
0663			; Load Block 0 Config 
0663			; Get max file id number 
0663			; For each logical block 
0663			;    Read block file id 
0663			;      If first block of file and dont have file id 
0663			;         if file get id and exit 
0663			 
0663			 
0663			 
0663			 
0663			; Create File 
0663			; ----------- 
0663			; 
0663			; With current bank  
0663			; Load Block 0 Config 
0663			; Get max file id number 
0663			; Increment file id number 
0663			; Save Config 
0663			; Find free block 
0663			; Set buffer with file name and file id 
0663			; Write buffer to free block  
0663			 
0663			 
0663			; hl point to file name 
0663			; hl returns file id 
0663			 
0663			; file format: 
0663			; byte 0 - file id 
0663			; byte 1 - extent number 
0663			; byte 2-> data 
0663			 
0663			; format for extent number 0: 
0663			; 
0663			; byte 0 - file id 
0663			; byte 1 - extent 0 
0663			; byte 2 - extent count 
0663			; byte 3 -> file name and meta data 
0663			 
0663			 
0663			storage_create: 
0663				if DEBUG_STORESE 
0663					DMARK "SCR" 
0663 f5				push af  
0664 3a 78 06			ld a, (.dmark)  
0667 32 71 ee			ld (debug_mark),a  
066a 3a 79 06			ld a, (.dmark+1)  
066d 32 72 ee			ld (debug_mark+1),a  
0670 3a 7a 06			ld a, (.dmark+2)  
0673 32 73 ee			ld (debug_mark+2),a  
0676 18 03			jr .pastdmark  
0678 ..			.dmark: db "SCR"  
067b f1			.pastdmark: pop af  
067c			endm  
# End of macro DMARK
067c					CALLMONITOR 
067c cd 87 14			call break_point_state  
067f				endm  
# End of macro CALLMONITOR
067f				endif 
067f			 
067f e5				push hl		; save file name pointer 
0680			 
0680 cd 11 03			call storage_get_block_0 
0683			 
0683 3a 5c eb			ld a,(store_page)	; get current file id 
0686 3c				inc a 
0687 32 5c eb			ld (store_page),a 
068a				 
068a 32 55 eb			ld (store_tmpid),a			; save id 
068d			 
068d 21 00 00			ld hl, 0 
0690 11 5c eb			ld de, store_page 
0693				if DEBUG_STORESE 
0693					DMARK "SCw" 
0693 f5				push af  
0694 3a a8 06			ld a, (.dmark)  
0697 32 71 ee			ld (debug_mark),a  
069a 3a a9 06			ld a, (.dmark+1)  
069d 32 72 ee			ld (debug_mark+1),a  
06a0 3a aa 06			ld a, (.dmark+2)  
06a3 32 73 ee			ld (debug_mark+2),a  
06a6 18 03			jr .pastdmark  
06a8 ..			.dmark: db "SCw"  
06ab f1			.pastdmark: pop af  
06ac			endm  
# End of macro DMARK
06ac					CALLMONITOR 
06ac cd 87 14			call break_point_state  
06af				endm  
# End of macro CALLMONITOR
06af				endif 
06af cd c5 02			call storage_write_block	 ; save update 
06b2			 
06b2				if DEBUG_STORESE 
06b2 11 5c eb				ld de, store_page 
06b5					DMARK "SCC" 
06b5 f5				push af  
06b6 3a ca 06			ld a, (.dmark)  
06b9 32 71 ee			ld (debug_mark),a  
06bc 3a cb 06			ld a, (.dmark+1)  
06bf 32 72 ee			ld (debug_mark+1),a  
06c2 3a cc 06			ld a, (.dmark+2)  
06c5 32 73 ee			ld (debug_mark+2),a  
06c8 18 03			jr .pastdmark  
06ca ..			.dmark: db "SCC"  
06cd f1			.pastdmark: pop af  
06ce			endm  
# End of macro DMARK
06ce					CALLMONITOR 
06ce cd 87 14			call break_point_state  
06d1				endm  
# End of macro CALLMONITOR
06d1				endif 
06d1				;  
06d1				 
06d1 21 40 00			ld hl, STORE_BLOCK_PHY 
06d4 11 00 00			ld de, 0 
06d7 cd 93 05			call storage_findnextid 
06da			 
06da 22 46 eb			ld (store_tmppageid), hl    ; save page to use  
06dd			 
06dd				; TODO detect 0 = no spare blocks 
06dd			 
06dd				; hl now contains the free page to use for the file header page 
06dd			 
06dd				if DEBUG_STORESE 
06dd				DMARK "SCF" 
06dd f5				push af  
06de 3a f2 06			ld a, (.dmark)  
06e1 32 71 ee			ld (debug_mark),a  
06e4 3a f3 06			ld a, (.dmark+1)  
06e7 32 72 ee			ld (debug_mark+1),a  
06ea 3a f4 06			ld a, (.dmark+2)  
06ed 32 73 ee			ld (debug_mark+2),a  
06f0 18 03			jr .pastdmark  
06f2 ..			.dmark: db "SCF"  
06f5 f1			.pastdmark: pop af  
06f6			endm  
# End of macro DMARK
06f6					CALLMONITOR 
06f6 cd 87 14			call break_point_state  
06f9				endm  
# End of macro CALLMONITOR
06f9				endif 
06f9			 
06f9 22 46 eb			ld (store_tmppageid), hl 
06fc				 
06fc 3a 55 eb			ld a,(store_tmpid)    ; get file id 
06ff			;	ld a, (store_filecache)			; save to cache 
06ff			 
06ff 32 5c eb			ld (store_page),a    ; set page id 
0702 3e 00			ld a, 0			 ; extent 0 is file header 
0704 32 5d eb			ld (store_page+1), a   ; set file extent 
0707			 
0707 32 5e eb			ld (store_page+2), a   ; extent count for the file 
070a			 
070a			;	inc hl 		; init block 0 of file 
070a			;	inc hl   		; skip file and extent id 
070a			 ;       ld a, 0 
070a			;	ld (hl),a 
070a			;	ld a, (store_filecache+1)  	; save to cache 
070a			 
070a			;	inc hl    ; file name 
070a				 
070a				 
070a 11 5f eb			ld de, store_page+3    ; get buffer for term string to use as file name 
070d				if DEBUG_STORESE 
070d					DMARK "SCc" 
070d f5				push af  
070e 3a 22 07			ld a, (.dmark)  
0711 32 71 ee			ld (debug_mark),a  
0714 3a 23 07			ld a, (.dmark+1)  
0717 32 72 ee			ld (debug_mark+1),a  
071a 3a 24 07			ld a, (.dmark+2)  
071d 32 73 ee			ld (debug_mark+2),a  
0720 18 03			jr .pastdmark  
0722 ..			.dmark: db "SCc"  
0725 f1			.pastdmark: pop af  
0726			endm  
# End of macro DMARK
0726					CALLMONITOR 
0726 cd 87 14			call break_point_state  
0729				endm  
# End of macro CALLMONITOR
0729				endif 
0729 e1				pop hl    ; get zero term string 
072a e5				push hl 
072b 3e 00			ld a, 0 
072d cd ef 10			call strlent 
0730 23				inc hl   ; cover zero term 
0731 06 00			ld b,0 
0733 4d				ld c,l 
0734 e1				pop hl 
0735				;ex de, hl 
0735				if DEBUG_STORESE 
0735					DMARK "SCa" 
0735 f5				push af  
0736 3a 4a 07			ld a, (.dmark)  
0739 32 71 ee			ld (debug_mark),a  
073c 3a 4b 07			ld a, (.dmark+1)  
073f 32 72 ee			ld (debug_mark+1),a  
0742 3a 4c 07			ld a, (.dmark+2)  
0745 32 73 ee			ld (debug_mark+2),a  
0748 18 03			jr .pastdmark  
074a ..			.dmark: db "SCa"  
074d f1			.pastdmark: pop af  
074e			endm  
# End of macro DMARK
074e					;push af 
074e					;ld a, 'a' 
074e					;ld (debug_mark),a 
074e					;pop af 
074e					CALLMONITOR 
074e cd 87 14			call break_point_state  
0751				endm  
# End of macro CALLMONITOR
0751				endif 
0751 ed b0			ldir    ; copy zero term string 
0753				if DEBUG_STORESE 
0753					DMARK "SCA" 
0753 f5				push af  
0754 3a 68 07			ld a, (.dmark)  
0757 32 71 ee			ld (debug_mark),a  
075a 3a 69 07			ld a, (.dmark+1)  
075d 32 72 ee			ld (debug_mark+1),a  
0760 3a 6a 07			ld a, (.dmark+2)  
0763 32 73 ee			ld (debug_mark+2),a  
0766 18 03			jr .pastdmark  
0768 ..			.dmark: db "SCA"  
076b f1			.pastdmark: pop af  
076c			endm  
# End of macro DMARK
076c					CALLMONITOR 
076c cd 87 14			call break_point_state  
076f				endm  
# End of macro CALLMONITOR
076f				endif 
076f			 
076f				; write file header page 
076f			 
076f 2a 46 eb			ld hl,(store_tmppageid) 
0772 11 5c eb			ld de, store_page 
0775				if DEBUG_STORESE 
0775					DMARK "SCb" 
0775 f5				push af  
0776 3a 8a 07			ld a, (.dmark)  
0779 32 71 ee			ld (debug_mark),a  
077c 3a 8b 07			ld a, (.dmark+1)  
077f 32 72 ee			ld (debug_mark+1),a  
0782 3a 8c 07			ld a, (.dmark+2)  
0785 32 73 ee			ld (debug_mark+2),a  
0788 18 03			jr .pastdmark  
078a ..			.dmark: db "SCb"  
078d f1			.pastdmark: pop af  
078e			endm  
# End of macro DMARK
078e					;push af 
078e					;ld a, 'b' 
078e					;ld (debug_mark),a 
078e					;pop af 
078e					CALLMONITOR 
078e cd 87 14			call break_point_state  
0791				endm  
# End of macro CALLMONITOR
0791				endif 
0791 cd c5 02			call storage_write_block 
0794			 
0794 3a 55 eb			ld a, (store_tmpid) 
0797 6f				ld l, a 
0798 26 00			ld h,0 
079a				if DEBUG_STORESE 
079a					DMARK "SCz" 
079a f5				push af  
079b 3a af 07			ld a, (.dmark)  
079e 32 71 ee			ld (debug_mark),a  
07a1 3a b0 07			ld a, (.dmark+1)  
07a4 32 72 ee			ld (debug_mark+1),a  
07a7 3a b1 07			ld a, (.dmark+2)  
07aa 32 73 ee			ld (debug_mark+2),a  
07ad 18 03			jr .pastdmark  
07af ..			.dmark: db "SCz"  
07b2 f1			.pastdmark: pop af  
07b3			endm  
# End of macro DMARK
07b3					CALLMONITOR 
07b3 cd 87 14			call break_point_state  
07b6				endm  
# End of macro CALLMONITOR
07b6				endif 
07b6 c9				ret 
07b7				 
07b7			 
07b7			 
07b7			; 
07b7			; Read File 
07b7			; 
07b7			; h - file id to locate 
07b7			; l - extent to locate 
07b7			; de - pointer to string to read into 
07b7			; 
07b7			; returns hl is 0 if block not found ie end of file or pointer to start of data read 
07b7			 
07b7			.sr_fail: 
07b7 d1				pop de 
07b8 c9				ret 
07b9			 
07b9			storage_read: 
07b9 d5				push de 
07ba			 
07ba			; TODO BUG the above push is it popped before the RET Z? 
07ba			 
07ba			; TODO how to handle multiple part blocks 
07ba			 
07ba				; locate file extent to read 
07ba			 
07ba 5c				ld e, h 
07bb 55				ld d, l 
07bc 21 40 00			ld hl, STORE_BLOCK_PHY 
07bf				if DEBUG_STORESE 
07bf					DMARK "SRE" 
07bf f5				push af  
07c0 3a d4 07			ld a, (.dmark)  
07c3 32 71 ee			ld (debug_mark),a  
07c6 3a d5 07			ld a, (.dmark+1)  
07c9 32 72 ee			ld (debug_mark+1),a  
07cc 3a d6 07			ld a, (.dmark+2)  
07cf 32 73 ee			ld (debug_mark+2),a  
07d2 18 03			jr .pastdmark  
07d4 ..			.dmark: db "SRE"  
07d7 f1			.pastdmark: pop af  
07d8			endm  
# End of macro DMARK
07d8					CALLMONITOR 
07d8 cd 87 14			call break_point_state  
07db				endm  
# End of macro CALLMONITOR
07db				endif 
07db cd 93 05			call storage_findnextid 
07de			 
07de				if DEBUG_STORESE 
07de					DMARK "SRf" 
07de f5				push af  
07df 3a f3 07			ld a, (.dmark)  
07e2 32 71 ee			ld (debug_mark),a  
07e5 3a f4 07			ld a, (.dmark+1)  
07e8 32 72 ee			ld (debug_mark+1),a  
07eb 3a f5 07			ld a, (.dmark+2)  
07ee 32 73 ee			ld (debug_mark+2),a  
07f1 18 03			jr .pastdmark  
07f3 ..			.dmark: db "SRf"  
07f6 f1			.pastdmark: pop af  
07f7			endm  
# End of macro DMARK
07f7					CALLMONITOR 
07f7 cd 87 14			call break_point_state  
07fa				endm  
# End of macro CALLMONITOR
07fa				endif 
07fa cd af 0c			call ishlzero 
07fd			;	ld a, l 
07fd			;	add h 
07fd			;	cp 0 
07fd 28 b8			jr z,.sr_fail			; block not found so EOF 
07ff			 
07ff				; hl contains page number to load 
07ff d1				pop de   ; get storage 
0800 d5				push de 
0801				if DEBUG_STORESE 
0801					DMARK "SRg" 
0801 f5				push af  
0802 3a 16 08			ld a, (.dmark)  
0805 32 71 ee			ld (debug_mark),a  
0808 3a 17 08			ld a, (.dmark+1)  
080b 32 72 ee			ld (debug_mark+1),a  
080e 3a 18 08			ld a, (.dmark+2)  
0811 32 73 ee			ld (debug_mark+2),a  
0814 18 03			jr .pastdmark  
0816 ..			.dmark: db "SRg"  
0819 f1			.pastdmark: pop af  
081a			endm  
# End of macro DMARK
081a					CALLMONITOR 
081a cd 87 14			call break_point_state  
081d				endm  
# End of macro CALLMONITOR
081d				endif 
081d cd 60 02			call storage_read_block 
0820			 
0820			 
0820			; TODO if block has no zeros then need to read next block  
0820			 
0820			 
0820					 
0820 e1				pop hl 		 ; return start of data to show as not EOF 
0821 23				inc hl   ; past file id 
0822 23				inc hl   ; past ext 
0823				if DEBUG_STORESE 
0823					DMARK "SRe" 
0823 f5				push af  
0824 3a 38 08			ld a, (.dmark)  
0827 32 71 ee			ld (debug_mark),a  
082a 3a 39 08			ld a, (.dmark+1)  
082d 32 72 ee			ld (debug_mark+1),a  
0830 3a 3a 08			ld a, (.dmark+2)  
0833 32 73 ee			ld (debug_mark+2),a  
0836 18 03			jr .pastdmark  
0838 ..			.dmark: db "SRe"  
083b f1			.pastdmark: pop af  
083c			endm  
# End of macro DMARK
083c					CALLMONITOR 
083c cd 87 14			call break_point_state  
083f				endm  
# End of macro CALLMONITOR
083f				endif 
083f c9					ret 
0840			 
0840			 
0840			 
0840			; 
0840			; Append File 
0840			; 
0840			; hl - file id to locate 
0840			; de - pointer to (multi block) string to write 
0840			 
0840			.sa_notfound: 
0840 d1				pop de 
0841 c9				ret 
0842			 
0842			 
0842			storage_append: 
0842				; hl -  file id to append to 
0842				; de - string to append 
0842			 
0842 d5				push de 
0843				 
0843				if DEBUG_STORESE 
0843					DMARK "AP1" 
0843 f5				push af  
0844 3a 58 08			ld a, (.dmark)  
0847 32 71 ee			ld (debug_mark),a  
084a 3a 59 08			ld a, (.dmark+1)  
084d 32 72 ee			ld (debug_mark+1),a  
0850 3a 5a 08			ld a, (.dmark+2)  
0853 32 73 ee			ld (debug_mark+2),a  
0856 18 03			jr .pastdmark  
0858 ..			.dmark: db "AP1"  
085b f1			.pastdmark: pop af  
085c			endm  
# End of macro DMARK
085c					CALLMONITOR 
085c cd 87 14			call break_point_state  
085f				endm  
# End of macro CALLMONITOR
085f				endif 
085f			 
085f 7d				ld a, l 
0860 32 55 eb			ld (store_tmpid), a 
0863			 
0863				; get file header  
0863			 
0863 16 00			ld d, 0			 ; file extent to locate - file name details at item 0 
0865 3a 55 eb			ld a, (store_tmpid) 
0868 5f				ld e, a 
0869			 
0869 21 40 00				ld hl, STORE_BLOCK_PHY 
086c cd 93 05				call storage_findnextid 
086f			 
086f cd af 0c			call ishlzero 
0872 28 cc			jr z, .sa_notfound 
0874			 
0874 22 46 eb			ld (store_tmppageid), hl 
0877			 
0877				; TODO handle file id not found 
0877			 
0877				if DEBUG_STORESE 
0877					DMARK "AP2" 
0877 f5				push af  
0878 3a 8c 08			ld a, (.dmark)  
087b 32 71 ee			ld (debug_mark),a  
087e 3a 8d 08			ld a, (.dmark+1)  
0881 32 72 ee			ld (debug_mark+1),a  
0884 3a 8e 08			ld a, (.dmark+2)  
0887 32 73 ee			ld (debug_mark+2),a  
088a 18 03			jr .pastdmark  
088c ..			.dmark: db "AP2"  
088f f1			.pastdmark: pop af  
0890			endm  
# End of macro DMARK
0890					CALLMONITOR 
0890 cd 87 14			call break_point_state  
0893				endm  
# End of macro CALLMONITOR
0893				endif 
0893			 
0893				; update file extent count 
0893			 
0893 11 5c eb			ld de, store_page 
0896			 
0896 cd 60 02			call storage_read_block 
0899			 
0899				if DEBUG_STORESE 
0899					DMARK "AP3" 
0899 f5				push af  
089a 3a ae 08			ld a, (.dmark)  
089d 32 71 ee			ld (debug_mark),a  
08a0 3a af 08			ld a, (.dmark+1)  
08a3 32 72 ee			ld (debug_mark+1),a  
08a6 3a b0 08			ld a, (.dmark+2)  
08a9 32 73 ee			ld (debug_mark+2),a  
08ac 18 03			jr .pastdmark  
08ae ..			.dmark: db "AP3"  
08b1 f1			.pastdmark: pop af  
08b2			endm  
# End of macro DMARK
08b2					CALLMONITOR 
08b2 cd 87 14			call break_point_state  
08b5				endm  
# End of macro CALLMONITOR
08b5				endif 
08b5			;	ld (store_tmppageid), hl 
08b5			 
08b5 3a 5e eb			ld a, (store_page+2) 
08b8 3c				inc a 
08b9 32 5e eb			ld (store_page+2), a 
08bc 32 54 eb			ld (store_tmpext), a 
08bf				 
08bf				if DEBUG_STORESE 
08bf					DMARK "AP3" 
08bf f5				push af  
08c0 3a d4 08			ld a, (.dmark)  
08c3 32 71 ee			ld (debug_mark),a  
08c6 3a d5 08			ld a, (.dmark+1)  
08c9 32 72 ee			ld (debug_mark+1),a  
08cc 3a d6 08			ld a, (.dmark+2)  
08cf 32 73 ee			ld (debug_mark+2),a  
08d2 18 03			jr .pastdmark  
08d4 ..			.dmark: db "AP3"  
08d7 f1			.pastdmark: pop af  
08d8			endm  
# End of macro DMARK
08d8					CALLMONITOR 
08d8 cd 87 14			call break_point_state  
08db				endm  
# End of macro CALLMONITOR
08db				endif 
08db 2a 46 eb			ld hl, (store_tmppageid) 
08de 11 5c eb			ld de, store_page 
08e1 cd c5 02			call storage_write_block 
08e4			 
08e4				; find free block 
08e4			 
08e4 11 00 00			ld de, 0			 ; file extent to locate 
08e7			 
08e7 21 40 00				ld hl, STORE_BLOCK_PHY 
08ea cd 93 05				call storage_findnextid 
08ed cd af 0c			call ishlzero 
08f0 ca 40 08			jp z, .sa_notfound 
08f3			 
08f3					; TODO handle no space left 
08f3					 
08f3 22 46 eb				ld (store_tmppageid), hl 
08f6			 
08f6				if DEBUG_STORESE 
08f6					DMARK "AP4" 
08f6 f5				push af  
08f7 3a 0b 09			ld a, (.dmark)  
08fa 32 71 ee			ld (debug_mark),a  
08fd 3a 0c 09			ld a, (.dmark+1)  
0900 32 72 ee			ld (debug_mark+1),a  
0903 3a 0d 09			ld a, (.dmark+2)  
0906 32 73 ee			ld (debug_mark+2),a  
0909 18 03			jr .pastdmark  
090b ..			.dmark: db "AP4"  
090e f1			.pastdmark: pop af  
090f			endm  
# End of macro DMARK
090f					CALLMONITOR 
090f cd 87 14			call break_point_state  
0912				endm  
# End of macro CALLMONITOR
0912				endif 
0912					; init the buffer with zeros so we can id if the buffer is full or not 
0912			 
0912 e5					push hl 
0913 c5					push bc 
0914			 
0914 21 5c eb				ld hl, store_page 
0917 06 40				ld b, STORE_BLOCK_PHY 
0919 3e 00				ld a, 0 
091b 77			.zeroblock:	ld (hl), a 
091c 23					inc hl 
091d 10 fc				djnz .zeroblock 
091f			 
091f c1					pop bc 
0920 e1					pop hl 
0921			 
0921					; construct block 
0921			 
0921 3a 55 eb				ld a, (store_tmpid) 
0924 32 5c eb				ld (store_page), a   ; file id 
0927 3a 54 eb				ld a, (store_tmpext)   ; extent for this block 
092a 32 5d eb				ld (store_page+1), a 
092d			 
092d e1					pop hl    ; get string to write 
092e 06 3e				ld b, STORE_BLOCK_PHY-2       ; exclude count of file id and extent 
0930 11 5e eb				ld de, store_page+2 
0933			 
0933				if DEBUG_STORESE 
0933					DMARK "AP5" 
0933 f5				push af  
0934 3a 48 09			ld a, (.dmark)  
0937 32 71 ee			ld (debug_mark),a  
093a 3a 49 09			ld a, (.dmark+1)  
093d 32 72 ee			ld (debug_mark+1),a  
0940 3a 4a 09			ld a, (.dmark+2)  
0943 32 73 ee			ld (debug_mark+2),a  
0946 18 03			jr .pastdmark  
0948 ..			.dmark: db "AP5"  
094b f1			.pastdmark: pop af  
094c			endm  
# End of macro DMARK
094c					CALLMONITOR 
094c cd 87 14			call break_point_state  
094f				endm  
# End of macro CALLMONITOR
094f				endif 
094f			 
094f			 
094f			 
094f					; fill buffer with data until end of string or full block 
094f			 
094f 7e			.appd:		ld a, (hl) 
0950 12					ld (de), a 
0951 fe 00				cp 0 
0953 28 04				jr z, .appdone 
0955 23					inc hl 
0956 13					inc de 
0957 10 f6				djnz .appd 
0959			 
0959 e5			.appdone:	push hl		 	; save current source in case we need to go around again 
095a f5					push af   		; save last byte dumped 
095b			 
095b			 
095b 2a 46 eb			ld hl, (store_tmppageid) 
095e 11 5c eb			ld de, store_page 
0961				if DEBUG_STORESE 
0961					DMARK "AP6" 
0961 f5				push af  
0962 3a 76 09			ld a, (.dmark)  
0965 32 71 ee			ld (debug_mark),a  
0968 3a 77 09			ld a, (.dmark+1)  
096b 32 72 ee			ld (debug_mark+1),a  
096e 3a 78 09			ld a, (.dmark+2)  
0971 32 73 ee			ld (debug_mark+2),a  
0974 18 03			jr .pastdmark  
0976 ..			.dmark: db "AP6"  
0979 f1			.pastdmark: pop af  
097a			endm  
# End of macro DMARK
097a					CALLMONITOR 
097a cd 87 14			call break_point_state  
097d				endm  
# End of macro CALLMONITOR
097d				endif 
097d cd c5 02				call storage_write_block 
0980			 
0980			 
0980				; was that a full block of data written? 
0980				; any more to write out? 
0980			 
0980				; if yes then set vars and jump to start of function again 
0980			 
0980 f1					pop af 
0981 d1					pop de 
0982			 
0982 fe 00				cp 0		 ; no, string was fully written 
0984 c8					ret z 
0985			 
0985					; setup vars for next cycle 
0985			 
0985 3a 55 eb				ld a, (store_tmpid) 
0988 6f					ld l, a 
0989 26 00				ld h, 0 
098b			 
098b c3 42 08			 	jp storage_append	 ; yes, need to write out some more 
098e			 
098e			 
098e			 
098e			 
098e			 
098e			 
098e			 
098e			if DEBUG_STORECF 
098e			storageput:	 
098e					ret 
098e			storageread: 
098e					ld hl, store_page 
098e					ld b, 200 
098e					ld a,0 
098e			.src:		ld (hl),a 
098e					inc hl 
098e					djnz .src 
098e					 
098e			 
098e					ld de, 0 
098e					ld bc, 1 
098e					ld hl, store_page 
098e					call cfRead 
098e			 
098e				call cfGetError 
098e				ld hl,scratch 
098e				call hexout 
098e				ld hl, scratch+2 
098e				ld a, 0 
098e				ld (hl),a 
098e				ld de, scratch 
098e				ld a,display_row_1 
098e				call str_at_display 
098e				call update_display 
098e			 
098e					ld hl, store_page 
098e					ld (os_cur_ptr),hl 
098e			 
098e					ret 
098e			endif 
098e			 
098e			 
098e			; Clear out the main buffer store (used to remove junk before writing a new block) 
098e			 
098e			storage_clear_page: 
098e e5				push hl 
098f d5				push de 
0990 c5				push bc 
0991 21 5c eb			ld hl, store_page 
0994 3e 00			ld a, 0 
0996 77				ld (hl), a 
0997			 
0997 11 5d eb			ld de, store_page+1 
099a 01 40 00			ld bc, STORE_BLOCK_PHY 
099d			 
099d ed b0			ldir 
099f				 
099f c1				pop bc 
09a0 d1				pop de 
09a1 e1				pop hl 
09a2 c9				ret 
09a3			 
09a3			; eof 
# End of file firmware_storage.asm
09a3			  
09a3			; support routines for above hardware abstraction layer  
09a3			  
09a3			include "firmware_general.asm"        ; general support functions  
09a3			 
09a3			; word look up 
09a3			 
09a3			; in 
09a3			; a is the index 
09a3			; hl is pointer start of array 
09a3			; 
09a3			; returns 
09a3			; hl to the word 
09a3			; 
09a3			 
09a3			table_lookup:  
09a3 d5					push de 
09a4 eb					ex de, hl 
09a5			 
09a5 6f					ld l, a 
09a6 26 00				ld h, 0 
09a8 29					add hl, hl 
09a9 19					add hl, de 
09aa 7e					ld a, (hl) 
09ab 23					inc hl 
09ac 66					ld h,(hl) 
09ad 6f					ld l, a 
09ae			 
09ae d1					pop de 
09af c9					ret 
09b0			 
09b0			; Delay loops 
09b0			 
09b0			 
09b0			 
09b0			aDelayInMS: 
09b0 c5				push bc 
09b1 47				ld b,a 
09b2			msdelay: 
09b2 c5				push bc 
09b3				 
09b3			 
09b3 01 41 00			ld bc,041h 
09b6 cd ce 09			call delayloop 
09b9 c1				pop bc 
09ba 05				dec b 
09bb 20 f5			jr nz,msdelay 
09bd			 
09bd			;if CPU_CLOCK_8MHZ 
09bd			;msdelay8: 
09bd			;	push bc 
09bd			;	 
09bd			; 
09bd			;	ld bc,041h 
09bd			;	call delayloop 
09bd			;	pop bc 
09bd			;	dec b 
09bd			;	jr nz,msdelay8 
09bd			;endif 
09bd			 
09bd			 
09bd c1				pop bc 
09be c9				ret 
09bf			 
09bf			 
09bf			delay250ms: 
09bf				;push de 
09bf 01 00 40			ld bc, 04000h 
09c2 c3 ce 09			jp delayloop 
09c5			delay500ms: 
09c5				;push de 
09c5 01 00 80			ld bc, 08000h 
09c8 c3 ce 09			jp delayloop 
09cb			delay1s: 
09cb				;push bc 
09cb			   ; Clobbers A, d and e 
09cb 01 00 00		    ld      bc,0      ; # 0ffffh = approx 1s 
09ce			delayloop: 
09ce c5			    push bc 
09cf			 
09cf			if BASE_CPM 
09cf 01 a0 0f			ld bc, CPM_DELAY_TUNE 
09d2			.cpmloop: 
09d2 c5				push bc 
09d3			 
09d3			endif 
09d3			 
09d3			 
09d3			 
09d3			delayloopi: 
09d3			;	push bc 
09d3			;.dl: 
09d3 cb 47		    bit     0,a    	; 8 
09d5 cb 47		    bit     0,a    	; 8 
09d7 cb 47		    bit     0,a    	; 8 
09d9 e6 ff		    and     255  	; 7 
09db 0b			    dec     bc      	; 6 
09dc 79			    ld      a,c     	; 4 
09dd b0			    or      b     	; 4 
09de c2 d3 09		    jp      nz,delayloopi   	; 10, total = 55 states/iteration 
09e1			    ; 65536 iterations * 55 states = 3604480 states = 2.00248 seconds 
09e1				;pop de 
09e1			;pop bc 
09e1			 
09e1			if BASE_CPM 
09e1 c1				pop bc 
09e2				 
09e2 0b			    dec     bc      	; 6 
09e3 79			    ld      a,c     	; 4 
09e4 b0			    or      b     	; 4 
09e5 c2 d2 09		    jp      nz,.cpmloop   	; 10, total = 55 states/iteration 
09e8				 
09e8			 
09e8			endif 
09e8			;if CPU_CLOCK_8MHZ 
09e8			;    pop bc 
09e8			;    push bc 
09e8			;.dl8: 
09e8			;    bit     0,a    	; 8 
09e8			;    bit     0,a    	; 8 
09e8			;    bit     0,a    	; 8 
09e8			;    and     255  	; 7 
09e8			;    dec     bc      	; 6 
09e8			;    ld      a,c     	; 4 
09e8			;    or      b     	; 4 
09e8			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
09e8			;endif 
09e8			 
09e8			;if CPU_CLOCK_10MHZ 
09e8			;    pop bc 
09e8			;    push bc 
09e8			;.dl8: 
09e8			;    bit     0,a    	; 8 
09e8			;    bit     0,a    	; 8 
09e8			;    bit     0,a    	; 8 
09e8			;    and     255  	; 7 
09e8			;    dec     bc      	; 6 
09e8			;    ld      a,c     	; 4 
09e8			;    or      b     	; 4 
09e8			;    jp      nz,.dl8   	; 10, total = 55 states/iteration 
09e8			;endif 
09e8 c1			    pop bc 
09e9			 
09e9 c9				ret 
09ea			 
09ea			 
09ea			 
09ea			; eof 
# End of file firmware_general.asm
09ea			include "firmware_display.asm"      ; frame buffer screen abstraction layer  
09ea			; display routines that use the physical hardware abstraction layer 
09ea			 
09ea			 
09ea			; information window 
09ea			 
09ea			; pass hl with 1st string to display 
09ea			; pass de with 2nd string to display 
09ea			 
09ea			info_panel: 
09ea e5				push hl 
09eb			 
09eb 2a d2 eb			ld hl, (display_fb_active) 
09ee e5				push hl    ; future de destination 
09ef 21 b7 ed				ld hl, display_fb0 
09f2 22 d2 eb				ld (display_fb_active), hl 
09f5			 
09f5			;	call clear_display 
09f5			 
09f5				if BASE_CPM 
09f5 3e 2e			ld a, '.' 
09f7				else 
09f7				ld a, 165 
09f7				endif 
09f7 cd 5e 0a			call fill_display 
09fa			 
09fa			 
09fa 3e 55			ld a, display_row_3 + 5 
09fc cd 6c 0a			call str_at_display 
09ff			 
09ff e1				pop hl 
0a00 d1				pop de 
0a01			 
0a01 e5				push hl 
0a02			 
0a02			 
0a02 3e 2d			ld a, display_row_2 + 5 
0a04 cd 6c 0a			call str_at_display 
0a07			 
0a07			 
0a07 cd 7c 0a			call update_display 
0a0a cd 59 1a			call next_page_prompt 
0a0d cd 59 0a			call clear_display 
0a10			 
0a10				 
0a10 21 16 ed				ld hl, display_fb1 
0a13 22 d2 eb				ld (display_fb_active), hl 
0a16 cd 7c 0a			call update_display 
0a19			 
0a19 e1				pop hl 
0a1a			 
0a1a c9				ret 
0a1b			 
0a1b			 
0a1b			 
0a1b			 
0a1b			; TODO windowing? 
0a1b			 
0a1b			; TODO scroll line up 
0a1b			 
0a1b			scroll_up: 
0a1b			 
0a1b e5				push hl 
0a1c d5				push de 
0a1d c5				push bc 
0a1e			 
0a1e				; get frame buffer  
0a1e			 
0a1e 2a d2 eb			ld hl, (display_fb_active) 
0a21 e5				push hl    ; future de destination 
0a22			 
0a22 11 28 00			ld  de, display_cols 
0a25 19				add hl, de 
0a26			 
0a26 d1				pop de 
0a27			 
0a27				;ex de, hl 
0a27 01 9f 00			ld bc, display_fb_len -1  
0a2a			;if DEBUG_FORTH_WORDS 
0a2a			;	DMARK "SCL" 
0a2a			;	CALLMONITOR 
0a2a			;endif	 
0a2a ed b0			ldir 
0a2c			 
0a2c				; wipe bottom row 
0a2c			 
0a2c			 
0a2c 2a d2 eb			ld hl, (display_fb_active) 
0a2f 11 a0 00			ld de, display_cols*display_rows 
0a32 19				add hl, de 
0a33 06 28			ld b, display_cols 
0a35 3e 20			ld a, ' ' 
0a37			.scwipe: 
0a37 77				ld (hl), a 
0a38 2b				dec hl 
0a39 10 fc			djnz .scwipe 
0a3b			 
0a3b				;pop hl 
0a3b			 
0a3b c1				pop bc 
0a3c d1				pop de 
0a3d e1				pop hl 
0a3e			 
0a3e c9				ret 
0a3f			 
0a3f			 
0a3f			;scroll_upo: 
0a3f			;	ld de, display_row_1 
0a3f			 ;	ld hl, display_row_2 
0a3f			;	ld bc, display_cols 
0a3f			;	ldir 
0a3f			;	ld de, display_row_2 
0a3f			 ;	ld hl, display_row_3 
0a3f			;	ld bc, display_cols 
0a3f			;	ldir 
0a3f			;	ld de, display_row_3 
0a3f			 ;	ld hl, display_row_4 
0a3f			;	ld bc, display_cols 
0a3f			;	ldir 
0a3f			 
0a3f			; TODO clear row 4 
0a3f			 
0a3f			;	ret 
0a3f			 
0a3f				 
0a3f			scroll_down: 
0a3f			 
0a3f e5				push hl 
0a40 d5				push de 
0a41 c5				push bc 
0a42			 
0a42				; get frame buffer  
0a42			 
0a42 2a d2 eb			ld hl, (display_fb_active) 
0a45			 
0a45 11 9f 00			ld de, display_fb_len - 1 
0a48 19				add hl, de 
0a49			 
0a49 e5			push hl    ; future de destination 
0a4a			 
0a4a 11 28 00			ld  de, display_cols 
0a4d ed 52			sbc hl, de 
0a4f			 
0a4f			 
0a4f d1				pop de 
0a50			 
0a50			;	ex de, hl 
0a50 01 9f 00			ld bc, display_fb_len -1  
0a53			 
0a53			 
0a53				 
0a53			 
0a53 ed b0			ldir 
0a55			 
0a55				; wipe bottom row 
0a55			 
0a55			 
0a55			;	ld hl, (display_fb_active) 
0a55			;;	ld de, display_cols*display_rows 
0a55			;;	add hl, de 
0a55			;	ld b, display_cols 
0a55			;	ld a, ' ' 
0a55			;.scwiped: 
0a55			;	ld (hl), a 
0a55			;	dec hl 
0a55			;	djnz .scwiped 
0a55			 
0a55				;pop hl 
0a55			 
0a55 c1				pop bc 
0a56 d1				pop de 
0a57 e1				pop hl 
0a58			 
0a58 c9				ret 
0a59			;scroll_down: 
0a59			;	ld de, display_row_4 
0a59			;	ld hl, display_row_3 
0a59			;	ld bc, display_cols 
0a59			;	ldir 
0a59			;	ld de, display_row_3 
0a59			; 	ld hl, display_row_2 
0a59			;	ld bc, display_cols 
0a59			;	ldir 
0a59			;	ld de, display_row_2 
0a59			;	ld hl, display_row_1 
0a59			;	ld bc, display_cols 
0a59			;	ldir 
0a59			;;; TODO clear row 1 
0a59			;	ret 
0a59			 
0a59			 
0a59			 
0a59			 
0a59			 
0a59			; clear active frame buffer 
0a59			 
0a59			clear_display: 
0a59 3e 20			ld a, ' ' 
0a5b c3 5e 0a			jp fill_display 
0a5e			 
0a5e			; fill active frame buffer with a char in A 
0a5e			 
0a5e			fill_display: 
0a5e 06 a0			ld b,display_fb_len 
0a60 2a d2 eb			ld hl, (display_fb_active) 
0a63 77			.fd1:	ld (hl),a 
0a64 23				inc hl 
0a65 10 fc			djnz .fd1 
0a67 23				inc hl 
0a68 3e 00			ld a,0 
0a6a 77				ld (hl),a 
0a6b			 
0a6b			 
0a6b c9				ret 
0a6c			; Write string (DE) at pos (A) to active frame buffer 
0a6c			 
0a6c 2a d2 eb		str_at_display:    ld hl,(display_fb_active) 
0a6f 06 00					ld b,0 
0a71 4f					ld c,a 
0a72 09					add hl,bc 
0a73 1a			.sad1: 		LD   A, (DE)        ;Get character from string 
0a74 b7			            OR   A              ;Null terminator? 
0a75 c8			            RET  Z              ;Yes, so finished 
0a76 77					ld (hl),a 
0a77 23				inc hl 
0a78 13			            INC  DE             ;Point to next character 
0a79 18 f8		            JR   .sad1     ;Repeat 
0a7b c9					ret 
0a7c			 
0a7c			; using current frame buffer write to physical display 
0a7c			 
0a7c			update_display: 
0a7c e5				push hl 
0a7d 2a d2 eb			ld hl, (display_fb_active) 
0a80 cd 7b 59			call write_display 
0a83 e1				pop hl 
0a84 c9				ret 
0a85			 
0a85			; TODO scrolling 
0a85			 
0a85			 
0a85			; move cursor right one char 
0a85			cursor_right: 
0a85			 
0a85				; TODO shift right 
0a85				; TODO if beyond max col 
0a85				; TODO       cursor_next_line 
0a85			 
0a85 c9				ret 
0a86			 
0a86			 
0a86			cursor_next_line: 
0a86				; TODO first char 
0a86				; TODO line down 
0a86				; TODO if past last row 
0a86				; TODO    scroll up 
0a86			 
0a86 c9				ret 
0a87			 
0a87			cursor_left: 
0a87				; TODO shift left 
0a87				; TODO if beyond left  
0a87				; TODO     cursor prev line 
0a87				 
0a87 c9				ret 
0a88			 
0a88			cursor_prev_line: 
0a88				; TODO last char 
0a88				; TODO line up 
0a88				; TODO if past first row 
0a88				; TODO   scroll down 
0a88			 
0a88 c9				ret 
0a89			 
0a89			 
0a89			cout: 
0a89				; A - char 
0a89 c9				ret 
0a8a			 
0a8a			 
0a8a			; Display a menu and allow item selection (optional toggle items) 
0a8a			; 
0a8a			; format: 
0a8a			; hl pointer to word array with zero term for items 
0a8a			; e.g.    db item1 
0a8a			;         db .... 
0a8a			;         db 0 
0a8a			; 
0a8a			; a = starting menu item  
0a8a			; 
0a8a			; de = pointer item toggle array   (todo) 
0a8a			; 
0a8a			; returns item selected in a 1-... 
0a8a			; returns 0 if back button pressed 
0a8a			; 
0a8a			; NOTE: Uses system frame buffer to display 
0a8a			; 
0a8a			; LEFT, Q = go back 
0a8a			; RIGHT, SPACE, CR = select 
0a8a			; UP, A - Up 
0a8a			; DOWN, Z - Down 
0a8a			 
0a8a			 
0a8a			 
0a8a			 
0a8a			 
0a8a			menu: 
0a8a			 
0a8a					; keep array pointer 
0a8a			 
0a8a 22 5a eb				ld (store_tmp1), hl 
0a8d 32 58 eb				ld (store_tmp2), a 
0a90			 
0a90					; check for key bounce 
0a90			 
0a90			if BASE_KEV 
0a90			 
0a90			.mbounce:	call cin 
0a90					cp 0 
0a90					jr nz, .mbounce 
0a90			endif 
0a90					; for ease use ex 
0a90			 
0a90					; use menu on fb0 so as not to disrupt user screens ie a menu popup 
0a90 21 b7 ed				ld hl, display_fb0 
0a93 22 d2 eb				ld (display_fb_active), hl 
0a96			 
0a96 cd 59 0a		.mloop:		call clear_display 
0a99 cd 7c 0a				call update_display 
0a9c			 
0a9c					; draw selection id '>' at 1 
0a9c			 
0a9c					; init start of list display 
0a9c			 
0a9c 3e 05				ld a, 5 
0a9e 32 56 eb				ld (store_tmp3), a   ; display row count 
0aa1 3a 58 eb				ld a,( store_tmp2) 
0aa4 32 59 eb				ld (store_tmp2+1), a   ; display item count 
0aa7			 
0aa7					 
0aa7			.mitem:	 
0aa7			 
0aa7			 
0aa7 3a 59 eb				ld a,(store_tmp2+1) 
0aaa 6f					ld l, a 
0aab 26 00				ld h, 0 
0aad 29					add hl, hl 
0aae ed 5b 5a eb			ld de, (store_tmp1) 
0ab2 19					add hl, de 
0ab3 7e					ld a, (hl) 
0ab4 23					inc hl 
0ab5 66					ld h,(hl) 
0ab6 6f					ld l, a 
0ab7			 
0ab7 cd af 0c				call ishlzero 
0aba 28 1a				jr z, .mdone 
0abc			 
0abc eb					ex de, hl 
0abd 3a 56 eb				ld a, (store_tmp3) 
0ac0 cd 6c 0a				call str_at_display 
0ac3					 
0ac3			 
0ac3					; next item 
0ac3 3a 59 eb				ld a, (store_tmp2+1) 
0ac6 3c					inc a 
0ac7 32 59 eb				ld (store_tmp2+1), a   ; display item count 
0aca			 
0aca			 		; next row 
0aca			 
0aca 3a 56 eb				ld a, (store_tmp3) 
0acd c6 28				add display_cols 
0acf 32 56 eb				ld (store_tmp3), a 
0ad2			 
0ad2					; at end of screen? 
0ad2			 
0ad2 fe 10				cp display_rows*4 
0ad4 20 d1				jr nz, .mitem 
0ad6			 
0ad6			 
0ad6			.mdone: 
0ad6 cd af 0c				call ishlzero 
0ad9 28 08				jr z, .nodn 
0adb			 
0adb 3e 78				ld a, display_row_4 
0add 11 5c 0b				ld de, .mdown 
0ae0 cd 6c 0a				call str_at_display 
0ae3			 
0ae3					; draw options to fill the screens with active item on line 1 
0ae3					; if current option is 2 or more then display ^ in top 
0ae3			 
0ae3 3a 58 eb		.nodn:		ld a, (store_tmp2) 
0ae6 fe 00				cp 0 
0ae8 28 08				jr z, .noup 
0aea			 
0aea 3e 00				ld a, 0 
0aec 11 5a 0b				ld de, .mup 
0aef cd 6c 0a				call str_at_display 
0af2			 
0af2 3e 02		.noup:		ld a, 2 
0af4 11 58 0b				ld de, .msel 
0af7 cd 6c 0a				call str_at_display 
0afa			 
0afa					; if current option + 1 is not null then display V in bottom 
0afa					; get key 
0afa cd 7c 0a				call update_display 
0afd			 
0afd			 
0afd					; handle key 
0afd			 
0afd cd 2d 5a				call cin_wait 
0b00			 
0b00 fe 05				cp KEY_UP 
0b02 28 2b				jr z, .mgoup 
0b04 fe 61				cp 'a' 
0b06 28 27				jr z, .mgoup 
0b08 fe 0a				cp KEY_DOWN 
0b0a 28 32				jr z, .mgod 
0b0c fe 7a				cp 'z' 
0b0e 28 2e				jr z, .mgod 
0b10 fe 20				cp ' ' 
0b12 28 34				jr z, .goend 
0b14 fe 0c				cp KEY_RIGHT 
0b16 28 30				jr z, .goend 
0b18 fe 0d				cp KEY_CR 
0b1a 28 2c				jr z, .goend 
0b1c fe 71				cp 'q' 
0b1e 28 0b				jr z, .goback 
0b20			 
0b20 fe 0b				cp KEY_LEFT 
0b22 28 07				jr z, .goback 
0b24 fe 08				cp KEY_BS 
0b26 28 03				jr z, .goback 
0b28 c3 96 0a				jp .mloop 
0b2b			 
0b2b			.goback: 
0b2b 3e 00			ld a, 0 
0b2d 18 1d			jr .goend2 
0b2f			 
0b2f				; move up one 
0b2f			.mgoup: 
0b2f 3a 58 eb				ld a, (store_tmp2) 
0b32 fe 00				cp 0 
0b34 ca 96 0a				jp z, .mloop 
0b37 3d					dec a 
0b38 32 58 eb				ld (store_tmp2), a 
0b3b c3 96 0a				jp .mloop 
0b3e			 
0b3e				; move down one 
0b3e			.mgod: 
0b3e 3a 58 eb				ld a, (store_tmp2) 
0b41 3c					inc a 
0b42 32 58 eb				ld (store_tmp2), a 
0b45 c3 96 0a				jp .mloop 
0b48			 
0b48			 
0b48			.goend: 
0b48					; get selected item number 
0b48			 
0b48 3a 58 eb				ld a, (store_tmp2) 
0b4b 3c					inc a 
0b4c			 
0b4c			.goend2: 
0b4c f5					push af 
0b4d			 
0b4d					; restore active fb 
0b4d					; TODO BUG assumes fb1 
0b4d			 
0b4d 21 16 ed				ld hl, display_fb1 
0b50 22 d2 eb				ld (display_fb_active), hl 
0b53			 
0b53					; restore main regs 
0b53			 
0b53			 
0b53 cd 7c 0a				call update_display 
0b56			 
0b56 f1					pop af 
0b57			 
0b57 c9				ret 
0b58			 
0b58 .. 00		.msel:   db ">",0 
0b5a .. 00		.mup:   db "^",0 
0b5c .. 00		.mdown:   db "v",0 
0b5e			 
0b5e			 
0b5e			; eof 
0b5e			 
# End of file firmware_display.asm
0b5e			include "firmware_maths.asm"     ; any odd maths stuff   TODO removed until I fix up the rng code  
0b5e			; random number generators 
0b5e			 
0b5e			 
0b5e			; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random 
0b5e			 
0b5e			 
0b5e			;-----> Generate a random number 
0b5e			; output a=answer 0<=a<=255 
0b5e			; all registers are preserved except: af 
0b5e			random: 
0b5e e5			        push    hl 
0b5f d5			        push    de 
0b60 2a b4 eb		        ld      hl,(randData) 
0b63 ed 5f		        ld      a,r 
0b65 57			        ld      d,a 
0b66 5e			        ld      e,(hl) 
0b67 19			        add     hl,de 
0b68 85			        add     a,l 
0b69 ac			        xor     h 
0b6a 22 b4 eb		        ld      (randData),hl 
0b6d d1			        pop     de 
0b6e e1			        pop     hl 
0b6f c9			        ret 
0b70			 
0b70			 
0b70			; randData here must be a 2 byte seed located in ram. While this is a fast generator, it's generally not considered very good in terms of randomness. 
0b70			 
0b70			 
0b70			 
0b70			;------LFSR------ 
0b70			;James Montelongo 
0b70			;optimized by Spencer Putt 
0b70			;out: 
0b70			; a = 8 bit random number 
0b70			RandLFSR: 
0b70 21 ba eb		        ld hl,LFSRSeed+4 
0b73 5e			        ld e,(hl) 
0b74 23			        inc hl 
0b75 56			        ld d,(hl) 
0b76 23			        inc hl 
0b77 4e			        ld c,(hl) 
0b78 23			        inc hl 
0b79 7e			        ld a,(hl) 
0b7a 47			        ld b,a 
0b7b cb 13		        rl e  
0b7d cb 12			rl d 
0b7f cb 11		        rl c  
0b81 17				rla 
0b82 cb 13		        rl e  
0b84 cb 12			rl d 
0b86 cb 11		        rl c  
0b88 17				rla 
0b89 cb 13		        rl e  
0b8b cb 12			rl d 
0b8d cb 11		        rl c  
0b8f 17				rla 
0b90 67			        ld h,a 
0b91 cb 13		        rl e  
0b93 cb 12			rl d 
0b95 cb 11		        rl c  
0b97 17				rla 
0b98 a8			        xor b 
0b99 cb 13		        rl e  
0b9b cb 12			rl d 
0b9d ac			        xor h 
0b9e a9			        xor c 
0b9f aa			        xor d 
0ba0 21 bc eb		        ld hl,LFSRSeed+6 
0ba3 11 bd eb		        ld de,LFSRSeed+7 
0ba6 01 07 00		        ld bc,7 
0ba9 ed b8		        lddr 
0bab 12			        ld (de),a 
0bac c9			        ret 
0bad			 
0bad			;While this may produces better numbers, it is slower, larger and requires a bigger seed than ionrandom. Assuming theres is a good seed to start, it should generate ~2^56 bytes before repeating. However if there is not a good seed(0 for example), then the numbers created will not be adequate. Unlike Ionrandom and its use of the r register, starting with the same seed the same numbers will be generated. With Ionrandom the code running may have an impact on the number generated. This means this method requires more initialization. 
0bad			 
0bad			;You can initialize with TI-OS's seeds, stored at seed1 and seed2, both are ti-floats but will serve the purpose.  
0bad			 
0bad			 
0bad			;This is a very fast, quality pseudo-random number generator. It combines a 16-bit Linear Feedback Shift Register and a 16-bit LCG. 
0bad			 
0bad			prng16: 
0bad			;Inputs: 
0bad			;   (seed1) contains a 16-bit seed value 
0bad			;   (seed2) contains a NON-ZERO 16-bit seed value 
0bad			;Outputs: 
0bad			;   HL is the result 
0bad			;   BC is the result of the LCG, so not that great of quality 
0bad			;   DE is preserved 
0bad			;Destroys: 
0bad			;   AF 
0bad			;cycle: 4,294,901,760 (almost 4.3 billion) 
0bad			;160cc 
0bad			;26 bytes 
0bad 2a ae eb		    ld hl,(seed1) 
0bb0 44			    ld b,h 
0bb1 4d			    ld c,l 
0bb2 29			    add hl,hl 
0bb3 29			    add hl,hl 
0bb4 2c			    inc l 
0bb5 09			    add hl,bc 
0bb6 22 ae eb		    ld (seed1),hl 
0bb9 2a ac eb		    ld hl,(seed2) 
0bbc 29			    add hl,hl 
0bbd 9f			    sbc a,a 
0bbe e6 2d		    and %00101101 
0bc0 ad			    xor l 
0bc1 6f			    ld l,a 
0bc2 22 ac eb		    ld (seed2),hl 
0bc5 09			    add hl,bc 
0bc6 c9			    ret 
0bc7			 
0bc7			;On their own, LCGs and LFSRs don't produce great results and are generally very cyclical, but they are very fast to compute. The 16-bit LCG in the above example will bounce around and reach each number from 0 to 65535, but the lower bits are far more predictable than the upper bits. The LFSR mixes up the predictability of a given bit's state, but it hits every number except 0, meaning there is a slightly higher chance of any given bit in the result being a 1 instead of a 0. It turns out that by adding together the outputs of these two generators, we can lose the predictability of a bit's state, while ensuring it has a 50% chance of being 0 or 1. As well, since the periods, 65536 and 65535 are coprime, then the overall period of the generator is 65535*65536, which is over 4 billion.  
0bc7			 
0bc7			rand32: 
0bc7			;Inputs: 
0bc7			;   (seed1_0) holds the lower 16 bits of the first seed 
0bc7			;   (seed1_1) holds the upper 16 bits of the first seed 
0bc7			;   (seed2_0) holds the lower 16 bits of the second seed 
0bc7			;   (seed2_1) holds the upper 16 bits of the second seed 
0bc7			;   **NOTE: seed2 must be non-zero 
0bc7			;Outputs: 
0bc7			;   HL is the result 
0bc7			;   BC,DE can be used as lower quality values, but are not independent of HL. 
0bc7			;Destroys: 
0bc7			;   AF 
0bc7			;Tested and passes all CAcert tests 
0bc7			;Uses a very simple 32-bit LCG and 32-bit LFSR 
0bc7			;it has a period of 18,446,744,069,414,584,320 
0bc7			;roughly 18.4 quintillion. 
0bc7			;LFSR taps: 0,2,6,7  = 11000101 
0bc7			;291cc 
0bc7			;seed1_0=$+1 
0bc7			;    ld hl,12345 
0bc7			;seed1_1=$+1 
0bc7			;    ld de,6789 
0bc7			;    ld b,h 
0bc7			;    ld c,l 
0bc7			;    add hl,hl \ rl e \ rl d 
0bc7			;    add hl,hl \ rl e \ rl d 
0bc7			;    inc l 
0bc7			;    add hl,bc 
0bc7			;    ld (seed1_0),hl 
0bc7			;    ld hl,(seed1_1) 
0bc7			;    adc hl,de 
0bc7			;    ld (seed1_1),hl 
0bc7			;    ex de,hl 
0bc7			;seed2_0=$+1 
0bc7			;    ld hl,9876 
0bc7			;seed2_1=$+1 
0bc7			;    ld bc,54321 
0bc7			;    add hl,hl \ rl c \ rl b 
0bc7			;    ld (seed2_1),bc 
0bc7			;    sbc a,a 
0bc7			;    and %11000101 
0bc7			;    xor l 
0bc7			;    ld l,a 
0bc7			;    ld (seed2_0),hl 
0bc7			;    ex de,hl 
0bc7			;    add hl,bc 
0bc7			;    ret 
0bc7			; 
0bc7			 
0bc7			; 16-bit xorshift pseudorandom number generator by John Metcalf 
0bc7			; 20 bytes, 86 cycles (excluding ret) 
0bc7			 
0bc7			; returns   hl = pseudorandom number 
0bc7			; corrupts   a 
0bc7			 
0bc7			; generates 16-bit pseudorandom numbers with a period of 65535 
0bc7			; using the xorshift method: 
0bc7			 
0bc7			; hl ^= hl << 7 
0bc7			; hl ^= hl >> 9 
0bc7			; hl ^= hl << 8 
0bc7			 
0bc7			; some alternative shift triplets which also perform well are: 
0bc7			; 6, 7, 13; 7, 9, 13; 9, 7, 13. 
0bc7			 
0bc7			;  org 32768 
0bc7			 
0bc7			xrnd: 
0bc7 2a b2 eb		  ld hl,(xrandc)       ; seed must not be 0 
0bca 3e 00		  ld a,0 
0bcc bd			  cp l 
0bcd 20 02		  jr nz, .xrnd1 
0bcf 2e 01		  ld l, 1 
0bd1			.xrnd1: 
0bd1			 
0bd1 7c			  ld a,h 
0bd2 1f			  rra 
0bd3 7d			  ld a,l 
0bd4 1f			  rra 
0bd5 ac			  xor h 
0bd6 67			  ld h,a 
0bd7 7d			  ld a,l 
0bd8 1f			  rra 
0bd9 7c			  ld a,h 
0bda 1f			  rra 
0bdb ad			  xor l 
0bdc 6f			  ld l,a 
0bdd ac			  xor h 
0bde 67			  ld h,a 
0bdf			 
0bdf 22 b2 eb		  ld (xrandc),hl 
0be2			 
0be2 c9			  ret 
0be3			;  
0be3			 
0be3			 
0be3			;;;; int maths 
0be3			 
0be3			; https://map.grauw.nl/articles/mult_div_shifts.php 
0be3			; Divide 16-bit values (with 16-bit result) 
0be3			; In: Divide BC by divider DE 
0be3			; Out: BC = result, HL = rest 
0be3			; 
0be3			Div16: 
0be3 21 00 00		    ld hl,0 
0be6 78			    ld a,b 
0be7 06 08		    ld b,8 
0be9			Div16_Loop1: 
0be9 17			    rla 
0bea ed 6a		    adc hl,hl 
0bec ed 52		    sbc hl,de 
0bee 30 01		    jr nc,Div16_NoAdd1 
0bf0 19			    add hl,de 
0bf1			Div16_NoAdd1: 
0bf1 10 f6		    djnz Div16_Loop1 
0bf3 17			    rla 
0bf4 2f			    cpl 
0bf5 47			    ld b,a 
0bf6 79			    ld a,c 
0bf7 48			    ld c,b 
0bf8 06 08		    ld b,8 
0bfa			Div16_Loop2: 
0bfa 17			    rla 
0bfb ed 6a		    adc hl,hl 
0bfd ed 52		    sbc hl,de 
0bff 30 01		    jr nc,Div16_NoAdd2 
0c01 19			    add hl,de 
0c02			Div16_NoAdd2: 
0c02 10 f6		    djnz Div16_Loop2 
0c04 17			    rla 
0c05 2f			    cpl 
0c06 41			    ld b,c 
0c07 4f			    ld c,a 
0c08 c9			ret 
0c09			 
0c09			 
0c09			;http://z80-heaven.wikidot.com/math 
0c09			; 
0c09			;Inputs: 
0c09			;     DE and A are factors 
0c09			;Outputs: 
0c09			;     A is not changed 
0c09			;     B is 0 
0c09			;     C is not changed 
0c09			;     DE is not changed 
0c09			;     HL is the product 
0c09			;Time: 
0c09			;     342+6x 
0c09			; 
0c09			Mult16: 
0c09			 
0c09 06 08		     ld b,8          ;7           7 
0c0b 21 00 00		     ld hl,0         ;10         10 
0c0e 29			       add hl,hl     ;11*8       88 
0c0f 07			       rlca          ;4*8        32 
0c10 30 01		       jr nc,$+3     ;(12|18)*8  96+6x 
0c12 19			         add hl,de   ;--         -- 
0c13 10 f9		       djnz $-5      ;13*7+8     99 
0c15 c9			ret 
0c16			 
0c16			; 
0c16			; Square root of 16-bit value 
0c16			; In:  HL = value 
0c16			; Out:  D = result (rounded down) 
0c16			; 
0c16			;Sqr16: 
0c16			;    ld de,#0040 
0c16			;    ld a,l 
0c16			;    ld l,h 
0c16			;    ld h,d 
0c16			;    or a 
0c16			;    ld b,8 
0c16			;Sqr16_Loop: 
0c16			;    sbc hl,de 
0c16			;    jr nc,Sqr16_Skip 
0c16			;    add hl,de 
0c16			;Sqr16_Skip: 
0c16			;    ccf 
0c16			;    rl d 
0c16			;    add a,a 
0c16			;    adc hl,hl 
0c16			;    add a,a 
0c16			;    adc hl,hl 
0c16			;    djnz Sqr16_Loop 
0c16			;    ret 
0c16			; 
0c16			; 
0c16			; Divide 8-bit values 
0c16			; In: Divide E by divider C 
0c16			; Out: A = result, B = rest 
0c16			; 
0c16			Div8: 
0c16 af			    xor a 
0c17 06 08		    ld b,8 
0c19			Div8_Loop: 
0c19 cb 13		    rl e 
0c1b 17			    rla 
0c1c 91			    sub c 
0c1d 30 01		    jr nc,Div8_NoAdd 
0c1f 81			    add a,c 
0c20			Div8_NoAdd: 
0c20 10 f7		    djnz Div8_Loop 
0c22 47			    ld b,a 
0c23 7b			    ld a,e 
0c24 17			    rla 
0c25 2f			    cpl 
0c26 c9			    ret 
0c27			 
0c27			; 
0c27			; Multiply 8-bit value with a 16-bit value (unrolled) 
0c27			; In: Multiply A with DE 
0c27			; Out: HL = result 
0c27			; 
0c27			Mult12U: 
0c27 2e 00		    ld l,0 
0c29 87			    add a,a 
0c2a 30 01		    jr nc,Mult12U_NoAdd0 
0c2c 19			    add hl,de 
0c2d			Mult12U_NoAdd0: 
0c2d 29			    add hl,hl 
0c2e 87			    add a,a 
0c2f 30 01		    jr nc,Mult12U_NoAdd1 
0c31 19			    add hl,de 
0c32			Mult12U_NoAdd1: 
0c32 29			    add hl,hl 
0c33 87			    add a,a 
0c34 30 01		    jr nc,Mult12U_NoAdd2 
0c36 19			    add hl,de 
0c37			Mult12U_NoAdd2: 
0c37 29			    add hl,hl 
0c38 87			    add a,a 
0c39 30 01		    jr nc,Mult12U_NoAdd3 
0c3b 19			    add hl,de 
0c3c			Mult12U_NoAdd3: 
0c3c 29			    add hl,hl 
0c3d 87			    add a,a 
0c3e 30 01		    jr nc,Mult12U_NoAdd4 
0c40 19			    add hl,de 
0c41			Mult12U_NoAdd4: 
0c41 29			    add hl,hl 
0c42 87			    add a,a 
0c43 30 01		    jr nc,Mult12U_NoAdd5 
0c45 19			    add hl,de 
0c46			Mult12U_NoAdd5: 
0c46 29			    add hl,hl 
0c47 87			    add a,a 
0c48 30 01		    jr nc,Mult12U_NoAdd6 
0c4a 19			    add hl,de 
0c4b			Mult12U_NoAdd6: 
0c4b 29			    add hl,hl 
0c4c 87			    add a,a 
0c4d d0			    ret nc 
0c4e 19			    add hl,de 
0c4f c9			    ret 
0c50			 
0c50			; 
0c50			; Multiply 8-bit value with a 16-bit value (right rotating) 
0c50			; In: Multiply A with DE 
0c50			;      Put lowest value in A for most efficient calculation 
0c50			; Out: HL = result 
0c50			; 
0c50			Mult12R: 
0c50 21 00 00		    ld hl,0 
0c53			Mult12R_Loop: 
0c53 cb 3f		    srl a 
0c55 30 01		    jr nc,Mult12R_NoAdd 
0c57 19			    add hl,de 
0c58			Mult12R_NoAdd: 
0c58 cb 23		    sla e 
0c5a cb 12		    rl d 
0c5c b7			    or a 
0c5d c2 53 0c		    jp nz,Mult12R_Loop 
0c60 c9			    ret 
0c61			 
0c61			; 
0c61			; Multiply 16-bit values (with 32-bit result) 
0c61			; In: Multiply BC with DE 
0c61			; Out: BCHL = result 
0c61			; 
0c61			Mult32: 
0c61 79			    ld a,c 
0c62 48			    ld c,b 
0c63 21 00 00		    ld hl,0 
0c66 06 10		    ld b,16 
0c68			Mult32_Loop: 
0c68 29			    add hl,hl 
0c69 17			    rla 
0c6a cb 11		    rl c 
0c6c 30 07		    jr nc,Mult32_NoAdd 
0c6e 19			    add hl,de 
0c6f ce 00		    adc a,0 
0c71 d2 75 0c		    jp nc,Mult32_NoAdd 
0c74 0c			    inc c 
0c75			Mult32_NoAdd: 
0c75 10 f1		    djnz Mult32_Loop 
0c77 41			    ld b,c 
0c78 4f			    ld c,a 
0c79 c9			    ret 
0c7a			 
0c7a			 
0c7a			 
0c7a			; 
0c7a			; Multiply 8-bit values 
0c7a			; In:  Multiply H with E 
0c7a			; Out: HL = result 
0c7a			; 
0c7a			Mult8: 
0c7a 16 00		    ld d,0 
0c7c 6a			    ld l,d 
0c7d 06 08		    ld b,8 
0c7f			Mult8_Loop: 
0c7f 29			    add hl,hl 
0c80 30 01		    jr nc,Mult8_NoAdd 
0c82 19			    add hl,de 
0c83			Mult8_NoAdd: 
0c83 10 fa		    djnz Mult8_Loop 
0c85 c9			    ret 
0c86			 
0c86			 
0c86			 
0c86			 
0c86			 
0c86			 
0c86			 
0c86			 
0c86			;;http://z80-heaven.wikidot.com/math 
0c86			;;This divides DE by BC, storing the result in DE, remainder in HL 
0c86			; 
0c86			;DE_Div_BC:          ;1281-2x, x is at most 16 
0c86			;     ld a,16        ;7 
0c86			;     ld hl,0        ;10 
0c86			;     jp $+5         ;10 
0c86			;.DivLoop: 
0c86			;       add hl,bc    ;-- 
0c86			;       dec a        ;64 
0c86			;       jr z,.DivLoopEnd        ;86 
0c86			; 
0c86			;       sla e        ;128 
0c86			;       rl d         ;128 
0c86			;       adc hl,hl    ;240 
0c86			;       sbc hl,bc    ;240 
0c86			;       jr nc,.DivLoop ;23|21 
0c86			;       inc e        ;-- 
0c86			;       jp .DivLoop+1 
0c86			; 
0c86			;.DivLoopEnd: 
0c86			 
0c86			;HL_Div_C: 
0c86			;Inputs: 
0c86			;     HL is the numerator 
0c86			;     C is the denominator 
0c86			;Outputs: 
0c86			;     A is the remainder 
0c86			;     B is 0 
0c86			;     C is not changed 
0c86			;     DE is not changed 
0c86			;     HL is the quotient 
0c86			; 
0c86			;       ld b,16 
0c86			;       xor a 
0c86			;         add hl,hl 
0c86			;         rla 
0c86			;         cp c 
0c86			;         jr c,$+4 
0c86			;           inc l 
0c86			;           sub c 
0c86			;         djnz $-7 
0c86			 
0c86			; https://plutiedev.com/z80-add-8bit-to-16bit 
0c86			 
0c86			addatohl: 
0c86 85			    add   a, l    ; A = A+L 
0c87 6f			    ld    l, a    ; L = A+L 
0c88 8c			    adc   a, h    ; A = A+L+H+carry 
0c89 95			    sub   l       ; A = H+carry 
0c8a 67			    ld    h, a    ; H = H+carry 
0c8b c9			ret 
0c8c			 
0c8c			addatode: 
0c8c 83			    add   a, e    ; A = A+L 
0c8d 5f			    ld    e, a    ; L = A+L 
0c8e 8a			    adc   a, d    ; A = A+L+H+carry 
0c8f 93			    sub   e       ; A = H+carry 
0c90 57			    ld    d, a    ; H = H+carry 
0c91 c9			ret 
0c92			 
0c92			 
0c92			addatobc: 
0c92 81			    add   a, c    ; A = A+L 
0c93 4f			    ld    c, a    ; L = A+L 
0c94 88			    adc   a, b    ; A = A+L+H+carry 
0c95 91			    sub   c       ; A = H+carry 
0c96 47			    ld    b, a    ; H = H+carry 
0c97 c9			ret 
0c98			 
0c98			subafromhl: 
0c98			   ; If A=0 do nothing 
0c98			    ; Otherwise flip A's sign. Since 
0c98			    ; the upper byte becomes -1, also 
0c98			    ; substract 1 from H. 
0c98 ed 44		    neg 
0c9a ca a3 0c		    jp    z, Skip 
0c9d 25			    dec   h 
0c9e			     
0c9e			    ; Now add the low byte as usual 
0c9e			    ; Two's complement takes care of 
0c9e			    ; ensuring the result is correct 
0c9e 85			    add   a, l 
0c9f 6f			    ld    l, a 
0ca0 8c			    adc   a, h 
0ca1 95			    sub   l 
0ca2 67			    ld    h, a 
0ca3			Skip: 
0ca3 c9				ret 
0ca4			 
0ca4			 
0ca4			; compare hl and de 
0ca4			; returns:  
0ca4			; if hl = de, z=1, s=0, c0=0 
0ca4			; if hl > de, z=0, s=0, c=0 
0ca4			; if hl < de, z=0, s=1, c=1 
0ca4			cmp16:	 
0ca4 b7				or a 
0ca5 ed 52			sbc hl,de 
0ca7 e0				ret po 
0ca8 7c				ld a,h 
0ca9 1f				rra 
0caa ee 40			xor 01000000B 
0cac 37				scf 
0cad 8f				adc a,a 
0cae c9				ret 
0caf			 
0caf			 
0caf			; test if hl contains zero   - A is destroyed 
0caf			 
0caf			ishlzero:    
0caf b7				or a     ; reset flags 
0cb0 7c				ld a, h 
0cb1 b5				or l        	 
0cb2			 
0cb2 c9				ret 
0cb3			 
0cb3			 
0cb3			 
0cb3			 
0cb3			if FORTH_ENABLE_FLOATMATH 
0cb3			;include "float/bbcmath.z80" 
0cb3			include "float/lpfpcalc.asm" 
0cb3			endif 
0cb3			 
0cb3			 
0cb3			; eof 
0cb3			 
# End of file firmware_maths.asm
0cb3			include "firmware_strings.asm"   ; string handling  
0cb3			 
0cb3			 
0cb3			; TODO string len 
0cb3			; input text string, end on cr with zero term 
0cb3			; a offset into frame buffer to start prompt 
0cb3			; d is max length 
0cb3			; e is display size TODO 
0cb3			; c is current cursor position 
0cb3			; hl is ptr to where string will be stored 
0cb3			 
0cb3			 
0cb3			; TODO check limit of buffer for new inserts 
0cb3			; TODO check insert does not push beyond buffer 
0cb3			; TODO scroll in a limited display area 
0cb3			; TODO scroll whole screen on page wrap 
0cb3			 
0cb3			 
0cb3			; TODO handle KEY_PREVWORD 
0cb3			; TODO handle KEY_NEXTWORD 
0cb3			; TODO handle KEY_HOME 
0cb3			; TODO handle KEY_END 
0cb3			; TODO use LCD cursor? 
0cb3			 
0cb3 32 6a ee		input_str:    	ld (input_at_pos),a      ; save display position to start 
0cb6 81					add c 
0cb7 32 68 ee				ld (input_at_cursor),a	; save draw pos of cursor 
0cba 22 6d ee				ld (input_start), hl     ; save ptr to buffer 
0cbd 79					ld a, c 
0cbe cd 86 0c				call addatohl 
0cc1 22 6f ee				ld (input_ptr), hl     ; save ptr to point under the cursor 
0cc4 7a					ld a,d 
0cc5 32 6c ee			        ld (input_size), a       ; save length of input area 
0cc8 79					ld a, c 
0cc9 32 5b ee				ld (input_cursor),a      ; init cursor start position  
0ccc 7b					ld a,e 
0ccd 32 6b ee			        ld (input_display_size), a       ; save length of input area that is displayed TODO 
0cd0					 
0cd0					 
0cd0			 
0cd0			;		ld a,(input_ptr) 
0cd0			;		ld (input_under_cursor),a 	; save what is under the cursor 
0cd0			 
0cd0			; TODO move out to cin as cursor shape is used by the 4x4 ??? 
0cd0					; init cursor shape if not set by the cin routines 
0cd0 21 ca eb				ld hl, cursor_shape 
0cd3 3e ff				ld a, 255 
0cd5 77					ld (hl), a 
0cd6 23					inc hl 
0cd7 3e 00				ld a, 0 
0cd9 77					ld (hl), a 
0cda			 
0cda 3e 0f				ld a, CUR_BLINK_RATE 
0cdc 32 66 ee				ld (input_cur_flash), a 
0cdf 3e 01				ld a, 1 
0ce1 32 65 ee				ld (input_cur_onoff),a 
0ce4			 
0ce4			;	if DEBUG_INPUT 
0ce4			;		push af 
0ce4			;		ld a, 'I' 
0ce4			;		ld (debug_mark),a 
0ce4			;		pop af 
0ce4			;		CALLMONITOR 
0ce4			;	endif 
0ce4			.is1:		; main entry loop 
0ce4			 
0ce4			 
0ce4			 
0ce4					; pause 1ms 
0ce4			 
0ce4 3e 01				ld a, 1 
0ce6 cd b0 09				call aDelayInMS 
0ce9			 
0ce9					; dec flash counter 
0ce9 3a 66 ee				ld a, (input_cur_flash) 
0cec 3d					dec a 
0ced 32 66 ee				ld (input_cur_flash), a 
0cf0 fe 00				cp 0 
0cf2 20 0d				jr nz, .nochgstate 
0cf4			 
0cf4			 
0cf4					; change state 
0cf4 3a 65 ee				ld a,(input_cur_onoff) 
0cf7 ed 44				neg 
0cf9 32 65 ee				ld (input_cur_onoff),a 
0cfc			 
0cfc			 
0cfc					; reset on change of state 
0cfc 3e 0f				ld a, CUR_BLINK_RATE 
0cfe 32 66 ee				ld (input_cur_flash), a 
0d01			 
0d01			.nochgstate: 
0d01					 
0d01					 
0d01			 
0d01					; display cursor  
0d01			 
0d01			;		ld hl, (input_start) 
0d01			;		ld a, (input_cursor) 
0d01			;		call addatohl 
0d01			 
0d01					; get char under cursor and replace with cursor 
0d01 2a 6f ee		ld hl, (input_ptr) 
0d04			;		ld a, (hl) 
0d04			;		ld (input_under_cursor),a 
0d04			;		ld a, '_' 
0d04			;		ld (hl), a 
0d04			 
0d04					; display string 
0d04			 
0d04 ed 5b 6d ee			ld de, (input_start) 
0d08 3a 6a ee				ld a, (input_at_pos) 
0d0b cd 6c 0a				call str_at_display 
0d0e			;	        call update_display 
0d0e			 
0d0e					; find place to put the cursor 
0d0e			;		add h 
0d0e			;		ld l, display_row_1 
0d0e			;		sub l 
0d0e			; (input_at_pos) 
0d0e					;ld c, a 
0d0e			;		ld a, (input_cursor) 
0d0e			;		ld l, (input_at_pos) 
0d0e			;		;ld b, h 
0d0e			;		add l 
0d0e			;		ld (input_at_cursor),a 
0d0e					;ld l,h 
0d0e			 
0d0e			;		ld h, 0 
0d0e			;		ld l,(input_at_pos) 
0d0e			;		ld a, (input_cursor) 
0d0e			;		call addatohl 
0d0e			;		ld a, 074H-19			; TODO BUG I dont know why offset is showing 74H 
0d0e			;		call subafromhl 
0d0e			;		ld a,l 
0d0e			;		ld (input_at_cursor), a 
0d0e			 
0d0e				if DEBUG_INPUT 
0d0e					ld a, (hardware_diag) 
0d0e					cp 0 
0d0e					jr z, .skip_input_diag 
0d0e			 
0d0e					ld a,(input_at_pos) 
0d0e					ld hl, LFSRSeed 
0d0e					call hexout 
0d0e					ld a, (input_cursor) 
0d0e					ld hl, LFSRSeed+2 
0d0e					call hexout 
0d0e					ld a,(input_at_cursor) 
0d0e					ld hl, LFSRSeed+4 
0d0e					call hexout 
0d0e			 
0d0e					ld a,(input_cur_onoff) 
0d0e					ld hl, LFSRSeed+6 
0d0e					call hexout 
0d0e			 
0d0e					ld a,(input_cur_flash) 
0d0e					ld hl, LFSRSeed+8 
0d0e					call hexout 
0d0e			 
0d0e					ld a,(input_len) 
0d0e					ld hl, LFSRSeed+10 
0d0e					call hexout 
0d0e					ld hl, LFSRSeed+12 
0d0e					ld a, 0 
0d0e					ld (hl),a 
0d0e					ld a, display_row_4 
0d0e					ld de, LFSRSeed 
0d0e					call str_at_display 
0d0e					.skip_input_diag: 
0d0e				endif 
0d0e			 
0d0e					; decide on if we are showing the cursor this time round 
0d0e			 
0d0e 3a 65 ee				ld a, (input_cur_onoff) 
0d11 fe ff				cp 255 
0d13 28 13				jr z, .skipcur 
0d15			 
0d15			 
0d15 3a 68 ee				ld a,(input_at_cursor) 
0d18 11 ca eb				ld de, cursor_shape 
0d1b cd 6c 0a				call str_at_display 
0d1e			 
0d1e					; save length of current input string 
0d1e 2a 6d ee				ld hl, (input_start) 
0d21 cd e4 10				call strlenz 
0d24 7d					ld a,l 
0d25 32 60 ee				ld (input_len),a 
0d28			 
0d28			.skipcur: 
0d28			 
0d28 cd 7c 0a			        call update_display 
0d2b					 
0d2b			 
0d2b			 
0d2b					; wait 
0d2b				 
0d2b					; TODO loop without wait to flash the cursor and char under cursor	 
0d2b cd 35 5a				call cin    ; _wait 
0d2e			 
0d2e fe 00				cp 0 
0d30 ca e4 0c				jp z, .is1 
0d33			 
0d33					; get ptr to char to input into 
0d33			 
0d33 4f					ld c,a 
0d34 2a 6d ee				ld hl, (input_start) 
0d37 3a 5b ee				ld a, (input_cursor) 
0d3a cd 86 0c				call addatohl 
0d3d 22 6f ee				ld (input_ptr), hl 
0d40 79					ld a,c 
0d41			 
0d41					; replace char under cursor 
0d41			 
0d41			;		ld hl, (input_ptr) 
0d41			;		ld a, (input_under_cursor) 	; get what is under the cursor 
0d41			;		ld (hl), a 
0d41			 
0d41			;	if DEBUG_INPUT 
0d41			;		push af 
0d41			;		ld a, 'i' 
0d41			;		ld (debug_mark),a 
0d41			;		pop af 
0d41			;		CALLMONITOR 
0d41			;	endif 
0d41 fe 0e				cp KEY_HOME 
0d43 20 0e				jr nz, .iske 
0d45			 
0d45 3a 6a ee				ld a, (input_at_pos) 
0d48 32 68 ee				ld (input_at_cursor),a 
0d4b 3e 00				ld a, 0 
0d4d 32 5b ee				ld (input_cursor), a 
0d50 c3 e4 0c				jp .is1 
0d53					 
0d53 fe 0f		.iske:		cp KEY_END 
0d55 20 03				jr nz, .isknw 
0d57 c3 e4 0c				jp .is1 
0d5a			 
0d5a fe 06		.isknw:		cp KEY_NEXTWORD 
0d5c 20 1b				jr nz, .iskpw 
0d5e			 
0d5e 2a 6f ee		.isknwm:	ld hl, (input_ptr) 
0d61 7e					ld a,(hl)	 
0d62 fe 00				cp 0 
0d64 ca e4 0c				jp z, .is1    ; end of string 
0d67 fe 20				cp ' ' 
0d69 ca e4 0c				jp z, .is1    ; end of word 
0d6c 23					inc hl 
0d6d 22 6f ee				ld (input_ptr), hl 
0d70 3a 68 ee				ld a, (input_at_cursor) 
0d73 3c					inc a 
0d74 32 68 ee				ld (input_at_cursor), a 
0d77 18 e5				jr .isknwm 
0d79			 
0d79 fe 07		.iskpw:		cp KEY_PREVWORD 
0d7b 20 1b				jr nz, .iskl 
0d7d			.iskpwm:	 
0d7d 2a 6f ee				ld hl, (input_ptr) 
0d80 7e					ld a,(hl)	 
0d81 fe 00				cp 0  
0d83 ca e4 0c				jp z, .is1    ; end of string 
0d86 fe 20				cp ' ' 
0d88 ca e4 0c				jp z, .is1    ; end of word 
0d8b 2b					dec hl 
0d8c 22 6f ee				ld (input_ptr), hl 
0d8f 3a 68 ee				ld a, (input_at_cursor) 
0d92 3d					dec a 
0d93 32 68 ee				ld (input_at_cursor), a 
0d96 18 e5				jr .iskpwm 
0d98			 
0d98			 
0d98 fe 0b		.iskl:		cp KEY_LEFT 
0d9a 20 27				jr nz, .isk1 
0d9c			 
0d9c 3a 5b ee				ld a, (input_cursor) 
0d9f			 
0d9f fe 00				cp 0 
0da1 ca e4 0c				jp z, .is1 		; at start of line to ignore  
0da4			 
0da4 3d					dec  a 		; TODO check underflow 
0da5 32 5b ee				ld (input_cursor), a 
0da8			 
0da8 2a 6f ee				ld hl, (input_ptr) 
0dab 2b					dec hl 
0dac 22 6f ee				ld (input_ptr), hl 
0daf					 
0daf 3a 68 ee				ld a, (input_at_cursor) 
0db2 3d					dec a 
0db3 32 68 ee				ld (input_at_cursor), a 
0db6			 
0db6 3e 01				ld a, 1		; show cursor moving 
0db8 32 65 ee				ld (input_cur_onoff),a 
0dbb 3e 0f				ld a, CUR_BLINK_RATE 
0dbd 32 66 ee				ld (input_cur_flash), a 
0dc0			 
0dc0 c3 e4 0c				jp .is1 
0dc3			 
0dc3 fe 0c		.isk1:		cp KEY_RIGHT 
0dc5 20 2a				jr nz, .isk2 
0dc7			 
0dc7 3a 60 ee				ld a,(input_len)		; TODO BUG why cant i load e direct? 
0dca 5f					ld e,a 
0dcb 3a 5b ee				ld a, (input_cursor) 
0dce bb					cp e 
0dcf ca e4 0c				jp z, .is1		; at the end of string so dont go right 
0dd2			 
0dd2 3c					inc  a 		; TODO check overflow 
0dd3 32 5b ee				ld (input_cursor), a 
0dd6			 
0dd6 3a 68 ee				ld a, (input_at_cursor) 
0dd9 3c					inc a 
0dda 32 68 ee				ld (input_at_cursor), a 
0ddd			 
0ddd 2a 6f ee				ld hl, (input_ptr) 
0de0 23					inc hl 
0de1 22 6f ee				ld (input_ptr), hl 
0de4			 
0de4 3e 01				ld a, 1		; show cursor moving 
0de6 32 65 ee				ld (input_cur_onoff),a 
0de9 3e 0f				ld a, CUR_BLINK_RATE 
0deb 32 66 ee				ld (input_cur_flash), a 
0dee			 
0dee c3 e4 0c				jp .is1 
0df1			 
0df1 fe 05		.isk2:		cp KEY_UP 
0df3			 
0df3 20 26				jr nz, .isk3 
0df5			 
0df5					; swap last command with the current on 
0df5			 
0df5					; move cursor to start of string 
0df5 2a 6d ee				ld hl, (input_start) 
0df8 22 6f ee				ld (input_ptr), hl 
0dfb			 
0dfb 3a 6a ee				ld a, (input_at_pos) 
0dfe 32 68 ee				ld (input_at_cursor), a 
0e01			 
0e01 3e 00				ld a, 0 
0e03 32 5b ee				ld (input_cursor), a 
0e06					 
0e06					; swap input and last command buffers 
0e06			 
0e06 21 fe e6				ld hl, os_cli_cmd 
0e09 11 fd e7				ld de, os_last_cmd 
0e0c 06 ff				ld b, 255 
0e0e 7e			.swap1:		ld a, (hl) 
0e0f 4f					ld c,a 
0e10 1a					ld a, (de) 
0e11 77					ld (hl), a 
0e12 79					ld a,c 
0e13 12					ld (de),a 
0e14 23					inc hl 
0e15 13					inc de 
0e16 10 f6				djnz .swap1 
0e18			 
0e18			 
0e18			 
0e18			 
0e18			 
0e18 c3 e4 0c				jp .is1 
0e1b			 
0e1b fe 08		.isk3:		cp KEY_BS 
0e1d 20 3c				jr nz, .isk4 
0e1f			 
0e1f 3a 5b ee				ld a, (input_cursor) 
0e22			 
0e22 fe 00				cp 0 
0e24 ca e4 0c				jp z, .is1 		; at start of line to ignore  
0e27			 
0e27 3d					dec  a 		; TODO check underflow 
0e28 32 5b ee				ld (input_cursor), a 
0e2b			 
0e2b					; hl is source 
0e2b					; de needs to be source - 1 
0e2b			 
0e2b			;		ld a, 0 
0e2b			;		dec hl 
0e2b			;		ld (hl), a 
0e2b			 
0e2b 2a 6f ee				ld hl, (input_ptr) 
0e2e 2b					dec hl 
0e2f 22 6f ee				ld (input_ptr), hl 
0e32			 
0e32					; shift all data 
0e32			 
0e32 e5					push hl 
0e33 23					inc hl 
0e34 d1					pop de 
0e35 3a 60 ee				ld a, (input_len)		; TODO BUG WAS ld c, (input... 
0e38 4f					ld c,a 
0e39 06 00				ld b,0 
0e3b ed b0				ldir  
0e3d			 
0e3d			 
0e3d			 
0e3d			 
0e3d 3a 68 ee				ld a, (input_at_cursor) 
0e40 3d					dec a 
0e41 32 68 ee				ld (input_at_cursor), a 
0e44			 
0e44			 
0e44 3e 01				ld a, 1		; show cursor moving 
0e46 32 65 ee				ld (input_cur_onoff),a 
0e49 3e 0f				ld a, CUR_BLINK_RATE 
0e4b 32 66 ee				ld (input_cur_flash), a 
0e4e			 
0e4e					; remove char 
0e4e 3a 68 ee				ld a, (input_at_cursor) 
0e51 3c					inc a 
0e52 11 dc 0e				ld de,.iblank 
0e55 cd 6c 0a				call str_at_display 
0e58			 
0e58 c3 e4 0c				jp .is1 
0e5b			 
0e5b fe 0d		.isk4:		cp KEY_CR 
0e5d 28 6c				jr z, .endinput 
0e5f			 
0e5f					; else add the key press to the end 
0e5f			 
0e5f 4f					ld c, a			; save key pressed 
0e60			 
0e60 7e					ld a,(hl)		; get what is currently under char 
0e61			 
0e61 fe 00				cp 0			; we are at the end of the string 
0e63 20 2f				jr nz, .onchar 
0e65					 
0e65					; add a char to the end of the string 
0e65				 
0e65 71					ld (hl),c 
0e66 23					inc hl 
0e67			;		ld a,' ' 
0e67			;		ld (hl),a 
0e67			;		inc hl 
0e67 3e 00				ld a,0 
0e69 77					ld (hl),a 
0e6a 2b					dec hl 
0e6b			 
0e6b 3a 5b ee				ld a, (input_cursor) 
0e6e 3c					inc a				; TODO check max string length and scroll  
0e6f 32 5b ee				ld (input_cursor), a		; inc cursor pos 
0e72							 
0e72 3a 68 ee				ld a, (input_at_cursor) 
0e75 3c					inc a 
0e76 32 68 ee				ld (input_at_cursor), a 
0e79			 
0e79 2a 6f ee				ld hl, (input_ptr) 
0e7c 23					inc hl 
0e7d 22 6f ee				ld (input_ptr), hl 
0e80			 
0e80 2a 6f ee				ld hl, (input_ptr) 
0e83 23					inc hl 
0e84 22 6f ee				ld (input_ptr), hl 
0e87			;	if DEBUG_INPUT 
0e87			;		push af 
0e87			;		ld a, '+' 
0e87			;		ld (debug_mark),a 
0e87			;		pop af 
0e87			;		CALLMONITOR 
0e87			;	endif 
0e87 3e 01				ld a, 1		; show cursor moving 
0e89 32 65 ee				ld (input_cur_onoff),a 
0e8c 3e 0f				ld a, CUR_BLINK_RATE 
0e8e 32 66 ee				ld (input_cur_flash), a 
0e91 c3 e4 0c				jp .is1 
0e94					 
0e94			 
0e94			 
0e94					; if on a char then insert 
0e94			.onchar: 
0e94			 
0e94					; TODO over flow check: make sure insert does not blow out buffer 
0e94			 
0e94					; need to do some maths to use lddr 
0e94			 
0e94 e5					push hl   ; save char pos 
0e95 c5					push bc 
0e96			 
0e96 2a 6d ee				ld hl, (input_start) 
0e99 3a 60 ee				ld a, (input_len) 
0e9c cd 86 0c				call addatohl  		; end of string 
0e9f 23					inc hl 
0ea0 23					inc hl		; past zero term 
0ea1 e5					push hl 
0ea2 23					inc hl 
0ea3 e5					push hl  
0ea4			 
0ea4								; start and end of lddr set, now how much to move? 
0ea4			 
0ea4							 
0ea4 3a 5b ee				ld a, (input_cursor)		; BUG TODO why cant i load directly into b??? 
0ea7 47					ld b,a 
0ea8 3a 60 ee				ld a,(input_len) 
0eab 5f					ld e,a 
0eac 90					sub b 
0ead 3c					inc a		;?? 
0eae 3c					inc a		;?? 
0eaf 3c					inc a		;?? 
0eb0			 
0eb0 06 00				ld b,0 
0eb2 4f					ld c,a 
0eb3			 
0eb3				if DEBUG_INPUT 
0eb3					push af 
0eb3					ld a, 'i' 
0eb3					ld (debug_mark),a 
0eb3					pop af 
0eb3			;		CALLMONITOR 
0eb3				endif 
0eb3 d1					pop de 
0eb4 e1					pop hl 
0eb5				if DEBUG_INPUT 
0eb5					push af 
0eb5					ld a, 'I' 
0eb5					ld (debug_mark),a 
0eb5					pop af 
0eb5			;		CALLMONITOR 
0eb5				endif 
0eb5 ed b8				lddr 
0eb7				 
0eb7			 
0eb7			 
0eb7					; TODO have a key for insert/overwrite mode???? 
0eb7 c1					pop bc 
0eb8 e1					pop hl 
0eb9 71					ld (hl), c		; otherwise overwrite current char 
0eba					 
0eba			 
0eba			 
0eba			 
0eba 3a 5b ee				ld a, (input_cursor) 
0ebd 3c					inc  a 		; TODO check overflow 
0ebe 32 5b ee				ld (input_cursor), a 
0ec1			 
0ec1 3a 68 ee				ld a, (input_at_cursor) 
0ec4 3c					inc a 
0ec5 32 68 ee				ld (input_at_cursor), a 
0ec8			 
0ec8 c3 e4 0c				jp .is1 
0ecb			 
0ecb			.endinput:	; TODO look for end of string 
0ecb			 
0ecb					; add trailing space for end of token 
0ecb			 
0ecb 2a 6d ee				ld hl, (input_start) 
0ece 3a 60 ee				ld a,(input_len) 
0ed1 cd 86 0c				call addatohl 
0ed4 3e 20				ld a, ' ' 
0ed6 77					ld (hl),a 
0ed7					; TODO eof of parse marker 
0ed7			 
0ed7 23					inc hl 
0ed8 3e 00				ld a, 0 
0eda 77					ld (hl),a 
0edb			 
0edb			 
0edb c9					ret 
0edc			 
0edc .. 00		.iblank: db " ",0 
0ede			 
0ede			 
0ede 32 6a ee		input_str_prev:	ld (input_at_pos), a 
0ee1 22 6d ee				ld (input_start), hl 
0ee4 3e 01				ld a,1			; add cursor 
0ee6 77					ld (hl),a 
0ee7 23					inc hl 
0ee8 3e 00				ld a,0 
0eea 77					ld (hl),a 
0eeb 22 6f ee				ld (input_ptr), hl 
0eee 7a					ld a,d 
0eef 32 6c ee				ld (input_size), a 
0ef2 3e 00				ld a,0 
0ef4 32 5b ee				ld (input_cursor),a 
0ef7			.instr1:	 
0ef7			 
0ef7					; TODO do block cursor 
0ef7					; TODO switch cursor depending on the modifer key 
0ef7			 
0ef7					; update cursor shape change on key hold 
0ef7			 
0ef7 2a 6f ee				ld hl, (input_ptr) 
0efa 2b					dec hl 
0efb 3a ca eb				ld a,(cursor_shape) 
0efe 77					ld (hl), a 
0eff			 
0eff					; display entered text 
0eff 3a 6a ee				ld a,(input_at_pos) 
0f02 cd 4a 59		            	CALL fLCD_Pos       ;Position cursor to location in A 
0f05 ed 5b 6d ee	            	LD   de, (input_start) 
0f09 cd 3f 59		            	CALL fLCD_Str       ;Display string pointed to by DE 
0f0c			 
0f0c cd 35 5a				call cin 
0f0f fe 00				cp 0 
0f11 28 e4				jr z, .instr1 
0f13			 
0f13					; proecess keyboard controls first 
0f13			 
0f13 2a 6f ee				ld hl,(input_ptr) 
0f16			 
0f16 fe 0d				cp KEY_CR	 ; pressing enter ends input 
0f18 28 5a				jr z, .instrcr 
0f1a			 
0f1a fe 08				cp KEY_BS 	; back space 
0f1c 20 0f				jr nz, .instr2 
0f1e					; process back space 
0f1e			 
0f1e					; TODO stop back space if at start of string 
0f1e 2b					dec hl 
0f1f 2b					dec hl ; to over write cursor 
0f20 3a ca eb				ld a,(cursor_shape) 
0f23					;ld a,0 
0f23 77					ld (hl),a 
0f24 23					inc hl 
0f25 3e 20				ld a," " 
0f27 77					ld (hl),a 
0f28 22 6f ee				ld (input_ptr),hl 
0f2b					 
0f2b			 
0f2b 18 ca				jr .instr1 
0f2d			 
0f2d fe 0b		.instr2:	cp KEY_LEFT    ; cursor left 
0f2f 20 06				jr nz, .instr3 
0f31 2b					dec hl 
0f32 22 6f ee				ld (input_ptr),hl 
0f35 18 c0				jr .instr1 
0f37				 
0f37 fe 0c		.instr3:	cp KEY_RIGHT ; cursor right 
0f39 20 06				jr nz, .instr4 
0f3b 23					inc hl 
0f3c 22 6f ee				ld (input_ptr),hl 
0f3f 18 b6				jr .instr1 
0f41			 
0f41 fe 0e		.instr4:	cp KEY_HOME    ; jump to start of line 
0f43 20 06				jr nz, .instr5 
0f45 2b					dec hl 
0f46 22 6f ee				ld (input_ptr),hl 
0f49 18 ac				jr .instr1 
0f4b			 
0f4b fe 0f		.instr5:	cp KEY_END     ; jump to end of line 
0f4d 20 06				jr nz, .instr6 
0f4f 2b					dec hl 
0f50 22 6f ee				ld (input_ptr),hl 
0f53 18 a2				jr .instr1 
0f55 fe 05		.instr6:        cp KEY_UP      ; recall last command 
0f57 20 0b				jr nz, .instrnew 
0f59			 
0f59 21 d7 e3			ld hl, scratch 
0f5c 11 fd e7			ld de, os_last_cmd 
0f5f cd 7d 0f			call strcpy 
0f62 18 93				jr .instr1 
0f64			 
0f64			 
0f64			.instrnew:	; no special key pressed to see if we have room to store it 
0f64			 
0f64					; TODO do string size test 
0f64			 
0f64 2b					dec hl ; to over write cursor 
0f65 77					ld (hl),a 
0f66 23					inc hl 
0f67 3a ca eb				ld a,(cursor_shape) 
0f6a 77					ld (hl),a 
0f6b 23					inc hl 
0f6c 3e 00				ld a,0 
0f6e 77					ld (hl),a 
0f6f			 
0f6f 22 6f ee				ld (input_ptr),hl 
0f72					 
0f72 18 83				jr .instr1 
0f74 2b			.instrcr:	dec hl		; remove cursor 
0f75 3e 20				ld a,' '	; TODO add a trailing space for safety 
0f77 77					ld (hl),a 
0f78 23					inc hl 
0f79 3e 00				ld a,0 
0f7b 77					ld (hl),a 
0f7c			 
0f7c			 
0f7c					; if at end of line scroll up    
0f7c					; TODO detecting only end of line 4 for scroll up  
0f7c			 
0f7c					;ld   
0f7c			 
0f7c c9					ret 
0f7d			 
0f7d			 
0f7d			; strcpy hl = dest, de source 
0f7d			 
0f7d 1a			strcpy:   LD   A, (DE)        ;Get character from string 
0f7e b7			            OR   A              ;Null terminator? 
0f7f c8			            RET  Z              ;Yes, so finished 
0f80 1a					ld a,(de) 
0f81 77					ld (hl),a 
0f82 13			            INC  DE             ;Point to next character 
0f83 23					inc hl 
0f84 18 f7		            JR   strcpy       ;Repeat 
0f86 c9					ret 
0f87			 
0f87			 
0f87			; TODO string_at  
0f87			; pass string which starts with lcd offset address and then null term string 
0f87			 
0f87			; TODO string to dec 
0f87			; TODO string to hex 
0f87			; TODO byte to string hex 
0f87			; TODO byte to string dec 
0f87			 
0f87			 
0f87			 
0f87			; from z80uartmonitor 
0f87			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f87			; OUTPUT VALUE OF A IN HEX ONE NYBBLE AT A TIME 
0f87			; pass hl for where to put the text 
0f87			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0f87 c5			hexout:	PUSH BC 
0f88 f5					PUSH AF 
0f89 47					LD B, A 
0f8a					; Upper nybble 
0f8a cb 3f				SRL A 
0f8c cb 3f				SRL A 
0f8e cb 3f				SRL A 
0f90 cb 3f				SRL A 
0f92 cd a2 0f				CALL tohex 
0f95 77					ld (hl),a 
0f96 23					inc hl	 
0f97					 
0f97					; Lower nybble 
0f97 78					LD A, B 
0f98 e6 0f				AND 0FH 
0f9a cd a2 0f				CALL tohex 
0f9d 77					ld (hl),a 
0f9e 23					inc hl	 
0f9f					 
0f9f f1					POP AF 
0fa0 c1					POP BC 
0fa1 c9					RET 
0fa2					 
0fa2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fa2			; TRANSLATE value in lower A TO 2 HEX CHAR CODES FOR DISPLAY 
0fa2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	 
0fa2			tohex: 
0fa2 e5					PUSH HL 
0fa3 d5					PUSH DE 
0fa4 16 00				LD D, 0 
0fa6 5f					LD E, A 
0fa7 21 af 0f				LD HL, .DATA 
0faa 19					ADD HL, DE 
0fab 7e					LD A, (HL) 
0fac d1					POP DE 
0fad e1					POP HL 
0fae c9					RET 
0faf			 
0faf			.DATA: 
0faf 30					DEFB	30h	; 0 
0fb0 31					DEFB	31h	; 1 
0fb1 32					DEFB	32h	; 2 
0fb2 33					DEFB	33h	; 3 
0fb3 34					DEFB	34h	; 4 
0fb4 35					DEFB	35h	; 5 
0fb5 36					DEFB	36h	; 6 
0fb6 37					DEFB	37h	; 7 
0fb7 38					DEFB	38h	; 8 
0fb8 39					DEFB	39h	; 9 
0fb9 41					DEFB	41h	; A 
0fba 42					DEFB	42h	; B 
0fbb 43					DEFB	43h	; C 
0fbc 44					DEFB	44h	; D 
0fbd 45					DEFB	45h	; E 
0fbe 46					DEFB	46h	; F 
0fbf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0fbf			;; 	ASCII char code for 0-9,A-F in A to single hex digit 
0fbf			;;    subtract $30, if result > 9 then subtract $7 more 
0fbf			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0fbf			atohex: 
0fbf d6 30				SUB $30 
0fc1 fe 0a				CP 10 
0fc3 f8					RET M		; If result negative it was 0-9 so we're done 
0fc4 d6 07				SUB $7		; otherwise, subtract $7 more to get to $0A-$0F 
0fc6 c9					RET		 
0fc7			 
0fc7			 
0fc7			 
0fc7			 
0fc7			; Get 2 ASCII characters as hex byte from pointer in hl 
0fc7			 
0fc7			BYTERD: 
0fc7 16 00			LD	D,00h		;Set up 
0fc9 cd d1 0f			CALL	HEXCON		;Get byte and convert to hex 
0fcc 87				ADD	A,A		;First nibble so 
0fcd 87				ADD	A,A		;multiply by 16 
0fce 87				ADD	A,A		; 
0fcf 87				ADD	A,A		; 
0fd0 57				LD	D,A		;Save hi nibble in D 
0fd1			HEXCON: 
0fd1 7e				ld a, (hl)		;Get next chr 
0fd2 23				inc hl 
0fd3 d6 30			SUB	030h		;Makes '0'-'9' equal 0-9 
0fd5 fe 0a			CP	00Ah		;Is it 0-9 ? 
0fd7 38 02			JR	C,NALPHA	;If so miss next bit 
0fd9 d6 07			SUB	007h		;Else convert alpha 
0fdb			NALPHA: 
0fdb b2				OR	D		;Add hi nibble back 
0fdc c9				RET			; 
0fdd			 
0fdd			 
0fdd			; 
0fdd			; Get a word (16 bit) in hexadecimal notation. The result is returned in HL. 
0fdd			; Since the routines get_byte and therefore get_nibble are called, only valid 
0fdd			; characters (0-9a-f) are accepted. 
0fdd			; 
0fdd			;get_word        push    af 
0fdd			;                call    get_byte        ; Get the upper byte 
0fdd			;                ld      h, a 
0fdd			;                call    get_byte        ; Get the lower byte 
0fdd			;                ld      l, a 
0fdd			;                pop     af 
0fdd			;                ret 
0fdd			; 
0fdd			; Get a byte in hexadecimal notation. The result is returned in A. Since 
0fdd			; the routine get_nibble is used only valid characters are accepted - the  
0fdd			; input routine only accepts characters 0-9a-f. 
0fdd			; 
0fdd c5			get_byte:        push    bc              ; Save contents of B (and C) 
0fde 7e					ld a,(hl) 
0fdf 23					inc hl 
0fe0 cd 05 10		                call    nibble2val      ; Get upper nibble 
0fe3 cb 07		                rlc     a 
0fe5 cb 07		                rlc     a 
0fe7 cb 07		                rlc     a 
0fe9 cb 07		                rlc     a 
0feb 47			                ld      b, a            ; Save upper four bits 
0fec 7e					ld a,(hl) 
0fed cd 05 10		                call    nibble2val      ; Get lower nibble 
0ff0 b0			                or      b               ; Combine both nibbles 
0ff1 c1			                pop     bc              ; Restore B (and C) 
0ff2 c9			                ret 
0ff3			; 
0ff3			; Get a hexadecimal digit from the serial line. This routine blocks until 
0ff3			; a valid character (0-9a-f) has been entered. A valid digit will be echoed 
0ff3			; to the serial line interface. The lower 4 bits of A contain the value of  
0ff3			; that particular digit. 
0ff3			; 
0ff3			;get_nibble      ld a,(hl)           ; Read a character 
0ff3			;                call    to_upper        ; Convert to upper case 
0ff3			;                call    is_hex          ; Was it a hex digit? 
0ff3			;                jr      nc, get_nibble  ; No, get another character 
0ff3			 ;               call    nibble2val      ; Convert nibble to value 
0ff3			 ;               call    print_nibble 
0ff3			 ;               ret 
0ff3			; 
0ff3			; is_hex checks a character stored in A for being a valid hexadecimal digit. 
0ff3			; A valid hexadecimal digit is denoted by a set C flag. 
0ff3			; 
0ff3			;is_hex          cp      'F' + 1         ; Greater than 'F'? 
0ff3			;                ret     nc              ; Yes 
0ff3			;                cp      '0'             ; Less than '0'? 
0ff3			;                jr      nc, is_hex_1    ; No, continue 
0ff3			;                ccf                     ; Complement carry (i.e. clear it) 
0ff3			;                ret 
0ff3			;is_hex_1        cp      '9' + 1         ; Less or equal '9*? 
0ff3			;                ret     c               ; Yes 
0ff3			;                cp      'A'             ; Less than 'A'? 
0ff3			;                jr      nc, is_hex_2    ; No, continue 
0ff3			;                ccf                     ; Yes - clear carry and return 
0ff3			;                ret 
0ff3			;is_hex_2        scf                     ; Set carry 
0ff3			;                ret 
0ff3			; 
0ff3			; Convert a single character contained in A to upper case: 
0ff3			; 
0ff3 fe 61		to_upper:        cp      'a'             ; Nothing to do if not lower case 
0ff5 d8			                ret     c 
0ff6 fe 7b		                cp      'z' + 1         ; > 'z'? 
0ff8 d0			                ret     nc              ; Nothing to do, either 
0ff9 e6 5f		                and     $5f             ; Convert to upper case 
0ffb c9			                ret 
0ffc			 
0ffc			 
0ffc			to_lower: 
0ffc			 
0ffc			   ; if char is in [A-Z] make it lower case 
0ffc			 
0ffc			   ; enter : a = char 
0ffc			   ; exit  : a = lower case char 
0ffc			   ; uses  : af 
0ffc			 
0ffc fe 41		   cp 'A' 
0ffe d8			   ret c 
0fff			    
0fff fe 5b		   cp 'Z'+1 
1001 d0			   ret nc 
1002			    
1002 f6 20		   or $20 
1004 c9			   ret 
1005			 
1005			; 
1005			; Expects a hexadecimal digit (upper case!) in A and returns the 
1005			; corresponding value in A. 
1005			; 
1005 fe 3a		nibble2val:      cp      '9' + 1         ; Is it a digit (less or equal '9')? 
1007 38 02		                jr      c, nibble2val_1 ; Yes 
1009 d6 07		                sub     7               ; Adjust for A-F 
100b d6 30		nibble2val_1:    sub     '0'             ; Fold back to 0..15 
100d e6 0f		                and     $f              ; Only return lower 4 bits 
100f c9			                ret 
1010			; 
1010			; Print_nibble prints a single hex nibble which is contained in the lower  
1010			; four bits of A: 
1010			; 
1010			;print_nibble    push    af              ; We won't destroy the contents of A 
1010			;                and     $f              ; Just in case... 
1010			;                add     a, '0'             ; If we have a digit we are done here. 
1010			;                cp      '9' + 1         ; Is the result > 9? 
1010			;                jr      c, print_nibble_1 
1010			;                add     a, 'A' - '0' - $a  ; Take care of A-F 
1010			;print_nibble_1  call    putc            ; Print the nibble and 
1010			;                pop     af              ; restore the original value of A 
1010			;                ret 
1010			;; 
1010			;; Send a CR/LF pair: 
1010			; 
1010			;crlf            push    af 
1010			;                ld      a, cr 
1010			;                call    putc 
1010			;                ld      a, lf 
1010			;                call    putc 
1010			;                pop     af 
1010			;                ret 
1010			; 
1010			; Print_word prints the four hex digits of a word to the serial line. The  
1010			; word is expected to be in HL. 
1010			; 
1010			;print_word      push    hl 
1010			;                push    af 
1010			;                ld      a, h 
1010			;                call    print_byte 
1010			;                ld      a, l 
1010			;                call    print_byte 
1010			;                pop     af 
1010			;                pop     hl 
1010			;                ret 
1010			; 
1010			; Print_byte prints a single byte in hexadecimal notation to the serial line. 
1010			; The byte to be printed is expected to be in A. 
1010			; 
1010			;print_byte      push    af              ; Save the contents of the registers 
1010			;                push    bc 
1010			;                ld      b, a 
1010			;                rrca 
1010			;                rrca 
1010			;                rrca 
1010			;                rrca 
1010			;                call    print_nibble    ; Print high nibble 
1010			;                ld      a, b 
1010			;                call    print_nibble    ; Print low nibble 
1010			;                pop     bc              ; Restore original register contents 
1010			;                pop     af 
1010			;                ret 
1010			 
1010			 
1010			 
1010			 
1010			 
1010			fourehexhl:  
1010 7e				ld a,(hl) 
1011 cd bf 0f			call atohex 
1014 cb 3f				SRL A 
1016 cb 3f				SRL A 
1018 cb 3f				SRL A 
101a cb 3f				SRL A 
101c 47				ld b, a 
101d 23				inc hl 
101e 7e				ld a,(hl) 
101f 23				inc hl 
1020 cd bf 0f			call atohex 
1023 80				add b 
1024 57				ld d,a 
1025 7e				ld a,(hl) 
1026 cd bf 0f			call atohex 
1029 cb 3f				SRL A 
102b cb 3f				SRL A 
102d cb 3f				SRL A 
102f cb 3f				SRL A 
1031 47				ld b, a 
1032 23				inc hl 
1033 7e				ld a,(hl) 
1034 23				inc hl 
1035 cd bf 0f			call atohex 
1038 80				add b 
1039 5f				ld e, a 
103a d5				push de 
103b e1				pop hl 
103c c9				ret 
103d			 
103d			; pass hl. returns z set if the byte at hl is a digit 
103d			;isdigithl:  
103d			;	push bc 
103d			;	ld a,(hl) 
103d			;	cp ':' 
103d			;	jr nc, .isdf 		; > 
103d			;	cp '0' 
103d			;	jr c, .isdf		; < 
103d			; 
103d			;	; TODO find a better way to set z 
103d			; 
103d			;	ld b,a 
103d			;	cp b 
103d			;	pop bc 
103d			;	ret 
103d			; 
103d			;.isdf:	; not digit so clear z 
103d			; 
103d			;	; TODO find a better way to unset z 
103d			; 
103d			;	ld b,a 
103d			;	inc b 
103d			;	cp b 
103d			; 
103d			;	pop bc 
103d			;	ret 
103d				 
103d				 
103d			 
103d			 
103d			; pass hl as the four byte address to load 
103d			 
103d			get_word_hl:  
103d e5				push hl 
103e cd dd 0f			call get_byte 
1041				 
1041 47				ld b, a 
1042			 
1042 e1				pop hl 
1043 23				inc hl 
1044 23				inc hl 
1045			 
1045			; TODO not able to handle a-f  
1045 7e				ld a,(hl) 
1046			;	;cp ':' 
1046			;	cp 'g' 
1046			;	jr nc, .single_byte_hl 		; > 
1046			;	cp 'G' 
1046			;	jr nc, .single_byte_hl 		; > 
1046			;	cp '0' 
1046			;	jr c, .single_byte_hl		; < 
1046			 
1046				;call isdigithl 
1046 fe 00			cp 0 
1048 28 06			jr z, .single_byte_hl 
104a			 
104a			.getwhln:   ; hex word so get next byte 
104a			 
104a cd dd 0f			call get_byte 
104d 6f				ld l, a 
104e 60				ld h,b 
104f c9				ret 
1050 68			.single_byte_hl:   ld l,b 
1051 26 00				ld h,0 
1053 c9					ret 
1054			 
1054			 
1054			 
1054			 
1054 21 f8 17			ld hl,asc+1 
1057			;	ld a, (hl) 
1057			;	call nibble2val 
1057 cd dd 0f			call get_byte 
105a			 
105a			;	call fourehexhl 
105a 32 0b e4			ld (scratch+52),a 
105d				 
105d 21 09 e4			ld hl,scratch+50 
1060 22 fa e6			ld (os_cur_ptr),hl 
1063			 
1063 c9				ret 
1064			 
1064			 
1064			; from https://wikiti.brandonw.net/index.php?title=Z80_Routines:Other:DispA 
1064			 
1064			; Decimal Unsigned Version 
1064			 
1064			;Number in a to decimal ASCII 
1064			;adapted from 16 bit found in z80 Bits to 8 bit by Galandros 
1064			;Example: display a=56 as "056" 
1064			;input: a = number 
1064			;Output: a=0,value of a in the screen 
1064			;destroys af,bc (don't know about hl and de) 
1064			DispAToASCII: 
1064 0e 9c			ld	c,-100 
1066 cd 70 10			call	.Na1 
1069 0e f6			ld	c,-10 
106b cd 70 10			call	.Na1 
106e 0e ff			ld	c,-1 
1070 06 2f		.Na1:	ld	b,'0'-1 
1072 04			.Na2:	inc	b 
1073 81				add	a,c 
1074 38 fc			jr	c,.Na2 
1076 91				sub	c		;works as add 100/10/1 
1077 f5				push af		;safer than ld c,a 
1078 78				ld	a,b		;char is in b 
1079			;TODO	CALL	PUTCHAR	;plot a char. Replace with bcall(_PutC) or similar. 
1079 f1				pop af		;safer than ld a,c 
107a c9				ret 
107b			 
107b			; Decimal Signed Version 
107b			 
107b			; DispA 
107b			; -------------------------------------------------------------- 
107b			; Converts a signed integer value to a zero-terminated ASCII 
107b			; string representative of that value (using radix 10). 
107b			; -------------------------------------------------------------- 
107b			; INPUTS: 
107b			;     HL     Value to convert (two's complement integer). 
107b			;     DE     Base address of string destination. (pointer). 
107b			; -------------------------------------------------------------- 
107b			; OUTPUTS: 
107b			;     None 
107b			; -------------------------------------------------------------- 
107b			; REGISTERS/MEMORY DESTROYED 
107b			; AF HL 
107b			; -------------------------------------------------------------- 
107b			 
107b			;DispHLToASCII: 
107b			;   push    de 
107b			;   push    bc 
107b			; 
107b			;; Detect sign of HL. 
107b			;    bit    7, h 
107b			;    jr     z, ._DoConvert 
107b			; 
107b			;; HL is negative. Output '-' to string and negate HL. 
107b			;    ld     a, '-' 
107b			;    ld     (de), a 
107b			;    inc    de 
107b			; 
107b			;; Negate HL (using two's complement) 
107b			;    xor    a 
107b			;    sub    l 
107b			;    ld     l, a 
107b			;    ld     a, 0     ; Note that XOR A or SUB A would disturb CF 
107b			;    sbc    a, h 
107b			;    ld     h, a 
107b			; 
107b			;; Convert HL to digit characters 
107b			;._DoConvert: 
107b			;    ld     b, 0     ; B will count character length of number 
107b			;-   ld     a, 10 
107b			;    syscall  .DivHLByA  ; HL = HL / A, A = remainder 
107b			;    push   af 
107b			;    inc    b 
107b			;    ld     a, h 
107b			;    or     l 
107b			;    jr     nz, - 
107b			; 
107b			;; Retrieve digits from stack 
107b			;-   pop    af 
107b			;    or     $30 
107b			;    ld     (de), a 
107b			;    inc    de 
107b			;    djnz   - 
107b			; 
107b			;; Terminate string with NULL 
107b			;    xor    a 
107b			;    ld     (de), a 
107b			; 
107b			;    pop    bc 
107b			;    pop    de 
107b			;    ret 
107b			 
107b			;Comments 
107b			; 
107b			;    This routine uses the common positive-integer radix conversion algorithm of repeatedly dividing a value by the desired radix (base case: the value is zero) and saving the remainders of each division. 
107b			;    As this algorithm gives the digits in reverse order, they are pushed onto the hardware stack so that subsequently popping them yields the correct order. 
107b			;    Note that the output string will not be fixed-width. 
107b			; 
107b			;Example Usage 
107b			; 
107b			;    ld    hl, -1004 
107b			;    ld    de, OP1 
107b			;    call  DispA 
107b			;    ld    hl, OP1 
107b			;    syscall  PutS 
107b			 
107b			 
107b			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
107b			 
107b			 
107b			;Converts an ASCII string to an unsigned 16-bit integer 
107b			;Quits when it reaches a non-decimal digit 
107b			 
107b			string_to_uint16: 
107b			atoui_16: 
107b			;Input: 
107b			;     DE points to the string 
107b			;Outputs: 
107b			;     HL is the result 
107b			;     A is the 8-bit value of the number 
107b			;     DE points to the byte after the number 
107b			;Destroys: 
107b			;     BC 
107b			;       if the string is non-empty, BC is HL/10 
107b			;Size:  24 bytes 
107b			;Speed: 42+d(104+{0,9}) 
107b			;       d is the number of digits in the number 
107b			;       max is 640 cycles for a 5 digit number 
107b			;Assuming no leading zeros: 
107b			;1 digit:  146cc 
107b			;2 digit:  250cc 
107b			;3 digit:  354cc or 363cc (avg: 354.126cc) 
107b			;4 digit:  458cc or 467cc (avg: 458.27cc) 
107b			;5 digit:  562cc or 571cc or 580cc (avg: 562.4104cc) 
107b			;avg: 544.81158447265625cc (544+13297/16384) 
107b			;=============================================================== 
107b 21 00 00		  ld hl,0 
107e			.u16a: 
107e 1a			  ld a,(de) 
107f d6 30		  sub 30h 
1081 fe 0a		  cp 10 
1083 d0			  ret nc 
1084 13			  inc de 
1085 44			  ld b,h 
1086 4d			  ld c,l 
1087 29			  add hl,hl 
1088 29			  add hl,hl 
1089 09			  add hl,bc 
108a 29			  add hl,hl 
108b 85			  add a,l 
108c 6f			  ld l,a 
108d 30 ef		  jr nc,.u16a 
108f 24			  inc h 
1090 c3 7e 10		  jp .u16a 
1093			 
1093			 
1093			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/string_to_uint16.z80 
1093			 
1093			;written by Zeda 
1093			;Converts a 16-bit unsigned integer to an ASCII string. 
1093			 
1093			uitoa_16: 
1093			;Input: 
1093			;   DE is the number to convert 
1093			;   HL points to where to write the ASCII string (up to 6 bytes needed). 
1093			;Output: 
1093			;   HL points to the null-terminated ASCII string 
1093			;      NOTE: This isn't necessarily the same as the input HL. 
1093 d5			  push de 
1094 c5			  push bc 
1095 f5			  push af 
1096 eb			  ex de,hl 
1097			 
1097 01 f0 d8		  ld bc,-10000 
109a 3e 2f		  ld a,'0'-1 
109c 3c			  inc a 
109d 09			  add hl,bc  
109e 38 fc		   jr c,$-2 
10a0 12			  ld (de),a 
10a1 13			  inc de 
10a2			 
10a2 01 e8 03		  ld bc,1000 
10a5 3e 3a		  ld a,'9'+1 
10a7 3d			  dec a  
10a8 09			  add hl,bc  
10a9 30 fc		   jr nc,$-2 
10ab 12			  ld (de),a 
10ac 13			  inc de 
10ad			 
10ad 01 9c ff		  ld bc,-100 
10b0 3e 2f		  ld a,'0'-1 
10b2 3c			  inc a  
10b3 09			  add hl,bc  
10b4 38 fc		   jr c,$-2 
10b6 12			  ld (de),a 
10b7 13			  inc de 
10b8			 
10b8 7d			  ld a,l 
10b9 26 3a		  ld h,'9'+1 
10bb 25			  dec h  
10bc c6 0a		  add a,10  
10be 30 fb		   jr nc,$-3 
10c0 c6 30		  add a,'0' 
10c2 eb			  ex de,hl 
10c3 72			  ld (hl),d 
10c4 23			  inc hl 
10c5 77			  ld (hl),a 
10c6 23			  inc hl 
10c7 36 00		  ld (hl),0 
10c9			 
10c9			;Now strip the leading zeros 
10c9 0e fa		  ld c,-6 
10cb 09			  add hl,bc 
10cc 3e 30		  ld a,'0' 
10ce 23			  inc hl  
10cf be			  cp (hl)  
10d0 28 fc		  jr z,$-2 
10d2			 
10d2			;Make sure that the string is non-empty! 
10d2 7e			  ld a,(hl) 
10d3 b7			  or a 
10d4 20 01		  jr nz,.atoub 
10d6 2b			  dec hl 
10d7			.atoub: 
10d7			 
10d7 f1			  pop af 
10d8 c1			  pop bc 
10d9 d1			  pop de 
10da c9			  ret 
10db			 
10db			; from https://github.com/Zeda/Z80-Optimized-Routines/blob/master/conversion/toUpper.z80 
10db			 
10db			toUpper: 
10db			;A is the char. 
10db			;If A is a lowercase letter, this sets it to the matching uppercase 
10db			;18cc or 30cc or 41cc 
10db			;avg: 26.75cc 
10db fe 61		  cp 'a' 
10dd d8			  ret c 
10de fe 7b		  cp 'z'+1 
10e0 d0			  ret nc 
10e1 d6 20		  sub 'a'-'A' 
10e3 c9			  ret 
10e4			 
10e4			; https://tutorials.eeems.ca/ASMin28Days/lesson/day16.html#cmp 
10e4			 
10e4			; String Length 
10e4			;With a length-prefixed string, finding the length is trivial. For a null-terminated string, the process is decidedly more involved. This is where CPIR comes in. 
10e4			 
10e4			; Get the length of the null-terminated string starting at $8000 hl 
10e4			;    LD     HL, $8000 
10e4			 
10e4			strlenz: 
10e4			 
10e4 af			    XOR    A               ; Zero is the value we are looking for. 
10e5 47			    LD     B, A             ; Since we haven't the slightest clue as to the  
10e6 4f			    LD     C, A             ; actual size of the string, put 0 in BC to search 
10e7			                           ; 65, 536 bytes (the entire addressable memory space). 
10e7 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
10e9			 
10e9			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
10e9 67			    LD     H, A             ; Zero HL (basically set it to 65, 536) to get the 
10ea 6f			    LD     L, A             ; number of bytes 
10eb ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
10ed 2b			    DEC    HL              ; Compensate for null. 
10ee c9				ret 
10ef			 
10ef			; Get the length of the A terminated string starting at $8000 hl 
10ef			;    LD     HL, $8000 
10ef			 
10ef			strlent: 
10ef			 
10ef			                  ; A is the value we are looking for. 
10ef 06 00		    LD     B, 0             ; Since we haven't the slightest clue as to the  
10f1 0e 00		    LD     C, 0             ; actual size of the string, put 0 in BC to search 
10f3			                           ; 65, 536 bytes (the entire addressable memory space). 
10f3 ed b1		    CPIR                   ; Begin search for a byte equalling zero. 
10f5			 
10f5			; BC has been decremented so that it holds -length. Now need to synthesize a NEG BC. 
10f5 26 00		    LD     H, 0             ; Zero HL (basically set it to 65, 536) to get the 
10f7 2e 00		    LD     L, 0             ; number of bytes 
10f9 ed 42		    SBC    HL, BC           ; Find the size. CPIR doesn't affect carry. 
10fb 2b			    DEC    HL              ; Compensate for null. 
10fc c9				ret 
10fd			 
10fd			 
10fd			;Comparing Strings 
10fd			 
10fd			;IN    HL     Address of string1. 
10fd			;      DE     Address of string2. 
10fd			 
10fd			; doc given but wrong??? 
10fd			;OUT   zero   Set if string1 = string2, reset if string1 != string2. 
10fd			;      carry  Set if string1 > string2, reset if string1 <= string2. 
10fd			; tested 
10fd			;OUT   carry set  if string1 = string2, carry  reset if string1 != string2. 
10fd			 
10fd			strcmp_old: 
10fd e5			    PUSH   HL 
10fe d5			    PUSH   DE 
10ff			 
10ff 1a			    LD     A, (DE)          ; Compare lengths to determine smaller string 
1100 be			    CP     (HL)            ; (want to minimize work). 
1101 38 01		    JR     C, Str1IsBigger 
1103 7e			    LD     A, (HL) 
1104			 
1104			Str1IsBigger: 
1104 4f			    LD     C, A             ; Put length in BC 
1105 06 00		    LD     B, 0 
1107 13			    INC    DE              ; Increment pointers to meat of string. 
1108 23			    INC    HL 
1109			 
1109			CmpLoop: 
1109 1a			    LD     A, (DE)          ; Compare bytes. 
110a ed a1		    CPI 
110c 20 09		    JR     NZ, NoMatch      ; If (HL) != (DE), abort. 
110e 13			    INC    DE              ; Update pointer. 
110f ea 09 11		    JP     PE, CmpLoop 
1112			 
1112 d1			    POP    DE 
1113 e1			    POP    HL 
1114 1a			    LD     A, (DE)          ; Check string lengths to see if really equal. 
1115 be			    CP     (HL) 
1116 c9			    RET 
1117			 
1117			NoMatch: 
1117 2b			    DEC    HL 
1118 be			    CP     (HL)            ; Compare again to affect carry. 
1119 d1			    POP    DE 
111a e1			    POP    HL 
111b c9			    RET 
111c			 
111c			;; test strmp 
111c			; 
111c			;ld de, .str1 
111c			;ld hl, .str2 
111c			;call strcmp 
111c			;jr z, .z1 
111c			;;this 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "NZ1" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			;.z1: 
111c			; 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "ZZ1" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			; 
111c			;ld de, .str1 
111c			;ld hl, .str1 
111c			;call strcmp 
111c			;jr z, .z2 
111c			;;this 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "NZ2" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			;.z2: 
111c			; 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "ZZ2" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			; 
111c			;ld de, .str1 
111c			;ld hl, .str2 
111c			;call strcmp 
111c			;jr c, .c1 
111c			; 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "Nc1" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			;.c1: 
111c			;;this 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "cc1" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			; 
111c			;ld de, .str1 
111c			;ld hl, .str1 
111c			;call strcmp 
111c			;jr c, .c2 
111c			;;this 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "Nc2" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			;.c2: 
111c			; 
111c			;	if DEBUG_FORTH_WORDS 
111c			;		DMARK "cc2" 
111c			;		CALLMONITOR 
111c			;	endif 
111c			;	NEXTW 
111c			;.str1:   db "string1",0 
111c			;.str2:   db "string2",0 
111c			 
111c			; only care about direct match or not 
111c			; hl and de strings 
111c			; zero set if the same 
111c			 
111c			strcmp: 
111c 1a				ld a, (de) 
111d be				cp (hl) 
111e 28 02			jr z, .ssame 
1120 b7				or a 
1121 c9				ret 
1122			 
1122			.ssame:  
1122 fe 00			cp 0 
1124 c8				ret z 
1125			 
1125 23				inc hl 
1126 13				inc de 
1127 18 f3			jr strcmp 
1129				 
1129				 
1129			 
1129			 
1129			 
1129			 
1129			; eof 
1129			 
1129			 
1129			 
1129			 
1129			 
1129			 
# End of file firmware_strings.asm
1129			include "firmware_memory.asm"   ; malloc and free  
1129			 
1129			if DEBUG_FORTH_MALLOC_HIGH 
1129			.mallocsize: db "Wants malloc >256",0 
1129			.mallocasize: db "MALLOC gives >256",0 
1129			.malloczero: db "MALLOC gives zero",0 
1129			 
1129			malloc_guard_zerolen: 
1129				push hl 
1129				push de 
1129				push af 
1129			 
1129				ld de, 0 
1129			        call cmp16 
1129				jr nz, .lowalloz 
1129			 
1129				push hl 
1129				push de 
1129					ld hl, display_fb0 
1129					ld (display_fb_active), hl 
1129				call clear_display 
1129				ld a, 0 
1129				ld de, .malloczero 
1129				call str_at_display 
1129				call update_display 
1129				call delay1s 
1129				call delay1s 
1129				ld a, 0 
1129				ld (os_view_disable), a 
1129			 
1129				pop de 
1129				pop hl 
1129			 
1129				 
1129			 
1129				CALLMONITOR 
1129			.lowalloz: 
1129			 
1129			 
1129				pop af 
1129				pop de 
1129				pop hl 
1129			ret 
1129			 
1129			malloc_guard_entry: 
1129				push hl 
1129				push de 
1129				push af 
1129			 
1129			 	or a      ;clear carry flag 
1129				push hl 
1129				ld de, 255 
1129				sbc hl, de 
1129				jr c, .lowalloc 
1129			 
1129				push de 
1129					ld hl, display_fb0 
1129					ld (display_fb_active), hl 
1129				call clear_display 
1129				ld a, 0 
1129				ld de, .mallocsize 
1129				call str_at_display 
1129				call update_display 
1129				call delay1s 
1129				call delay1s 
1129				ld a, 0 
1129				ld (os_view_disable), a 
1129			 
1129				pop de 
1129				pop hl 
1129			 
1129				 
1129			 
1129				CALLMONITOR 
1129				jr .lowdone 
1129			.lowalloc: 
1129			 
1129			 
1129				pop hl 
1129			.lowdone:	pop af 
1129				pop de 
1129				pop hl 
1129			ret 
1129			 
1129			malloc_guard_exit: 
1129				push hl 
1129				push de 
1129				push af 
1129			 
1129			 	or a      ;clear carry flag 
1129				push hl 
1129				ld de, 255 
1129				sbc hl, de 
1129				jr c, .lowallocx 
1129			 
1129				push de 
1129					ld hl, display_fb0 
1129					ld (display_fb_active), hl 
1129				call clear_display 
1129				ld a, 0 
1129				ld de, .mallocasize 
1129				call str_at_display 
1129				call update_display 
1129				call delay1s 
1129				call delay1s 
1129				ld a, 0 
1129				ld (os_view_disable), a 
1129				pop de 
1129				pop hl 
1129			 
1129				CALLMONITOR 
1129				jr .lowdonex 
1129			.lowallocx: 
1129			 
1129				pop hl 
1129			.lowdonex:	pop af 
1129				pop de 
1129				pop hl 
1129			ret 
1129			endif 
1129			 
1129			if MALLOC_2 
1129			; Z80 Malloc and Free Functions 
1129			 
1129			; Malloc Function: 
1129			; Input: 
1129			;   HL: Size of block to allocate 
1129			; Output: 
1129			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1129			 
1129			malloc: 
1129				 
1129			if DEBUG_FORTH_MALLOC_HIGH 
1129			call malloc_guard_entry 
1129			endif 
1129			 
1129			 
1129			 
1129			 
1129					if DEBUG_FORTH_MALLOC 
1129						DMARK "mal" 
1129						CALLMONITOR 
1129					endif 
1129			    push af            ; Save AF register 
1129			    ld a, l            ; Load low byte of size into A 
1129			    or h               ; Check if size is zero 
1129			    jp z, malloc_exit  ; If size is zero, exit with NULL pointer 
1129			 
1129			    ; Allocate memory 
1129			    ld hl, (heap_start) ; Load start of heap into HL 
1129					if DEBUG_FORTH_MALLOC 
1129						DMARK "ma1" 
1129						CALLMONITOR 
1129					endif 
1129			    call malloc_internal ; Call internal malloc function 
1129			    pop af             ; Restore AF register 
1129			if DEBUG_FORTH_MALLOC_HIGH 
1129			call malloc_guard_exit 
1129			call malloc_guard_zerolen 
1129			endif 
1129			    ret                ; Return 
1129			 
1129			; Free Function: 
1129			; Input: 
1129			;   HL: Pointer to memory block to free 
1129			; Output: 
1129			;   None 
1129			 
1129			free: 
1129			    push af            ; Save AF register 
1129			    ld a, l            ; Load low byte of pointer into A 
1129			    or h               ; Check if pointer is NULL 
1129			    jp z, free_exit    ; If pointer is NULL, exit 
1129			 
1129			    ; Free memory 
1129			    ld hl, (heap_start) ; Load start of heap into HL 
1129			    call free_internal  ; Call internal free function 
1129			    pop af             ; Restore AF register 
1129			    ret                ; Return 
1129			 
1129			; Internal Malloc Function: 
1129			; Input: 
1129			;   HL: Size of block to allocate 
1129			; Output: 
1129			;   HL: Pointer to allocated memory block (NULL if allocation fails) 
1129			 
1129			malloc_internal: 
1129			    ld bc, 2           ; Number of bytes to allocate for management overhead 
1129			    add hl, bc         ; Add management overhead to requested size 
1129			    ex de, hl          ; Save total size in DE, and keep it in HL 
1129					if DEBUG_FORTH_MALLOC 
1129						DMARK "ma2" 
1129						CALLMONITOR 
1129					endif 
1129			 
1129			    ; Search for free memory block 
1129			    ld de, (heap_end)  ; Load end of heap into DE 
1129			    ld bc, 0           ; Initialize counter 
1129			 
1129					if DEBUG_FORTH_MALLOC 
1129						DMARK "ma2" 
1129						CALLMONITOR 
1129					endif 
1129			malloc_search_loop: 
1129			    ; Check if current block is free 
1129			    ld a, (hl)         ; Load current block's status (free or used) 
1129			    cp 0               ; Compare with zero (free) 
1129			    jr nz, malloc_skip_block_check  ; If not free, skip to the next block 
1129			 
1129			    ; Check if current block is large enough 
1129			    ld a, (hl+1)       ; Load high byte of block size 
1129			    cp l               ; Compare with low byte of requested size 
1129			    jr nz, malloc_skip_block_check  ; If not large enough, skip to the next block 
1129			 
1129			    ld a, (hl+2)       ; Load low byte of block size 
1129			    cp h               ; Compare with high byte of requested size 
1129			    jr c, malloc_skip_block_check   ; If not large enough, skip to the next block 
1129			 
1129			    ; Mark block as used 
1129			    ld (hl), 0xFF      ; Set status byte to indicate used block 
1129			 
1129			    ; Calculate remaining space in block 
1129			    ld bc, 0           ; Clear BC 
1129			    add hl, bc         ; Increment HL to point to start of data block 
1129			    add hl, de         ; HL = HL + DE (total size) 
1129			    ld bc, 1           ; Number of bytes to allocate for management overhead 
1129			    add hl, bc         ; Add management overhead to start of data block 
1129			 
1129			    ; Save pointer to allocated block in HL 
1129			if DEBUG_FORTH_MALLOC_HIGH 
1129						DMARK "ma5" 
1129			call malloc_guard_exit 
1129			call malloc_guard_zerolen 
1129			endif 
1129			    ret 
1129			 
1129			malloc_skip_block_check: 
1129			    ; Move to the next block 
1129			    ld bc, 3           ; Size of management overhead 
1129			    add hl, bc         ; Move to the next block 
1129			    inc de             ; Increment counter 
1129			 
1129			    ; Check if we have reached the end of heap 
1129			    ld a, e            ; Load low byte of heap end address 
1129			    cp (hl)            ; Compare with low byte of current address 
1129			    jr nz, malloc_search_loop  ; If not equal, continue searching 
1129			    ld a, d            ; Load high byte of heap end address 
1129			    cp 0               ; Check if it's zero (end of memory) 
1129			    jr nz, malloc_search_loop  ; If not zero, continue searching 
1129			 
1129			    ; If we reached here, allocation failed 
1129			    xor a              ; Set result to NULL 
1129			if DEBUG_FORTH_MALLOC_HIGH 
1129						DMARK "ma6" 
1129			call malloc_guard_exit 
1129			call malloc_guard_zerolen 
1129			endif 
1129			    ret 
1129			malloc_exit: 
1129			if DEBUG_FORTH_MALLOC_HIGH 
1129						DMARK "ma7" 
1129			call malloc_guard_exit 
1129			call malloc_guard_zerolen 
1129			endif 
1129			    ret 
1129			 
1129			; Internal Free Function: 
1129			; Input: 
1129			;   HL: Pointer to memory block to free 
1129			; Output: 
1129			;   None 
1129			 
1129			free_internal: 
1129			    ld de, (heap_start) ; Load start of heap into DE 
1129			    ld bc, 0            ; Initialize counter 
1129			 
1129			free_search_loop: 
1129			    ; Check if current block contains the pointer 
1129			    ld a, l             ; Load low byte of pointer 
1129			    cp (hl+1)           ; Compare with high byte of current block's address 
1129			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1129			    ld a, h             ; Load high byte of pointer 
1129			    cp (hl+2)           ; Compare with low byte of current block's address 
1129			    jr nz, free_skip_block_check  ; If not equal, skip to the next block 
1129			 
1129			    ; Mark block as free 
1129			    ld (hl), 0          ; Set status byte to indicate free block 
1129			    ret                 ; Return 
1129			 
1129			free_skip_block_check: 
1129			    ; Move to the next block 
1129			    ld bc, 3            ; Size of management overhead 
1129			    add hl, bc          ; Move to the next block 
1129			    inc de              ; Increment counter 
1129			 
1129			    ; Check if we have reached the end of heap 
1129			    ld a, e             ; Load low byte of heap end address 
1129			    cp (hl)             ; Compare with low byte of current address 
1129			    jr nz, free_search_loop  ; If not equal, continue searching 
1129			    ld a, d             ; Load high byte of heap end address 
1129			    cp 0                ; Check if it's zero (end of memory) 
1129			    jr nz, free_search_loop  ; If not zero, continue searching 
1129			 
1129			    ; If we reached here, pointer is not found in heap 
1129			    ret 
1129			 
1129			free_exit: 
1129			    ret                 ; Return 
1129			 
1129			; Define heap start and end addresses 
1129			;heap_start:    .dw 0xC000   ; Start of heap 
1129			;heap_end:      .dw 0xE000   ; End of heap 
1129			 
1129			endif 
1129			 
1129			 
1129			if MALLOC_1 
1129			 
1129			 
1129			 
1129			; from https://gist.github.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca 
1129			 
1129			;moved to firmware.asm 
1129			;heap_start        .equ  0x9000      ; Starting address of heap 
1129			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
1129			 
1129			;      .org 0 
1129			;      jp    main 
1129			 
1129			 
1129			;      .org  0x100 
1129			;main: 
1129			;      ld    HL, 0x8100 
1129			;      ld    SP, HL 
1129			; 
1129			;      call  heap_init 
1129			; 
1129			;      ; Make some allocations 
1129			;      ld    HL, 12 
1129			;      call  malloc            ; Allocates 0x9004 
1129			; 
1129			;      ld    HL, 12 
1129			;      call  malloc            ; Allocates 0x9014 
1129			; 
1129			;      ld    HL, 12 
1129			;      call  malloc            ; Allocates 0x9024 
1129			; 
1129			;      ; Free some allocations 
1129			;      ld    HL, 0x9014 
1129			;      call  free 
1129			; 
1129			;      ld    HL, 0x9004 
1129			;      call  free 
1129			; 
1129			;      ld    HL, 0x9024 
1129			;      call  free 
1129			; 
1129			; 
1129			;      halt 
1129			 
1129			 
1129			;------------------------------------------------------------------------------ 
1129			;     heap_init                                                               : 
1129			;                                                                             : 
1129			; Description                                                                 : 
1129			;     Initialise the heap and make it ready for malloc and free operations.   : 
1129			;                                                                             : 
1129			;     The heap is maintained as a linked list, starting with an initial       : 
1129			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
1129			;     the first free block in the heap. Each block then points to the next    : 
1129			;     free block within the heap, and the free list ends at the first block   : 
1129			;     with a null pointer to the next free block.                             : 
1129			;                                                                             : 
1129			; Parameters                                                                  : 
1129			;     Inputs are compile-time only. Two defines which specify the starting    : 
1129			;     address of the heap and its size are required, along with a memory      : 
1129			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
1129			;     principally stores a pointer to the first free block in the heap.       : 
1129			;                                                                             : 
1129			; Returns                                                                     : 
1129			;     Nothing                                                                 : 
1129			;------------------------------------------------------------------------------ 
1129			heap_init: 
1129 e5			      push  HL 
112a			 
112a			      ; Initialise free list struct 
112a 21 5d 5a		      ld    HL, heap_start 
112d 22 58 5a		      ld    (free_list), HL 
1130 21 00 00		      ld    HL, 0 
1133 22 5a 5a		      ld    (free_list+2), HL 
1136			 
1136			      ; Insert first free block at bottom of heap, consumes entire heap 
1136 21 b9 e3		      ld    HL, heap_start+heap_size-4 
1139 22 5d 5a		      ld    (heap_start), HL        ; Next block (end of free list) 
113c 21 5c 89		      ld    HL, heap_size-4 
113f 22 5f 5a		      ld    (heap_start+2), HL      ; Block size 
1142			 
1142			      ; Insert end of free list block at top of heap - two null words will 
1142			      ; terminate the free list 
1142 21 00 00		      ld    HL, 0 
1145 22 bb e3		      ld    (heap_start+heap_size-2), HL 
1148 22 b9 e3		      ld    (heap_start+heap_size-4), HL 
114b			 
114b e1			      pop   HL 
114c			 
114c c9			      ret 
114d			 
114d			 
114d			;------------------------------------------------------------------------------ 
114d			;     malloc                                                                  : 
114d			;                                                                             : 
114d			; Description                                                                 : 
114d			;     Allocates the wanted space from the heap and returns the address of the : 
114d			;     first useable byte of the allocation.                                   : 
114d			;                                                                             : 
114d			;     Allocations can happen in one of two ways:                              : 
114d			;                                                                             : 
114d			;     1. A free block may be found which is the exact size wanted. In this    : 
114d			;        case the block is removed from the free list and retuedn to the      : 
114d			;        caller.                                                              : 
114d			;     2. A free block may be found which is larger than the size wanted. In   : 
114d			;        this case, the larger block is split into two. The first portion of  : 
114d			;        this block will become the requested space by the malloc call and    : 
114d			;        is returned to the caller. The second portion becomes a new free     : 
114d			;        block, and the free list is adjusted to maintain continuity via this : 
114d			;        newly created block.                                                 : 
114d			;                                                                             : 
114d			;     malloc does not set any initial value in the allocated space, the       : 
114d			;     caller is required to do this as required.                              : 
114d			;                                                                             : 
114d			;     This implementation of malloc uses the stack exclusively, and is        : 
114d			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
114d			;     advisable to disable interrupts before calling malloc, and recommended  : 
114d			;     to avoid the use of malloc inside ISRs in general.                      : 
114d			;                                                                             : 
114d			;     NOTE: heap_init must be called before malloc and free can be used.      : 
114d			;                                                                             : 
114d			; Parameters                                                                  : 
114d			;     HL  Number of bytes wanted                                              : 
114d			;                                                                             : 
114d			; Returns                                                                     : 
114d			;     HL  Address of the first useable byte of the allocation                 : 
114d			;                                                                             : 
114d			; Flags                                                                       : 
114d			;     Z   Set if the allocation did not succeed, clear otherwise              : 
114d			;                                                                             : 
114d			; Stack frame                                                                 : 
114d			;       |             |                                                       : 
114d			;       +-------------+                                                       : 
114d			;       |     BC      |                                                       : 
114d			;       +-------------+                                                       : 
114d			;       |     DE      |                                                       : 
114d			;       +-------------+                                                       : 
114d			;       |     IX      |                                                       : 
114d			;       +-------------+                                                       : 
114d			;       |  prev_free  |                                                       : 
114d			;   +4  +-------------+                                                       : 
114d			;       |  this_free  |                                                       : 
114d			;   +2  +-------------+                                                       : 
114d			;       |  next_free  |                                                       : 
114d			;   +0  +-------------+                                                       : 
114d			;       |             |                                                       : 
114d			;                                                                             : 
114d			;------------------------------------------------------------------------------ 
114d			 
114d			 
114d			;malloc: 
114d			; 
114d			;	SAVESP ON 1 
114d			; 
114d			;	call malloc_code 
114d			; 
114d			;	CHECKSP ON 1 
114d			;	ret 
114d			 
114d			 
114d			malloc: 
114d c5			      push  BC 
114e d5			      push  DE 
114f dd e5		      push  IX 
1151			if DEBUG_FORTH_MALLOC_HIGH 
1151			call malloc_guard_entry 
1151			endif 
1151			 
1151					if DEBUG_FORTH_MALLOC 
1151						DMARK "mal" 
1151						CALLMONITOR 
1151					endif 
1151 7c			      ld    A, H                    ; Exit if no space requested 
1152 b5			      or    L 
1153 ca 12 12		      jp    Z, malloc_early_exit 
1156			 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			; 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			;inc hl 
1156			 
1156			 
1156			 
1156			 
1156					if DEBUG_FORTH_MALLOC 
1156						DMARK "maA" 
1156						CALLMONITOR 
1156					endif 
1156			      ; Set up stack frame 
1156 eb			      ex    DE, HL 
1157 21 fa ff		      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
115a 39			      add   HL, SP 
115b f9			      ld    SP, HL 
115c dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
1160 dd 39		      add   IX, SP 
1162			 
1162			      ; Setup initial state 
1162 21 04 00		      ld    HL, 4                   ; want must also include space used by block struct 
1165 19			      add   HL, DE 
1166			 
1166 44			      ld    B, H                    ; Move want to BC 
1167 4d			      ld    C, L 
1168			 
1168 21 58 5a		      ld    HL, free_list           ; Store prev_free ptr to stack 
116b dd 75 04		      ld    (IX+4), L 
116e dd 74 05		      ld    (IX+5), H 
1171			 
1171 5e			      ld    E, (HL)                 ; Store this_free ptr to stack 
1172 23			      inc   HL 
1173 56			      ld    D, (HL) 
1174 dd 73 02		      ld    (IX+2), E 
1177 dd 72 03		      ld    (IX+3), D 
117a eb			      ex    DE, HL                  ; this_free ptr into HL 
117b			 
117b					if DEBUG_FORTH_MALLOC 
117b						DMARK "maB" 
117b						CALLMONITOR 
117b					endif 
117b			      ; Loop through free block list to find some space 
117b			malloc_find_space: 
117b 5e			      ld    E, (HL)                 ; Load next_free ptr into DE 
117c 23			      inc   HL 
117d 56			      ld    D, (HL) 
117e			 
117e 7a			      ld    A, D                    ; Check for null next_free ptr - end of free list 
117f b3			      or    E 
1180 ca 0c 12		      jp    Z, malloc_no_space 
1183			 
1183 dd 73 00		      ld    (IX+0), E               ; Store next_free ptr to stack 
1186 dd 72 01		      ld    (IX+1), D 
1189			 
1189			      ; Does this block have enough space to make the allocation? 
1189 23			      inc   HL                      ; Load free block size into DE 
118a 5e			      ld    E, (HL) 
118b 23			      inc   HL 
118c 56			      ld    D, (HL) 
118d			 
118d eb			      ex    DE, HL                  ; Check size of block against want 
118e b7			      or    A                       ; Ensure carry flag clear 
118f ed 42		      sbc   HL, BC 
1191 e5			      push  HL                      ; Store the result for later (new block size) 
1192			 
1192 ca e1 11		      jp   Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
1195 30 1b		      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
1197			 
1197			      ; this_free block is not big enough, setup ptrs to test next free block 
1197 e1			      pop   HL                      ; Discard previous result 
1198			 
1198 dd 6e 02		      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
119b dd 66 03		      ld    H, (IX+3) 
119e dd 75 04		      ld    (IX+4), L 
11a1 dd 74 05		      ld    (IX+5), H 
11a4			 
11a4 dd 6e 00		      ld    L, (IX+0)               ; Move next_free ptr into this_free 
11a7 dd 66 01		      ld    H, (IX+1) 
11aa dd 75 02		      ld    (IX+2), L 
11ad dd 74 03		      ld    (IX+3), H 
11b0			 
11b0					if DEBUG_FORTH_MALLOC 
11b0						DMARK "MA>" 
11b0						CALLMONITOR 
11b0					endif 
11b0 18 c9		      jr    malloc_find_space 
11b2			 
11b2			      ; split a bigger block into two - requested size and remaining size 
11b2			malloc_alloc_split: 
11b2					if DEBUG_FORTH_MALLOC 
11b2						DMARK "MAs" 
11b2						CALLMONITOR 
11b2					endif 
11b2 eb			      ex    DE, HL                  ; Calculate address of new free block 
11b3 2b			      dec   HL 
11b4 2b			      dec   HL 
11b5 2b			      dec   HL 
11b6 09			      add   HL, BC 
11b7			 
11b7			      ; Create a new block and point it at next_free 
11b7 dd 5e 00		      ld    E, (IX+0)               ; Load next_free ptr into DE 
11ba dd 56 01		      ld    D, (IX+1) 
11bd			 
11bd 73			      ld    (HL), E                 ; Store next_free ptr into new block 
11be 23			      inc   HL 
11bf 72			      ld    (HL), D 
11c0			 
11c0 d1			      pop   DE                      ; Store size of new block into new block 
11c1 23			      inc   HL 
11c2 73			      ld    (HL), E 
11c3 23			      inc   HL 
11c4 72			      ld    (HL), D 
11c5			 
11c5			      ; Update this_free ptr to point to new block 
11c5 2b			      dec   HL 
11c6 2b			      dec   HL 
11c7 2b			      dec   HL 
11c8			 
11c8 dd 5e 02		      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
11cb dd 56 03		      ld    D, (IX+3) 
11ce			 
11ce dd 75 02		      ld    (IX+2), L               ; Store new block addr as this_free ptr 
11d1 dd 74 03		      ld    (IX+3), H 
11d4			 
11d4			      ; Modify this_free block to be allocation 
11d4 eb			      ex    DE, HL 
11d5 af			      xor   A                       ; Null the next block ptr of allocated block 
11d6 77			      ld    (HL), A 
11d7 23			      inc   HL 
11d8 77			      ld    (HL), A 
11d9			 
11d9 23			      inc   HL                      ; Store want size into allocated block 
11da 71			      ld    (HL), C 
11db 23			      inc   HL 
11dc 70			      ld    (HL), B 
11dd 23			      inc   HL 
11de e5			      push  HL                      ; Address of allocation to return 
11df			 
11df 18 19		      jr    malloc_update_links 
11e1			 
11e1			malloc_alloc_fit: 
11e1 e1			      pop   HL                      ; Dont need new block size, want is exact fit 
11e2			 
11e2					if DEBUG_FORTH_MALLOC 
11e2						DMARK "MAf" 
11e2						CALLMONITOR 
11e2					endif 
11e2			      ; Modify this_free block to be allocation 
11e2 eb			      ex    DE, HL 
11e3 2b			      dec   HL 
11e4 2b			      dec   HL 
11e5 2b			      dec   HL 
11e6			 
11e6 af			      xor   A                       ; Null the next block ptr of allocated block 
11e7 77			      ld    (HL), A 
11e8 23			      inc   HL 
11e9 77			      ld    (HL), A 
11ea			 
11ea 23			      inc   HL                      ; Store address of allocation to return 
11eb 23			      inc   HL 
11ec 23			      inc   HL 
11ed e5			      push  HL 
11ee			 
11ee			      ; Copy next_free ptr to this_free, remove allocated block from free list 
11ee dd 6e 00		      ld    L, (IX+0)               ; next_free to HL 
11f1 dd 66 01		      ld    H, (IX+1) 
11f4			 
11f4 dd 75 02		      ld    (IX+2), L               ; HL to this_free 
11f7 dd 74 03		      ld    (IX+3), H 
11fa			 
11fa			 
11fa			malloc_update_links: 
11fa			      ; Update prev_free ptr to point to this_free 
11fa dd 6e 04		      ld    L, (IX+4)               ; prev_free ptr to HL 
11fd dd 66 05		      ld    H, (IX+5) 
1200			 
1200 dd 5e 02		      ld    E, (IX+2)               ; this_free ptr to DE 
1203 dd 56 03		      ld    D, (IX+3) 
1206			 
1206 73			      ld    (HL), E                 ; this_free ptr into prev_free 
1207 23			      inc   HL 
1208 72			      ld    (HL), D 
1209			 
1209					if DEBUG_FORTH_MALLOC 
1209						DMARK "Mul" 
1209						CALLMONITOR 
1209					endif 
1209			      ; Clear the Z flag to indicate successful allocation 
1209 7a			      ld    A, D 
120a b3			      or    E 
120b			 
120b d1			      pop   DE                      ; Address of allocation 
120c					if DEBUG_FORTH_MALLOC 
120c						DMARK "MAu" 
120c						CALLMONITOR 
120c					endif 
120c			 
120c			malloc_no_space: 
120c 21 06 00		      ld    HL, 6                   ; Clean up stack frame 
120f 39			      add   HL, SP 
1210 f9			      ld    SP, HL 
1211			 
1211 eb			      ex    DE, HL                  ; Alloc addr into HL for return 
1212					if DEBUG_FORTH_MALLOC 
1212						DMARK "MAN" 
1212						CALLMONITOR 
1212					endif 
1212			 
1212			malloc_early_exit: 
1212					if DEBUG_FORTH_MALLOC 
1212						DMARK "MAx" 
1212						CALLMONITOR 
1212					endif 
1212 dd e1		      pop   IX 
1214 d1			      pop   DE 
1215 c1			      pop   BC 
1216			 
1216			if DEBUG_FORTH_MALLOC_HIGH 
1216			call malloc_guard_exit 
1216			call malloc_guard_zerolen 
1216			endif 
1216 c9			      ret 
1217			 
1217			 
1217			;------------------------------------------------------------------------------ 
1217			;     free                                                                    : 
1217			;                                                                             : 
1217			; Description                                                                 : 
1217			;     Return the space pointed to by HL to the heap. HL must be an address as : 
1217			;     returned by malloc, otherwise the behaviour is undefined.               : 
1217			;                                                                             : 
1217			;     Where possible, directly adjacent free blocks will be merged together   : 
1217			;     into larger blocks to help ensure that the heap does not become         : 
1217			;     excessively fragmented.                                                 : 
1217			;                                                                             : 
1217			;     free does not clear or set any other value into the freed space, and    : 
1217			;     therefore its contents may be visible through subsequent malloc's. The  : 
1217			;     caller should clear the freed space as required.                        : 
1217			;                                                                             : 
1217			;     This implementation of free uses the stack exclusively, and is          : 
1217			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
1217			;     advisable to disable interrupts before calling free, and recommended    : 
1217			;     to avoid the use of free inside ISRs in general.                        : 
1217			;                                                                             : 
1217			;     NOTE: heap_init must be called before malloc and free can be used.      : 
1217			;                                                                             : 
1217			; Parameters                                                                  : 
1217			;     HL  Pointer to address of first byte of allocation to be freed          : 
1217			;                                                                             : 
1217			; Returns                                                                     : 
1217			;     Nothing                                                                 : 
1217			;                                                                             : 
1217			; Stack frame                                                                 : 
1217			;       |             |                                                       : 
1217			;       +-------------+                                                       : 
1217			;       |     BC      |                                                       : 
1217			;       +-------------+                                                       : 
1217			;       |     DE      |                                                       : 
1217			;       +-------------+                                                       : 
1217			;       |     IX      |                                                       : 
1217			;       +-------------+                                                       : 
1217			;       |  prev_free  |                                                       : 
1217			;   +2  +-------------+                                                       : 
1217			;       |  next_free  |                                                       : 
1217			;   +0  +-------------+                                                       : 
1217			;       |             |                                                       : 
1217			;                                                                             : 
1217			;------------------------------------------------------------------------------ 
1217			free: 
1217 c5			      push  BC 
1218 d5			      push  DE 
1219 dd e5		      push  IX 
121b			 
121b 7c			      ld    A, H                    ; Exit if ptr is null 
121c b5			      or    L 
121d ca e1 12		      jp    Z, free_early_exit 
1220			 
1220			      ; Set up stack frame 
1220 eb			      ex    DE, HL 
1221 21 fc ff		      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
1224 39			      add   HL, SP 
1225 f9			      ld    SP, HL 
1226 dd 21 00 00	      ld    IX, 0                   ; Use IX as a frame pointer 
122a dd 39		      add   IX, SP 
122c			 
122c			      ; The address in HL points to the start of the useable allocated space, 
122c			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
122c			      ; address of the block itself. 
122c eb			      ex    DE, HL 
122d 11 fc ff		      ld    DE, -4 
1230 19			      add   HL, DE 
1231			 
1231			      ; An allocated block must have a null next block pointer in it 
1231 7e			      ld    A, (HL) 
1232 23			      inc   HL 
1233 b6			      or    (HL) 
1234 c2 dc 12		      jp    NZ, free_done 
1237			 
1237 2b			      dec   HL 
1238			 
1238 44			      ld    B, H                    ; Copy HL to BC 
1239 4d			      ld    C, L 
123a			 
123a			      ; Loop through the free list to find the first block with an address 
123a			      ; higher than the block being freed 
123a 21 58 5a		      ld    HL, free_list 
123d			 
123d			free_find_higher_block: 
123d 5e			      ld    E, (HL)                 ; Load next ptr from free block 
123e 23			      inc   HL 
123f 56			      ld    D, (HL) 
1240 2b			      dec   HL 
1241			 
1241 dd 73 00		      ld    (IX+0), E               ; Save ptr to next free block 
1244 dd 72 01		      ld    (IX+1), D 
1247 dd 75 02		      ld    (IX+2), L               ; Save ptr to prev free block 
124a dd 74 03		      ld    (IX+3), H 
124d			 
124d 78			      ld    A, B                    ; Check if DE is greater than BC 
124e ba			      cp    D                       ; Compare MSB first 
124f 28 02		      jr    Z, $+4                  ; MSB the same, compare LSB 
1251 30 04		      jr    NC, free_find_higher_block_skip 
1253 79			      ld    A, C 
1254 bb			      cp    E                       ; Then compare LSB 
1255 38 08		      jr    C, free_found_higher_block 
1257			 
1257			free_find_higher_block_skip: 
1257 7a			      ld    A, D                    ; Reached the end of the free list? 
1258 b3			      or    E 
1259 ca dc 12		      jp    Z, free_done 
125c			 
125c eb			      ex    DE, HL 
125d			 
125d 18 de		      jr    free_find_higher_block 
125f			 
125f			free_found_higher_block: 
125f			      ; Insert freed block between prev and next free blocks 
125f 71			      ld    (HL), C                 ; Point prev free block to freed block 
1260 23			      inc   HL 
1261 70			      ld    (HL), B 
1262			 
1262 60			      ld    H, B                    ; Point freed block at next free block 
1263 69			      ld    L, C 
1264 73			      ld    (HL), E 
1265 23			      inc   HL 
1266 72			      ld    (HL), D 
1267			 
1267			      ; Check if the freed block is adjacent to the next free block 
1267 23			      inc   HL                      ; Load size of freed block into HL 
1268 5e			      ld    E, (HL) 
1269 23			      inc   HL 
126a 56			      ld    D, (HL) 
126b eb			      ex    DE, HL 
126c			 
126c 09			      add   HL, BC                  ; Add addr of freed block and its size 
126d			 
126d dd 5e 00		      ld    E, (IX+0)               ; Load addr of next free block into DE 
1270 dd 56 01		      ld    D, (IX+1) 
1273			 
1273 b7			      or    A                       ; Clear the carry flag 
1274 ed 52		      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
1276 20 22		      jr    NZ, free_check_adjacent_to_prev 
1278			 
1278			      ; Freed block is adjacent to next, merge into one bigger block 
1278 eb			      ex    DE, HL                  ; Load next ptr from next block into DE 
1279 5e			      ld    E, (HL) 
127a 23			      inc   HL 
127b 56			      ld    D, (HL) 
127c e5			      push  HL                      ; Save ptr to next block for later 
127d			 
127d 60			      ld    H, B                    ; Store ptr from next block into freed block 
127e 69			      ld    L, C 
127f 73			      ld    (HL), E 
1280 23			      inc   HL 
1281 72			      ld    (HL), D 
1282			 
1282 e1			      pop   HL                      ; Restore ptr to next block 
1283 23			      inc   HL                      ; Load size of next block into DE 
1284 5e			      ld    E, (HL) 
1285 23			      inc   HL 
1286 56			      ld    D, (HL) 
1287 d5			      push  DE                      ; Save next block size for later 
1288			 
1288 60			      ld    H, B                    ; Load size of freed block into HL 
1289 69			      ld    L, C 
128a 23			      inc   HL 
128b 23			      inc   HL 
128c 5e			      ld    E, (HL) 
128d 23			      inc   HL 
128e 56			      ld    D, (HL) 
128f eb			      ex    DE, HL 
1290			 
1290 d1			      pop   DE                      ; Restore size of next block 
1291 19			      add   HL, DE                  ; Add sizes of both blocks 
1292 eb			      ex    DE, HL 
1293			 
1293 60			      ld    H, B                    ; Store new bigger size into freed block 
1294 69			      ld    L, C 
1295 23			      inc   HL 
1296 23			      inc   HL 
1297 73			      ld    (HL), E 
1298 23			      inc   HL 
1299 72			      ld    (HL), D 
129a			 
129a			free_check_adjacent_to_prev: 
129a			      ; Check if the freed block is adjacent to the prev free block 
129a dd 6e 02		      ld    L, (IX+2)               ; Prev free block ptr into HL 
129d dd 66 03		      ld    H, (IX+3) 
12a0			 
12a0 23			      inc   HL                      ; Size of prev free block into DE 
12a1 23			      inc   HL 
12a2 5e			      ld    E, (HL) 
12a3 23			      inc   HL 
12a4 56			      ld    D, (HL) 
12a5 2b			      dec   HL 
12a6 2b			      dec   HL 
12a7 2b			      dec   HL 
12a8			 
12a8 19			      add   HL, DE                  ; Add prev block addr and size 
12a9			 
12a9 b7			      or    A                       ; Clear the carry flag 
12aa ed 42		      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12ac 20 2e		      jr    NZ, free_done 
12ae			 
12ae			      ; Freed block is adjacent to prev, merge into one bigger block 
12ae 60			      ld    H, B                    ; Load next ptr from freed block into DE 
12af 69			      ld    L, C 
12b0 5e			      ld    E, (HL) 
12b1 23			      inc   HL 
12b2 56			      ld    D, (HL) 
12b3 e5			      push  HL                      ; Save freed block ptr for later 
12b4			 
12b4 dd 6e 02		      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12b7 dd 66 03		      ld    H, (IX+3) 
12ba 73			      ld    (HL), E 
12bb 23			      inc   HL 
12bc 72			      ld    (HL), D 
12bd			 
12bd e1			      pop   HL                      ; Restore freed block ptr 
12be 23			      inc   HL                      ; Load size of freed block into DE 
12bf 5e			      ld    E, (HL) 
12c0 23			      inc   HL 
12c1 56			      ld    D, (HL) 
12c2 d5			      push  DE                      ; Save freed block size for later 
12c3			 
12c3 dd 6e 02		      ld    L, (IX+2)               ; Load size of prev block into DE 
12c6 dd 66 03		      ld    H, (IX+3) 
12c9 23			      inc   HL 
12ca 23			      inc   HL 
12cb 5e			      ld    E, (HL) 
12cc 23			      inc   HL 
12cd 56			      ld    D, (HL) 
12ce			 
12ce e1			      pop   HL                      ; Add sizes of both blocks 
12cf 19			      add   HL, DE 
12d0 eb			      ex    DE, HL 
12d1			 
12d1 dd 6e 02		      ld    L, (IX+2)               ; Store new bigger size into prev block 
12d4 dd 66 03		      ld    H, (IX+3) 
12d7 23			      inc   HL 
12d8 23			      inc   HL 
12d9 73			      ld    (HL), E 
12da 23			      inc   HL 
12db 72			      ld    (HL), D 
12dc			 
12dc			free_done: 
12dc 21 04 00		      ld    HL, 4                   ; Clean up stack frame 
12df 39			      add   HL, SP 
12e0 f9			      ld    SP, HL 
12e1			 
12e1			free_early_exit: 
12e1 dd e1		      pop   IX 
12e3 d1			      pop   DE 
12e4 c1			      pop   BC 
12e5			 
12e5 c9			      ret 
12e6			 
12e6			; moved to firmware.asm 
12e6			; 
12e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
12e6			;                  .dw   0 
12e6			 
12e6			 
12e6			endif 
12e6			 
12e6			 
12e6			if MALLOC_3 
12e6			; https://gist.githubusercontent.com/tomstorey/947a8b084bad69391a4b2a1c5b6d69ca/raw/5a08fb30a480d98c0deb4a6afe2d48961cc8e9d9/z80_malloc.s 
12e6			;heap_start        .equ  0x9000      ; Starting address of heap 
12e6			;heap_size         .equ  0x0100      ; Number of bytes available in heap 
12e6			; 
12e6			 ;     .org 0 
12e6			  ;    jp    main 
12e6			; 
12e6			; 
12e6			 ;     .org  0x100 
12e6			;main: 
12e6			 ;     ld    HL, 0x8100 
12e6			  ;    ld    SP, HL 
12e6			; 
12e6			;      call  heap_init 
12e6			 
12e6			      ; Make some allocations 
12e6			;      ld    HL, 12 
12e6			;      call  malloc            ; Allocates 0x9004 
12e6			; 
12e6			 ;     ld    HL, 12 
12e6			;      call  malloc            ; Allocates 0x9014 
12e6			 
12e6			;      ld    HL, 12 
12e6			;      call  malloc            ; Allocates 0x9024 
12e6			 
12e6			      ; Free some allocations 
12e6			;      ld    HL, 0x9014 
12e6			;      call  free 
12e6			 
12e6			;      ld    HL, 0x9004 
12e6			;      call  free 
12e6			; 
12e6			;      ld    HL, 0x9024 
12e6			;      call  free 
12e6			 
12e6			 
12e6			 ;     halt 
12e6			 
12e6			 
12e6			;------------------------------------------------------------------------------ 
12e6			;     heap_init                                                               : 
12e6			;                                                                             : 
12e6			; Description                                                                 : 
12e6			;     Initialise the heap and make it ready for malloc and free operations.   : 
12e6			;                                                                             : 
12e6			;     The heap is maintained as a linked list, starting with an initial       : 
12e6			;     "dummy block" of zero size which is mainly used to hold a pointer to    : 
12e6			;     the first free block in the heap. Each block then points to the next    : 
12e6			;     free block within the heap, and the free list ends at the first block   : 
12e6			;     with a null pointer to the next free block.                             : 
12e6			;                                                                             : 
12e6			; Parameters                                                                  : 
12e6			;     Inputs are compile-time only. Two defines which specify the starting    : 
12e6			;     address of the heap and its size are required, along with a memory      : 
12e6			;     allocation of 4 consecutive bytes which is used for a dummy block which : 
12e6			;     principally stores a pointer to the first free block in the heap.       : 
12e6			;                                                                             : 
12e6			; Returns                                                                     : 
12e6			;     Nothing                                                                 : 
12e6			;------------------------------------------------------------------------------ 
12e6			heap_init: 
12e6			      push  HL 
12e6			 
12e6			      ; Initialise free list struct 
12e6			      ld    HL, heap_start 
12e6			      ld    (free_list), HL 
12e6			      ld    HL, 0 
12e6			      ld    (free_list+2), HL 
12e6			 
12e6			      ; Insert first free block at bottom of heap, consumes entire heap 
12e6			      ld    HL, heap_start+heap_size-4 
12e6			      ld    (heap_start), HL        ; Next block (end of free list) 
12e6			      ld    HL, heap_size-4 
12e6			      ld    (heap_start+2), HL      ; Block size 
12e6			 
12e6			      ; Insert end of free list block at top of heap - two null words will 
12e6			      ; terminate the free list 
12e6			      ld    HL, 0 
12e6			      ld    (heap_start+heap_size-2), HL 
12e6			      ld    (heap_start+heap_size-4), HL 
12e6			 
12e6			      pop   HL 
12e6			 
12e6			      ret 
12e6			 
12e6			 
12e6			;------------------------------------------------------------------------------ 
12e6			;     malloc                                                                  : 
12e6			;                                                                             : 
12e6			; Description                                                                 : 
12e6			;     Allocates the wanted space from the heap and returns the address of the : 
12e6			;     first useable byte of the allocation.                                   : 
12e6			;                                                                             : 
12e6			;     Allocations can happen in one of two ways:                              : 
12e6			;                                                                             : 
12e6			;     1. A free block may be found which is the exact size wanted. In this    : 
12e6			;        case the block is removed from the free list and retuedn to the      : 
12e6			;        caller.                                                              : 
12e6			;     2. A free block may be found which is larger than the size wanted. In   : 
12e6			;        this case, the larger block is split into two. The first portion of  : 
12e6			;        this block will become the requested space by the malloc call and    : 
12e6			;        is returned to the caller. The second portion becomes a new free     : 
12e6			;        block, and the free list is adjusted to maintain continuity via this : 
12e6			;        newly created block.                                                 : 
12e6			;                                                                             : 
12e6			;     malloc does not set any initial value in the allocated space, the       : 
12e6			;     caller is required to do this as required.                              : 
12e6			;                                                                             : 
12e6			;     This implementation of malloc uses the stack exclusively, and is        : 
12e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12e6			;     advisable to disable interrupts before calling malloc, and recommended  : 
12e6			;     to avoid the use of malloc inside ISRs in general.                      : 
12e6			;                                                                             : 
12e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12e6			;                                                                             : 
12e6			; Parameters                                                                  : 
12e6			;     HL  Number of bytes wanted                                              : 
12e6			;                                                                             : 
12e6			; Returns                                                                     : 
12e6			;     HL  Address of the first useable byte of the allocation                 : 
12e6			;                                                                             : 
12e6			; Flags                                                                       : 
12e6			;     Z   Set if the allocation did not succeed, clear otherwise              : 
12e6			;                                                                             : 
12e6			; Stack frame                                                                 : 
12e6			;       |             |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |     BC      |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |     DE      |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |     IX      |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |  prev_free  |                                                       : 
12e6			;   +4  +-------------+                                                       : 
12e6			;       |  this_free  |                                                       : 
12e6			;   +2  +-------------+                                                       : 
12e6			;       |  next_free  |                                                       : 
12e6			;   +0  +-------------+                                                       : 
12e6			;       |             |                                                       : 
12e6			;                                                                             : 
12e6			;------------------------------------------------------------------------------ 
12e6			malloc: 
12e6			      push  BC 
12e6			      push  DE 
12e6			      push  IX 
12e6			 
12e6			      ld    A, H                    ; Exit if no space requested 
12e6			      or    L 
12e6			      jp    Z, malloc_early_exit 
12e6			 
12e6			      ; Set up stack frame 
12e6			      ex    DE, HL 
12e6			      ld    HL, -6                  ; Reserve 6 bytes for stack frame 
12e6			      add   HL, SP 
12e6			      ld    SP, HL 
12e6			      ld    IX, 0                   ; Use IX as a frame pointer 
12e6			      add   IX, SP 
12e6			 
12e6			      ; Setup initial state 
12e6			      ld    HL, 4                   ; want must also include space used by block struct 
12e6			      add   HL, DE 
12e6			 
12e6			      ld    B, H                    ; Move want to BC 
12e6			      ld    C, L 
12e6			 
12e6			      ld    HL, free_list           ; Store prev_free ptr to stack 
12e6			      ld    (IX+4), L 
12e6			      ld    (IX+5), H 
12e6			 
12e6			      ld    E, (HL)                 ; Store this_free ptr to stack 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      ld    (IX+2), E 
12e6			      ld    (IX+3), D 
12e6			      ex    DE, HL                  ; this_free ptr into HL 
12e6			 
12e6			      ; Loop through free block list to find some space 
12e6			malloc_find_space: 
12e6			      ld    E, (HL)                 ; Load next_free ptr into DE 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			 
12e6			      ld    A, D                    ; Check for null next_free ptr - end of free list 
12e6			      or    E 
12e6			      jp    Z, malloc_no_space 
12e6			 
12e6			      ld    (IX+0), E               ; Store next_free ptr to stack 
12e6			      ld    (IX+1), D 
12e6			 
12e6			      ; Does this block have enough space to make the allocation? 
12e6			      inc   HL                      ; Load free block size into DE 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			 
12e6			      ex    DE, HL                  ; Check size of block against want 
12e6			      or    A                       ; Ensure carry flag clear 
12e6			      sbc   HL, BC 
12e6			      push  HL                      ; Store the result for later (new block size) 
12e6			 
12e6			      jr    Z, malloc_alloc_fit     ; Z means block size matches want - can allocate 
12e6			      jr    NC, malloc_alloc_split  ; NC means block is bigger than want - can allocate 
12e6			 
12e6			      ; this_free block is not big enough, setup ptrs to test next free block 
12e6			      pop   HL                      ; Discard previous result 
12e6			 
12e6			      ld    L, (IX+2)               ; Move this_free ptr into prev_free 
12e6			      ld    H, (IX+3) 
12e6			      ld    (IX+4), L 
12e6			      ld    (IX+5), H 
12e6			 
12e6			      ld    L, (IX+0)               ; Move next_free ptr into this_free 
12e6			      ld    H, (IX+1) 
12e6			      ld    (IX+2), L 
12e6			      ld    (IX+3), H 
12e6			 
12e6			      jr    malloc_find_space 
12e6			 
12e6			      ; split a bigger block into two - requested size and remaining size 
12e6			malloc_alloc_split: 
12e6			      ex    DE, HL                  ; Calculate address of new free block 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			      add   HL, BC 
12e6			 
12e6			      ; Create a new block and point it at next_free 
12e6			      ld    E, (IX+0)               ; Load next_free ptr into DE 
12e6			      ld    D, (IX+1) 
12e6			 
12e6			      ld    (HL), E                 ; Store next_free ptr into new block 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			      pop   DE                      ; Store size of new block into new block 
12e6			      inc   HL 
12e6			      ld    (HL), E 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			      ; Update this_free ptr to point to new block 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			 
12e6			      ld    E, (IX+2)               ; Take a copy of current this_free ptr 
12e6			      ld    D, (IX+3) 
12e6			 
12e6			      ld    (IX+2), L               ; Store new block addr as this_free ptr 
12e6			      ld    (IX+3), H 
12e6			 
12e6			      ; Modify this_free block to be allocation 
12e6			      ex    DE, HL 
12e6			      xor   A                       ; Null the next block ptr of allocated block 
12e6			      ld    (HL), A 
12e6			      inc   HL 
12e6			      ld    (HL), A 
12e6			 
12e6			      inc   HL                      ; Store want size into allocated block 
12e6			      ld    (HL), C 
12e6			      inc   HL 
12e6			      ld    (HL), B 
12e6			      inc   HL 
12e6			      push  HL                      ; Address of allocation to return 
12e6			 
12e6			      jr    malloc_update_links 
12e6			 
12e6			malloc_alloc_fit: 
12e6			      pop   HL                      ; Dont need new block size, want is exact fit 
12e6			 
12e6			      ; Modify this_free block to be allocation 
12e6			      ex    DE, HL 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			 
12e6			      xor   A                       ; Null the next block ptr of allocated block 
12e6			      ld    (HL), A 
12e6			      inc   HL 
12e6			      ld    (HL), A 
12e6			 
12e6			      inc   HL                      ; Store address of allocation to return 
12e6			      inc   HL 
12e6			      inc   HL 
12e6			      push  HL 
12e6			 
12e6			      ; Copy next_free ptr to this_free, remove allocated block from free list 
12e6			      ld    L, (IX+0)               ; next_free to HL 
12e6			      ld    H, (IX+1) 
12e6			 
12e6			      ld    (IX+2), L               ; HL to this_free 
12e6			      ld    (IX+3), H 
12e6			 
12e6			 
12e6			malloc_update_links: 
12e6			      ; Update prev_free ptr to point to this_free 
12e6			      ld    L, (IX+4)               ; prev_free ptr to HL 
12e6			      ld    H, (IX+5) 
12e6			 
12e6			      ld    E, (IX+2)               ; this_free ptr to DE 
12e6			      ld    D, (IX+3) 
12e6			 
12e6			      ld    (HL), E                 ; this_free ptr into prev_free 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			      ; Clear the Z flag to indicate successful allocation 
12e6			      ld    A, D 
12e6			      or    E 
12e6			 
12e6			      pop   DE                      ; Address of allocation 
12e6			 
12e6			malloc_no_space: 
12e6			      ld    HL, 6                   ; Clean up stack frame 
12e6			      add   HL, SP 
12e6			      ld    SP, HL 
12e6			 
12e6			      ex    DE, HL                  ; Alloc addr into HL for return 
12e6			 
12e6			malloc_early_exit: 
12e6			      pop   IX 
12e6			      pop   DE 
12e6			      pop   BC 
12e6			 
12e6			      ret 
12e6			 
12e6			 
12e6			;------------------------------------------------------------------------------ 
12e6			;     free                                                                    : 
12e6			;                                                                             : 
12e6			; Description                                                                 : 
12e6			;     Return the space pointed to by HL to the heap. HL must be an address as : 
12e6			;     returned by malloc, otherwise the behaviour is undefined.               : 
12e6			;                                                                             : 
12e6			;     Where possible, directly adjacent free blocks will be merged together   : 
12e6			;     into larger blocks to help ensure that the heap does not become         : 
12e6			;     excessively fragmented.                                                 : 
12e6			;                                                                             : 
12e6			;     free does not clear or set any other value into the freed space, and    : 
12e6			;     therefore its contents may be visible through subsequent malloc's. The  : 
12e6			;     caller should clear the freed space as required.                        : 
12e6			;                                                                             : 
12e6			;     This implementation of free uses the stack exclusively, and is          : 
12e6			;     therefore re-entrant. But due to the Z80's lack of atomicity, it is     : 
12e6			;     advisable to disable interrupts before calling free, and recommended    : 
12e6			;     to avoid the use of free inside ISRs in general.                        : 
12e6			;                                                                             : 
12e6			;     NOTE: heap_init must be called before malloc and free can be used.      : 
12e6			;                                                                             : 
12e6			; Parameters                                                                  : 
12e6			;     HL  Pointer to address of first byte of allocation to be freed          : 
12e6			;                                                                             : 
12e6			; Returns                                                                     : 
12e6			;     Nothing                                                                 : 
12e6			;                                                                             : 
12e6			; Stack frame                                                                 : 
12e6			;       |             |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |     BC      |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |     DE      |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |     IX      |                                                       : 
12e6			;       +-------------+                                                       : 
12e6			;       |  prev_free  |                                                       : 
12e6			;   +2  +-------------+                                                       : 
12e6			;       |  next_free  |                                                       : 
12e6			;   +0  +-------------+                                                       : 
12e6			;       |             |                                                       : 
12e6			;                                                                             : 
12e6			;------------------------------------------------------------------------------ 
12e6			free: 
12e6			      push  BC 
12e6			      push  DE 
12e6			      push  IX 
12e6			 
12e6			      ld    A, H                    ; Exit if ptr is null 
12e6			      or    L 
12e6			      jp    Z, free_early_exit 
12e6			 
12e6			      ; Set up stack frame 
12e6			      ex    DE, HL 
12e6			      ld    HL, -4                  ; Reserve 4 bytes for stack frame 
12e6			      add   HL, SP 
12e6			      ld    SP, HL 
12e6			      ld    IX, 0                   ; Use IX as a frame pointer 
12e6			      add   IX, SP 
12e6			 
12e6			      ; The address in HL points to the start of the useable allocated space, 
12e6			      ; but the block struct starts 4 bytes before this. Sub 4 to get the 
12e6			      ; address of the block itself. 
12e6			      ex    DE, HL 
12e6			      ld    DE, -4 
12e6			      add   HL, DE 
12e6			 
12e6			      ; An allocated block must have a null next block pointer in it 
12e6			      ld    A, (HL) 
12e6			      inc   HL 
12e6			      or    (HL) 
12e6			      jp    NZ, free_done 
12e6			 
12e6			      dec   HL 
12e6			 
12e6			      ld    B, H                    ; Copy HL to BC 
12e6			      ld    C, L 
12e6			 
12e6			      ; Loop through the free list to find the first block with an address 
12e6			      ; higher than the block being freed 
12e6			      ld    HL, free_list 
12e6			 
12e6			free_find_higher_block: 
12e6			      ld    E, (HL)                 ; Load next ptr from free block 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      dec   HL 
12e6			 
12e6			      ld    (IX+0), E               ; Save ptr to next free block 
12e6			      ld    (IX+1), D 
12e6			      ld    (IX+2), L               ; Save ptr to prev free block 
12e6			      ld    (IX+3), H 
12e6			 
12e6			      ld    A, B                    ; Check if DE is greater than BC 
12e6			      cp    D                       ; Compare MSB first 
12e6			      jr    Z, $+4                  ; MSB the same, compare LSB 
12e6			      jr    NC, free_find_higher_block_skip 
12e6			      ld    A, C 
12e6			      cp    E                       ; Then compare LSB 
12e6			      jr    C, free_found_higher_block 
12e6			 
12e6			free_find_higher_block_skip: 
12e6			      ld    A, D                    ; Reached the end of the free list? 
12e6			      or    E 
12e6			      jp    Z, free_done 
12e6			 
12e6			      ex    DE, HL 
12e6			 
12e6			      jr    free_find_higher_block 
12e6			 
12e6			free_found_higher_block: 
12e6			      ; Insert freed block between prev and next free blocks 
12e6			      ld    (HL), C                 ; Point prev free block to freed block 
12e6			      inc   HL 
12e6			      ld    (HL), B 
12e6			 
12e6			      ld    H, B                    ; Point freed block at next free block 
12e6			      ld    L, C 
12e6			      ld    (HL), E 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			      ; Check if the freed block is adjacent to the next free block 
12e6			      inc   HL                      ; Load size of freed block into HL 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      ex    DE, HL 
12e6			 
12e6			      add   HL, BC                  ; Add addr of freed block and its size 
12e6			 
12e6			      ld    E, (IX+0)               ; Load addr of next free block into DE 
12e6			      ld    D, (IX+1) 
12e6			 
12e6			      or    A                       ; Clear the carry flag 
12e6			      sbc   HL, DE                  ; Subtract addrs to compare adjacency 
12e6			      jr    NZ, free_check_adjacent_to_prev 
12e6			 
12e6			      ; Freed block is adjacent to next, merge into one bigger block 
12e6			      ex    DE, HL                  ; Load next ptr from next block into DE 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      push  HL                      ; Save ptr to next block for later 
12e6			 
12e6			      ld    H, B                    ; Store ptr from next block into freed block 
12e6			      ld    L, C 
12e6			      ld    (HL), E 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			      pop   HL                      ; Restore ptr to next block 
12e6			      inc   HL                      ; Load size of next block into DE 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      push  DE                      ; Save next block size for later 
12e6			 
12e6			      ld    H, B                    ; Load size of freed block into HL 
12e6			      ld    L, C 
12e6			      inc   HL 
12e6			      inc   HL 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      ex    DE, HL 
12e6			 
12e6			      pop   DE                      ; Restore size of next block 
12e6			      add   HL, DE                  ; Add sizes of both blocks 
12e6			      ex    DE, HL 
12e6			 
12e6			      ld    H, B                    ; Store new bigger size into freed block 
12e6			      ld    L, C 
12e6			      inc   HL 
12e6			      inc   HL 
12e6			      ld    (HL), E 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			free_check_adjacent_to_prev: 
12e6			      ; Check if the freed block is adjacent to the prev free block 
12e6			      ld    L, (IX+2)               ; Prev free block ptr into HL 
12e6			      ld    H, (IX+3) 
12e6			 
12e6			      inc   HL                      ; Size of prev free block into DE 
12e6			      inc   HL 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			      dec   HL 
12e6			 
12e6			      add   HL, DE                  ; Add prev block addr and size 
12e6			 
12e6			      or    A                       ; Clear the carry flag 
12e6			      sbc   HL, BC                  ; Subtract addrs to compare adjacency 
12e6			      jr    NZ, free_done 
12e6			 
12e6			      ; Freed block is adjacent to prev, merge into one bigger block 
12e6			      ld    H, B                    ; Load next ptr from freed block into DE 
12e6			      ld    L, C 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      push  HL                      ; Save freed block ptr for later 
12e6			 
12e6			      ld    L, (IX+2)               ; Store freed block ptr into prev block 
12e6			      ld    H, (IX+3) 
12e6			      ld    (HL), E 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			      pop   HL                      ; Restore freed block ptr 
12e6			      inc   HL                      ; Load size of freed block into DE 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			      push  DE                      ; Save freed block size for later 
12e6			 
12e6			      ld    L, (IX+2)               ; Load size of prev block into DE 
12e6			      ld    H, (IX+3) 
12e6			      inc   HL 
12e6			      inc   HL 
12e6			      ld    E, (HL) 
12e6			      inc   HL 
12e6			      ld    D, (HL) 
12e6			 
12e6			      pop   HL                      ; Add sizes of both blocks 
12e6			      add   HL, DE 
12e6			      ex    DE, HL 
12e6			 
12e6			      ld    L, (IX+2)               ; Store new bigger size into prev block 
12e6			      ld    H, (IX+3) 
12e6			      inc   HL 
12e6			      inc   HL 
12e6			      ld    (HL), E 
12e6			      inc   HL 
12e6			      ld    (HL), D 
12e6			 
12e6			free_done: 
12e6			      ld    HL, 4                   ; Clean up stack frame 
12e6			      add   HL, SP 
12e6			      ld    SP, HL 
12e6			 
12e6			free_early_exit: 
12e6			      pop   IX 
12e6			      pop   DE 
12e6			      pop   BC 
12e6			 
12e6			      ret 
12e6			 
12e6			 
12e6			;      .org 0x8000 
12e6			; 
12e6			;free_list         .dw   0     ; Block struct for start of free list (MUST be 4 bytes) 
12e6			 ;                 .dw   0 
12e6			 
12e6			endif 
12e6			 
12e6			 
12e6			if MALLOC_4 
12e6			 
12e6			; My memory allocation code. Very very simple.... 
12e6			; allocate space under 250 chars 
12e6			 
12e6			heap_init: 
12e6				; init start of heap as zero 
12e6				;  
12e6			 
12e6				ld hl, heap_start 
12e6				ld a, 0 
12e6				ld (hl), a      ; empty block 
12e6				inc hl 
12e6				ld a, 0 
12e6				ld (hl), a      ; length of block 
12e6				; write end of list 
12e6				inc hl 
12e6				ld a,(hl) 
12e6				inc hl 
12e6				ld a,(hl) 
12e6				 
12e6			 
12e6				; init some malloc vars 
12e6			 
12e6				ld hl, 0 
12e6				ld (free_list), hl       ; store last malloc location 
12e6			 
12e6				ld hl, free_list+3      ; flag for 'free' being used and force a rescan for reuse of block  
12e6				ld a, 0 
12e6				ld (hl), a 
12e6			 
12e6			 
12e6				ld hl, heap_start 
12e6				;  
12e6				  
12e6				ret 
12e6			 
12e6			 
12e6			;    free block marker 
12e6			;    requested size  
12e6			;    pointer to next block 
12e6			;    .... 
12e6			;    next block marker 
12e6			 
12e6			 
12e6			; TODO add a flag that is reset on use of free. if flag is reset then start scan from start of heap otherwise use last location 
12e6			; 
12e6			 
12e6			 
12e6			malloc:  
12e6				push de 
12e6				push bc 
12e6				push af 
12e6			 
12e6				; hl space required 
12e6				 
12e6				ld c, l    ; hold space   (TODO only a max of 255) 
12e6			 
12e6			;	inc c     ; TODO BUG need to fix memory leak on push str 
12e6			;	inc c 
12e6			;	inc c 
12e6			;	inc c 
12e6			;	inc c 
12e6			;	inc c 
12e6			;	inc c 
12e6			 
12e6			 
12e6			 
12e6				; start at heap if a free has been issued so we can reclaim it otherwise continue from last time 
12e6			 
12e6				ld a, (free_list+3) 
12e6				cp 0 
12e6				jr z, .contheap 
12e6			 
12e6				ld hl, (free_list)     ; get last alloc 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "mrs" 
12e6						CALLMONITOR 
12e6					endif 
12e6				jr .startalloc 
12e6			 
12e6			.contheap: 
12e6				ld hl, heap_start 
12e6			 
12e6			.startalloc: 
12e6			 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "mym" 
12e6						CALLMONITOR 
12e6					endif 
12e6			.findblock: 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "mmf" 
12e6						CALLMONITOR 
12e6					endif 
12e6			 
12e6				ld a,(hl)  
12e6				; if byte is zero then clear to use 
12e6			 
12e6				cp 0 
12e6				jr z, .foundemptyblock 
12e6			 
12e6				; if byte is not clear 
12e6				;     then byte is offset to next block 
12e6			 
12e6				inc hl 
12e6				ld a, (hl) ; get size 
12e6			.nextblock:	inc hl 
12e6					ld e, (hl) 
12e6					inc hl 
12e6					ld d, (hl) 
12e6					ex de, hl 
12e6			;	inc hl  ; move past the store space 
12e6			;	inc hl  ; move past zero index  
12e6			 
12e6				; TODO detect no more space 
12e6			 
12e6				push hl 
12e6				ld de, heap_end 
12e6				call cmp16 
12e6				pop hl 
12e6				jr nc, .nospace 
12e6			 
12e6				jr .findblock 
12e6			 
12e6			.nospace: ld hl, 0 
12e6				jp .exit 
12e6			 
12e6			 
12e6			.foundemptyblock:	 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "mme" 
12e6						CALLMONITOR 
12e6					endif 
12e6			 
12e6			; TODO has block enough space if reusing??? 
12e6			 
12e6				;  
12e6			 
12e6			; see if this block has been previously used 
12e6				inc hl 
12e6				ld a, (hl) 
12e6				dec hl 
12e6				cp 0 
12e6				jr z, .newblock 
12e6			 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "meR" 
12e6						CALLMONITOR 
12e6					endif 
12e6			 
12e6			; no reusing previously allocated block 
12e6			 
12e6			; is it smaller than previously used? 
12e6				 
12e6				inc hl    ; move to size 
12e6				ld a, c 
12e6				sub (hl)        ; we want c < (hl) 
12e6				dec hl    ; move back to marker 
12e6			        jr z, .findblock 
12e6			 
12e6				; update with the new size which should be lower 
12e6			 
12e6			        ;inc  hl   ; negate next move. move back to size  
12e6			 
12e6			.newblock: 
12e6				; need to be at marker here 
12e6			 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "meN" 
12e6						CALLMONITOR 
12e6					endif 
12e6			 
12e6			 
12e6				ld a, c 
12e6			 
12e6				ld (free_list+3), a	 ; flag resume from last malloc  
12e6				ld (free_list), hl    ; save out last location 
12e6			 
12e6			 
12e6				;inc a     ; space for length byte 
12e6				ld (hl), a     ; save block in use marker 
12e6			 
12e6				inc hl   ; move to space marker 
12e6				ld (hl), a    ; save new space 
12e6			 
12e6				inc hl   ; move to start of allocated area 
12e6				 
12e6			;	push hl     ; save where we are - 1  
12e6			 
12e6			;	inc hl  ; move past zero index  
12e6				; skip space to set down new marker 
12e6			 
12e6				; provide some extra space for now 
12e6			 
12e6				inc a    ; actual is one fewer than bytes requested. correct if zero index is taken into account 
12e6				inc a 
12e6				inc a 
12e6			 
12e6				push hl   ; save where we are in the node block 
12e6			 
12e6				call addatohl 
12e6			 
12e6				; write linked list point 
12e6			 
12e6				pop de     ; get our node position 
12e6				ex de, hl 
12e6			 
12e6				ld (hl), e 
12e6				inc hl 
12e6				ld (hl), d 
12e6			 
12e6				inc hl 
12e6			 
12e6				; now at start of allocated data so save pointer 
12e6			 
12e6				push hl 
12e6			 
12e6				; jump to position of next node and setup empty header in DE 
12e6			 
12e6				ex de, hl 
12e6			 
12e6			;	inc hl ; move past end of block 
12e6			 
12e6				ld a, 0 
12e6				ld (hl), a   ; empty marker 
12e6				inc hl 
12e6				ld (hl), a   ; size 
12e6				inc hl  
12e6				ld (hl), a   ; ptr 
12e6				inc hl 
12e6				ld (hl), a   ; ptr 
12e6			 
12e6			 
12e6				pop hl 
12e6			 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "mmr" 
12e6						CALLMONITOR 
12e6					endif 
12e6			 
12e6			.exit: 
12e6				pop af 
12e6				pop bc 
12e6				pop de  
12e6				ret 
12e6			 
12e6			 
12e6			 
12e6			 
12e6			free:  
12e6				push hl 
12e6				push af 
12e6				; get address in hl 
12e6			 
12e6					if DEBUG_FORTH_MALLOC_INT 
12e6						DMARK "fre" 
12e6						CALLMONITOR 
12e6					endif 
12e6				; data is at hl - move to block count 
12e6				dec hl 
12e6				dec hl    ; get past pointer 
12e6				dec hl 
12e6			 
12e6				ld a, (hl)    ; need this for a validation check 
12e6			 
12e6				dec hl    ; move to block marker 
12e6			 
12e6				; now check that the block count and block marker are the same  
12e6			        ; this checks that we are on a malloc node and not random memory 
12e6			        ; OK a faint chance this could be a problem but rare - famous last words! 
12e6			 
12e6				ld c, a 
12e6				ld a, (hl)    
12e6			 
12e6				cp c 
12e6				jr nz, .freeignore      ; not a valid malloc node in use so dont break anything 
12e6			 
12e6				; yes good chance we are on a malloc node 
12e6			 
12e6				ld a, 0      
12e6				ld (hl), a   ; mark as free 
12e6			 
12e6				ld (free_list+3), a	 ; flag reuse of existing block on next malloc 
12e6			 
12e6			.freeignore:  
12e6			 
12e6				pop af 
12e6				pop hl 
12e6			 
12e6				ret 
12e6			 
12e6			 
12e6			 
12e6			endif 
12e6			 
12e6			; eof 
# End of file firmware_memory.asm
12e6			  
12e6			; device C  
12e6			if SOUND_ENABLE  
12e6				include "firmware_sound.asm"  
12e6			endif  
12e6			  
12e6			include "firmware_diags.asm"  
12e6			; Hardware diags menu 
12e6			 
12e6			 
12e6			config: 
12e6			 
12e6 3e 00			ld a, 0 
12e8 21 16 13			ld hl, .configmn 
12eb cd 8a 0a			call menu 
12ee			 
12ee fe 00			cp 0 
12f0 c8				ret z 
12f1			 
12f1 fe 01			cp 1 
12f3 cc 44 13			call z, .savetostore 
12f6			 
12f6 fe 02			cp 2 
12f8 cc 30 13			call z, .selautoload 
12fb fe 03			cp 3 
12fd cc 26 13			call z, .disautoload 
1300 fe 04			cp 4 
1302 cc 3a 13			call z, .selbank 
1305 fe 05			cp 5 
1307 cc 4e 13			call z, .debug_tog 
130a fe 06			cp 6 
130c cc 91 14			call z, .bpsgo 
130f fe 07			cp 7 
1311 cc 74 13			call z, hardware_diags 
1314			 
1314 18 d0			jr config 
1316			 
1316			.configmn: 
1316 82 16			dw prom_c3 
1318 99 16			dw prom_c2 
131a ae 16			dw prom_c2a 
131c c4 16			dw prom_c2b 
131e			;	dw prom_c4 
131e e1 16			dw prom_m4 
1320 fc 16			dw prom_m4b 
1322 04 17			dw prom_c1 
1324 00 00			dw 0 
1326				 
1326			 
1326			 
1326			 
1326			.disautoload: 
1326				if STORAGE_SE 
1326				ld a, $fe      ; bit 0 clear 
1326				ld (spi_device), a 
1326			 
1326				call storage_get_block_0 
1326			 
1326				ld a, 0 
1326				ld (store_page+STORE_0_AUTOFILE), a 
1326			 
1326					ld hl, 0 
1326					ld de, store_page 
1326				call storage_write_block	 ; save update 
1326				else 
1326			 
1326 21 13 17			ld hl, prom_notav 
1329 11 29 17			ld de, prom_empty 
132c cd ea 09			call info_panel 
132f				endif 
132f			 
132f			 
132f c9				ret 
1330			 
1330			 
1330			 
1330			; Select auto start 
1330			 
1330			.selautoload: 
1330			 
1330				 
1330				if STORAGE_SE 
1330			 
1330					call config_dir 
1330				        ld hl, scratch 
1330					ld a, 0 
1330					call menu 
1330			 
1330					cp 0 
1330					ret z 
1330			 
1330					dec a 
1330			 
1330			 
1330					; locate menu option 
1330			 
1330					ld hl, scratch 
1330					call table_lookup 
1330			 
1330					if DEBUG_FORTH_WORDS 
1330						DMARK "ALl" 
1330						CALLMONITOR 
1330					endif 
1330					; with the pointer to the menu it, the byte following the zero term is the file id 
1330			 
1330					ld a, 0 
1330					ld bc, 50   ; max of bytes to look at 
1330					cpir  
1330			 
1330					if DEBUG_FORTH_WORDS 
1330						DMARK "ALb" 
1330						CALLMONITOR 
1330					endif 
1330					;inc hl 
1330			 
1330					ld a, (hl)   ; file id 
1330					 
1330				        ; save bank and file ids 
1330			 
1330					push af 
1330			 
1330			; TODO need to save to block 0 on bank 1	 
1330			 
1330					call storage_get_block_0 
1330			 
1330					if DEBUG_FORTH_WORDS 
1330						DMARK "AL0" 
1330						CALLMONITOR 
1330					endif 
1330					pop af 
1330			 
1330					ld (store_page+STORE_0_FILERUN),a 
1330					 
1330					; save bank id 
1330			 
1330					ld a,(spi_device) 
1330					ld (store_page+STORE_0_BANKRUN),a 
1330			 
1330					; enable auto run of store file 
1330			 
1330					ld a, 1 
1330					ld (store_page+STORE_0_AUTOFILE),a 
1330			 
1330					; save buffer 
1330			 
1330					ld hl, 0 
1330					ld de, store_page 
1330					if DEBUG_FORTH_WORDS 
1330						DMARK "ALw" 
1330						CALLMONITOR 
1330					endif 
1330				call storage_write_block	 ; save update 
1330			  
1330			 
1330			 
1330			 
1330					ld hl, scratch 
1330					call config_fdir 
1330			 
1330				else 
1330			 
1330 21 13 17			ld hl, prom_notav 
1333 11 29 17			ld de, prom_empty 
1336 cd ea 09			call info_panel 
1339			 
1339				endif 
1339 c9				ret 
133a			 
133a			 
133a			 
133a			; Select storage bank 
133a			 
133a			.selbank: 
133a			 
133a				if STORAGE_SE 
133a				else 
133a			 
133a 21 13 17			ld hl, prom_notav 
133d 11 29 17			ld de, prom_empty 
1340 cd ea 09			call info_panel 
1343				endif 
1343				 
1343 c9				ret 
1344			 
1344			if STORAGE_SE 
1344			 
1344			.config_ldir:   
1344				; Load storage bank labels into menu array 
1344			 
1344				 
1344			 
1344			 
1344				ret 
1344			 
1344			 
1344			endif 
1344			 
1344			 
1344			; Save user words to storage 
1344			 
1344			.savetostore: 
1344			 
1344				if STORAGE_SE 
1344			 
1344					call config_dir 
1344				        ld hl, scratch 
1344					ld a, 0 
1344					call menu 
1344					 
1344					ld hl, scratch 
1344					call config_fdir 
1344			 
1344				else 
1344			 
1344 21 13 17			ld hl, prom_notav 
1347 11 29 17			ld de, prom_empty 
134a cd ea 09			call info_panel 
134d			 
134d				endif 
134d			 
134d c9				ret 
134e			 
134e			 
134e			 
134e			if STORAGE_SE 
134e			 
134e			config_fdir: 
134e				; using the scratch dir go through and release the memory allocated for each string 
134e				 
134e				ld hl, scratch 
134e			.cfdir:	ld e,(hl) 
134e				inc hl 
134e				ld d,(hl) 
134e				inc hl 
134e			 
134e				ex de, hl 
134e				call ishlzero 
134e				ret z     ; return on null pointer 
134e				call free 
134e				ex de, hl 
134e				jr .cfdir 
134e			 
134e			 
134e				ret 
134e			 
134e			 
134e			config_dir: 
134e			 
134e				; for the config menus that need to build a directory of storage call this routine 
134e				; it will construct a menu in scratch to pass to menu 
134e			 
134e				; open storage device 
134e			 
134e				; execute DIR to build a list of files and their ids into scratch in menu format 
134e				; once the menu has finished then will need to call config_fdir to release the strings 
134e				 
134e				; c = number items 
134e			 
134e				 
134e				call storage_get_block_0 
134e			 
134e				ld hl, store_page     ; get current id count 
134e				ld b, (hl) 
134e				ld c, 0    ; count of files   
134e			 
134e			 
134e				ld hl, scratch 
134e				ld (store_tmp2), hl    ; location to poke strings 
134e			 
134e				; check for empty drive 
134e			 
134e				ld a, 0 
134e				cp b 
134e				jp z, .dirdone 
134e			 
134e				 
134e					if DEBUG_FORTH_WORDS 
134e						DMARK "Cdc" 
134e						CALLMONITOR 
134e					endif 
134e			 
134e			 
134e			.diritem:	 
134e				push bc 
134e				; for each of the current ids do a search for them and if found push to stack 
134e			 
134e					ld hl, STORE_BLOCK_PHY 
134e					ld d, 0		 ; look for extent 0 of block id as this contains file name 
134e					ld e,b 
134e			 
134e					call storage_findnextid 
134e			 
134e			 
134e					; if found hl will be non zero 
134e			 
134e					call ishlzero 
134e					jr z, .dirnotfound 
134e			 
134e					; increase count 
134e			 
134e					pop bc	 
134e					inc c 
134e					push bc 
134e					 
134e			 
134e					; get file header and push the file name 
134e			 
134e					ld de, store_page 
134e					call storage_read_block 
134e			 
134e					; push file id to stack 
134e				 
134e					ld a, (store_page) 
134e					ld h, 0 
134e					ld l, a 
134e			 
134e					;call forth_push_numhl 
134e					; TODO store id 
134e			 
134e					push hl 
134e			 
134e					; push extent count to stack  
134e				 
134e					ld hl, store_page+3 
134e			 
134e					; get file name length 
134e			 
134e					call strlenz   
134e			 
134e					inc hl   ; cover zero term 
134e					inc hl  ; stick the id at the end of the area 
134e			 
134e					push hl 
134e					pop bc    ; move length to bc 
134e			 
134e					call malloc 
134e			 
134e					; TODO save malloc area to scratch 
134e			 
134e					ex de, hl 
134e					ld hl, (store_tmp2) 
134e					ld (hl), e 
134e					inc hl 
134e					ld (hl), d 
134e					inc hl 
134e					ld (store_tmp2), hl 
134e			 
134e					 
134e			 
134e					;pop hl   ; get source 
134e			;		ex de, hl    ; swap aronund	 
134e			 
134e					ld hl, store_page+3 
134e					if DEBUG_FORTH_WORDS 
134e						DMARK "CFd" 
134e						CALLMONITOR 
134e					endif 
134e					ldir 
134e			 
134e					; de is past string, move back one and store id 
134e					 
134e					dec de 
134e			 
134e					; store file id 
134e			 
134e					pop hl 
134e					ex de,hl 
134e					ld (hl), e 
134e			 
134e					if DEBUG_FORTH_WORDS 
134e						DMARK "Cdi" 
134e						CALLMONITOR 
134e					endif 
134e					 
134e			.dirnotfound: 
134e					pop bc     
134e					djnz .diritem 
134e				 
134e			.dirdone:	 
134e			 
134e					ld a, 0 
134e					ld hl, (store_tmp2) 
134e					ld (hl), a 
134e					inc hl 
134e					ld (hl), a 
134e					inc hl 
134e					; push a count of the dir items found 
134e			 
134e			;		ld h, 0 
134e			;		ld l, c 
134e			 
134e				ret 
134e			 
134e			endif 
134e			 
134e			 
134e			; Settings 
134e			; Run  
134e			 
134e			 
134e			 
134e			;hd_menu1:   db "Diags:  1: Key Matrix   5: Sound",0 
134e			;;hd_menu2:   db "        2: Editor",0   
134e			;hd_menu2:   db "        2: Editor       6: Menu",0   
134e			;hd_menu3:   db "        3: Storage",0 
134e			;hd_menu4:   db "0=quit  4: Debug",0 
134e			;hd_don:     db "ON",0 
134e			;hd_doff:     db "OFF",0 
134e			; 
134e			; 
134e			; 
134e			;hardware_diags_old:       
134e			; 
134e			;.diagmenu: 
134e			;	call clear_display 
134e			;	ld a, display_row_1 
134e			;	ld de, hd_menu1 
134e			;	call str_at_display 
134e			; 
134e			;	ld a, display_row_2 
134e			;	ld de, hd_menu2 
134e			;	call str_at_display 
134e			; 
134e			;	ld a, display_row_3 
134e			;	ld de, hd_menu3 
134e			;	call str_at_display 
134e			; 
134e			;	ld a,  display_row_4 
134e			;	ld de, hd_menu4 
134e			;	call str_at_display 
134e			; 
134e			;	; display debug state 
134e			; 
134e			;	ld de, hd_don 
134e			;	ld a, (os_view_disable) 
134e			;	cp 0 
134e			;	jr z, .distog 
134e			;	ld de, hd_doff 
134e			;.distog: ld a, display_row_4+17 
134e			;	call str_at_display 
134e			; 
134e			;	call update_display 
134e			; 
134e			;	call cin_wait 
134e			; 
134e			; 
134e			; 
134e			;	cp '4' 
134e			;	jr nz, .diagn1 
134e			; 
134e			;	; debug toggle 
134e			; 
134e			;	ld a, (os_view_disable) 
134e			;	ld b, '*' 
134e			;	cp 0 
134e			;	jr z, .debtog 
134e			;	ld b, 0 
134e			;.debtog:	 
134e			;	ld a,b 
134e			;	ld (os_view_disable),a 
134e			; 
134e			;.diagn1: cp '0' 
134e			;	 ret z 
134e			; 
134e			;;	cp '1' 
134e			;;       jp z, matrix	 
134e			;;   TODO keyboard matrix test 
134e			; 
134e			;	cp '2' 
134e			;	jp z, .diagedit 
134e			; 
134e			;;	cp '6' 
134e			;;	jp z, .menutest 
134e			;;if ENABLE_BASIC 
134e			;;	cp '6' 
134e			;;	jp z, basic 
134e			;;endif 
134e			 ; 
134e			;	jp .diagmenu 
134e			; 
134e			; 
134e			;	ret 
134e			 
134e			 
134e			.debug_tog: 
134e 21 95 13			ld hl, .menudebug 
1351				 
1351 3a c8 e3			ld a, (os_view_disable) 
1354 fe 2a			cp '*' 
1356 20 04			jr nz,.tdon  
1358 3e 01			ld a, 1 
135a 18 02			jr .tog1 
135c 3e 00		.tdon: ld a, 0 
135e			 
135e			.tog1: 
135e cd 8a 0a			call menu 
1361 fe 00			cp 0 
1363 c8				ret z 
1364 fe 01			cp 1    ; disable debug 
1366 28 04			jr z, .dtog0 
1368 3e 2a			ld a, '*' 
136a 18 02			jr .dtogset 
136c 3e 00		.dtog0: ld a, 0 
136e 32 c8 e3		.dtogset:  ld (os_view_disable), a 
1371 c3 4e 13			jp .debug_tog 
1374			 
1374			 
1374			hardware_diags:       
1374			 
1374			.diagm: 
1374 21 87 13			ld hl, .menuitems 
1377 3e 00			ld a, 0 
1379 cd 8a 0a			call menu 
137c			 
137c fe 00		         cp 0 
137e c8				 ret z 
137f			 
137f fe 02			cp 2 
1381 ca e0 13			jp z, .diagedit 
1384			 
1384			;	cp '6' 
1384			;	jp z, .menutest 
1384			;if ENABLE_BASIC 
1384			;	cp '6' 
1384			;	jp z, basic 
1384			;endif 
1384			  
1384 c3 74 13			jp .diagm 
1387			 
1387				 
1387 9b 13		.menuitems:   	dw .m1 
1389 a6 13				dw .m2 
138b ad 13				dw .m3 
138d b5 13				dw .m5 
138f bb 13				dw .m5a 
1391 c4 13				dw .m5b 
1393 00 00				dw 0 
1395			 
1395			.menudebug: 
1395 cd 13				dw .m6 
1397 d6 13				dw .m7 
1399 00 00				dw 0 
139b			 
139b .. 00		.m1:   db "Key Matrix",0 
13a6 .. 00		.m2:   db "Editor",0 
13ad .. 00		.m3:   db "Storage",0 
13b5 .. 00		.m5:   db "Sound",0 
13bb .. 00		.m5a:  db "RAM Test",0 
13c4 .. 00		.m5b:  db "LCD Test",0 
13cd			 
13cd .. 00		.m6:   db "Debug ON",0 
13d6 .. 00		.m7:   db "Debug OFF",0 
13e0			 
13e0			; debug editor 
13e0			 
13e0			.diagedit: 
13e0			 
13e0 21 d7 e3			ld hl, scratch 
13e3			;	ld bc, 250 
13e3			;	ldir 
13e3				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
13e3 3e 00			ld a, 0 
13e5 77				ld (hl), a 
13e6 23				inc hl 
13e7 77				ld (hl), a 
13e8 23				inc hl 
13e9 77				ld (hl), a 
13ea			 
13ea cd 59 0a		        call clear_display 
13ed cd 7c 0a			call update_display 
13f0				;ld a, 1 
13f0				;ld (hardware_diag), a 
13f0			.diloop: 
13f0 3e 00			ld a, display_row_1 
13f2 0e 00			ld c, 0 
13f4 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
13f6 1e 28			ld e, 40 
13f8			 
13f8 21 d7 e3			ld hl, scratch	 
13fb cd b3 0c			call input_str 
13fe			 
13fe 3e 28			ld a, display_row_2 
1400 11 d7 e3			ld de, scratch 
1403 cd 6c 0a			call str_at_display 
1406 cd 7c 0a			call update_display 
1409			 
1409 c3 f0 13			jp .diloop 
140c			 
140c			 
140c			; pass word in hl 
140c			; a has display location 
140c			display_word_at: 
140c f5				push af 
140d e5				push hl 
140e 7c				ld a,h 
140f 21 dc e6			ld hl, os_word_scratch 
1412 cd 87 0f			call hexout 
1415 e1				pop hl 
1416 7d				ld a,l 
1417 21 de e6			ld hl, os_word_scratch+2 
141a cd 87 0f			call hexout 
141d 21 e0 e6			ld hl, os_word_scratch+4 
1420 3e 00			ld a,0 
1422 77				ld (hl),a 
1423 11 dc e6			ld de,os_word_scratch 
1426 f1				pop af 
1427 cd 6c 0a				call str_at_display 
142a c9				ret 
142b			 
142b			display_ptr_state: 
142b			 
142b				; to restore afterwards 
142b			 
142b d5				push de 
142c c5				push bc 
142d e5				push hl 
142e f5				push af 
142f			 
142f				; for use in here 
142f			 
142f			;	push bc 
142f			;	push de 
142f			;	push hl 
142f			;	push af 
142f			 
142f cd 59 0a			call clear_display 
1432			 
1432 11 05 16			ld de, .ptrstate 
1435 3e 00			ld a, display_row_1 
1437 cd 6c 0a			call str_at_display 
143a			 
143a				; display debug step 
143a			 
143a			 
143a 11 71 ee			ld de, debug_mark 
143d 3e 26			ld a, display_row_1+display_cols-2 
143f cd 6c 0a			call str_at_display 
1442			 
1442				; display a 
1442 11 0f 16			ld de, .ptrcliptr 
1445 3e 28			ld a, display_row_2 
1447 cd 6c 0a			call str_at_display 
144a			 
144a f1				pop af 
144b 2a 22 eb			ld hl,(cli_ptr) 
144e 3e 30			ld a, display_row_2+8 
1450 cd 0c 14			call display_word_at 
1453			 
1453			 
1453				; display hl 
1453			 
1453			 
1453 11 17 16			ld de, .ptrclioptr 
1456 3e 32			ld a, display_row_2+10 
1458 cd 6c 0a			call str_at_display 
145b			; 
145b			;	pop hl 
145b 3e 35			ld a, display_row_2+13 
145d 2a 20 eb			ld hl,(cli_origptr) 
1460 cd 0c 14			call display_word_at 
1463			; 
1463			;	 
1463			;	; display de 
1463			 
1463			;	ld de, .regstatede 
1463			;	ld a, display_row_3 
1463			;	call str_at_display 
1463			 
1463			;	pop de 
1463			;	ld h,d 
1463			;	ld l, e 
1463			;	ld a, display_row_3+3 
1463			;	call display_word_at 
1463			 
1463			 
1463				; display bc 
1463			 
1463			;	ld de, .regstatebc 
1463			;	ld a, display_row_3+10 
1463			;	call str_at_display 
1463			 
1463			;	pop bc 
1463			;	ld h,b 
1463			;	ld l, c 
1463			;	ld a, display_row_3+13 
1463			;	call display_word_at 
1463			 
1463			 
1463				; display dsp 
1463			 
1463			;	ld de, .regstatedsp 
1463			;	ld a, display_row_4 
1463			;	call str_at_display 
1463			 
1463				 
1463			;	ld hl,(cli_data_sp) 
1463			;	ld a, display_row_4+4 
1463			;	call display_word_at 
1463			 
1463				; display rsp 
1463			 
1463 11 46 16			ld de, .regstatersp 
1466 3e 82			ld a, display_row_4+10 
1468 cd 6c 0a			call str_at_display 
146b			 
146b				 
146b 2a 08 eb			ld hl,(cli_ret_sp) 
146e 3e 86			ld a, display_row_4+14 
1470 cd 0c 14			call display_word_at 
1473			 
1473 cd 7c 0a			call update_display 
1476			 
1476 cd cb 09			call delay1s 
1479 cd cb 09			call delay1s 
147c cd cb 09			call delay1s 
147f			 
147f			 
147f cd 59 1a			call next_page_prompt 
1482			 
1482				; restore  
1482			 
1482 f1				pop af 
1483 e1				pop hl 
1484 c1				pop bc 
1485 d1				pop de 
1486 c9				ret 
1487			 
1487			break_point_state: 
1487 f5				push af 
1488			 
1488				; see if disabled 
1488			 
1488 3a c8 e3			ld a, (os_view_disable) 
148b fe 2a			cp '*' 
148d 20 02			jr nz, .bpsgo 
148f f1				pop af 
1490 c9				ret 
1491			 
1491			.bpsgo: 
1491 f1				pop af 
1492 f5				push af 
1493 22 c4 e3			ld (os_view_hl), hl 
1496 ed 53 c2 e3		ld (os_view_de), de 
149a ed 43 c0 e3		ld (os_view_bc), bc 
149e e5				push hl 
149f 6f				ld l, a 
14a0 26 00			ld h, 0 
14a2 22 c6 e3			ld (os_view_af),hl 
14a5			 
14a5 21 b7 ed				ld hl, display_fb0 
14a8 22 d2 eb				ld (display_fb_active), hl 
14ab e1				pop hl	 
14ac			 
14ac 3e 31			ld a, '1' 
14ae fe 2a		.bps1:  cp '*' 
14b0 20 03			jr nz, .bps1b 
14b2 32 c8 e3			ld (os_view_disable),a 
14b5 fe 31		.bps1b:  cp '1' 
14b7 20 14			jr nz, .bps2 
14b9			 
14b9				; display reg 
14b9			 
14b9				 
14b9			 
14b9 3a c6 e3			ld a, (os_view_af) 
14bc 2a c4 e3			ld hl, (os_view_hl) 
14bf ed 5b c2 e3		ld de, (os_view_de) 
14c3 ed 4b c0 e3		ld bc, (os_view_bc) 
14c7 cd 61 15			call display_reg_state 
14ca c3 4d 15			jp .bpschk 
14cd			 
14cd fe 32		.bps2:  cp '2' 
14cf 20 08			jr nz, .bps3 
14d1				 
14d1				; display hl 
14d1 2a c4 e3			ld hl, (os_view_hl) 
14d4 cd 4b 16			call display_dump_at_hl 
14d7			 
14d7 18 74			jr .bpschk 
14d9			 
14d9 fe 33		.bps3:  cp '3' 
14db 20 08			jr nz, .bps4 
14dd			 
14dd			        ; display de 
14dd 2a c2 e3			ld hl, (os_view_de) 
14e0 cd 4b 16			call display_dump_at_hl 
14e3			 
14e3 18 68			jr .bpschk 
14e5 fe 34		.bps4:  cp '4' 
14e7 20 08			jr nz, .bps5 
14e9			 
14e9			        ; display bc 
14e9 2a c0 e3			ld hl, (os_view_bc) 
14ec cd 4b 16			call display_dump_at_hl 
14ef			 
14ef 18 5c			jr .bpschk 
14f1 fe 35		.bps5:  cp '5' 
14f3 20 08		        jr nz, .bps7 
14f5			 
14f5				; display cur ptr 
14f5 2a 22 eb			ld hl, (cli_ptr) 
14f8 cd 4b 16			call display_dump_at_hl 
14fb			 
14fb 18 50			jr .bpschk 
14fd fe 36		.bps7:  cp '6' 
14ff 20 08			jr nz, .bps8b 
1501				 
1501				; display cur orig ptr 
1501 2a 20 eb			ld hl, (cli_origptr) 
1504 cd 4b 16			call display_dump_at_hl 
1507 18 44			jr .bpschk 
1509 fe 37		.bps8b:  cp '7' 
150b 20 08			jr nz, .bps9 
150d				 
150d				; display dsp 
150d 2a 04 eb			ld hl, (cli_data_sp) 
1510 cd 4b 16			call display_dump_at_hl 
1513			 
1513 18 38			jr .bpschk 
1515 fe 39		.bps9:  cp '9' 
1517 20 05			jr nz, .bps8c 
1519				 
1519				; display SP 
1519			;	ld hl, sp 
1519 cd 4b 16			call display_dump_at_hl 
151c			 
151c 18 2f			jr .bpschk 
151e fe 38		.bps8c:  cp '8' 
1520 20 08			jr nz, .bps8d 
1522				 
1522				; display rsp 
1522 2a 08 eb			ld hl, (cli_ret_sp) 
1525 cd 4b 16			call display_dump_at_hl 
1528			 
1528 18 23			jr .bpschk 
152a fe 23		.bps8d:  cp '#'     ; access monitor sub system 
152c 20 05			jr nz, .bps8 
152e cd 4f 18			call monitor 
1531			 
1531 18 1a			jr .bpschk 
1533 fe 30		.bps8:  cp '0' 
1535 20 16			jr nz, .bpschk 
1537			 
1537 21 16 ed				ld hl, display_fb1 
153a 22 d2 eb				ld (display_fb_active), hl 
153d cd 7c 0a				call update_display 
1540			 
1540				;ld a, (os_view_af) 
1540 2a c4 e3			ld hl, (os_view_hl) 
1543 ed 5b c2 e3		ld de, (os_view_de) 
1547 ed 4b c0 e3		ld bc, (os_view_bc) 
154b f1				pop af 
154c c9				ret 
154d			 
154d			.bpschk:   
154d cd cb 09			call delay1s 
1550 3e 9f		ld a,display_row_4 + display_cols - 1 
1552 11 57 1a		        ld de, endprg 
1555 cd 6c 0a			call str_at_display 
1558 cd 7c 0a			call update_display 
155b cd 2d 5a			call cin_wait 
155e			 
155e c3 ae 14			jp .bps1 
1561			 
1561			 
1561			display_reg_state: 
1561			 
1561				; to restore afterwards 
1561			 
1561 d5				push de 
1562 c5				push bc 
1563 e5				push hl 
1564 f5				push af 
1565			 
1565				; for use in here 
1565			 
1565 c5				push bc 
1566 d5				push de 
1567 e5				push hl 
1568 f5				push af 
1569			 
1569 cd 59 0a			call clear_display 
156c			 
156c 11 21 16			ld de, .regstate 
156f 3e 00			ld a, display_row_1 
1571 cd 6c 0a			call str_at_display 
1574			 
1574				; display debug step 
1574			 
1574			 
1574 11 71 ee			ld de, debug_mark 
1577 3e 25			ld a, display_row_1+display_cols-3 
1579 cd 6c 0a			call str_at_display 
157c			 
157c				; display a 
157c 11 3d 16			ld de, .regstatea 
157f 3e 28			ld a, display_row_2 
1581 cd 6c 0a			call str_at_display 
1584			 
1584 e1				pop hl 
1585			;	ld h,0 
1585			;	ld l, a 
1585 3e 2b			ld a, display_row_2+3 
1587 cd 0c 14			call display_word_at 
158a			 
158a			 
158a				; display hl 
158a			 
158a			 
158a 11 31 16			ld de, .regstatehl 
158d 3e 32			ld a, display_row_2+10 
158f cd 6c 0a			call str_at_display 
1592			 
1592 e1				pop hl 
1593 3e 35			ld a, display_row_2+13 
1595 cd 0c 14			call display_word_at 
1598			 
1598				 
1598				; display de 
1598			 
1598 11 35 16			ld de, .regstatede 
159b 3e 50			ld a, display_row_3 
159d cd 6c 0a			call str_at_display 
15a0			 
15a0 e1				pop hl 
15a1			;	ld h,d 
15a1			;	ld l, e 
15a1 3e 53			ld a, display_row_3+3 
15a3 cd 0c 14			call display_word_at 
15a6			 
15a6			 
15a6				; display bc 
15a6			 
15a6 11 39 16			ld de, .regstatebc 
15a9 3e 5a			ld a, display_row_3+10 
15ab cd 6c 0a			call str_at_display 
15ae			 
15ae e1				pop hl 
15af			;	ld h,b 
15af			;	ld l, c 
15af 3e 5d			ld a, display_row_3+13 
15b1 cd 0c 14			call display_word_at 
15b4			 
15b4			 
15b4				; display dsp 
15b4			 
15b4 11 41 16			ld de, .regstatedsp 
15b7 3e 78			ld a, display_row_4 
15b9 cd 6c 0a			call str_at_display 
15bc			 
15bc				 
15bc 2a 04 eb			ld hl,(cli_data_sp) 
15bf 3e 7c			ld a, display_row_4+4 
15c1 cd 0c 14			call display_word_at 
15c4			 
15c4				; display rsp 
15c4			 
15c4 11 46 16			ld de, .regstatersp 
15c7 3e 82			ld a, display_row_4+10 
15c9 cd 6c 0a			call str_at_display 
15cc			 
15cc				 
15cc 2a 08 eb			ld hl,(cli_ret_sp) 
15cf 3e 86			ld a, display_row_4+14 
15d1 cd 0c 14			call display_word_at 
15d4			 
15d4 cd 7c 0a			call update_display 
15d7			 
15d7			;	call delay1s 
15d7			;	call delay1s 
15d7			;	call delay1s 
15d7			 
15d7			 
15d7			;	call next_page_prompt 
15d7			 
15d7				; restore  
15d7			 
15d7 f1				pop af 
15d8 e1				pop hl 
15d9 c1				pop bc 
15da d1				pop de 
15db c9				ret 
15dc			 
15dc .. 00		.wordincurptr:  db "Word in cur_ptr (5)",0 
15f0 .. 00		.wordincuroptr:  db "Word in cur_optr (6)",0 
1605 .. 00		.ptrstate:	db "Ptr State",0 
160f .. 00		.ptrcliptr:     db "cli_ptr",0 
1617 .. 00		.ptrclioptr:     db "cli_o_ptr",0 
1621 .. 00		.regstate:	db "Reg State (1/0)",0 
1631 .. 00		.regstatehl:	db "HL:",0 
1635 .. 00		.regstatede:	db "DE:",0 
1639 .. 00		.regstatebc:	db "BC:",0 
163d .. 00		.regstatea:	db "A :",0 
1641 .. 00		.regstatedsp:	db "DSP:",0 
1646 .. 00		.regstatersp:	db "RSP:",0 
164b			 
164b			display_dump_at_hl: 
164b e5				push hl 
164c d5				push de 
164d c5				push bc 
164e f5				push af 
164f			 
164f 22 fa e6			ld (os_cur_ptr),hl	 
1652 cd 59 0a			call clear_display 
1655 cd 61 19			call dumpcont 
1658			;	call delay1s 
1658			;	call next_page_prompt 
1658			 
1658			 
1658 f1				pop af 
1659 c1				pop bc 
165a d1				pop de 
165b e1				pop hl 
165c c9				ret 
165d			 
165d			;if ENABLE_BASIC 
165d			;	include "nascombasic.asm" 
165d			;	basic: 
165d			;	include "forth/FORTH.ASM" 
165d			;endif 
165d			 
165d			; eof 
165d			 
165d			 
# End of file firmware_diags.asm
165d			  
165d			include "firmware_prompts.asm"  
165d			; Prompts  
165d			 
165d			; boot messages 
165d			 
165d .. 00		prom_bootmsg:	db "z80-homebrew OS v1.6",0 
1672 .. 00		prom_bootmsg1:	db "by Kevin Groves",0 
1682			 
1682			 
1682			; config menus 
1682			 
1682 .. 00		prom_c3: db "Add Dictionary To File",0 
1699 .. 00		prom_c2: db "Select Autoload File",0 
16ae .. 00		prom_c2a: db "Disable Autoload File", 0 
16c4 .. 00		prom_c2b: db "Select Storage Bank",0 
16d8 .. 00		prom_c4: db "Settings",0 
16e1 .. 00		prom_m4:   db "Debug & Breakpoints On/Off",0 
16fc .. 00		prom_m4b:   db "Monitor",0 
1704 .. 00		prom_c1: db "Hardware Diags",0 
1713			 
1713			 
1713 .. 00		prom_notav:    db "Feature not available",0 
1729 .. 00		prom_empty:    db "",0 
172a			 
172a			; eof 
172a			 
# End of file firmware_prompts.asm
172a			  
172a			  
172a			; eof  
172a			  
# End of file firmware.asm
172a			 
172a			;; below moved from firmware.asm for strange zero calc of baseusermem label. Scope issue on multipass???? 
172a			;if BASE_KEV  
172a			;baseram: equ 08000h 
172a			;endif 
172a			 
172a			;if BASE_SC114 
172a			;baseram:     equ    endofcode 
172a			;endif 
172a			 
172a			 
172a			; start system 
172a			 
172a			coldstart: 
172a				; set sp 
172a				; di/ei 
172a			 
172a f3				di 
172b 31 00 f0			ld sp, tos 
172e			;	ei 
172e			 
172e			 
172e				; disable breakpoint by default 
172e			 
172e 3e 2a			ld a,'*' 
1730 32 c8 e3			ld (os_view_disable),a 
1733			 
1733				; init hardware 
1733			 
1733				; init keyboard and screen hardware 
1733			 
1733 cd 03 01			call hardware_init 
1736			 
1736			 
1736				; detect if any keys are held down to enable breakpoints at start up 
1736			 
1736 cd 35 5a			call cin  
1739 fe 00			cp 0 
173b 28 03			jr z, .nokeys 
173d			 
173d				;call hardware_diags 
173d cd e6 12			call config 
1740			 
1740			;	ld de, .bpen 
1740			;	ld a, display_row_4 
1740			;	call str_at_display 
1740			;	call update_display 
1740			; 
1740			;	ld a,0 
1740			;	ld (os_view_disable),a 
1740			; 
1740			;.bpwait: 
1740			;	call cin 
1740			;	cp 0 
1740			;	jr z, .bpwait 
1740			;	jr .nokeys 
1740			; 
1740			; 
1740			;.bpen:  db "Break points enabled!",0 
1740			 
1740			 
1740			 
1740			 
1740			 
1740			 
1740			.nokeys: 
1740			 
1740			 
1740				 
1740			 
1740			;jp  testkey 
1740			 
1740			;call storage_get_block_0 
1740			; 
1740			;ld hl, 0 
1740			;ld de, store_page 
1740			;call storage_read_block 
1740			 
1740				 
1740			;ld hl, 10 
1740			;ld de, store_page 
1740			;call storage_read_block 
1740			 
1740			 
1740			 
1740			 
1740			 
1740			;stop:	nop 
1740			;	jp stop 
1740			 
1740			 
1740			 
1740			main: 
1740 cd 59 0a			call clear_display 
1743 cd 7c 0a			call update_display 
1746			 
1746			 
1746			 
1746			;	call testlcd 
1746			 
1746			 
1746			 
1746 cd 1f 1e			call forth_init 
1749			 
1749			 
1749			warmstart: 
1749 cd f5 1d			call forth_warmstart 
174c			 
174c				; run startup word load 
174c			        ; TODO prevent this running at warmstart after crash  
174c			 
174c				if STARTUP_ENABLE 
174c					if STORAGE_SE 
174c						call forth_autoload 
174c					endif 
174c cd 7b 56				call forth_startup 
174f			 
174f			 
174f				endif 
174f			 
174f				; show free memory after boot 
174f 11 e9 17			ld de, freeram 
1752 3e 00			ld a, display_row_1 
1754 cd 6c 0a			call str_at_display 
1757			 
1757			; Or use heap_size word???? 
1757 21 bd e3			ld hl, heap_end 
175a 11 5d 5a			ld de, heap_start 
175d ed 52			sbc hl, de 
175f e5				push hl 
1760 7c				ld a,h	         	 
1761 21 dc e6			ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
1764 cd 87 0f			call hexout 
1767 e1			   	pop hl 
1768			 
1768 7d				ld a,l 
1769 21 de e6			ld hl, os_word_scratch+2 
176c cd 87 0f			call hexout 
176f 21 e0 e6			ld hl, os_word_scratch+4 
1772 3e 00			ld a, 0 
1774 77				ld (hl),a 
1775 11 dc e6			ld de, os_word_scratch 
1778 3e 0d			ld a, display_row_1 + 13 
177a cd 6c 0a			call str_at_display 
177d cd 7c 0a			call update_display 
1780			 
1780			 
1780				;call demo 
1780			 
1780			 
1780				; init scratch input area for cli commands 
1780			 
1780 21 fe e6			ld hl, os_cli_cmd 
1783 3e 00			ld a,0 
1785 77				ld (hl),a 
1786 23				inc hl 
1787 77				ld (hl),a 
1788			 
1788 3e 00			ld a,0 
178a 32 fd e7			ld (os_last_cmd),a	; current command in use to enable repeated use with an enter etc 
178d			 
178d 32 fa e6			ld (os_cur_ptr),a	; ptr to whatever is needed for this command 
1790 32 fb e6			ld (os_cur_ptr+1),a	 
1793			 
1793 32 dc e6			ld (os_word_scratch),a	; byte or word being used in parsing for this command 
1796 32 dd e6			ld (os_word_scratch+1),a	 
1799				 
1799			 
1799				;ld a, kLCD_Line2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
1799 21 fe e6			ld hl, os_cli_cmd 
179c			 
179c 3e 00			ld a, 0		 ; init cli input 
179e 77				ld (hl), a 
179f 3e 28			ld a, display_row_2        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17a1			cli: 
17a1				; show cli prompt 
17a1				;push af 
17a1				;ld a, 0 
17a1				;ld de, prompt 
17a1				;call str_at_display 
17a1			 
17a1				;call update_display 
17a1				;pop af 
17a1				;inc a 
17a1				;ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
17a1 0e 00			ld c, 0 
17a3 16 ff			ld d, 255    ; TODO fix input_str to actually take note of max string input length 
17a5 1e 28			ld e, 40 
17a7			 
17a7 21 fe e6			ld hl, os_cli_cmd 
17aa			 
17aa				STACKFRAME OFF $fefe $9f9f 
17aa				if DEBUG_STACK_IMB 
17aa					if OFF 
17aa						exx 
17aa						ld de, $fefe 
17aa						ld a, d 
17aa						ld hl, curframe 
17aa						call hexout 
17aa						ld a, e 
17aa						ld hl, curframe+2 
17aa						call hexout 
17aa						ld hl, $fefe 
17aa						push hl 
17aa						ld hl, $9f9f 
17aa						push hl 
17aa						exx 
17aa					endif 
17aa				endif 
17aa			endm 
# End of macro STACKFRAME
17aa			 
17aa cd b3 0c			call input_str 
17ad			 
17ad				STACKFRAMECHK OFF $fefe $9f9f 
17ad				if DEBUG_STACK_IMB 
17ad					if OFF 
17ad						exx 
17ad						ld hl, $9f9f 
17ad						pop de   ; $9f9f 
17ad						call cmp16 
17ad						jr nz, .spnosame 
17ad						ld hl, $fefe 
17ad						pop de   ; $fefe 
17ad						call cmp16 
17ad						jr z, .spfrsame 
17ad						.spnosame: call showsperror 
17ad						.spfrsame: nop 
17ad						exx 
17ad					endif 
17ad				endif 
17ad			endm 
# End of macro STACKFRAMECHK
17ad			 
17ad				; copy input to last command 
17ad			 
17ad 21 fe e6			ld hl, os_cli_cmd 
17b0 11 fd e7			ld de, os_last_cmd 
17b3 01 ff 00			ld bc, 255 
17b6 ed b0			ldir 
17b8			 
17b8				; wipe current buffer 
17b8			 
17b8			;	ld a, 0 
17b8			;	ld hl, os_cli_cmd 
17b8			;	ld de, os_cli_cmd+1 
17b8			;	ld bc, 254 
17b8			;	ldir 
17b8				; TODO ldir is not working strcpy may not get all the terms on the input line???? 
17b8			;	call strcpy 
17b8			;	ld a, 0 
17b8			;	ld (hl), a 
17b8			;	inc hl 
17b8			;	ld (hl), a 
17b8			;	inc hl 
17b8			;	ld (hl), a 
17b8			 
17b8				; switch frame buffer to program  
17b8			 
17b8 21 16 ed				ld hl, display_fb1 
17bb 22 d2 eb				ld (display_fb_active), hl 
17be			 
17be			;	nop 
17be				STACKFRAME ON $fbfe $8f9f 
17be				if DEBUG_STACK_IMB 
17be					if ON 
17be						exx 
17be						ld de, $fbfe 
17be						ld a, d 
17be						ld hl, curframe 
17be						call hexout 
17be						ld a, e 
17be						ld hl, curframe+2 
17be						call hexout 
17be						ld hl, $fbfe 
17be						push hl 
17be						ld hl, $8f9f 
17be						push hl 
17be						exx 
17be					endif 
17be				endif 
17be			endm 
# End of macro STACKFRAME
17be				; first time into the parser so pass over the current scratch pad 
17be 21 fe e6			ld hl,os_cli_cmd 
17c1				; tokenise the entered statement(s) in HL 
17c1 cd 98 1e			call forthparse 
17c4			        ; exec forth statements in top of return stack 
17c4 cd d8 1e			call forthexec 
17c7				;call forthexec_cleanup 
17c7			;	call parsenext 
17c7			 
17c7				STACKFRAMECHK ON $fbfe $8f9f 
17c7				if DEBUG_STACK_IMB 
17c7					if ON 
17c7						exx 
17c7						ld hl, $8f9f 
17c7						pop de   ; $8f9f 
17c7						call cmp16 
17c7						jr nz, .spnosame 
17c7						ld hl, $fbfe 
17c7						pop de   ; $fbfe 
17c7						call cmp16 
17c7						jr z, .spfrsame 
17c7						.spnosame: call showsperror 
17c7						.spfrsame: nop 
17c7						exx 
17c7					endif 
17c7				endif 
17c7			endm 
# End of macro STACKFRAMECHK
17c7				; TODO on return from forth parsing should there be a prompt to return to system? but already in system. 
17c7			 
17c7 3e 78			ld a, display_row_4 
17c9 11 fb 17			ld de, endprog 
17cc			 
17cc cd 7c 0a			call update_display		 
17cf			 
17cf cd 59 1a			call next_page_prompt 
17d2			 
17d2				; switch frame buffer to cli 
17d2			 
17d2 21 b7 ed				ld hl, display_fb0 
17d5 22 d2 eb				ld (display_fb_active), hl 
17d8			 
17d8			 
17d8 cd 59 0a		        call clear_display 
17db cd 7c 0a			call update_display		 
17de			 
17de 21 fe e6			ld hl, os_cli_cmd 
17e1			 
17e1 3e 00			ld a, 0		 ; init cli input 
17e3 77				ld (hl), a 
17e4			 
17e4				; TODO f_cursor_ptr should inc row (scroll if required) and set start of row for next input  
17e4			 
17e4				; now on last line 
17e4			 
17e4				; TODO scroll screen up 
17e4			 
17e4				; TODO instead just clear screen and place at top of screen 
17e4			 
17e4			;	ld a, 0 
17e4			;	ld (f_cursor_ptr),a 
17e4			 
17e4				;call clear_display 
17e4				;call update_display 
17e4			 
17e4				;ld a, kLCD_Line1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17e4 3e 00			ld a, display_row_1        ; TODO prompt using direct screen line address. Correct this to frame buffer 
17e6 c3 a1 17			jp cli 
17e9			 
17e9 .. 00		freeram: db "Free bytes: $",0 
17f7 ..			asc: db "1A2F" 
17fb .. 00		endprog: db "End prog...",0 
1807			 
1807			testenter2:   
1807 21 09 e4			ld hl,scratch+50 
180a 22 fa e6			ld (os_cur_ptr),hl 
180d c3 a1 17			jp cli 
1810			 
1810			testenter:  
1810			 
1810 21 f7 17			ld hl,asc 
1813			;	ld a,(hl) 
1813			;	call nibble2val 
1813 cd dd 0f			call get_byte 
1816			 
1816			 
1816			;	ld a,(hl) 
1816			;	call atohex 
1816			 
1816			;	call fourehexhl 
1816 32 09 e4			ld (scratch+50),a 
1819			 
1819			 
1819			 
1819 21 f9 17			ld hl,asc+2 
181c			;	ld a, (hl) 
181c			;	call nibble2val 
181c cd dd 0f			call get_byte 
181f			 
181f			;	call fourehexhl 
181f 32 0b e4			ld (scratch+52),a 
1822				 
1822 21 09 e4			ld hl,scratch+50 
1825 22 fa e6			ld (os_cur_ptr),hl 
1828 c3 a1 17			jp cli 
182b			 
182b			enter:	 
182b 3a db e3			ld a,(scratch+4) 
182e fe 00			cp 0 
1830 28 0c			jr z, .entercont 
1832				; no, not a null term line so has an address to work out.... 
1832			 
1832 21 d9 e3			ld hl,scratch+2 
1835 cd 3d 10			call get_word_hl 
1838			 
1838 22 fa e6			ld (os_cur_ptr),hl	 
183b c3 a1 17			jp cli 
183e			 
183e			 
183e			.entercont:  
183e			 
183e 21 d9 e3			ld hl, scratch+2 
1841 cd dd 0f			call get_byte 
1844			 
1844 2a fa e6		   	ld hl,(os_cur_ptr) 
1847 77					ld (hl),a 
1848 23					inc hl 
1849 22 fa e6				ld (os_cur_ptr),hl 
184c				 
184c			; get byte  
184c			 
184c			 
184c c3 a1 17			jp cli 
184f			 
184f			 
184f			; basic monitor support 
184f			 
184f			monitor: 
184f				;  
184f cd 59 0a			call clear_display 
1852 3e 00			ld a, 0 
1854 11 9c 18			ld de, .monprompt 
1857 cd 6c 0a			call str_at_display 
185a cd 7c 0a			call update_display 
185d			 
185d				; get a monitor command 
185d			 
185d 0e 00			ld c, 0     ; entry at top left 
185f 16 64			ld d, 100   ; max buffer size 
1861 1e 0f			ld e, 15    ; input scroll area 
1863 3e 00			ld a, 0     ; init string 
1865 21 d5 e5			ld hl, os_input 
1868 77				ld (hl), a 
1869 23				inc hl 
186a 77				ld (hl), a 
186b 21 d5 e5			ld hl, os_input 
186e 3e 01			ld a, 1     ; init string 
1870 cd b3 0c			call input_str 
1873			 
1873 cd 59 0a		        call clear_display 
1876 cd 7c 0a			call update_display		 
1879			 
1879 3a d5 e5			ld a, (os_input) 
187c cd db 10			call toUpper 
187f fe 48		        cp 'H' 
1881 28 6f		        jr z, .monhelp 
1883 fe 44			cp 'D'		; dump 
1885 ca 13 19			jp z, .mondump	 
1888 fe 43			cp 'C'		; dump 
188a ca 2d 19			jp z, .moncdump	 
188d fe 4d			cp 'M'		; dump 
188f ca 9e 18			jp z, .moneditstart 
1892 fe 55			cp 'U'		; dump 
1894 28 14			jr z, .monedit	 
1896 fe 51			cp 'Q'		; dump 
1898 c8				ret z	 
1899			 
1899			 
1899				; TODO "S" to access symbol by name and not need the address 
1899				; TODO "F" to find a string in memory 
1899			 
1899 c3 4f 18			jp monitor 
189c			 
189c .. 00		.monprompt: db ">", 0 
189e			 
189e			.moneditstart: 
189e				; get starting address 
189e			 
189e 21 d7 e5			ld hl,os_input+2 
18a1 cd 3d 10			call get_word_hl 
18a4			 
18a4 22 fa e6			ld (os_cur_ptr),hl	 
18a7			 
18a7 c3 4f 18			jp monitor 
18aa			 
18aa			.monedit: 
18aa				; get byte to load 
18aa			 
18aa 21 d7 e5			ld hl,os_input+2 
18ad cd dd 0f			call get_byte 
18b0			 
18b0				; get address to update 
18b0 2a fa e6			ld hl, (os_cur_ptr) 
18b3			 
18b3				; update byte 
18b3			 
18b3 77				ld (hl), a 
18b4			 
18b4				; move to next address and save it 
18b4			 
18b4 23				inc hl 
18b5 22 fa e6			ld (os_cur_ptr),hl	 
18b8			 
18b8 c3 4f 18			jp monitor 
18bb			 
18bb			 
18bb .. 00		.monhelptext1: 	db "D-Dump, C-Cont Dump",0 
18cf .. 00		.monhelptext2:  db "M-Edit Start, U-Update Byte",0 
18eb .. 00		.monhelptext3:  db "Q-Quit",0 
18f2			        
18f2			.monhelp: 
18f2 3e 00			ld a, display_row_1 
18f4 11 bb 18		        ld de, .monhelptext1 
18f7			 
18f7 cd 6c 0a			call str_at_display 
18fa 3e 28			ld a, display_row_2 
18fc 11 cf 18		        ld de, .monhelptext2 
18ff					 
18ff cd 6c 0a			call str_at_display 
1902 3e 50			ld a, display_row_3 
1904 11 eb 18		        ld de, .monhelptext3 
1907					 
1907 cd 6c 0a			call str_at_display 
190a cd 7c 0a			call update_display		 
190d			 
190d cd 59 1a			call next_page_prompt 
1910 c3 4f 18			jp monitor 
1913			 
1913			.mondump:    
1913 21 d7 e5			ld hl,os_input+2 
1916 cd 3d 10			call get_word_hl 
1919			 
1919 22 fa e6			ld (os_cur_ptr),hl	 
191c cd 61 19			call dumpcont 
191f 3e 78			ld a, display_row_4 
1921 11 fb 17			ld de, endprog 
1924			 
1924 cd 7c 0a			call update_display		 
1927			 
1927 cd 59 1a			call next_page_prompt 
192a c3 4f 18			jp monitor 
192d			.moncdump: 
192d cd 61 19			call dumpcont 
1930 3e 78			ld a, display_row_4 
1932 11 fb 17			ld de, endprog 
1935			 
1935 cd 7c 0a			call update_display		 
1938			 
1938 cd 59 1a			call next_page_prompt 
193b c3 4f 18			jp monitor 
193e			 
193e			 
193e			; TODO symbol access  
193e			 
193e			.symbols:     ;; A list of symbols that can be called up  
193e b7 ed			dw display_fb0 
1940 .. 00			db "fb0",0  
1944 5c eb		     	dw store_page 
1946 .. 00			db "store_page",0 
1951			 
1951			 
1951			dump:	; see if we are cotinuing on from the last command by not uncluding any address 
1951			 
1951 3a d8 e3			ld a,(scratch+1) 
1954 fe 00			cp 0 
1956 28 09			jr z, dumpcont 
1958			 
1958				; no, not a null term line so has an address to work out.... 
1958			 
1958 21 d9 e3			ld hl,scratch+2 
195b cd 3d 10			call get_word_hl 
195e			 
195e 22 fa e6			ld (os_cur_ptr),hl	 
1961			 
1961			 
1961			 
1961			dumpcont: 
1961			 
1961				; dump bytes at ptr 
1961			 
1961			 
1961 3e 00			ld a, display_row_1 
1963 2a d2 eb			ld hl, (display_fb_active) 
1966 cd 86 0c			call addatohl 
1969 cd 91 19			call .dumpbyterow 
196c			 
196c 3e 28			ld a, display_row_2 
196e 2a d2 eb			ld hl, (display_fb_active) 
1971 cd 86 0c			call addatohl 
1974 cd 91 19			call .dumpbyterow 
1977			 
1977			 
1977 3e 50			ld a, display_row_3 
1979 2a d2 eb			ld hl, (display_fb_active) 
197c cd 86 0c			call addatohl 
197f cd 91 19			call .dumpbyterow 
1982			 
1982 3e 78			ld a, display_row_4 
1984 2a d2 eb			ld hl, (display_fb_active) 
1987 cd 86 0c			call addatohl 
198a cd 91 19			call .dumpbyterow 
198d			 
198d cd 7c 0a			call update_display 
1990			;		jp cli 
1990 c9				ret 
1991			 
1991			.dumpbyterow: 
1991			 
1991				;push af 
1991			 
1991 e5				push hl 
1992			 
1992				; calc where to poke the ascii 
1992			if display_cols == 20 
1992				ld a, 16 
1992			else 
1992 3e 1f			ld a, 31 
1994			endif 
1994			 
1994 cd 86 0c			call addatohl 
1997 22 dc e6			ld (os_word_scratch),hl  		; save pos for later 
199a			 
199a			 
199a			; display decoding address 
199a 2a fa e6		   	ld hl,(os_cur_ptr) 
199d			 
199d 7c				ld a,h 
199e e1				pop hl 
199f e5				push hl 
19a0			;	ld hl, os_word_scratch		; TODO do direct write to frame buffer instead and drop the str_at_display 
19a0 cd 87 0f			call hexout 
19a3 2a fa e6		   	ld hl,(os_cur_ptr) 
19a6			 
19a6 7d				ld a,l 
19a7 e1				pop hl 
19a8 23				inc hl 
19a9 23				inc hl 
19aa e5				push hl 
19ab			;	ld hl, os_word_scratch+2 
19ab cd 87 0f			call hexout 
19ae e1				pop hl 
19af 23				inc hl 
19b0 23				inc hl 
19b1				;ld hl, os_word_scratch+4 
19b1 3e 3a			ld a, ':' 
19b3 77				ld (hl),a 
19b4 23				inc hl 
19b5				;ld a, 0 
19b5				;ld (hl),a 
19b5				;ld de, os_word_scratch 
19b5				;pop af 
19b5				;push af 
19b5			;		ld a, display_row_2 
19b5			;		call str_at_display 
19b5			;		call update_display 
19b5			 
19b5			 
19b5			;pop af 
19b5			;	add 5 
19b5			 
19b5			if display_cols == 20 
19b5				ld b, 4 
19b5			else 
19b5 06 08			ld b, 8 
19b7			endif	 
19b7			 
19b7			.dumpbyte: 
19b7 c5				push bc 
19b8 e5				push hl 
19b9			 
19b9			 
19b9 2a fa e6		   	ld hl,(os_cur_ptr) 
19bc 7e					ld a,(hl) 
19bd			 
19bd					; poke the ascii to display 
19bd 2a dc e6				ld hl,(os_word_scratch) 
19c0 77					ld (hl),a 
19c1 23					inc hl 
19c2 22 dc e6				ld (os_word_scratch),hl 
19c5			 
19c5					 
19c5			 
19c5			 
19c5 e1					pop hl 
19c6 e5					push hl 
19c7			 
19c7 cd 87 0f				call hexout 
19ca			 
19ca					 
19ca 2a fa e6		   	ld hl,(os_cur_ptr) 
19cd 23				inc hl 
19ce 22 fa e6		   	ld (os_cur_ptr),hl 
19d1			 
19d1 e1					pop hl 
19d2 23					inc hl 
19d3 23					inc hl 
19d4 23					inc hl 
19d5			 
19d5			 
19d5			 
19d5					;ld a,0 
19d5					;ld (os_word_scratch+2),a 
19d5					;pop af 
19d5					;push af 
19d5			 
19d5					;ld de, os_word_scratch 
19d5					;call str_at_display 
19d5			;		call update_display 
19d5			;		pop af 
19d5 c1					pop bc 
19d6 c6 03				add 3 
19d8 10 dd			djnz .dumpbyte 
19da			 
19da				 
19da			 
19da c9				ret 
19db			 
19db			jump:	 
19db			 
19db 21 d9 e3			ld hl,scratch+2 
19de cd 3d 10			call get_word_hl 
19e1				;ld hl,(scratch+2) 
19e1				;call fourehexhl 
19e1			 
19e1 22 fa e6			ld (os_cur_ptr),hl	 
19e4			 
19e4 e9				jp (hl) 
19e5			 
19e5			 
19e5			 
19e5			; TODO implement a basic monitor mode to start with 
19e5			 
19e5			 
19e5			 
19e5			 
19e5			 
19e5			 
19e5			 
19e5			 
19e5			 
19e5			; testing and demo code during development 
19e5			 
19e5			 
19e5 .. 00		str1: db "Enter some text...",0 
19f8 .. 00		clear: db "                    ",0 
1a0d			 
1a0d			demo: 
1a0d			 
1a0d			 
1a0d			 
1a0d			;	call update_display 
1a0d			 
1a0d				; init scratch input area for testing 
1a0d 21 d7 e3			ld hl, scratch	 
1a10 3e 00			ld a,0 
1a12 77				ld (hl),a 
1a13			 
1a13			 
1a13 3e 28		            LD   A, display_row_2 
1a15			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a15 11 e5 19		            LD   DE, str1 
1a18 cd 6c 0a			call str_at_display 
1a1b			 
1a1b			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a1b			cloop:	 
1a1b 3e 50		            LD   A, display_row_3 
1a1d			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a1d 11 f8 19		            LD   DE, clear 
1a20			 ;           CALL fLCD_Str       ;Display string pointed to by DE 
1a20 cd 6c 0a				call str_at_display 
1a23 3e 78			ld a, display_row_4 
1a25 11 55 1a			ld de, prompt 
1a28			 
1a28 cd 6c 0a				call str_at_display 
1a2b cd 7c 0a			call update_display 
1a2e			 
1a2e 3e 79			ld a, kLCD_Line4+1	 ; TODO using direct screen line writes. Correct this to frame buffer 
1a30 16 0a			ld d, 10 
1a32 21 d7 e3			ld hl, scratch	 
1a35 cd b3 0c			call input_str 
1a38			 
1a38			;	call clear_display 
1a38			;'	call update_display 
1a38			 
1a38 3e 00		            LD   A, display_row_1 
1a3a			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a3a 11 f8 19		            LD   DE, clear 
1a3d cd 6c 0a				call str_at_display 
1a40			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a40 3e 00		            LD   A, display_row_1 
1a42			;            CALL fLCD_Pos       ;Position cursor to location in A 
1a42 11 d7 e3		            LD   DE, scratch 
1a45			;            CALL fLCD_Str       ;Display string pointed to by DE 
1a45 cd 6c 0a				call str_at_display 
1a48 cd 7c 0a			call update_display 
1a4b			 
1a4b 3e 00				ld a,0 
1a4d 21 d7 e3			ld hl, scratch 
1a50 77				ld (hl),a 
1a51			 
1a51 00				nop 
1a52 c3 1b 1a			jp cloop 
1a55			 
1a55			 
1a55			 
1a55			; OS Prompt 
1a55			 
1a55 .. 00		prompt: db ">",0 
1a57 .. 00		endprg: db "?",0 
1a59			 
1a59			 
1a59			; handy next page prompt 
1a59			next_page_prompt: 
1a59 e5				push hl 
1a5a d5				push de 
1a5b f5				push af 
1a5c c5				push bc 
1a5d			 
1a5d 3e 9f			ld a,display_row_4 + display_cols - 1 
1a5f 11 57 1a		        ld de, endprg 
1a62 cd 6c 0a			call str_at_display 
1a65 cd 7c 0a			call update_display 
1a68 cd 2d 5a			call cin_wait 
1a6b c1				pop bc 
1a6c f1				pop af 
1a6d d1				pop de 
1a6e e1				pop hl 
1a6f			 
1a6f			 
1a6f c9				ret 
1a70			 
1a70			 
1a70			; forth parser 
1a70			 
1a70			; My forth kernel 
1a70			include "forth_kernel.asm" 
1a70			; 
1a70			; kernel to the forth OS 
1a70			 
1a70			DS_TYPE_STR: equ 1     ; string type 
1a70			DS_TYPE_INUM: equ 2     ; $ 16 bit unsigned int usually a hex address 
1a70			DS_TYPE_SNUM: equ 3     ; $ 16 bit signed int  
1a70			;DS_TYPE_FNUM: equ 3      ; 24/32 bit floating point  do string conversion instead of a new type 
1a70			 
1a70			FORTH_PARSEV1: equ 0 
1a70			FORTH_PARSEV2: equ 0 
1a70			FORTH_PARSEV3: equ 0 
1a70			FORTH_PARSEV4: equ 0 
1a70			FORTH_PARSEV5: equ 1 
1a70			 
1a70			;if FORTH_PARSEV5 
1a70			;	FORTH_END_BUFFER: equ 0 
1a70			;else 
1a70			FORTH_END_BUFFER: equ 127 
1a70			;endif 
1a70			 
1a70			FORTH_TRUE: equ 1 
1a70			FORTH_FALSE: equ 0 
1a70			 
1a70			if FORTH_PARSEV4 
1a70			include "forth_stackops.asm" 
1a70			endif 
1a70			 
1a70			if FORTH_PARSEV5 
1a70			include "forth_stackopsv5.asm" 
1a70			 
1a70			; Stack operations for v5 parser on wards 
1a70			; * DATA stack 
1a70			; * LOOP stack 
1a70			; * RETURN stack 
1a70			 
1a70			 
1a70			 
1a70			FORTH_CHK_DSP_UNDER: macro 
1a70				push hl 
1a70				push de 
1a70				ld hl,(cli_data_sp) 
1a70				ld de, cli_data_stack 
1a70				call cmp16 
1a70				jp c, fault_dsp_under 
1a70				pop de 
1a70				pop hl 
1a70				endm 
1a70			 
1a70			 
1a70			FORTH_CHK_RSP_UNDER: macro 
1a70				push hl 
1a70				push de 
1a70				ld hl,(cli_ret_sp) 
1a70				ld de, cli_ret_stack 
1a70				call cmp16 
1a70				jp c, fault_rsp_under 
1a70				pop de 
1a70				pop hl 
1a70				endm 
1a70			 
1a70			FORTH_CHK_LOOP_UNDER: macro 
1a70				push hl 
1a70				push de 
1a70				ld hl,(cli_loop_sp) 
1a70				ld de, cli_loop_stack 
1a70				call cmp16 
1a70				jp c, fault_loop_under 
1a70				pop de 
1a70				pop hl 
1a70				endm 
1a70			 
1a70			FORTH_ERR_TOS_NOTSTR: macro 
1a70				; TOSO might need more for checks when used 
1a70				push af 
1a70				ld a,(hl) 
1a70				cp DS_TYPE_STR 
1a70				jp nz, type_faultn   
1a70				pop af 
1a70				endm 
1a70			 
1a70			FORTH_ERR_TOS_NOTNUM: macro 
1a70				push af 
1a70				ld a,(hl) 
1a70				cp DS_TYPE_INUM 
1a70				jp nz, type_faultn   
1a70				pop af 
1a70				endm 
1a70			 
1a70			 
1a70			; increase data stack pointer and save hl to it 
1a70				 
1a70			FORTH_DSP_NEXT: macro 
1a70				call macro_forth_dsp_next 
1a70				endm 
1a70			 
1a70			 
1a70			macro_forth_dsp_next: 
1a70				if DEBUG_FORTH_STACK_GUARD 
1a70 cd 45 57				call check_stacks 
1a73				endif 
1a73 e5				push hl 
1a74 d5				push de 
1a75 eb				ex de,hl 
1a76 2a 04 eb			ld hl,(cli_data_sp) 
1a79 23				inc hl 
1a7a 23				inc hl 
1a7b			 
1a7b			; PARSEV5 
1a7b 23				inc hl 
1a7c 22 04 eb			ld (cli_data_sp),hl 
1a7f 73				ld (hl), e 
1a80 23				inc hl 
1a81 72				ld (hl), d 
1a82 d1				pop de 
1a83 e1				pop hl 
1a84				if DEBUG_FORTH_STACK_GUARD 
1a84 cd 45 57				call check_stacks 
1a87				endif 
1a87 c9				ret 
1a88			 
1a88			 
1a88			; increase ret stack pointer and save hl to it 
1a88				 
1a88			FORTH_RSP_NEXT: macro 
1a88				call macro_forth_rsp_next 
1a88				endm 
1a88			 
1a88			macro_forth_rsp_next: 
1a88				if DEBUG_FORTH_STACK_GUARD 
1a88 cd 45 57				call check_stacks 
1a8b				endif 
1a8b e5				push hl 
1a8c d5				push de 
1a8d eb				ex de,hl 
1a8e 2a 08 eb			ld hl,(cli_ret_sp) 
1a91 23				inc hl 
1a92 23				inc hl 
1a93 22 08 eb			ld (cli_ret_sp),hl 
1a96 73				ld (hl), e 
1a97 23				inc hl 
1a98 72				ld (hl), d 
1a99 d1				pop de 
1a9a e1				pop hl 
1a9b				if DEBUG_FORTH_STACK_GUARD 
1a9b cd 45 57				call check_stacks 
1a9e				endif 
1a9e c9				ret 
1a9f			 
1a9f			; get current ret stack pointer and save to hl  
1a9f				 
1a9f			FORTH_RSP_TOS: macro 
1a9f				call macro_forth_rsp_tos 
1a9f				endm 
1a9f			 
1a9f			macro_forth_rsp_tos: 
1a9f				;push de 
1a9f 2a 08 eb			ld hl,(cli_ret_sp) 
1aa2 cd da 1a			call loadhlptrtohl 
1aa5				;ld e, (hl) 
1aa5				;inc hl 
1aa5				;ld d, (hl) 
1aa5				;ex de, hl 
1aa5					if DEBUG_FORTH_WORDS 
1aa5			;			DMARK "RST" 
1aa5						CALLMONITOR 
1aa5 cd 87 14			call break_point_state  
1aa8				endm  
# End of macro CALLMONITOR
1aa8					endif 
1aa8				;pop de 
1aa8 c9				ret 
1aa9			 
1aa9			; pop ret stack pointer 
1aa9				 
1aa9			FORTH_RSP_POP: macro 
1aa9				call macro_forth_rsp_pop 
1aa9				endm 
1aa9			 
1aa9			 
1aa9			macro_forth_rsp_pop: 
1aa9				if DEBUG_FORTH_STACK_GUARD 
1aa9			;		DMARK "RPP" 
1aa9 cd 45 57				call check_stacks 
1aac					FORTH_CHK_RSP_UNDER 
1aac e5				push hl 
1aad d5				push de 
1aae 2a 08 eb			ld hl,(cli_ret_sp) 
1ab1 11 c2 ea			ld de, cli_ret_stack 
1ab4 cd a4 0c			call cmp16 
1ab7 da 59 58			jp c, fault_rsp_under 
1aba d1				pop de 
1abb e1				pop hl 
1abc				endm 
# End of macro FORTH_CHK_RSP_UNDER
1abc				endif 
1abc e5				push hl 
1abd 2a 08 eb			ld hl,(cli_ret_sp) 
1ac0			 
1ac0			 
1ac0				if FORTH_ENABLE_FREE 
1ac0			 
1ac0					; get pointer 
1ac0			 
1ac0					push de 
1ac0					push hl 
1ac0			 
1ac0					ld e, (hl) 
1ac0					inc hl 
1ac0					ld d, (hl) 
1ac0			 
1ac0					ex de, hl 
1ac0					call free 
1ac0			 
1ac0					pop hl 
1ac0					pop de 
1ac0			 
1ac0			 
1ac0				endif 
1ac0			 
1ac0			 
1ac0 2b				dec hl 
1ac1 2b				dec hl 
1ac2 22 08 eb			ld (cli_ret_sp), hl 
1ac5				; do stack underflow checks 
1ac5 e1				pop hl 
1ac6				if DEBUG_FORTH_STACK_GUARD 
1ac6 cd 45 57				call check_stacks 
1ac9					FORTH_CHK_RSP_UNDER 
1ac9 e5				push hl 
1aca d5				push de 
1acb 2a 08 eb			ld hl,(cli_ret_sp) 
1ace 11 c2 ea			ld de, cli_ret_stack 
1ad1 cd a4 0c			call cmp16 
1ad4 da 59 58			jp c, fault_rsp_under 
1ad7 d1				pop de 
1ad8 e1				pop hl 
1ad9				endm 
# End of macro FORTH_CHK_RSP_UNDER
1ad9				endif 
1ad9 c9				ret 
1ada			 
1ada			 
1ada			 
1ada			; routine to load word pointed to by hl into hl 
1ada			 
1ada			loadhlptrtohl: 
1ada			 
1ada d5				push de 
1adb 5e				ld e, (hl) 
1adc 23				inc hl 
1add 56				ld d, (hl) 
1ade eb				ex de, hl 
1adf d1				pop de 
1ae0			 
1ae0 c9				ret 
1ae1			 
1ae1			 
1ae1			 
1ae1			 
1ae1			 
1ae1			; push a number held in HL onto the data stack 
1ae1			; entry point for pushing a value when already in hl used in function above 
1ae1			 
1ae1			forth_push_numhl: 
1ae1			 
1ae1 e5				push hl    ; save value to push 
1ae2			 
1ae2			if DEBUG_FORTH_PUSH 
1ae2				; see if disabled 
1ae2			 
1ae2			 
1ae2 f5				push af 
1ae3 3a c8 e3			ld a, (os_view_disable) 
1ae6 fe 2a			cp '*' 
1ae8 28 34			jr z, .pskip2 
1aea e5				push hl 
1aeb e5			push hl 
1aec cd 59 0a			call clear_display 
1aef e1			pop hl 
1af0 7c				ld a,h 
1af1 21 dc e6			ld hl, os_word_scratch 
1af4 cd 87 0f			call hexout 
1af7 e1				pop hl 
1af8 7d				ld a,l 
1af9 21 de e6			ld hl, os_word_scratch+2 
1afc cd 87 0f			call hexout 
1aff			 
1aff 21 e0 e6			ld hl, os_word_scratch+4 
1b02 3e 00			ld a,0 
1b04 77				ld (hl),a 
1b05 11 dc e6			ld de,os_word_scratch 
1b08 3e 28				ld a, display_row_2 
1b0a cd 6c 0a				call str_at_display 
1b0d 11 24 46			ld de, .push_num 
1b10 3e 00			ld a, display_row_1 
1b12			 
1b12 cd 6c 0a				call str_at_display 
1b15			 
1b15			 
1b15 cd 7c 0a			call update_display 
1b18 cd cb 09			call delay1s 
1b1b cd cb 09			call delay1s 
1b1e			.pskip2:  
1b1e			 
1b1e f1				pop af 
1b1f			endif	 
1b1f			 
1b1f			 
1b1f				FORTH_DSP_NEXT 
1b1f cd 70 1a			call macro_forth_dsp_next 
1b22				endm 
# End of macro FORTH_DSP_NEXT
1b22			 
1b22 2a 04 eb			ld hl, (cli_data_sp) 
1b25			 
1b25				; save item type 
1b25 3e 02			ld a,  DS_TYPE_INUM 
1b27 77				ld (hl), a 
1b28 23				inc hl 
1b29			 
1b29				; get word off stack 
1b29 d1				pop de 
1b2a 7b				ld a,e 
1b2b 77				ld (hl), a 
1b2c 23				inc hl 
1b2d 7a				ld a,d 
1b2e 77				ld (hl), a 
1b2f			 
1b2f			if DEBUG_FORTH_PUSH 
1b2f 2b				dec hl 
1b30 2b				dec hl 
1b31 2b				dec hl 
1b32						DMARK "PH5" 
1b32 f5				push af  
1b33 3a 47 1b			ld a, (.dmark)  
1b36 32 71 ee			ld (debug_mark),a  
1b39 3a 48 1b			ld a, (.dmark+1)  
1b3c 32 72 ee			ld (debug_mark+1),a  
1b3f 3a 49 1b			ld a, (.dmark+2)  
1b42 32 73 ee			ld (debug_mark+2),a  
1b45 18 03			jr .pastdmark  
1b47 ..			.dmark: db "PH5"  
1b4a f1			.pastdmark: pop af  
1b4b			endm  
# End of macro DMARK
1b4b				CALLMONITOR 
1b4b cd 87 14			call break_point_state  
1b4e				endm  
# End of macro CALLMONITOR
1b4e			endif	 
1b4e			 
1b4e c9				ret 
1b4f			 
1b4f			 
1b4f			; Push a string to stack pointed to by hl 
1b4f			 
1b4f			forth_push_str: 
1b4f			 
1b4f			if DEBUG_FORTH_PUSH 
1b4f						DMARK "PSQ" 
1b4f f5				push af  
1b50 3a 64 1b			ld a, (.dmark)  
1b53 32 71 ee			ld (debug_mark),a  
1b56 3a 65 1b			ld a, (.dmark+1)  
1b59 32 72 ee			ld (debug_mark+1),a  
1b5c 3a 66 1b			ld a, (.dmark+2)  
1b5f 32 73 ee			ld (debug_mark+2),a  
1b62 18 03			jr .pastdmark  
1b64 ..			.dmark: db "PSQ"  
1b67 f1			.pastdmark: pop af  
1b68			endm  
# End of macro DMARK
1b68				CALLMONITOR 
1b68 cd 87 14			call break_point_state  
1b6b				endm  
# End of macro CALLMONITOR
1b6b			endif	 
1b6b			    
1b6b e5				push hl 
1b6c e5				push hl 
1b6d			 
1b6d			;	ld a, 0   ; find end of string 
1b6d cd e4 10			call strlenz 
1b70			if DEBUG_FORTH_PUSH 
1b70						DMARK "PQ2" 
1b70 f5				push af  
1b71 3a 85 1b			ld a, (.dmark)  
1b74 32 71 ee			ld (debug_mark),a  
1b77 3a 86 1b			ld a, (.dmark+1)  
1b7a 32 72 ee			ld (debug_mark+1),a  
1b7d 3a 87 1b			ld a, (.dmark+2)  
1b80 32 73 ee			ld (debug_mark+2),a  
1b83 18 03			jr .pastdmark  
1b85 ..			.dmark: db "PQ2"  
1b88 f1			.pastdmark: pop af  
1b89			endm  
# End of macro DMARK
1b89				CALLMONITOR 
1b89 cd 87 14			call break_point_state  
1b8c				endm  
# End of macro CALLMONITOR
1b8c			endif	 
1b8c eb				ex de, hl 
1b8d e1				pop hl   ; get ptr to start of string 
1b8e			if DEBUG_FORTH_PUSH 
1b8e						DMARK "PQ3" 
1b8e f5				push af  
1b8f 3a a3 1b			ld a, (.dmark)  
1b92 32 71 ee			ld (debug_mark),a  
1b95 3a a4 1b			ld a, (.dmark+1)  
1b98 32 72 ee			ld (debug_mark+1),a  
1b9b 3a a5 1b			ld a, (.dmark+2)  
1b9e 32 73 ee			ld (debug_mark+2),a  
1ba1 18 03			jr .pastdmark  
1ba3 ..			.dmark: db "PQ3"  
1ba6 f1			.pastdmark: pop af  
1ba7			endm  
# End of macro DMARK
1ba7				CALLMONITOR 
1ba7 cd 87 14			call break_point_state  
1baa				endm  
# End of macro CALLMONITOR
1baa			endif	 
1baa 19				add hl,de 
1bab			if DEBUG_FORTH_PUSH 
1bab						DMARK "PQE" 
1bab f5				push af  
1bac 3a c0 1b			ld a, (.dmark)  
1baf 32 71 ee			ld (debug_mark),a  
1bb2 3a c1 1b			ld a, (.dmark+1)  
1bb5 32 72 ee			ld (debug_mark+1),a  
1bb8 3a c2 1b			ld a, (.dmark+2)  
1bbb 32 73 ee			ld (debug_mark+2),a  
1bbe 18 03			jr .pastdmark  
1bc0 ..			.dmark: db "PQE"  
1bc3 f1			.pastdmark: pop af  
1bc4			endm  
# End of macro DMARK
1bc4				CALLMONITOR 
1bc4 cd 87 14			call break_point_state  
1bc7				endm  
# End of macro CALLMONITOR
1bc7			endif	 
1bc7			 
1bc7 2b				dec hl    ; see if there is an optional trailing double quote 
1bc8 7e				ld a,(hl) 
1bc9 fe 22			cp '"' 
1bcb 20 03			jr nz, .strnoq 
1bcd 3e 00			ld a, 0      ; get rid of double quote 
1bcf 77				ld (hl), a 
1bd0 23			.strnoq: inc hl 
1bd1			 
1bd1 3e 00			ld a, 0 
1bd3 77				ld (hl), a     ; add null term and get rid of trailing double quote 
1bd4			 
1bd4 13				inc de ; add one for the type string 
1bd5 13				inc de ; add one for null term??? 
1bd6			 
1bd6				; tos is get string pointer again 
1bd6				; de contains space to allocate 
1bd6				 
1bd6 d5				push de 
1bd7			 
1bd7 eb				ex de, hl 
1bd8			 
1bd8				;push af 
1bd8			 
1bd8			if DEBUG_FORTH_PUSH 
1bd8						DMARK "PHm" 
1bd8 f5				push af  
1bd9 3a ed 1b			ld a, (.dmark)  
1bdc 32 71 ee			ld (debug_mark),a  
1bdf 3a ee 1b			ld a, (.dmark+1)  
1be2 32 72 ee			ld (debug_mark+1),a  
1be5 3a ef 1b			ld a, (.dmark+2)  
1be8 32 73 ee			ld (debug_mark+2),a  
1beb 18 03			jr .pastdmark  
1bed ..			.dmark: db "PHm"  
1bf0 f1			.pastdmark: pop af  
1bf1			endm  
# End of macro DMARK
1bf1				CALLMONITOR 
1bf1 cd 87 14			call break_point_state  
1bf4				endm  
# End of macro CALLMONITOR
1bf4			endif	 
1bf4 cd 4d 11			call malloc	; on ret hl now contains allocated memory 
1bf7				if DEBUG_FORTH_MALLOC_GUARD 
1bf7 cc 7c 46				call z,malloc_error 
1bfa				endif 
1bfa			 
1bfa				 
1bfa c1				pop bc    ; get length 
1bfb d1				pop de   ;  get string start    
1bfc			 
1bfc				; hl has destination from malloc 
1bfc			 
1bfc eb				ex de, hl    ; prep for ldir 
1bfd			 
1bfd d5				push de   ; save malloc area for DSP later 
1bfe				;push hl   ; save malloc area for DSP later 
1bfe			 
1bfe			if DEBUG_FORTH_PUSH 
1bfe						DMARK "PHc" 
1bfe f5				push af  
1bff 3a 13 1c			ld a, (.dmark)  
1c02 32 71 ee			ld (debug_mark),a  
1c05 3a 14 1c			ld a, (.dmark+1)  
1c08 32 72 ee			ld (debug_mark+1),a  
1c0b 3a 15 1c			ld a, (.dmark+2)  
1c0e 32 73 ee			ld (debug_mark+2),a  
1c11 18 03			jr .pastdmark  
1c13 ..			.dmark: db "PHc"  
1c16 f1			.pastdmark: pop af  
1c17			endm  
# End of macro DMARK
1c17				CALLMONITOR 
1c17 cd 87 14			call break_point_state  
1c1a				endm  
# End of macro CALLMONITOR
1c1a			endif	 
1c1a			 
1c1a			 
1c1a ed b0			ldir 
1c1c			 
1c1c			 
1c1c				; push malloc to data stack     macro?????  
1c1c			 
1c1c				FORTH_DSP_NEXT 
1c1c cd 70 1a			call macro_forth_dsp_next 
1c1f				endm 
# End of macro FORTH_DSP_NEXT
1c1f			 
1c1f				; save value and type 
1c1f			 
1c1f 2a 04 eb			ld hl, (cli_data_sp) 
1c22			 
1c22				; save item type 
1c22 3e 01			ld a,  DS_TYPE_STR 
1c24 77				ld (hl), a 
1c25 23				inc hl 
1c26			 
1c26				; get malloc word off stack 
1c26 d1				pop de 
1c27 73				ld (hl), e 
1c28 23				inc hl 
1c29 72				ld (hl), d 
1c2a			 
1c2a			 
1c2a			 
1c2a			if DEBUG_FORTH_PUSH 
1c2a 2a 04 eb			ld hl, (cli_data_sp) 
1c2d						DMARK "PHS" 
1c2d f5				push af  
1c2e 3a 42 1c			ld a, (.dmark)  
1c31 32 71 ee			ld (debug_mark),a  
1c34 3a 43 1c			ld a, (.dmark+1)  
1c37 32 72 ee			ld (debug_mark+1),a  
1c3a 3a 44 1c			ld a, (.dmark+2)  
1c3d 32 73 ee			ld (debug_mark+2),a  
1c40 18 03			jr .pastdmark  
1c42 ..			.dmark: db "PHS"  
1c45 f1			.pastdmark: pop af  
1c46			endm  
# End of macro DMARK
1c46				CALLMONITOR 
1c46 cd 87 14			call break_point_state  
1c49				endm  
# End of macro CALLMONITOR
1c49			;	ex de,hl 
1c49			endif	 
1c49				; in case of spaces, skip the ptr past the copied string 
1c49				;pop af 
1c49				;ld (cli_origptr),hl 
1c49			 
1c49 c9				ret 
1c4a			 
1c4a			 
1c4a			 
1c4a			; TODO ascii push input onto stack given hl to start of input 
1c4a			 
1c4a			; identify type 
1c4a			; if starts with a " then a string 
1c4a			; otherwise it is a number 
1c4a			;  
1c4a			; if a string 
1c4a			;     scan for ending " to get length of string to malloc for + 1 
1c4a			;     malloc 
1c4a			;     put pointer to string on stack first byte flags as string 
1c4a			; 
1c4a			; else a number 
1c4a			;    look for number format identifier 
1c4a			;    $xx hex 
1c4a			;    %xxxxx bin 
1c4a			;    xxxxx decimal 
1c4a			;    convert number to 16bit word.  
1c4a			;    malloc word + 1 with flag to identiy as num 
1c4a			;    put pointer to number on stack 
1c4a			;   
1c4a			;  
1c4a			  
1c4a			forth_apush: 
1c4a				; kernel push 
1c4a			 
1c4a			if DEBUG_FORTH_PUSH 
1c4a						DMARK "PSH" 
1c4a f5				push af  
1c4b 3a 5f 1c			ld a, (.dmark)  
1c4e 32 71 ee			ld (debug_mark),a  
1c51 3a 60 1c			ld a, (.dmark+1)  
1c54 32 72 ee			ld (debug_mark+1),a  
1c57 3a 61 1c			ld a, (.dmark+2)  
1c5a 32 73 ee			ld (debug_mark+2),a  
1c5d 18 03			jr .pastdmark  
1c5f ..			.dmark: db "PSH"  
1c62 f1			.pastdmark: pop af  
1c63			endm  
# End of macro DMARK
1c63				CALLMONITOR 
1c63 cd 87 14			call break_point_state  
1c66				endm  
# End of macro CALLMONITOR
1c66			endif	 
1c66				; identify input type 
1c66			 
1c66 7e				ld a,(hl) 
1c67 fe 22			cp '"' 
1c69 28 0a			jr z, .fapstr 
1c6b fe 24			cp '$' 
1c6d ca 95 1c			jp z, .faphex 
1c70 fe 25			cp '%' 
1c72 ca 7d 1c			jp z, .fapbin 
1c75			;	cp 'b' 
1c75			;	jp z, .fabin 
1c75				; else decimal 
1c75			 
1c75				; TODO do decimal conversion 
1c75				; decimal is stored as a 16bit word 
1c75			 
1c75				; by default everything is a string if type is not detected 
1c75			.fapstr: ; 
1c75 fe 22			cp '"' 
1c77 20 01			jr nz, .strnoqu 
1c79 23				inc hl 
1c7a			.strnoqu: 
1c7a c3 4f 1b			jp forth_push_str 
1c7d			 
1c7d			 
1c7d			 
1c7d			.fapbin:    ; push a binary string.  
1c7d 11 00 00			ld de, 0   ; hold a 16bit value 
1c80			 
1c80 23			.fapbinshift:	inc hl  
1c81 7e				ld a,(hl) 
1c82 fe 00			cp 0     ; done scanning  
1c84 28 0b			jr z, .fapbdone  	; got it in HL so push  
1c86			 
1c86				; left shift de 
1c86 eb				ex de, hl	 
1c87 29				add hl, hl 
1c88			 
1c88				; is 1 
1c88 fe 31			cp '1' 
1c8a 20 02			jr nz, .binzero 
1c8c cb 4d			bit 1, l 
1c8e			.binzero: 
1c8e eb				ex de, hl	 ; save current de 
1c8f 18 ef			jr .fapbinshift 
1c91			 
1c91			.fapbdone: 
1c91 eb				ex de, hl 
1c92 c3 e1 1a			jp forth_push_numhl 
1c95			 
1c95			 
1c95			.faphex:   ; hex is always stored as a 16bit word 
1c95				; skip number prefix 
1c95 23				inc hl 
1c96				; turn ascii into number 
1c96 cd 3d 10			call get_word_hl	; ret 16bit word in hl 
1c99			 
1c99 c3 e1 1a			jp forth_push_numhl 
1c9c			 
1c9c 00				 nop 
1c9d			 
1c9d			.fabin:   ; TODO bin conversion 
1c9d			 
1c9d			 
1c9d c9				ret 
1c9e			 
1c9e			 
1c9e			; get either a string ptr or a 16bit word from the data stack 
1c9e			 
1c9e			FORTH_DSP: macro 
1c9e				call macro_forth_dsp 
1c9e				endm 
1c9e			 
1c9e			macro_forth_dsp: 
1c9e				; data stack pointer points to current word on tos 
1c9e			 
1c9e 2a 04 eb			ld hl,(cli_data_sp) 
1ca1			 
1ca1				if DEBUG_FORTH_PUSH 
1ca1						DMARK "DSP" 
1ca1 f5				push af  
1ca2 3a b6 1c			ld a, (.dmark)  
1ca5 32 71 ee			ld (debug_mark),a  
1ca8 3a b7 1c			ld a, (.dmark+1)  
1cab 32 72 ee			ld (debug_mark+1),a  
1cae 3a b8 1c			ld a, (.dmark+2)  
1cb1 32 73 ee			ld (debug_mark+2),a  
1cb4 18 03			jr .pastdmark  
1cb6 ..			.dmark: db "DSP"  
1cb9 f1			.pastdmark: pop af  
1cba			endm  
# End of macro DMARK
1cba			 
1cba cd b1 46				call display_data_sp 
1cbd				;call break_point_state 
1cbd				;rst 030h 
1cbd				CALLMONITOR 
1cbd cd 87 14			call break_point_state  
1cc0				endm  
# End of macro CALLMONITOR
1cc0				endif 
1cc0			 
1cc0 c9				ret 
1cc1			 
1cc1			; return hl to start of value on stack 
1cc1			 
1cc1			FORTH_DSP_VALUE: macro 
1cc1				call macro_forth_dsp_value 
1cc1				endm 
1cc1			 
1cc1			macro_forth_dsp_value: 
1cc1			 
1cc1				FORTH_DSP 
1cc1 cd 9e 1c			call macro_forth_dsp 
1cc4				endm 
# End of macro FORTH_DSP
1cc4			 
1cc4 d5				push de 
1cc5			 
1cc5 23				inc hl ; skip type 
1cc6			 
1cc6 5e				ld e, (hl) 
1cc7 23				inc hl 
1cc8 56				ld d, (hl) 
1cc9 eb				ex de,hl  
1cca			 
1cca d1				pop de 
1ccb			 
1ccb c9				ret 
1ccc			 
1ccc			; return hl to start of value to second item on stack 
1ccc			 
1ccc			FORTH_DSP_VALUEM1: macro 
1ccc				call macro_forth_dsp_value_m1 
1ccc				endm 
1ccc			 
1ccc			macro_forth_dsp_value_m1: 
1ccc			 
1ccc				FORTH_DSP 
1ccc cd 9e 1c			call macro_forth_dsp 
1ccf				endm 
# End of macro FORTH_DSP
1ccf			 
1ccf 2b				dec hl 
1cd0 2b				dec hl 
1cd1			;	dec hl 
1cd1			 
1cd1 d5				push de 
1cd2			 
1cd2 5e				ld e, (hl) 
1cd3 23				inc hl 
1cd4 56				ld d, (hl) 
1cd5 eb				ex de,hl  
1cd6			 
1cd6 d1				pop de 
1cd7			 
1cd7 c9				ret 
1cd8			 
1cd8				 
1cd8			 
1cd8			; whatever the current top os stack points to, we are now done with it so return memory to malloc 
1cd8			 
1cd8			FORTH_DSP_POP: macro 
1cd8				call macro_forth_dsp_pop 
1cd8				endm 
1cd8			 
1cd8			 
1cd8			; get the tos data type 
1cd8			 
1cd8			FORTH_DSP_TYPE:   macro 
1cd8			 
1cd8				;FORTH_DSP_VALUE 
1cd8				FORTH_DSP 
1cd8				 
1cd8				; hl points to value 
1cd8				; check type 
1cd8			 
1cd8				ld a,(hl) 
1cd8			 
1cd8				endm 
1cd8			 
1cd8			; load the tos value into hl 
1cd8			 
1cd8			 
1cd8			FORTH_DSP_VALUEHL:  macro 
1cd8				call macro_dsp_valuehl 
1cd8				endm 
1cd8			 
1cd8			 
1cd8			 
1cd8			macro_dsp_valuehl: 
1cd8				FORTH_DSP_VALUE 
1cd8 cd c1 1c			call macro_forth_dsp_value 
1cdb				endm 
# End of macro FORTH_DSP_VALUE
1cdb			 
1cdb				;FORTH_ERR_TOS_NOTNUM 
1cdb			 
1cdb				;inc hl   ; skip type id 
1cdb			 
1cdb			;	push de 
1cdb			; 
1cdb			;	ld e, (hl) 
1cdb			;	inc hl 
1cdb			;	ld d, (hl) 
1cdb			;	ex de,hl  
1cdb			 
1cdb			;	pop de 
1cdb			 
1cdb				if DEBUG_FORTH_PUSH 
1cdb						DMARK "DVL" 
1cdb f5				push af  
1cdc 3a f0 1c			ld a, (.dmark)  
1cdf 32 71 ee			ld (debug_mark),a  
1ce2 3a f1 1c			ld a, (.dmark+1)  
1ce5 32 72 ee			ld (debug_mark+1),a  
1ce8 3a f2 1c			ld a, (.dmark+2)  
1ceb 32 73 ee			ld (debug_mark+2),a  
1cee 18 03			jr .pastdmark  
1cf0 ..			.dmark: db "DVL"  
1cf3 f1			.pastdmark: pop af  
1cf4			endm  
# End of macro DMARK
1cf4				CALLMONITOR 
1cf4 cd 87 14			call break_point_state  
1cf7				endm  
# End of macro CALLMONITOR
1cf7				endif 
1cf7 c9				ret 
1cf8			 
1cf8			forth_apushstrhl:      
1cf8				; push of string requires use of cli_origptr 
1cf8				; bodge use 
1cf8			 
1cf8				; get current cli_origptr, save, update with temp pointer  
1cf8 ed 5b 20 eb		ld de, (cli_origptr) 
1cfc 22 20 eb			ld (cli_origptr), hl 
1cff d5				push de 
1d00 cd 4a 1c			call forth_apush 
1d03 d1				pop de 
1d04 ed 53 20 eb		ld (cli_origptr), de 
1d08 c9			        ret	 
1d09			 
1d09			 
1d09			; increase loop stack pointer and save hl to it 
1d09				 
1d09			FORTH_LOOP_NEXT: macro 
1d09				call macro_forth_loop_next 
1d09				;nop 
1d09				endm 
1d09			 
1d09			macro_forth_loop_next: 
1d09				if DEBUG_FORTH_STACK_GUARD 
1d09 cd 45 57				call check_stacks 
1d0c				endif 
1d0c e5				push hl 
1d0d d5				push de 
1d0e eb				ex de,hl 
1d0f 2a 06 eb			ld hl,(cli_loop_sp) 
1d12 23				inc hl 
1d13 23				inc hl 
1d14					if DEBUG_FORTH_WORDS 
1d14						DMARK "LNX" 
1d14 f5				push af  
1d15 3a 29 1d			ld a, (.dmark)  
1d18 32 71 ee			ld (debug_mark),a  
1d1b 3a 2a 1d			ld a, (.dmark+1)  
1d1e 32 72 ee			ld (debug_mark+1),a  
1d21 3a 2b 1d			ld a, (.dmark+2)  
1d24 32 73 ee			ld (debug_mark+2),a  
1d27 18 03			jr .pastdmark  
1d29 ..			.dmark: db "LNX"  
1d2c f1			.pastdmark: pop af  
1d2d			endm  
# End of macro DMARK
1d2d						CALLMONITOR 
1d2d cd 87 14			call break_point_state  
1d30				endm  
# End of macro CALLMONITOR
1d30					endif 
1d30 22 06 eb			ld (cli_loop_sp),hl 
1d33 73				ld (hl), e 
1d34 23				inc hl 
1d35 72				ld (hl), d 
1d36 d1				pop de    ; been reversed so save a swap on restore 
1d37 e1				pop hl 
1d38				if DEBUG_FORTH_STACK_GUARD 
1d38 cd 45 57				call check_stacks 
1d3b				endif 
1d3b c9				ret 
1d3c			 
1d3c			; get current ret stack pointer and save to hl  
1d3c				 
1d3c			FORTH_LOOP_TOS: macro 
1d3c				call macro_forth_loop_tos 
1d3c				endm 
1d3c			 
1d3c			macro_forth_loop_tos: 
1d3c d5				push de 
1d3d 2a 06 eb			ld hl,(cli_loop_sp) 
1d40 5e				ld e, (hl) 
1d41 23				inc hl 
1d42 56				ld d, (hl) 
1d43 eb				ex de, hl 
1d44 d1				pop de 
1d45 c9				ret 
1d46			 
1d46			; pop loop stack pointer 
1d46				 
1d46			FORTH_LOOP_POP: macro 
1d46				call macro_forth_loop_pop 
1d46				endm 
1d46			 
1d46			 
1d46			macro_forth_loop_pop: 
1d46				if DEBUG_FORTH_STACK_GUARD 
1d46					DMARK "LPP" 
1d46 f5				push af  
1d47 3a 5b 1d			ld a, (.dmark)  
1d4a 32 71 ee			ld (debug_mark),a  
1d4d 3a 5c 1d			ld a, (.dmark+1)  
1d50 32 72 ee			ld (debug_mark+1),a  
1d53 3a 5d 1d			ld a, (.dmark+2)  
1d56 32 73 ee			ld (debug_mark+2),a  
1d59 18 03			jr .pastdmark  
1d5b ..			.dmark: db "LPP"  
1d5e f1			.pastdmark: pop af  
1d5f			endm  
# End of macro DMARK
1d5f cd 45 57				call check_stacks 
1d62					FORTH_CHK_LOOP_UNDER 
1d62 e5				push hl 
1d63 d5				push de 
1d64 2a 06 eb			ld hl,(cli_loop_sp) 
1d67 11 40 ea			ld de, cli_loop_stack 
1d6a cd a4 0c			call cmp16 
1d6d da 5f 58			jp c, fault_loop_under 
1d70 d1				pop de 
1d71 e1				pop hl 
1d72				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d72				endif 
1d72 e5				push hl 
1d73 2a 06 eb			ld hl,(cli_loop_sp) 
1d76 2b				dec hl 
1d77 2b				dec hl 
1d78 22 06 eb			ld (cli_loop_sp), hl 
1d7b				; TODO do stack underflow checks 
1d7b e1				pop hl 
1d7c				if DEBUG_FORTH_STACK_GUARD 
1d7c cd 45 57				call check_stacks 
1d7f					FORTH_CHK_LOOP_UNDER 
1d7f e5				push hl 
1d80 d5				push de 
1d81 2a 06 eb			ld hl,(cli_loop_sp) 
1d84 11 40 ea			ld de, cli_loop_stack 
1d87 cd a4 0c			call cmp16 
1d8a da 5f 58			jp c, fault_loop_under 
1d8d d1				pop de 
1d8e e1				pop hl 
1d8f				endm 
# End of macro FORTH_CHK_LOOP_UNDER
1d8f				endif 
1d8f c9				ret 
1d90			 
1d90			macro_forth_dsp_pop: 
1d90			 
1d90 e5				push hl 
1d91			 
1d91				; release malloc data 
1d91			 
1d91				if DEBUG_FORTH_STACK_GUARD 
1d91 cd 45 57				call check_stacks 
1d94					FORTH_CHK_DSP_UNDER 
1d94 e5				push hl 
1d95 d5				push de 
1d96 2a 04 eb			ld hl,(cli_data_sp) 
1d99 11 3e e9			ld de, cli_data_stack 
1d9c cd a4 0c			call cmp16 
1d9f da 53 58			jp c, fault_dsp_under 
1da2 d1				pop de 
1da3 e1				pop hl 
1da4				endm 
# End of macro FORTH_CHK_DSP_UNDER
1da4				endif 
1da4				;ld hl,(cli_data_sp) 
1da4			if DEBUG_FORTH_DOT 
1da4				DMARK "DPP" 
1da4				CALLMONITOR 
1da4			endif	 
1da4			 
1da4			 
1da4			if FORTH_ENABLE_DSPPOPFREE 
1da4			 
1da4				FORTH_DSP 
1da4 cd 9e 1c			call macro_forth_dsp 
1da7				endm 
# End of macro FORTH_DSP
1da7			 
1da7 7e				ld a, (hl) 
1da8 fe 01			cp DS_TYPE_STR 
1daa 20 07			jr nz, .skippopfree 
1dac			 
1dac				FORTH_DSP_VALUEHL 
1dac cd d8 1c			call macro_dsp_valuehl 
1daf				endm 
# End of macro FORTH_DSP_VALUEHL
1daf 00				nop 
1db0			if DEBUG_FORTH_DOT 
1db0				DMARK "DPf" 
1db0				CALLMONITOR 
1db0			endif	 
1db0 cd 17 12			call free 
1db3			.skippopfree: 
1db3				 
1db3			 
1db3			endif 
1db3			 
1db3			if DEBUG_FORTH_DOT_KEY 
1db3				DMARK "DP2" 
1db3				CALLMONITOR 
1db3			endif	 
1db3			 
1db3				; move pointer down 
1db3			 
1db3 2a 04 eb			ld hl,(cli_data_sp) 
1db6 2b				dec hl 
1db7 2b				dec hl 
1db8			; PARSEV5 
1db8 2b				dec hl 
1db9 22 04 eb			ld (cli_data_sp), hl 
1dbc			 
1dbc				if DEBUG_FORTH_STACK_GUARD 
1dbc cd 45 57				call check_stacks 
1dbf					FORTH_CHK_DSP_UNDER 
1dbf e5				push hl 
1dc0 d5				push de 
1dc1 2a 04 eb			ld hl,(cli_data_sp) 
1dc4 11 3e e9			ld de, cli_data_stack 
1dc7 cd a4 0c			call cmp16 
1dca da 53 58			jp c, fault_dsp_under 
1dcd d1				pop de 
1dce e1				pop hl 
1dcf				endm 
# End of macro FORTH_CHK_DSP_UNDER
1dcf				endif 
1dcf			 
1dcf e1				pop hl 
1dd0			 
1dd0 c9				ret 
1dd1			 
1dd1			getwordathl: 
1dd1				; hl points to an address 
1dd1				; load hl with the word at that address 
1dd1			 
1dd1 d5				push de 
1dd2			 
1dd2 5e				ld e, (hl) 
1dd3 23				inc hl 
1dd4 56				ld d, (hl) 
1dd5 eb				ex de, hl 
1dd6			 
1dd6 d1				pop de 
1dd7 c9				ret 
1dd8			 
1dd8			 
1dd8			 
1dd8			 
1dd8			 
1dd8			; eof 
1dd8			 
# End of file forth_stackopsv5.asm
1dd8			endif 
1dd8			 
1dd8			user_word_eol:  
1dd8				; hl contains the pointer to where to create a linked list item from the end 
1dd8				; of the user dict to continue on at the system word dict 
1dd8				 
1dd8				; poke the stub of the word list linked list to repoint to rom words 
1dd8			 
1dd8				; stub format 
1dd8				; db   word id 
1dd8				; dw    link to next word 
1dd8			        ; db char length of token 
1dd8				; db string + 0 term 
1dd8				; db exec code....  
1dd8			 
1dd8 3e 00			ld a, WORD_SYS_ROOT     ; root word 
1dda 77				ld (hl), a		; word id 
1ddb 23				inc hl 
1ddc			 
1ddc 11 a2 1f			ld de, sysdict 
1ddf 73				ld (hl), e		; next word link ie system dict 
1de0 23				inc hl 
1de1 72				ld (hl), d		; next word link ie system dict 
1de2 23				inc hl	 
1de3			 
1de3			;	ld (hl), sysdict		; next word link ie system dict 
1de3			;	inc hl 
1de3			;	inc hl 
1de3			 
1de3			;	inc hl 
1de3			;	inc hl 
1de3			 
1de3 3e 02			ld a, 2			; word length is 0 
1de5 77				ld (hl), a	 
1de6 23				inc hl 
1de7			 
1de7 3e 7e			ld a, '~'			; word length is 0 
1de9 77				ld (hl), a	 
1dea 23				inc hl 
1deb 3e 00			ld a, 0			; save empty word 
1ded 77				ld (hl), a 
1dee			 
1dee c9				ret 
1def			 
1def				 
1def			 
1def			forthexec_cleanup: 
1def				FORTH_RSP_POP 
1def cd a9 1a			call macro_forth_rsp_pop 
1df2				endm 
# End of macro FORTH_RSP_POP
1df2 c9				ret 
1df3			 
1df3			forth_call_hl: 
1df3				; taking hl 
1df3 e5				push hl 
1df4 c9				ret 
1df5			 
1df5			; this is called to reset Forth system but keep existing uwords etc 
1df5			 
1df5			forth_warmstart: 
1df5				; setup stack over/under flow checks 
1df5				if DEBUG_FORTH_STACK_GUARD 
1df5 cd 2b 57				call chk_stk_init 
1df8				endif 
1df8			 
1df8				; init stack pointers  - * these stacks go upwards *  
1df8 21 c2 ea			ld hl, cli_ret_stack 
1dfb 22 08 eb			ld (cli_ret_sp), hl	 
1dfe				; set bottom of stack 
1dfe 3e 00			ld a,0 
1e00 77				ld (hl),a 
1e01 23				inc hl 
1e02 77				ld (hl),a 
1e03			 
1e03 21 3e e9			ld hl, cli_data_stack 
1e06 22 04 eb			ld (cli_data_sp), hl	 
1e09				; set bottom of stack 
1e09 3e 00			ld a,0 
1e0b 77				ld (hl),a 
1e0c 23				inc hl 
1e0d 77				ld (hl),a 
1e0e			 
1e0e 21 40 ea			ld hl, cli_loop_stack 
1e11 22 06 eb			ld (cli_loop_sp), hl	 
1e14				; set bottom of stack 
1e14 3e 00			ld a,0 
1e16 77				ld (hl),a 
1e17 23				inc hl 
1e18 77				ld (hl),a 
1e19			 
1e19				; init extent of current open file 
1e19			 
1e19 3e 00			ld a, 0 
1e1b 32 53 eb			ld (store_openext), a 
1e1e			 
1e1e c9				ret 
1e1f			 
1e1f			 
1e1f			; Cold Start - this is called to setup the whole Forth system 
1e1f			 
1e1f			forth_init: 
1e1f			 
1e1f				; setup stack over/under flow checks 
1e1f			 
1e1f			;	if DEBUG_FORTH_STACK_GUARD 
1e1f			;		call chk_stk_init 
1e1f			;	endif 
1e1f			 
1e1f				; enable auto display updates (slow.....) 
1e1f			 
1e1f 3e 01			ld a, 1 
1e21 32 1e eb			ld (cli_autodisplay), a 
1e24			 
1e24			 
1e24			 
1e24				; show start up screen 
1e24			 
1e24 cd 59 0a			call clear_display 
1e27			 
1e27 3e 00			ld a,0 
1e29 32 40 eb			ld (f_cursor_ptr), a 
1e2c			 
1e2c				; set start of word list in start of ram - for use when creating user words 
1e2c			 
1e2c 21 4e 5a			ld hl, baseram 
1e2f 22 d4 e6			ld (os_last_new_uword), hl 
1e32 cd d8 1d			call user_word_eol 
1e35				 
1e35			;		call display_data_sp 
1e35			;		call next_page_prompt 
1e35			 
1e35			 
1e35			 
1e35			 
1e35 c9				ret 
1e36			 
1e36 .. 00		.bootforth: db " Forth Kernel Init ",0 
1e4a			 
1e4a			; TODO push to stack 
1e4a			 
1e4a			;  
1e4a			 
1e4a			if FORTH_PARSEV2 
1e4a			 
1e4a			 
1e4a				include "forth_parserv2.asm" 
1e4a			 
1e4a			endif 
1e4a			 
1e4a			 
1e4a			; parse cli version 1 
1e4a			 
1e4a			if FORTH_PARSEV1 
1e4a			 
1e4a			 
1e4a			 
1e4a			      include "forth_parserv1.asm" 
1e4a			endif 
1e4a				 
1e4a			if FORTH_PARSEV3 
1e4a			 
1e4a			 
1e4a			 
1e4a			      include "forth_parserv3.asm" 
1e4a				include "forth_wordsv3.asm" 
1e4a			endif 
1e4a			 
1e4a			if FORTH_PARSEV4 
1e4a			 
1e4a			 
1e4a			 
1e4a			      include "forth_parserv4.asm" 
1e4a				include "forth_wordsv4.asm" 
1e4a			endif 
1e4a			 
1e4a			if FORTH_PARSEV5 
1e4a			 
1e4a			 
1e4a			 
1e4a			      include "forth_parserv5.asm" 
1e4a			 
1e4a			 
1e4a			; A better parser without using malloc and string copies all over the place.  
1e4a			; Exec in situ should be faster 
1e4a			 
1e4a			;WORD_SYS_LOWPRIM: equ 4    ; Offset for low level prim words opcode 
1e4a			;WORD_SYS_BRANCH: equ 10    ; Offset for branching and loop words opcode 
1e4a			WORD_SYS_UWORD: equ 1   ; Opcode for all user words 
1e4a			WORD_SYS_DELETED: equ 3 ; Op code for a deleted UWORD 
1e4a			WORD_SYS_ROOT: equ 0   ; Opcode for all user words 
1e4a			WORD_SYS_END: equ 0   ; Opcode for all user words 
1e4a			WORD_SYS_CORE: equ 20    ; Offset for dict core words opcode 
1e4a			WORD_FLAG_CODE: equ 0	   ; opcodeflag to exec pure code for this word 
1e4a			WORD_FLAG_JP: equ 1	   ; opcodeflag to list zero term jump table words 
1e4a			 
1e4a			; Core word preamble macro 
1e4a			 
1e4a			CWHEAD:   macro nxtword opcode lit len opflags 
1e4a				db WORD_SYS_CORE+opcode             
1e4a				; internal op code number 
1e4a				dw nxtword            
1e4a				; link to next dict word block 
1e4a				db len + 1 
1e4a				; literal length of dict word inc zero term 
1e4a				db lit,0              
1e4a				; literal dict word 
1e4a			        ; TODO db opflags        
1e4a				endm 
1e4a			 
1e4a			 
1e4a			NEXTW: macro  
1e4a				jp macro_next 
1e4a				endm 
1e4a			 
1e4a			macro_next: 
1e4a			if DEBUG_FORTH_PARSE_KEY 
1e4a				DMARK "NXT" 
1e4a				CALLMONITOR 
1e4a			endif	 
1e4a			;	inc hl  ; skip token null term  
1e4a ed 4b 22 eb		ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1e4e ed 5b 20 eb		ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1e52 2a d8 e6			ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1e55			if DEBUG_FORTH_PARSE_KEY 
1e55				DMARK "}AA" 
1e55				CALLMONITOR 
1e55			endif	 
1e55 c3 58 1f			jp execnext 
1e58				;jp exec1 
1e58			       
1e58			 
1e58			 
1e58			; Another go at the parser to compile  
1e58			 
1e58			 
1e58			; TODO rework parser to change all of the string words to byte tokens 
1e58			; TODO do a search for  
1e58			 
1e58			; TODO first run normal parser to zero term sections 
1e58			; TODO for each word do a token look up to get the op code 
1e58			; TODO need some means to flag to the exec that this is a byte code form    
1e58			 
1e58			 
1e58			forthcompile: 
1e58			 
1e58			; 
1e58			; line parse: 
1e58			;       parse raw input buffer 
1e58			;       tokenise the words 
1e58			;       malloc new copy (for looping etc) 
1e58			;       copy to malloc + current pc in line to start of string and add line term 
1e58			;       save on new rsp 
1e58			; 
1e58			 
1e58			; hl to point to the line to tokenise 
1e58			 
1e58			;	push hl 
1e58 22 d8 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1e5b			 
1e5b			;	ld a,0		; string term on input 
1e5b			;	call strlent 
1e5b			 
1e5b			;	ld (os_tok_len), hl	 ; save string length 
1e5b			 
1e5b			;if DEBUG_FORTH_TOK 
1e5b			;	ex de,hl		 
1e5b			;endif 
1e5b			 
1e5b			;	pop hl 		; get back string pointer 
1e5b			 
1e5b			if DEBUG_FORTH_TOK 
1e5b						DMARK "TOc" 
1e5b				CALLMONITOR 
1e5b			endif 
1e5b 7e			.cptoken2:    ld a,(hl) 
1e5c 23				inc hl 
1e5d fe 7f			cp FORTH_END_BUFFER 
1e5f 28 29			jr z, .cptokendone2 
1e61 fe 00			cp 0 
1e63 28 25			jr z, .cptokendone2 
1e65 fe 22			cp '"' 
1e67 28 0b			jr z, .cptokenstr2     ; will want to skip until end of string delim 
1e69 fe 20			cp ' ' 
1e6b 20 ee			jr nz,  .cptoken2 
1e6d			 
1e6d			; TODO consume comments held between ( and ) 
1e6d			 
1e6d				; we have a space so change to zero term for dict match later 
1e6d 2b				dec hl 
1e6e 3e 00			ld a,0 
1e70 77				ld (hl), a 
1e71 23				inc hl 
1e72 18 e7			jr .cptoken2 
1e74				 
1e74			 
1e74			.cptokenstr2: 
1e74				; skip all white space until either eol (because forgot to term) or end double quote 
1e74			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1e74				;inc hl ; skip current double quote 
1e74 7e				ld a,(hl) 
1e75 23				inc hl 
1e76 fe 22			cp '"' 
1e78 28 e1			jr z, .cptoken2 
1e7a fe 7f			cp FORTH_END_BUFFER 
1e7c 28 0c			jr z, .cptokendone2 
1e7e fe 00			cp 0 
1e80 28 08			jr z, .cptokendone2 
1e82 fe 20			cp ' ' 
1e84 28 02			jr z, .cptmp2 
1e86 18 ec			jr .cptokenstr2 
1e88			 
1e88			.cptmp2:	; we have a space so change to zero term for dict match later 
1e88				;dec hl 
1e88				;ld a,"-"	; TODO remove this when working 
1e88				;ld (hl), a 
1e88				;inc hl 
1e88 18 ea			jr .cptokenstr2 
1e8a			 
1e8a			.cptokendone2: 
1e8a				;inc hl 
1e8a 3e 7f			ld a, FORTH_END_BUFFER 
1e8c 77				ld (hl),a 
1e8d 23				inc hl 
1e8e 3e 21			ld a, '!' 
1e90 77				ld (hl),a 
1e91			 
1e91 2a d8 e6			ld hl,(os_tok_ptr) 
1e94			         
1e94			if DEBUG_FORTH_TOK 
1e94						DMARK "Tc1" 
1e94				CALLMONITOR 
1e94			endif 
1e94			 
1e94				; push exec string to top of return stack 
1e94				FORTH_RSP_NEXT 
1e94 cd 88 1a			call macro_forth_rsp_next 
1e97				endm 
# End of macro FORTH_RSP_NEXT
1e97 c9				ret 
1e98			 
1e98			; Another go at the parser need to simplify the process 
1e98			 
1e98			forthparse: 
1e98			 
1e98			; 
1e98			; line parse: 
1e98			;       parse raw input buffer 
1e98			;       tokenise the words 
1e98			;       malloc new copy (for looping etc) 
1e98			;       copy to malloc + current pc in line to start of string and add line term 
1e98			;       save on new rsp 
1e98			; 
1e98			 
1e98			; hl to point to the line to tokenise 
1e98			 
1e98			;	push hl 
1e98 22 d8 e6			ld (os_tok_ptr), hl  ; save ptr to string 
1e9b			 
1e9b			;	ld a,0		; string term on input 
1e9b			;	call strlent 
1e9b			 
1e9b			;	ld (os_tok_len), hl	 ; save string length 
1e9b			 
1e9b			;if DEBUG_FORTH_TOK 
1e9b			;	ex de,hl		 
1e9b			;endif 
1e9b			 
1e9b			;	pop hl 		; get back string pointer 
1e9b			 
1e9b			if DEBUG_FORTH_TOK 
1e9b						DMARK "TOK" 
1e9b				CALLMONITOR 
1e9b			endif 
1e9b 7e			.ptoken2:    ld a,(hl) 
1e9c 23				inc hl 
1e9d fe 7f			cp FORTH_END_BUFFER 
1e9f 28 29			jr z, .ptokendone2 
1ea1 fe 00			cp 0 
1ea3 28 25			jr z, .ptokendone2 
1ea5 fe 22			cp '"' 
1ea7 28 0b			jr z, .ptokenstr2     ; will want to skip until end of string delim 
1ea9 fe 20			cp ' ' 
1eab 20 ee			jr nz,  .ptoken2 
1ead			 
1ead			; TODO consume comments held between ( and ) 
1ead			 
1ead				; we have a space so change to zero term for dict match later 
1ead 2b				dec hl 
1eae 3e 00			ld a,0 
1eb0 77				ld (hl), a 
1eb1 23				inc hl 
1eb2 18 e7			jr .ptoken2 
1eb4				 
1eb4			 
1eb4			.ptokenstr2: 
1eb4				; skip all white space until either eol (because forgot to term) or end double quote 
1eb4			        ;   if double quotes spotted ensure to skip any space sep until matched doble quote 
1eb4				;inc hl ; skip current double quote 
1eb4 7e				ld a,(hl) 
1eb5 23				inc hl 
1eb6 fe 22			cp '"' 
1eb8 28 e1			jr z, .ptoken2 
1eba fe 7f			cp FORTH_END_BUFFER 
1ebc 28 0c			jr z, .ptokendone2 
1ebe fe 00			cp 0 
1ec0 28 08			jr z, .ptokendone2 
1ec2 fe 20			cp ' ' 
1ec4 28 02			jr z, .ptmp2 
1ec6 18 ec			jr .ptokenstr2 
1ec8			 
1ec8			.ptmp2:	; we have a space so change to zero term for dict match later 
1ec8				;dec hl 
1ec8				;ld a,"-"	; TODO remove this when working 
1ec8				;ld (hl), a 
1ec8				;inc hl 
1ec8 18 ea			jr .ptokenstr2 
1eca			 
1eca			.ptokendone2: 
1eca				;inc hl 
1eca 3e 7f			ld a, FORTH_END_BUFFER 
1ecc 77				ld (hl),a 
1ecd 23				inc hl 
1ece 3e 21			ld a, '!' 
1ed0 77				ld (hl),a 
1ed1			 
1ed1 2a d8 e6			ld hl,(os_tok_ptr) 
1ed4			         
1ed4			if DEBUG_FORTH_TOK 
1ed4						DMARK "TK1" 
1ed4				CALLMONITOR 
1ed4			endif 
1ed4			 
1ed4				; push exec string to top of return stack 
1ed4				FORTH_RSP_NEXT 
1ed4 cd 88 1a			call macro_forth_rsp_next 
1ed7				endm 
# End of macro FORTH_RSP_NEXT
1ed7 c9				ret 
1ed8			 
1ed8			; 
1ed8			;	; malloc size + buffer pointer + if is loop flag 
1ed8			;	ld hl,(os_tok_len) 		 ; get string length 
1ed8			; 
1ed8			;	ld a,l 
1ed8			; 
1ed8			;	cp 0			; we dont want to use a null string 
1ed8			;	ret z 
1ed8			; 
1ed8			;;	add 3    ; prefix malloc with buffer for current word ptr 
1ed8			; 
1ed8			;	add 5     ; TODO when certain not over writing memory remove 
1ed8			; 
1ed8			;		 
1ed8			; 
1ed8			;if DEBUG_FORTH_TOK 
1ed8			;			DMARK "TKE" 
1ed8			;	CALLMONITOR 
1ed8			;endif 
1ed8			; 
1ed8			;	ld l,a 
1ed8			;	ld h,0 
1ed8			;;	push hl   ; save required space for the copy later 
1ed8			;	call malloc 
1ed8			;if DEBUG_FORTH_TOK 
1ed8			;			DMARK "TKM" 
1ed8			;	CALLMONITOR 
1ed8			;endif 
1ed8			;	if DEBUG_FORTH_MALLOC_GUARD 
1ed8			;		push af 
1ed8			;		call ishlzero 
1ed8			;;		ld a, l 
1ed8			;;		add h 
1ed8			;;		cp 0 
1ed8			;		pop af 
1ed8			;		 
1ed8			;		call z,malloc_error 
1ed8			;	endif 
1ed8			;	ld (os_tok_malloc), hl	 ; save malloc ptr 
1ed8			; 
1ed8			; 
1ed8			;if DEBUG_FORTH_TOK 
1ed8			;			DMARK "TKR" 
1ed8			;	CALLMONITOR 
1ed8			;endif 
1ed8			; 
1ed8			;	FORTH_RSP_NEXT 
1ed8			; 
1ed8			;	;inc hl	 ; go past current buffer pointer 
1ed8			;	;inc hl 
1ed8			;	;inc hl   ; and past if loop flag 
1ed8			;		; TODO Need to set flag  
1ed8			; 
1ed8			;	 
1ed8			;	 
1ed8			;	ex de,hl	; malloc is dest 
1ed8			;	ld hl, (os_tok_len) 
1ed8			;;	pop bc 
1ed8			;	ld c, l                
1ed8			;	ld b,0 
1ed8			;	ld hl, (os_tok_ptr) 
1ed8			; 
1ed8			;if DEBUG_FORTH_TOK 
1ed8			;			DMARK "TKT" 
1ed8			;	CALLMONITOR 
1ed8			;endif 
1ed8			; 
1ed8			;	; do str cpy 
1ed8			; 
1ed8			;	ldir      ; copy byte in hl to de 
1ed8			; 
1ed8			;	; set end of buffer to high bit on zero term and use that for end of buffer scan 
1ed8			; 
1ed8			;if DEBUG_FORTH_TOK 
1ed8			; 
1ed8			;			DMARK "TKY" 
1ed8			;	CALLMONITOR 
1ed8			;endif 
1ed8			;	;ld a,0 
1ed8			;	;ld a,FORTH_END_BUFFER 
1ed8			;	ex de, hl 
1ed8			;	;dec hl			 ; go back over the space delim at the end of word 
1ed8			;	;ld (hl),a 
1ed8			;	;inc hl                    ;  TODO double check this. Going past the end of string to make sure end of processing buffer is marked 
1ed8			;	ld a,FORTH_END_BUFFER 
1ed8			;	ld (hl),a 
1ed8			;	inc hl 
1ed8			;	ld a,FORTH_END_BUFFER 
1ed8			;	ld (hl),a 
1ed8			; 
1ed8			;	; init the malloc area data 
1ed8			;	; set pc for in current area 
1ed8			;	;ld hl, (os_tok_malloc) 
1ed8			;	;inc hl 
1ed8			;	;inc hl 
1ed8			;	;inc hl 
1ed8			;	;ex de,hl 
1ed8			;	;ld hl, (os_tok_malloc) 
1ed8			;	;ld (hl),e 
1ed8			;	;inc hl 
1ed8			;	;ld (hl),d 
1ed8			; 
1ed8			; 
1ed8			;	ld hl,(os_tok_malloc) 
1ed8			;if DEBUG_FORTH_PARSE_KEY 
1ed8			;			DMARK "TKU" 
1ed8			;	CALLMONITOR 
1ed8			;endif 
1ed8			; 
1ed8			;	ret 
1ed8			 
1ed8			forthexec: 
1ed8			 
1ed8			; line exec: 
1ed8			; forth parser 
1ed8			 
1ed8			; 
1ed8			;       get current exec line on rsp 
1ed8			 
1ed8				FORTH_RSP_TOS 
1ed8 cd 9f 1a			call macro_forth_rsp_tos 
1edb				endm 
# End of macro FORTH_RSP_TOS
1edb			 
1edb			;       restore current pc - hl points to malloc of data 
1edb			 
1edb				;ld e, (hl) 
1edb				;inc hl 
1edb				;ld d, (hl) 
1edb				;ex de,hl 
1edb			 
1edb			 
1edb			exec1: 
1edb 22 d8 e6			ld (os_tok_ptr), hl 
1ede			 
1ede				; copy our PC to working vars  
1ede 22 22 eb			ld (cli_ptr), hl 
1ee1 22 20 eb			ld (cli_origptr), hl 
1ee4			 
1ee4 7e				ld a,(hl) 
1ee5 fe 7f			cp FORTH_END_BUFFER 
1ee7 c8				ret z 
1ee8			 
1ee8				; skip any nulls 
1ee8			 
1ee8 fe 00			cp 0 
1eea 20 03			jr nz, .execword 
1eec 23				inc hl 
1eed 18 ec			jr exec1 
1eef			 
1eef			 
1eef			.execword: 
1eef			 
1eef			 
1eef			 
1eef			if DEBUG_FORTH_PARSE_KEY 
1eef						DMARK "KYQ" 
1eef				CALLMONITOR 
1eef			endif 
1eef			;       while at start of word: 
1eef			; get start of dict (in user area first) 
1eef			 
1eef 21 4e 5a		ld hl, baseram 
1ef2			;ld hl, sysdict 
1ef2 22 24 eb		ld (cli_nextword),hl 
1ef5			;           match word at pc 
1ef5			;           exec word 
1ef5			;           or push to dsp 
1ef5			;           forward to next token 
1ef5			;           if line term pop rsp and exit 
1ef5			;        
1ef5			 
1ef5			if DEBUG_FORTH_PARSE_KEY 
1ef5						DMARK "KYq" 
1ef5				CALLMONITOR 
1ef5			endif 
1ef5			 
1ef5			; 
1ef5			; word comp 
1ef5			;    get compiled byte and save it (need to decide if code is compiled or not for comparison) 
1ef5			;    if byte is 0 then end parsing and report failed lookup (or could be something to add to stack etc) 
1ef5			;    move to start of word  
1ef5			;    compare word to cli_token 
1ef5			 
1ef5			.execpnword:	; HL at start of a word in the dictionary to check 
1ef5			;	ld hl,(cli_origptr)	 ; reset start of word to look up 
1ef5			;	ld (cli_ptr), hl 
1ef5			 
1ef5 2a 24 eb			ld hl,(cli_nextword) 
1ef8			 
1ef8 cd 9b 1f			call forth_tok_next 
1efb			; tok next start here 
1efb			;	; TODO skip compiled symbol for now 
1efb			;	inc hl 
1efb			; 
1efb			;	; save pointer to next word 
1efb			; 
1efb			;	; hl now points to the address of the next word pointer  
1efb			;	ld e, (hl) 
1efb			;	inc hl 
1efb			;	ld d, (hl) 
1efb			;	inc l 
1efb			; 
1efb			;	ex de,hl 
1efb			;if DEBUG_FORTH_PARSE_NEXTWORD 
1efb			;	push bc 
1efb			;	ld bc, (cli_nextword) 
1efb			;			DMARK "NXW" 
1efb			;	CALLMONITOR 
1efb			;	pop bc 
1efb			;endif 
1efb			; tok next end here 
1efb 22 24 eb			ld (cli_nextword), hl     ; save for next check if no match on this word 
1efe eb				ex de, hl 
1eff			 
1eff			 
1eff				; save the pointer of the current token - 1 to check against 
1eff				 
1eff 22 28 eb			ld (cli_token), hl   
1f02				; TODO maybe remove below save if no debug 
1f02				; save token string ptr for any debug later 
1f02 23				inc hl  
1f03 22 2a eb			ld (cli_origtoken), hl 
1f06 2b				dec hl 
1f07				; save pointer to the start of the next dictionay word 
1f07 7e				ld a,(hl)   ; get string length 
1f08 47				ld b,a 
1f09			.execpnwordinc:  
1f09 23				inc hl 
1f0a 10 fd			djnz .execpnwordinc 
1f0c 22 26 eb			ld (cli_execword), hl      ; save start of this words code 
1f0f			 
1f0f				; now check the word token against the string being parsed 
1f0f			 
1f0f 2a 28 eb			ld hl,(cli_token) 
1f12 23				inc hl     ; skip string length (use zero term instead to end) 
1f13 22 28 eb			ld (cli_token), hl 
1f16			 
1f16			if DEBUG_FORTH_PARSE_KEY 
1f16						DMARK "KY2" 
1f16			endif 
1f16			if DEBUG_FORTH_PARSE_EXEC 
1f16				; see if disabled 
1f16			 
1f16				ld a, (os_view_disable) 
1f16				cp '*' 
1f16				jr z, .skip 
1f16			 
1f16				push hl 
1f16				push hl 
1f16				call clear_display 
1f16				ld de, .compword 
1f16				ld a, display_row_1 
1f16				call str_at_display 
1f16				pop de 
1f16				ld a, display_row_2 
1f16				call str_at_display 
1f16				ld hl,(cli_ptr) 
1f16				ld a,(hl) 
1f16			        ld hl, os_word_scratch 
1f16				ld (hl),a 
1f16				ld a,0 
1f16				inc hl 
1f16				ld (hl),a 	 
1f16				ld de, os_word_scratch 
1f16				ld a, display_row_2+10 
1f16				call str_at_display 
1f16				call update_display 
1f16				ld a, 100 
1f16				call aDelayInMS 
1f16				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f16				call delay250ms 
1f16				endif 
1f16				pop hl 
1f16			.skip:  
1f16			endif	 
1f16			.execpnchar:    ; compare char between token and string to parse 
1f16			 
1f16			if DEBUG_FORTH_PARSE_KEY 
1f16						DMARK "Ky3" 
1f16			endif 
1f16			if DEBUG_FORTH_PARSE_EXEC 
1f16				; see if disabled 
1f16			 
1f16				ld a, (os_view_disable) 
1f16				cp '*' 
1f16				jr z, .skip2 
1f16			 
1f16			;	call clear_display 
1f16			ld hl,(cli_token) 
1f16			ld a,(hl) 
1f16			ld (os_word_scratch),a 
1f16				ld hl,(cli_ptr) 
1f16			ld a,(hl) 
1f16				ld (os_word_scratch+1),a 
1f16				ld a,0 
1f16				ld (os_word_scratch+2),a 
1f16				ld de,os_word_scratch 
1f16				ld a,display_row_4 
1f16				call str_at_display 
1f16				call update_display 
1f16			.skip2:  
1f16			endif 
1f16 2a 28 eb			ld hl,(cli_token) 
1f19 7e				ld a, (hl)	 ; char in word token 
1f1a 23				inc hl 		; move to next char 
1f1b 22 28 eb			ld (cli_token), hl ; and save it 
1f1e 47				ld b,a 
1f1f			 
1f1f 2a 22 eb			ld hl,(cli_ptr) ;	get the char from the string to parse 
1f22 7e				ld a,(hl) 
1f23 23				inc hl 
1f24 22 22 eb			ld (cli_ptr), hl		; move to next char 
1f27 cd db 10			call toUpper 		; make sure the input string matches case 
1f2a			 
1f2a			if DEBUG_FORTH_PARSE 
1f2a			endif 
1f2a			 
1f2a				; input stream end of token is a space so get rid of it 
1f2a			 
1f2a			;	cp ' ' 
1f2a			;	jr nz, .pnskipspace 
1f2a			; 
1f2a			;	ld a, 0		; make same term as word token term 
1f2a			; 
1f2a			;.pnskipspace: 
1f2a			 
1f2a			if DEBUG_FORTH_PARSE_KEY 
1f2a						DMARK "KY7" 
1f2a			endif 
1f2a b8				cp b 
1f2b c2 41 1f			jp nz, .execpnskipword	 ; no match so move to next word 
1f2e				 
1f2e			;    if same 
1f2e			;       scan for string terms 0 for token and 32 for input 
1f2e			 
1f2e				 
1f2e			if DEBUG_FORTH_PARSE_KEY 
1f2e						DMARK "KY8" 
1f2e			endif 
1f2e			 
1f2e 80				add b			 
1f2f fe 00			cp 0			 ; add both chars together, if 32 then other must be 0 so at end of string we are parsing? 
1f31							; TODO need to make sure last word in zero term string is accounted for 
1f31 20 e3			jr nz, .execpnchar 		 ; not at end of strings yet 
1f33			 
1f33			 
1f33				; at end of both strings so both are exact match 
1f33			 
1f33			;       skip ptr for next word 
1f33			 
1f33 2a 22 eb			ld hl,(cli_ptr) 	; at input string term 
1f36 23				inc hl			 ; at next char 
1f37 22 22 eb			ld (cli_ptr), hl     ; save for next round of the parser 
1f3a 22 20 eb			ld (cli_origptr), hl     ; save for any restart of current string ie a number or string to push to data stack 
1f3d				 
1f3d				 
1f3d			if DEBUG_FORTH_PARSE_KEY 
1f3d						DMARK "KY3" 
1f3d			endif 
1f3d			 
1f3d			 
1f3d			 
1f3d			;       exec code block 
1f3d			if DEBUG_FORTH_JP 
1f3d				call clear_display 
1f3d				call update_display 
1f3d				call delay1s 
1f3d				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f3d				ld a,h 
1f3d				ld hl, os_word_scratch 
1f3d				call hexout 
1f3d				ld hl, (cli_execword)     ; save for next check if no match on this word 
1f3d				ld a,l 
1f3d				ld hl, os_word_scratch+2 
1f3d				call hexout 
1f3d				ld hl, os_word_scratch+4 
1f3d				ld a,0 
1f3d				ld (hl),a 
1f3d				ld de,os_word_scratch 
1f3d				call str_at_display 
1f3d					ld a, display_row_2 
1f3d					call str_at_display 
1f3d				ld de, (cli_origtoken) 
1f3d				ld a, display_row_1+10 
1f3d					call str_at_display 
1f3d			 
1f3d				ld a,display_row_1 
1f3d				ld de, .foundword 
1f3d				ld a, display_row_3 
1f3d				call str_at_display 
1f3d				call update_display 
1f3d				call delay1s 
1f3d				call delay1s 
1f3d				call delay1s 
1f3d			endif 
1f3d			 
1f3d			if DEBUG_FORTH_PARSE_KEY 
1f3d						DMARK "KYj" 
1f3d			endif 
1f3d				; TODO save the word pointer in this exec 
1f3d			 
1f3d 2a 26 eb			ld hl,(cli_execword) 
1f40 e9				jp (hl) 
1f41			 
1f41			 
1f41			;    if not same 
1f41			;	scan for zero term 
1f41			;	get ptr for next word 
1f41			;	goto word comp 
1f41			 
1f41			.execpnskipword:	; get pointer to next word 
1f41 2a 24 eb			ld hl,(cli_nextword) 
1f44			 
1f44 7e				ld a,(hl) 
1f45 fe 00			cp WORD_SYS_END 
1f47			;	cp 0 
1f47 28 09			jr z, .execendofdict			 ; at end of words 
1f49			 
1f49			if DEBUG_FORTH_PARSE_KEY 
1f49						DMARK "KY4" 
1f49			endif 
1f49			if DEBUG_FORTH_PARSE_EXEC 
1f49			 
1f49				; see if disabled 
1f49			 
1f49				ld a, (os_view_disable) 
1f49				cp '*' 
1f49				jr z, .noskip 
1f49			 
1f49			 
1f49				ld de, .nowordfound 
1f49				ld a, display_row_3 
1f49				call str_at_display 
1f49				call update_display 
1f49				ld a, 100 
1f49				call aDelayInMS 
1f49				 
1f49				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f49					call delay250ms 
1f49				endif 
1f49			.noskip:  
1f49			 
1f49			endif	 
1f49			 
1f49 2a 20 eb			ld hl,(cli_origptr) 
1f4c 22 22 eb			ld (cli_ptr),hl 
1f4f			 
1f4f			if DEBUG_FORTH_PARSE_KEY 
1f4f						DMARK "KY5" 
1f4f			endif 
1f4f c3 f5 1e			jp .execpnword			; else go to next word 
1f52			 
1f52			.execendofdict:  
1f52			 
1f52			if DEBUG_FORTH_PARSE_KEY 
1f52						DMARK "KYe" 
1f52			endif 
1f52			if DEBUG_FORTH_PARSE_EXEC 
1f52				; see if disabled 
1f52			 
1f52				ld a, (os_view_disable) 
1f52				cp '*' 
1f52				jr z, .ispskip 
1f52			 
1f52				call clear_display 
1f52				call update_display 
1f52				call delay1s 
1f52				ld de, (cli_origptr) 
1f52				ld a, display_row_1 
1f52				call str_at_display 
1f52				 
1f52				ld de, .enddict 
1f52				ld a, display_row_3 
1f52				call str_at_display 
1f52				call update_display 
1f52				ld a, 100 
1f52				call aDelayInMS 
1f52				if DEBUG_FORTH_PARSE_EXEC_SLOW 
1f52				call delay1s 
1f52				call delay1s 
1f52				call delay1s 
1f52				endif 
1f52			.ispskip:  
1f52				 
1f52			endif	 
1f52			 
1f52			 
1f52			 
1f52				; if the word is not a keyword then must be a literal so push it to stack 
1f52			 
1f52			; push token to stack to end of word 
1f52			 
1f52				STACKFRAME ON $1efe $2f9f 
1f52				if DEBUG_STACK_IMB 
1f52					if ON 
1f52						exx 
1f52						ld de, $1efe 
1f52						ld a, d 
1f52						ld hl, curframe 
1f52						call hexout 
1f52						ld a, e 
1f52						ld hl, curframe+2 
1f52						call hexout 
1f52						ld hl, $1efe 
1f52						push hl 
1f52						ld hl, $2f9f 
1f52						push hl 
1f52						exx 
1f52					endif 
1f52				endif 
1f52			endm 
# End of macro STACKFRAME
1f52			 
1f52 2a d8 e6		ld hl,(os_tok_ptr) 
1f55 cd 4a 1c		call forth_apush 
1f58			 
1f58				STACKFRAMECHK ON $1efe $2f9f 
1f58				if DEBUG_STACK_IMB 
1f58					if ON 
1f58						exx 
1f58						ld hl, $2f9f 
1f58						pop de   ; $2f9f 
1f58						call cmp16 
1f58						jr nz, .spnosame 
1f58						ld hl, $1efe 
1f58						pop de   ; $1efe 
1f58						call cmp16 
1f58						jr z, .spfrsame 
1f58						.spnosame: call showsperror 
1f58						.spfrsame: nop 
1f58						exx 
1f58					endif 
1f58				endif 
1f58			endm 
# End of macro STACKFRAMECHK
1f58			 
1f58			execnext: 
1f58			 
1f58			if DEBUG_FORTH_PARSE_KEY 
1f58						DMARK "KY>" 
1f58			endif 
1f58			; move past token to next word 
1f58			 
1f58 2a d8 e6		ld hl, (os_tok_ptr) 
1f5b 3e 00		ld a, 0 
1f5d 01 ff 00		ld bc, 255     ; input buffer size 
1f60 ed b1		cpir 
1f62			 
1f62			if DEBUG_FORTH_PARSE_KEY 
1f62						DMARK "KY!" 
1f62				CALLMONITOR 
1f62			endif	 
1f62			; TODO this might place hl on the null, so will need to forward on??? 
1f62			;inc hl   ; see if this gets onto the next item 
1f62			 
1f62			 
1f62			; TODO pass a pointer to the buffer to push 
1f62			; TODO call function to push 
1f62			 
1f62			; look for end of input 
1f62			 
1f62			;inc hl 
1f62			;ld a,(hl) 
1f62			;cp FORTH_END_BUFFER 
1f62			;ret z 
1f62			 
1f62			 
1f62 c3 db 1e		jp exec1 
1f65			 
1f65			 
1f65			 
1f65			 
1f65			 
1f65			 
1f65			 
1f65			 
1f65			 
1f65			findnexttok: 
1f65			 
1f65				; hl is pointer to move 
1f65				; de is the token to locate 
1f65			 
1f65					if DEBUG_FORTH 
1f65						DMARK "NTK" 
1f65						CALLMONITOR 
1f65					endif 
1f65 d5				push de 
1f66			 
1f66			.fnt1:	 
1f66				; find first char of token to locate 
1f66			 
1f66 1a				ld a, (de) 
1f67 4f				ld c,a 
1f68 7e				ld a,(hl) 
1f69 cd db 10			call toUpper 
1f6c					if DEBUG_FORTH 
1f6c						DMARK "NT1" 
1f6c						CALLMONITOR 
1f6c					endif 
1f6c b9				cp c 
1f6d			 
1f6d 28 03			jr z, .fnt2cmpmorefirst	 
1f6f			 
1f6f				; first char not found move to next char 
1f6f			 
1f6f 23				inc hl 
1f70 18 f4			jr .fnt1 
1f72			 
1f72			.fnt2cmpmorefirst:	 
1f72				; first char of token found.  
1f72			 
1f72 e5				push hl     ; save start of token just in case it is the right one 
1f73 d9				exx 
1f74 e1				pop hl        ; save it to hl' 
1f75 d9				exx 
1f76			 
1f76			 
1f76			.fnt2cmpmore:	 
1f76				; compare the rest 
1f76				 
1f76 23				inc hl 
1f77 13				inc de 
1f78				 
1f78 1a				ld a, (de) 
1f79 4f				ld c,a 
1f7a 7e				ld a,(hl) 
1f7b cd db 10			call toUpper 
1f7e			 
1f7e					if DEBUG_FORTH 
1f7e						DMARK "NT2" 
1f7e						CALLMONITOR 
1f7e					endif 
1f7e				; c has the token to find char 
1f7e				; a has the mem to scan char 
1f7e			 
1f7e b9				cp c 
1f7f 28 04			jr z,.fntmatch1 
1f81			 
1f81				; they are not the same 
1f81			 
1f81					if DEBUG_FORTH 
1f81						DMARK "NT3" 
1f81						CALLMONITOR 
1f81					endif 
1f81 d1				pop de	; reset de token to look for 
1f82 d5				push de 
1f83 18 e1			jr .fnt1 
1f85				 
1f85			.fntmatch1: 
1f85			 
1f85				; is the same char a null which means we might have a full hit? 
1f85					if DEBUG_FORTH 
1f85						DMARK "NT4" 
1f85						CALLMONITOR 
1f85					endif 
1f85			 
1f85 fe 00			cp 0 
1f87 28 0b			jr z, .fntmatchyes 
1f89			 
1f89				; are we at the end of the token to find? 
1f89			 
1f89					if DEBUG_FORTH 
1f89						DMARK "NT5" 
1f89						CALLMONITOR 
1f89					endif 
1f89 3e 00			ld a, 0 
1f8b b9				cp c 
1f8c			 
1f8c c2 76 1f			jp nz, .fnt2cmpmore    ; no, so keep going to a direct hit 
1f8f			 
1f8f					if DEBUG_FORTH 
1f8f						DMARK "NT6" 
1f8f						CALLMONITOR 
1f8f					endif 
1f8f				; token to find is exhusted but no match to stream 
1f8f			 
1f8f				; restore tok pointer and continue on 
1f8f d1				pop de 
1f90 d5				push de 
1f91 c3 66 1f			jp .fnt1 
1f94			 
1f94			 
1f94			.fntmatchyes: 
1f94			 
1f94				; hl now contains the end of the found token 
1f94			 
1f94				; get rid of saved token pointer to find 
1f94			 
1f94 d1				pop de 
1f95			 
1f95					if DEBUG_FORTH 
1f95						DMARK "NT9" 
1f95						CALLMONITOR 
1f95					endif 
1f95			 
1f95				; hl will be on the null term so forward on 
1f95			 
1f95				; get back the saved start of the token 
1f95			 
1f95 d9				exx 
1f96 e5				push hl     ; save start of token just in case it is the right one 
1f97 d9				exx 
1f98 e1				pop hl        ; save it to hl 
1f99			 
1f99 c9				ret 
1f9a			 
1f9a			 
1f9a			; LIST needs to find a specific token   
1f9a			; FORGET needs to find a spefici token 
1f9a			 
1f9a			; SAVE needs to find all tokens by flag 
1f9a			; WORDS just needs to scan through all  by flag 
1f9a			; UWORDS needs to scan through all by flag 
1f9a			 
1f9a			 
1f9a			; given hl as pointer to start of dict look up string 
1f9a			; return hl as pointer to start of word block 
1f9a			; or 0 if not found 
1f9a			 
1f9a			forth_find_tok: 
1f9a c9				ret 
1f9b			 
1f9b			; given hl as pointer to dict structure 
1f9b			; move to the next dict block structure 
1f9b			 
1f9b			forth_tok_next: 
1f9b				; hl now points to the address of the next word pointer  
1f9b				; TODO skip compiled symbol for now 
1f9b			;	push de 
1f9b 23				inc hl 
1f9c 5e				ld e, (hl) 
1f9d 23				inc hl 
1f9e 56				ld d, (hl) 
1f9f 23				inc hl 
1fa0			 
1fa0 eb				ex de,hl 
1fa1			if DEBUG_FORTH_PARSE_NEXTWORD 
1fa1				push bc 
1fa1				ld bc, (cli_nextword) 
1fa1						DMARK "NXW" 
1fa1				CALLMONITOR 
1fa1				pop bc 
1fa1			endif 
1fa1			;	pop de	 
1fa1 c9				ret 
1fa2			 
1fa2			 
1fa2			 
1fa2			; eof 
# End of file forth_parserv5.asm
1fa2				include "forth_wordsv4.asm" 
1fa2			 
1fa2			; the core word dictionary v4 
1fa2			; https://www.complang.tuwien.ac.at/forth/gforth/Docs-html/Notation.html#Notation 
1fa2			 
1fa2			; this is a linked list for each of the system words used 
1fa2			; user defined words will follow the same format but will be in ram 
1fa2			 
1fa2			 
1fa2			; 
1fa2			; 
1fa2			; define linked list: 
1fa2			; 
1fa2			; 1. compiled byte op code 
1fa2			; 2. len of text word 
1fa2			; 3. text word 
1fa2			; 4. ptr to next dictionary word 
1fa2			; 5. asm, calls etc for the word 
1fa2			; 
1fa2			;  if 1 == 0 then last word in dict  
1fa2			;   
1fa2			; set the start of dictionary scanning to be in ram and the last word point to the system dict 
1fa2			;  
1fa2			;  
1fa2			; create basic standard set of words 
1fa2			; 
1fa2			;  
1fa2			; + - / * DUP EMIT . SWAP IF..THEN..ELSE DO..LOOP  : ; DROP  
1fa2			; 2DUP 2DROP 2SWAP  
1fa2			; @ C@ - get byte  
1fa2			; ! C! - store byte 
1fa2			; 0< true if less than zero 
1fa2			; 0= true if zero 
1fa2			; < >  
1fa2			; = true if same 
1fa2			; variables 
1fa2			 
1fa2			 
1fa2			; Hardware specific words I may need 
1fa2			; 
1fa2			; IN OUT  
1fa2			; calls to key util functions 
1fa2			; calls to hardward abstraction stuff 
1fa2			; easy control of frame buffers and lcd i/o 
1fa2			; keyboard  
1fa2			 
1fa2			 
1fa2			;DICT: macro 
1fa2			; op_code, len, word, next 
1fa2			;    word: 
1fa2			;    db op_code 
1fa2			;    ds word zero term 
1fa2			;    dw next 
1fa2			;    endm 
1fa2			 
1fa2			 
1fa2			 
1fa2			 
1fa2			; op code 1 is a flag for user define words which are to be handled differently 
1fa2			 
1fa2			 
1fa2			; 
1fa2			; 
1fa2			;    TODO on entry to a word this should be the expected environment 
1fa2			;    hl - tos value if number then held, if string this is the ptr 
1fa2			;    de -  
1fa2			 
1fa2			 
1fa2			; opcode ranges 
1fa2			; 0 - end of word dict 
1fa2			; 255 - user define words 
1fa2			 
1fa2			sysdict: 
1fa2			include "forth_opcodes.asm" 
1fa2			; op codes for forth keywords 
1fa2			; free to use code 0  
1fa2				OPCODE_HEAP: equ  1 
1fa2				OPCODE_EXEC: equ 2 
1fa2				OPCODE_DUP: equ 3 
1fa2				OPCODE_SWAP: equ 4 
1fa2				OPCODE_COLN: equ 5 
1fa2				OPCODE_SCOLN: equ 6 
1fa2				OPCODE_DROP: equ 7 
1fa2				OPCODE_DUP2: equ 8 
1fa2				OPCODE_DROP2: equ 9 
1fa2				OPCODE_SWAP2: equ 10 
1fa2				OPCODE_AT: equ 11 
1fa2				OPCODE_CAT: equ 12 
1fa2				OPCODE_BANG: equ 13 
1fa2				OPCODE_CBANG: equ 14 
1fa2				OPCODE_SCALL: equ 15 
1fa2				OPCODE_DEPTH: equ 16 
1fa2				OPCODE_OVER: equ 17 
1fa2				OPCODE_PAUSE: equ 18 
1fa2				OPCODE_PAUSES: equ 19 
1fa2				OPCODE_ROT: equ 20 
1fa2			;free to reuse	OPCODE_WORDS: equ 21 
1fa2			        OPCODE_NOT: equ 21 
1fa2				OPCODE_UWORDS: equ 22 
1fa2				OPCODE_BP: equ 23 
1fa2				OPCODE_MONITOR: equ 24  
1fa2				OPCODE_MALLOC: equ 25 
1fa2				OPCODE_FREE: equ 26 
1fa2				OPCODE_LIST: equ 27 
1fa2				OPCODE_FORGET: equ 28 
1fa2				OPCODE_NOP: equ 29 
1fa2				OPCODE_COMO: equ 30 
1fa2				OPCODE_COMC: equ 31 
1fa2			;free to reuse	OPCODE_ENDCORE: equ 32 
1fa2				OPCODE_AFTERSOUND: equ 33 
1fa2				OPCODE_GP2: equ 34 
1fa2				OPCODE_GP3: equ 35 
1fa2				OPCODE_GP4: equ 36 
1fa2				OPCODE_SIN: equ 37 
1fa2				OPCODE_SOUT: equ 38 
1fa2				OPCODE_SPIO: equ 39 
1fa2				OPCODE_SPICEH: equ 40 
1fa2				OPCODE_SPIOb: equ 41 
1fa2				OPCODE_SPII: equ 42 
1fa2				OPCODE_SESEL: equ 43 
1fa2				OPCODE_CARTDEV: equ 44 
1fa2			; free to reuse	OPCODE_ENDDEVICE: equ 45 
1fa2				OPCODE_FB: equ 46 
1fa2				OPCODE_EMIT: equ 47 
1fa2				OPCODE_DOTH: equ 48 
1fa2				OPCODE_DOTF: equ 49 
1fa2				OPCODE_DOT: equ 50 
1fa2				OPCODE_CLS: equ 51 
1fa2				OPCODE_DRAW: equ 52 
1fa2				OPCODE_DUMP: equ 53 
1fa2				OPCODE_CDUMP: equ 54 
1fa2				OPCODE_DAT: equ 55 
1fa2				OPCODE_HOME: equ 56 
1fa2				OPCODE_SPACE: equ 57 
1fa2				OPCODE_SPACES: equ 58 
1fa2				OPCODE_SCROLL: equ 59 
1fa2				OPCODE_ATQ: equ 60 
1fa2				OPCODE_AUTODSP: equ 61 
1fa2				OPCODE_MENU: equ 62 
1fa2			; free to reuse	OPCODE_ENDDISPLAY: equ 63  
1fa2				OPCODE_THEN: equ 64 
1fa2				OPCODE_ELSE: equ 65 
1fa2				OPCODE_DO: equ 66 
1fa2				OPCODE_LOOP: equ 67 
1fa2				OPCODE_I: equ 68 
1fa2				OPCODE_DLOOP: equ 69  
1fa2				OPCODE_REPEAT: equ 70  
1fa2				OPCODE_UNTIL: equ 71 
1fa2				OPCODE_ENDFLOW: equ 72 
1fa2				OPCODE_WAITK: equ 73 
1fa2				OPCODE_ACCEPT: equ 74 
1fa2				OPCODE_EDIT: equ 75 
1fa2			;free to reuse	OPCODE_ENDKEY: equ 76 
1fa2				OPCODE_LZERO: equ 77 
1fa2				OPCODE_TZERO: equ 78 
1fa2				OPCODE_LESS: equ 79 
1fa2				OPCODE_GT: equ 80 
1fa2				OPCODE_EQUAL: equ 81  
1fa2			;free to reuse	OPCODE_ENDLOGIC: equ 82 
1fa2				OPCODE_NEG: equ 83 
1fa2				OPCODE_DIV: equ 84 
1fa2				OPCODE_MUL: equ 85 
1fa2				OPCODE_MIN: equ 86 
1fa2				OPCODE_MAX: equ 87 
1fa2				OPCODE_RND16: equ 88 
1fa2				OPCODE_RND8: equ 89 
1fa2				OPCODE_RND: equ 90 
1fa2			;free to reuse	OPCODE_ENDMATHS: equ 91  
1fa2				OPCODE_BYNAME: equ 92 
1fa2				OPCODE_DIR: equ 93 
1fa2				OPCODE_SAVE: equ 94 
1fa2				OPCODE_LOAD: equ 95 
1fa2				OPCODE_BSAVE: equ 96 
1fa2				OPCODE_BLOAD: equ 97 
1fa2				OPCODE_SEO: equ 98  
1fa2				OPCODE_SEI: equ 99 
1fa2				OPCODE_SFREE: equ 100 
1fa2				OPCODE_SIZE: equ 101 
1fa2				OPCODE_CREATE: equ 102 
1fa2				OPCODE_APPEND: equ 103 
1fa2				OPCODE_SDEL: equ 104 
1fa2				OPCODE_OPEN: equ 105 
1fa2				OPCODE_READ: equ 106 
1fa2				OPCODE_EOF: equ 106 
1fa2				OPCODE_FORMAT: equ 107 
1fa2				OPCODE_LABEL: equ 108 
1fa2				OPCODE_LABELS: equ 109 
1fa2			;free to reuse	OPCODE_ENDSTORAGE: equ 110  
1fa2				OPCODE_UPPER: equ 111 
1fa2				OPCODE_LOWER: equ 112 
1fa2				OPCODE_SUBSTR: equ 113 
1fa2				OPCODE_LEFT: equ 114 
1fa2				OPCODE_RIGHT: equ 115 
1fa2				OPCODE_STR2NUM: equ 116 
1fa2				OPCODE_NUM2STR: equ 117 
1fa2				OPCODE_CONCAT: equ 118 
1fa2				OPCODE_FIND: equ 119 
1fa2				OPCODE_LEN: equ 120 
1fa2				OPCODE_CHAR: equ 121 
1fa2			; free to reuse	OPCODE_STRLEN: equ 122 
1fa2			; free to reuse	OPCODE_ENDSTR: equ 123 
1fa2				OPCODE_V0S: equ 124 
1fa2				OPCODE_V0Q: equ 125 
1fa2				OPCODE_V1S: equ 126 
1fa2				OPCODE_V1Q: equ 127 
1fa2				OPCODE_V2S: equ 128 
1fa2				OPCODE_V2Q: equ 129 
1fa2				OPCODE_V3S: equ 130 
1fa2				OPCODE_V3Q: equ 131 
1fa2			;free to reuse	OPCODE_END: equ 132 
1fa2				OPCODE_ZDUP: equ 133 
1fa2			 
1fa2			; eof 
# End of file forth_opcodes.asm
1fa2			 
1fa2			include "forth_words_core.asm" 
1fa2			 
1fa2			; | ## Core Words 
1fa2			 
1fa2			;if MALLOC_4 
1fa2			 
1fa2			.HEAP: 
1fa2				CWHEAD .EXEC OPCODE_HEAP "HEAP" 4 WORD_FLAG_CODE 
1fa2 15				db WORD_SYS_CORE+OPCODE_HEAP             
1fa3 e1 1f			dw .EXEC            
1fa5 05				db 4 + 1 
1fa6 .. 00			db "HEAP",0              
1fab				endm 
# End of macro CWHEAD
1fab			; | HEAP ( -- u1 u2 )   Pushes u1 the current number of bytes in the heap and u2 the remaining bytes - Only present if using my MALLOC | DONE 
1fab			; | | u1 - Current number of bytes in the heap 
1fab			; | | u2 - Remaining bytes left on the heap 
1fab			; | |  
1fab			; | | The heap is used for storing user defined words as well as any values pushed to stack. 
1fab			 
1fab			 
1fab					if DEBUG_FORTH_WORDS_KEY 
1fab						DMARK "HEP" 
1fab f5				push af  
1fac 3a c0 1f			ld a, (.dmark)  
1faf 32 71 ee			ld (debug_mark),a  
1fb2 3a c1 1f			ld a, (.dmark+1)  
1fb5 32 72 ee			ld (debug_mark+1),a  
1fb8 3a c2 1f			ld a, (.dmark+2)  
1fbb 32 73 ee			ld (debug_mark+2),a  
1fbe 18 03			jr .pastdmark  
1fc0 ..			.dmark: db "HEP"  
1fc3 f1			.pastdmark: pop af  
1fc4			endm  
# End of macro DMARK
1fc4						CALLMONITOR 
1fc4 cd 87 14			call break_point_state  
1fc7				endm  
# End of macro CALLMONITOR
1fc7					endif 
1fc7 2a 58 5a				ld hl, (free_list )      
1fca 11 5d 5a				ld de, heap_start 
1fcd			 
1fcd ed 52				sbc hl, de  
1fcf			 
1fcf cd e1 1a				call forth_push_numhl 
1fd2			 
1fd2			 
1fd2 ed 5b 58 5a			ld de, (free_list )      
1fd6 21 bd e3				ld hl, heap_end 
1fd9			 
1fd9 ed 52				sbc hl, de 
1fdb			 
1fdb cd e1 1a				call forth_push_numhl 
1fde					 
1fde			 
1fde					 
1fde			 
1fde			 
1fde			 
1fde					NEXTW 
1fde c3 4a 1e			jp macro_next 
1fe1				endm 
# End of macro NEXTW
1fe1			;endif 
1fe1			 
1fe1			.EXEC: 
1fe1			;	CWHEAD .STKEXEC OPCODE_EXEC "EXEC" 4 WORD_FLAG_CODE 
1fe1			;; > EXEC ( u -- )    Execs the string on TOS as a FORTH expression > CRASHES ON NEXTW 
1fe1			;; > > u - A qutoed string which can consist of any valid Forth expression excluding : defintions (use LOAD instead) 
1fe1			;; > > 
1fe1			;; > >   
1fe1			;	STACKFRAME OFF $5efe $5f9f 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS_KEY 
1fe1			;			DMARK "EXE" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			; 
1fe1			;	FORTH_DSP_VALUEHL 
1fe1			; 
1fe1			;	FORTH_DSP_POP 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EX1" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;;	ld e,(hl) 
1fe1			;;	inc hl 
1fe1			;;	ld d,(hl) 
1fe1			;;	ex de,hl 
1fe1			; 
1fe1			;;		if DEBUG_FORTH_WORDS 
1fe1			;;			DMARK "EX2" 
1fe1			;;			CALLMONITOR 
1fe1			;;		endif 
1fe1			;	push hl 
1fe1			; 
1fe1			;	;ld a, 0 
1fe1			;	;ld a, FORTH_END_BUFFER 
1fe1			;	call strlenz 
1fe1			;	inc hl   ; include zero term to copy 
1fe1			;	inc hl   ; include term 
1fe1			;	inc hl   ; include term 
1fe1			;	ld b,0 
1fe1			;	ld c,l 
1fe1			;	pop hl 
1fe1			;	ld de, execscratch 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EX3" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;	ldir 
1fe1			; 
1fe1			; 
1fe1			;	ld hl, execscratch 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EXe" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			; 
1fe1			;	call forthparse 
1fe1			;	call forthexec 
1fe1			;;	call forthexec_cleanup 
1fe1			;;	call forthparse 
1fe1			;;	call forthexec 
1fe1			; 
1fe1			;	STACKFRAMECHK OFF $5efe $5f9f 
1fe1			; 
1fe1			;	; an immediate word so no need to process any more words 
1fe1			;	ret 
1fe1			;	NEXTW 
1fe1			 
1fe1			; dead code - old version  
1fe1			;	FORTH_RSP_NEXT 
1fe1			 
1fe1			;  
1fe1			;	ld bc,(cli_ptr)   ; move to next token to parse in the input stream 
1fe1			;	ld de,(cli_origptr)   ; move to next token to parse in the input stream 
1fe1			;	ld hl,(os_tok_ptr)   ; move to next token to parse in the input stream 
1fe1			;	push hl 
1fe1			;	push de 
1fe1			;	push bc 
1fe1			; 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS_KEY 
1fe1			;			DMARK "EXR" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			; 
1fe1			; 
1fe1			; 
1fe1			;	;v5 FORTH_DSP_VALUE 
1fe1			;	FORTH_DSP_VALUEHL 
1fe1			; 
1fe1			;	; TODO do string type checks 
1fe1			; 
1fe1			;;v5	inc hl   ; skip type 
1fe1			; 
1fe1			;	push hl  ; source code  
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EX1" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;	ld a, 0 
1fe1			;	call strlent 
1fe1			; 
1fe1			;	inc hl 
1fe1			;	inc hl 
1fe1			;	inc hl 
1fe1			;	inc hl 
1fe1			; 
1fe1			;	push hl    ; size 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EX2" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;	call malloc 
1fe1			; 
1fe1			;	ex de, hl    ; de now contains malloc area 
1fe1			;	pop bc   	; get byte count 
1fe1			;	pop hl      ; get string to copy 
1fe1			; 
1fe1			;	push de     ; save malloc for free later 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EX3" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;	ldir       ; duplicate string 
1fe1			; 
1fe1			;	; at the end of the string so go back the three extra spaces and fill in with extra terms 
1fe1			;	 
1fe1			;	; TODO fix the parse would be better than this...  
1fe1			;	ex de, hl 
1fe1			;	dec hl 
1fe1			;	ld a, 0 
1fe1			;	ld (hl), a 
1fe1			;	dec hl 
1fe1			;	ld a, ' ' 
1fe1			;	ld (hl), a 
1fe1			;	dec hl 
1fe1			;	ld (hl), a 
1fe1			; 
1fe1			;	dec hl 
1fe1			;	ld (hl), a 
1fe1			; 
1fe1			; 
1fe1			;	FORTH_DSP_POP  
1fe1			; 
1fe1			;	pop hl     
1fe1			;	push hl    ; save malloc area 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EX4" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			; 
1fe1			;	call forthparse 
1fe1			;	call forthexec 
1fe1			;	 
1fe1			;	pop hl 
1fe1			;	if DEBUG_FORTH_WORDS 
1fe1			;		DMARK "EX5" 
1fe1			;		CALLMONITOR 
1fe1			;	endif 
1fe1			; 
1fe1			;	if FORTH_ENABLE_FREE 
1fe1			;	call free 
1fe1			;	endif 
1fe1			; 
1fe1			;	if DEBUG_FORTH_WORDS 
1fe1			;		DMARK "EX6" 
1fe1			;		CALLMONITOR 
1fe1			;	endif 
1fe1			; 
1fe1			;	pop bc 
1fe1			;	pop de 
1fe1			;	pop hl 
1fe1			;;	FORTH_RSP_POP	  
1fe1			;	ld (cli_ptr),bc   ; move to next token to parse in the input stream 
1fe1			;	ld (cli_origptr),de   ; move to next token to parse in the input stream 
1fe1			;	ld (os_tok_ptr),hl   ; move to next token to parse in the input stream 
1fe1			; 
1fe1			;	if DEBUG_FORTH_WORDS 
1fe1			;		DMARK "EX7" 
1fe1			;		CALLMONITOR 
1fe1			;	endif 
1fe1			;	NEXTW 
1fe1			 
1fe1			;.STKEXEC: 
1fe1			;	CWHEAD .ZDUP 43 "STKEXEC" 7 WORD_FLAG_CODE 
1fe1			;; > STKEXEC ( u .. u c -- ) Taking c count of strings off of the stack the strings are evaluated as code > TO TEST 
1fe1			; 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS_KEY 
1fe1			;			DMARK "STX" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			; 
1fe1			;	FORTH_DSP_VALUEHL 
1fe1			; 
1fe1			;	ld (store_tmp1), hl    ; count 
1fe1			; 
1fe1			;	FORTH_DSP_POP 
1fe1			;.stkexec1: 
1fe1			;	ld hl, (store_tmp1)   ; count 
1fe1			;	ld a, 0 
1fe1			;	cp l 
1fe1			;	ret z 
1fe1			; 
1fe1			;	dec hl 
1fe1			;	ld (store_tmp1), hl    ; count 
1fe1			;	 
1fe1			;	FORTH_DSP_VALUEHL 
1fe1			;	push hl 
1fe1			;	 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EXp" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;	FORTH_DSP_POP 
1fe1			; 
1fe1			;	call strlenz 
1fe1			;	inc hl   ; include zero term to copy 
1fe1			;	inc hl   ; include zero term to copy 
1fe1			;	inc hl   ; include zero term to copy 
1fe1			;	ld b,0 
1fe1			;	ld c,l 
1fe1			;	pop hl 
1fe1			;	ld de, execscratch 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EX3" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;	ldir 
1fe1			; 
1fe1			; 
1fe1			;	ld hl, execscratch 
1fe1			; 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EXP" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			; 
1fe1			;	call forthparse 
1fe1			;	ld hl, execscratch 
1fe1			;		if DEBUG_FORTH_WORDS 
1fe1			;			DMARK "EXx" 
1fe1			;			CALLMONITOR 
1fe1			;		endif 
1fe1			;	call forthexec 
1fe1			; 
1fe1			;	jp .stkexec1 
1fe1			; 
1fe1			;	ret 
1fe1			 
1fe1			 
1fe1			.DUP: 
1fe1				CWHEAD .ZDUP OPCODE_DUP "DUP" 3 WORD_FLAG_CODE 
1fe1 17				db WORD_SYS_CORE+OPCODE_DUP             
1fe2 57 20			dw .ZDUP            
1fe4 04				db 3 + 1 
1fe5 .. 00			db "DUP",0              
1fe9				endm 
# End of macro CWHEAD
1fe9			; | DUP ( u -- u u )     Duplicate whatever item is on TOS | DONE 
1fe9			 
1fe9					if DEBUG_FORTH_WORDS_KEY 
1fe9						DMARK "DUP" 
1fe9 f5				push af  
1fea 3a fe 1f			ld a, (.dmark)  
1fed 32 71 ee			ld (debug_mark),a  
1ff0 3a ff 1f			ld a, (.dmark+1)  
1ff3 32 72 ee			ld (debug_mark+1),a  
1ff6 3a 00 20			ld a, (.dmark+2)  
1ff9 32 73 ee			ld (debug_mark+2),a  
1ffc 18 03			jr .pastdmark  
1ffe ..			.dmark: db "DUP"  
2001 f1			.pastdmark: pop af  
2002			endm  
# End of macro DMARK
2002						CALLMONITOR 
2002 cd 87 14			call break_point_state  
2005				endm  
# End of macro CALLMONITOR
2005					endif 
2005			 
2005					FORTH_DSP 
2005 cd 9e 1c			call macro_forth_dsp 
2008				endm 
# End of macro FORTH_DSP
2008			 
2008 7e					ld a, (HL) 
2009 fe 01				cp DS_TYPE_STR 
200b 20 25				jr nz, .dupinum 
200d			 
200d					; push another string 
200d			 
200d					FORTH_DSP_VALUEHL     		 
200d cd d8 1c			call macro_dsp_valuehl 
2010				endm 
# End of macro FORTH_DSP_VALUEHL
2010			 
2010				if DEBUG_FORTH_WORDS 
2010					DMARK "DUs" 
2010 f5				push af  
2011 3a 25 20			ld a, (.dmark)  
2014 32 71 ee			ld (debug_mark),a  
2017 3a 26 20			ld a, (.dmark+1)  
201a 32 72 ee			ld (debug_mark+1),a  
201d 3a 27 20			ld a, (.dmark+2)  
2020 32 73 ee			ld (debug_mark+2),a  
2023 18 03			jr .pastdmark  
2025 ..			.dmark: db "DUs"  
2028 f1			.pastdmark: pop af  
2029			endm  
# End of macro DMARK
2029					CALLMONITOR 
2029 cd 87 14			call break_point_state  
202c				endm  
# End of macro CALLMONITOR
202c				endif 
202c cd 4f 1b				call forth_push_str 
202f			 
202f					NEXTW 
202f c3 4a 1e			jp macro_next 
2032				endm 
# End of macro NEXTW
2032			 
2032			 
2032			.dupinum: 
2032					 
2032			 
2032			 
2032					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2032 cd d8 1c			call macro_dsp_valuehl 
2035				endm 
# End of macro FORTH_DSP_VALUEHL
2035			 
2035				; TODO add floating point number detection 
2035			 
2035				if DEBUG_FORTH_WORDS 
2035					DMARK "DUi" 
2035 f5				push af  
2036 3a 4a 20			ld a, (.dmark)  
2039 32 71 ee			ld (debug_mark),a  
203c 3a 4b 20			ld a, (.dmark+1)  
203f 32 72 ee			ld (debug_mark+1),a  
2042 3a 4c 20			ld a, (.dmark+2)  
2045 32 73 ee			ld (debug_mark+2),a  
2048 18 03			jr .pastdmark  
204a ..			.dmark: db "DUi"  
204d f1			.pastdmark: pop af  
204e			endm  
# End of macro DMARK
204e					CALLMONITOR 
204e cd 87 14			call break_point_state  
2051				endm  
# End of macro CALLMONITOR
2051				endif 
2051			 
2051 cd e1 1a				call forth_push_numhl 
2054					NEXTW 
2054 c3 4a 1e			jp macro_next 
2057				endm 
# End of macro NEXTW
2057			.ZDUP: 
2057				CWHEAD .SWAP OPCODE_ZDUP "?DUP" 4 WORD_FLAG_CODE 
2057 99				db WORD_SYS_CORE+OPCODE_ZDUP             
2058 8f 20			dw .SWAP            
205a 05				db 4 + 1 
205b .. 00			db "?DUP",0              
2060				endm 
# End of macro CWHEAD
2060			; | ?DUP ( u -- u u )     Duplicate item on TOS if the item is non-zero | DONE 
2060			 
2060					if DEBUG_FORTH_WORDS_KEY 
2060						DMARK "qDU" 
2060 f5				push af  
2061 3a 75 20			ld a, (.dmark)  
2064 32 71 ee			ld (debug_mark),a  
2067 3a 76 20			ld a, (.dmark+1)  
206a 32 72 ee			ld (debug_mark+1),a  
206d 3a 77 20			ld a, (.dmark+2)  
2070 32 73 ee			ld (debug_mark+2),a  
2073 18 03			jr .pastdmark  
2075 ..			.dmark: db "qDU"  
2078 f1			.pastdmark: pop af  
2079			endm  
# End of macro DMARK
2079						CALLMONITOR 
2079 cd 87 14			call break_point_state  
207c				endm  
# End of macro CALLMONITOR
207c					endif 
207c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
207c cd d8 1c			call macro_dsp_valuehl 
207f				endm 
# End of macro FORTH_DSP_VALUEHL
207f			 
207f e5					push hl 
2080			 
2080					; is it a zero? 
2080			 
2080 3e 00				ld a, 0 
2082 84					add h 
2083 85					add l 
2084			 
2084 e1					pop hl 
2085			 
2085 fe 00				cp 0 
2087 28 03				jr z, .dup2orig 
2089			 
2089			 
2089 cd e1 1a				call forth_push_numhl 
208c			 
208c			 
208c				; TODO add floating point number detection 
208c			 
208c			.dup2orig: 
208c			 
208c					NEXTW 
208c c3 4a 1e			jp macro_next 
208f				endm 
# End of macro NEXTW
208f			.SWAP: 
208f				CWHEAD .COLN OPCODE_SWAP "SWAP" 4 WORD_FLAG_CODE 
208f 18				db WORD_SYS_CORE+OPCODE_SWAP             
2090 ce 20			dw .COLN            
2092 05				db 4 + 1 
2093 .. 00			db "SWAP",0              
2098				endm 
# End of macro CWHEAD
2098			; | SWAP ( w1 w2 -- w2 w1 )    Swap top two items on TOS | DONE 
2098					if DEBUG_FORTH_WORDS_KEY 
2098						DMARK "SWP" 
2098 f5				push af  
2099 3a ad 20			ld a, (.dmark)  
209c 32 71 ee			ld (debug_mark),a  
209f 3a ae 20			ld a, (.dmark+1)  
20a2 32 72 ee			ld (debug_mark+1),a  
20a5 3a af 20			ld a, (.dmark+2)  
20a8 32 73 ee			ld (debug_mark+2),a  
20ab 18 03			jr .pastdmark  
20ad ..			.dmark: db "SWP"  
20b0 f1			.pastdmark: pop af  
20b1			endm  
# End of macro DMARK
20b1						CALLMONITOR 
20b1 cd 87 14			call break_point_state  
20b4				endm  
# End of macro CALLMONITOR
20b4					endif 
20b4			 
20b4					FORTH_DSP_VALUEHL 
20b4 cd d8 1c			call macro_dsp_valuehl 
20b7				endm 
# End of macro FORTH_DSP_VALUEHL
20b7 e5					push hl     ; w2 
20b8			 
20b8					FORTH_DSP_POP 
20b8 cd 90 1d			call macro_forth_dsp_pop 
20bb				endm 
# End of macro FORTH_DSP_POP
20bb			 
20bb					FORTH_DSP_VALUEHL 
20bb cd d8 1c			call macro_dsp_valuehl 
20be				endm 
# End of macro FORTH_DSP_VALUEHL
20be			 
20be					FORTH_DSP_POP 
20be cd 90 1d			call macro_forth_dsp_pop 
20c1				endm 
# End of macro FORTH_DSP_POP
20c1			 
20c1 d1					pop de     ; w2	, hl = w1 
20c2			 
20c2 eb					ex de, hl 
20c3 d5					push de 
20c4			 
20c4 cd e1 1a				call forth_push_numhl 
20c7			 
20c7 e1					pop hl 
20c8			 
20c8 cd e1 1a				call forth_push_numhl 
20cb					 
20cb			 
20cb					NEXTW 
20cb c3 4a 1e			jp macro_next 
20ce				endm 
# End of macro NEXTW
20ce			.COLN: 
20ce				CWHEAD .SCOLN OPCODE_COLN ":" 1 WORD_FLAG_CODE 
20ce 19				db WORD_SYS_CORE+OPCODE_COLN             
20cf 5a 22			dw .SCOLN            
20d1 02				db 1 + 1 
20d2 .. 00			db ":",0              
20d4				endm 
# End of macro CWHEAD
20d4			; | : ( -- )         Create new word | DONE 
20d4			 
20d4					if DEBUG_FORTH_WORDS_KEY 
20d4						DMARK "CLN" 
20d4 f5				push af  
20d5 3a e9 20			ld a, (.dmark)  
20d8 32 71 ee			ld (debug_mark),a  
20db 3a ea 20			ld a, (.dmark+1)  
20de 32 72 ee			ld (debug_mark+1),a  
20e1 3a eb 20			ld a, (.dmark+2)  
20e4 32 73 ee			ld (debug_mark+2),a  
20e7 18 03			jr .pastdmark  
20e9 ..			.dmark: db "CLN"  
20ec f1			.pastdmark: pop af  
20ed			endm  
# End of macro DMARK
20ed						CALLMONITOR 
20ed cd 87 14			call break_point_state  
20f0				endm  
# End of macro CALLMONITOR
20f0					endif 
20f0				STACKFRAME OFF $8efe $989f 
20f0				if DEBUG_STACK_IMB 
20f0					if OFF 
20f0						exx 
20f0						ld de, $8efe 
20f0						ld a, d 
20f0						ld hl, curframe 
20f0						call hexout 
20f0						ld a, e 
20f0						ld hl, curframe+2 
20f0						call hexout 
20f0						ld hl, $8efe 
20f0						push hl 
20f0						ld hl, $989f 
20f0						push hl 
20f0						exx 
20f0					endif 
20f0				endif 
20f0			endm 
# End of macro STACKFRAME
20f0				; get parser buffer length  of new word 
20f0			 
20f0				 
20f0			 
20f0					; move tok past this to start of name defintition 
20f0					; TODO get word to define 
20f0					; TODO Move past word token 
20f0					; TODO get length of string up to the ';' 
20f0			 
20f0 2a d8 e6			ld hl, (os_tok_ptr) 
20f3 23				inc hl 
20f4 23				inc hl 
20f5			 
20f5 3e 3b			ld a, ';' 
20f7 cd ef 10			call strlent 
20fa			 
20fa 7d				ld a,l 
20fb 32 d3 e3			ld (os_new_parse_len), a 
20fe			 
20fe			 
20fe			if DEBUG_FORTH_UWORD 
20fe ed 5b d8 e6		ld de, (os_tok_ptr) 
2102						DMARK ":01" 
2102 f5				push af  
2103 3a 17 21			ld a, (.dmark)  
2106 32 71 ee			ld (debug_mark),a  
2109 3a 18 21			ld a, (.dmark+1)  
210c 32 72 ee			ld (debug_mark+1),a  
210f 3a 19 21			ld a, (.dmark+2)  
2112 32 73 ee			ld (debug_mark+2),a  
2115 18 03			jr .pastdmark  
2117 ..			.dmark: db ":01"  
211a f1			.pastdmark: pop af  
211b			endm  
# End of macro DMARK
211b				CALLMONITOR 
211b cd 87 14			call break_point_state  
211e				endm  
# End of macro CALLMONITOR
211e			endif 
211e			 
211e			; 
211e			;  new word memory layout: 
211e			;  
211e			;    : adg 6666 ;  
211e			; 
211e			;    db   1     ; user defined word  
211e 23				inc hl    
211f			;    dw   sysdict 
211f 23				inc hl 
2120 23				inc hl 
2121			;    db <word len>+1 (for null) 
2121 23				inc hl 
2122			;    db .... <word> 
2122			; 
2122			 
2122 23				inc hl    ; some extras for the word preamble before the above 
2123 23				inc hl 
2124 23				inc hl 
2125 23				inc hl 
2126 23				inc hl 
2127 23				inc hl 
2128 23				inc hl  
2129 23				inc hl 
212a 23				inc hl 
212b 23				inc hl 
212c 23				inc hl 
212d 23				inc hl 
212e 23				inc hl 
212f 23				inc hl     ; TODO how many do we really need?     maybe only 6 
2130			;       exec word buffer 
2130			;	<ptr word>   
2130 23				inc hl 
2131 23				inc hl 
2132			;       <word list><null term> 7F final term 
2132			 
2132			 
2132			if DEBUG_FORTH_UWORD 
2132						DMARK ":02" 
2132 f5				push af  
2133 3a 47 21			ld a, (.dmark)  
2136 32 71 ee			ld (debug_mark),a  
2139 3a 48 21			ld a, (.dmark+1)  
213c 32 72 ee			ld (debug_mark+1),a  
213f 3a 49 21			ld a, (.dmark+2)  
2142 32 73 ee			ld (debug_mark+2),a  
2145 18 03			jr .pastdmark  
2147 ..			.dmark: db ":02"  
214a f1			.pastdmark: pop af  
214b			endm  
# End of macro DMARK
214b				CALLMONITOR 
214b cd 87 14			call break_point_state  
214e				endm  
# End of macro CALLMONITOR
214e			endif 
214e			 
214e				 
214e					; malloc the size 
214e			 
214e cd 4d 11				call malloc 
2151 22 d5 e3				ld (os_new_malloc), hl     ; save malloc start 
2154			 
2154			;    db   1     ; user defined word  
2154 3e 01				ld a, WORD_SYS_UWORD  
2156 77					ld (hl), a 
2157				 
2157 23				inc hl    
2158			;    dw   sysdict 
2158 11 a2 1f			ld de, sysdict       ; continue on with the scan to the system dict 
215b 73				ld (hl), e 
215c 23				inc hl 
215d 72				ld (hl), d 
215e 23				inc hl 
215f			 
215f			 
215f			;    Setup dict word 
215f			 
215f 23				inc hl 
2160 22 cf e3			ld (os_new_work_ptr), hl     ; save start of dict word  
2163			 
2163				; 1. get length of dict word 
2163			 
2163			 
2163 2a d8 e6			ld hl, (os_tok_ptr) 
2166 23				inc hl 
2167 23				inc hl    ; position to start of dict word 
2168 3e 00			ld a, 0 
216a cd ef 10			call strlent 
216d			 
216d			 
216d 23				inc hl    ; to include null??? 
216e			 
216e				; write length of dict word 
216e			 
216e ed 5b cf e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
2172 1b				dec de 
2173 eb				ex de, hl 
2174 73				ld (hl), e 
2175 eb				ex de, hl 
2176			 
2176				 
2176			 
2176				; copy  
2176 4d				ld c, l 
2177 06 00			ld b, 0 
2179 ed 5b cf e3		ld de, (os_new_work_ptr)   ; get dest for copy of word 
217d 2a d8 e6			ld hl, (os_tok_ptr) 
2180 23				inc hl 
2181 23				inc hl    ; position to start of dict word 
2182				 
2182			;	ldir       ; copy word - HL now is where we need to be for copy of the line 
2182				 
2182				; TODO need to convert word to upper case 
2182			 
2182			ucasetok:	 
2182 7e				ld a,(hl) 
2183 cd db 10			call toUpper 
2186 77				ld (hl),a 
2187 ed a0			ldi 
2189 f2 82 21		 	jp p, ucasetok 
218c			 
218c			 
218c			 
218c				; de now points to start of where the word body code should be placed 
218c ed 53 cf e3		ld (os_new_work_ptr), de 
2190				; hl now points to the words to throw at forthexec which needs to be copied 
2190 22 cd e3			ld (os_new_src_ptr), hl 
2193			 
2193				; TODO add 'call to forthexec' 
2193			 
2193			if DEBUG_FORTH_UWORD 
2193 c5				push bc 
2194 ed 4b d5 e3		ld bc, (os_new_malloc) 
2198						DMARK ":0x" 
2198 f5				push af  
2199 3a ad 21			ld a, (.dmark)  
219c 32 71 ee			ld (debug_mark),a  
219f 3a ae 21			ld a, (.dmark+1)  
21a2 32 72 ee			ld (debug_mark+1),a  
21a5 3a af 21			ld a, (.dmark+2)  
21a8 32 73 ee			ld (debug_mark+2),a  
21ab 18 03			jr .pastdmark  
21ad ..			.dmark: db ":0x"  
21b0 f1			.pastdmark: pop af  
21b1			endm  
# End of macro DMARK
21b1				CALLMONITOR 
21b1 cd 87 14			call break_point_state  
21b4				endm  
# End of macro CALLMONITOR
21b4 c1				pop bc 
21b5			endif 
21b5			 
21b5			 
21b5				; create word preamble which should be: 
21b5			 
21b5			; TODO possibly push the current os_tok_ptr to rsp and the current rsp will be the start of the string and not current pc???? 
21b5			 
21b5				;    ld hl, <word code> 
21b5				;    jp user_exec 
21b5			        ;    <word code bytes> 
21b5			 
21b5			 
21b5			;	inc de     ; TODO ??? or are we already past the word's null 
21b5 eb				ex de, hl 
21b6			 
21b6 36 21			ld (hl), 021h     ; TODO get bytes poke "ld hl, " 
21b8			 
21b8 23				inc hl 
21b9 22 c9 e3			ld (os_new_exec_ptr),hl     ; save this location to poke with the address of the word buffer 
21bc 23				inc hl 
21bd			 
21bd 23				inc hl 
21be 36 c3			ld (hl), 0c3h     ; TODO get bytes poke "jp xx  " 
21c0			 
21c0 01 aa 45			ld bc, user_exec 
21c3 23				inc hl 
21c4 71				ld (hl), c     ; poke address of user_exec 
21c5 23				inc hl 
21c6 70				ld (hl), b     
21c7			 ; 
21c7			;	inc hl 
21c7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21c7			; 
21c7			; 
21c7			;	ld bc, macro_forth_rsp_next 
21c7			;	inc hl 
21c7			;	ld (hl), c     ; poke address of FORTH_RSP_NEXT 
21c7			;	inc hl 
21c7			;	ld (hl), b     
21c7			 ; 
21c7			;	inc hl 
21c7			;	ld (hl), 0cdh     ; TODO get bytes poke "call  " 
21c7			; 
21c7			; 
21c7			;	inc hl 
21c7			;	ld bc, forthexec 
21c7			;	ld (hl), c     ; poke address of forthexec 
21c7			;	inc hl 
21c7			;	ld (hl), b      
21c7			; 
21c7			;	inc hl 
21c7			;	ld (hl), 0c3h     ; TODO get bytes poke "jp  " 
21c7			; 
21c7			;	ld bc, user_dict_next 
21c7			;	inc hl 
21c7			;	ld (hl), c     ; poke address of forthexec 
21c7			;	inc hl 
21c7			;	ld (hl), b      
21c7			 
21c7				; hl is now where we need to copy the word byte data to save this 
21c7			 
21c7 23				inc hl 
21c8 22 cb e3			ld (os_new_exec), hl 
21cb				 
21cb				; copy definition 
21cb			 
21cb eb				ex de, hl 
21cc			;	inc de    ; TODO BUG It appears the exec of a uword requires pc to be set 
21cc			;	inc de    ; skip the PC for this parse 
21cc 3a d3 e3			ld a, (os_new_parse_len) 
21cf 4f				ld c, a 
21d0 06 00			ld b, 0 
21d2 ed b0			ldir		 ; copy defintion 
21d4			 
21d4			 
21d4				; poke the address of where the new word bytes live for forthexec 
21d4			 
21d4 2a c9 e3			ld hl, (os_new_exec_ptr)     ; TODO this isnt correct 
21d7			 
21d7 ed 5b cb e3		ld de, (os_new_exec)      
21db				 
21db 73				ld (hl), e 
21dc 23				inc hl 
21dd 72				ld (hl), d 
21de			 
21de					; TODO copy last user dict word next link to this word 
21de					; TODO update last user dict word to point to this word 
21de			; 
21de			; hl f923 de 812a ; bc 811a 
21de			 
21de			if DEBUG_FORTH_UWORD 
21de c5				push bc 
21df ed 4b d5 e3		ld bc, (os_new_malloc) 
21e3						DMARK ":0A" 
21e3 f5				push af  
21e4 3a f8 21			ld a, (.dmark)  
21e7 32 71 ee			ld (debug_mark),a  
21ea 3a f9 21			ld a, (.dmark+1)  
21ed 32 72 ee			ld (debug_mark+1),a  
21f0 3a fa 21			ld a, (.dmark+2)  
21f3 32 73 ee			ld (debug_mark+2),a  
21f6 18 03			jr .pastdmark  
21f8 ..			.dmark: db ":0A"  
21fb f1			.pastdmark: pop af  
21fc			endm  
# End of macro DMARK
21fc				CALLMONITOR 
21fc cd 87 14			call break_point_state  
21ff				endm  
# End of macro CALLMONITOR
21ff c1				pop bc 
2200			endif 
2200			if DEBUG_FORTH_UWORD 
2200 c5				push bc 
2201 ed 4b d5 e3		ld bc, (os_new_malloc) 
2205 03				inc bc 
2206 03				inc bc 
2207 03				inc bc 
2208 03				inc bc 
2209 03				inc bc 
220a 03				inc bc 
220b 03				inc bc 
220c 03				inc bc 
220d			 
220d						DMARK ":0B" 
220d f5				push af  
220e 3a 22 22			ld a, (.dmark)  
2211 32 71 ee			ld (debug_mark),a  
2214 3a 23 22			ld a, (.dmark+1)  
2217 32 72 ee			ld (debug_mark+1),a  
221a 3a 24 22			ld a, (.dmark+2)  
221d 32 73 ee			ld (debug_mark+2),a  
2220 18 03			jr .pastdmark  
2222 ..			.dmark: db ":0B"  
2225 f1			.pastdmark: pop af  
2226			endm  
# End of macro DMARK
2226				CALLMONITOR 
2226 cd 87 14			call break_point_state  
2229				endm  
# End of macro CALLMONITOR
2229 c1				pop bc 
222a			endif 
222a			 
222a			; update word dict linked list for new word 
222a			 
222a			 
222a 2a d4 e6		ld hl, (os_last_new_uword)		; get the start of the last added uword 
222d 23			inc hl     ; move to next work linked list ptr 
222e			 
222e ed 5b d5 e3	ld de, (os_new_malloc)		 ; new next word 
2232 73			ld (hl), e 
2233 23			inc hl 
2234 72			ld (hl), d 
2235			 
2235			if DEBUG_FORTH_UWORD 
2235 ed 4b d4 e6		ld bc, (os_last_new_uword)		; get the last word so we can check it worked in debug 
2239			endif 
2239			 
2239 ed 53 d4 e6	ld (os_last_new_uword), de      ; update last new uword ptr 
223d			 
223d			 
223d			if DEBUG_FORTH_UWORD 
223d						DMARK ":0+" 
223d f5				push af  
223e 3a 52 22			ld a, (.dmark)  
2241 32 71 ee			ld (debug_mark),a  
2244 3a 53 22			ld a, (.dmark+1)  
2247 32 72 ee			ld (debug_mark+1),a  
224a 3a 54 22			ld a, (.dmark+2)  
224d 32 73 ee			ld (debug_mark+2),a  
2250 18 03			jr .pastdmark  
2252 ..			.dmark: db ":0+"  
2255 f1			.pastdmark: pop af  
2256			endm  
# End of macro DMARK
2256				CALLMONITOR 
2256 cd 87 14			call break_point_state  
2259				endm  
# End of macro CALLMONITOR
2259			endif 
2259			 
2259				STACKFRAMECHK OFF $8efe $989f 
2259				if DEBUG_STACK_IMB 
2259					if OFF 
2259						exx 
2259						ld hl, $989f 
2259						pop de   ; $989f 
2259						call cmp16 
2259						jr nz, .spnosame 
2259						ld hl, $8efe 
2259						pop de   ; $8efe 
2259						call cmp16 
2259						jr z, .spfrsame 
2259						.spnosame: call showsperror 
2259						.spfrsame: nop 
2259						exx 
2259					endif 
2259				endif 
2259			endm 
# End of macro STACKFRAMECHK
2259			 
2259 c9			ret    ; dont process any remaining parser tokens as they form new word 
225a			 
225a			 
225a			 
225a			 
225a			;		NEXT 
225a			.SCOLN: 
225a			;	CWHEAD .DROP 17 '\;' 1 WORD_FLAG_CODE 
225a 06				db OPCODE_SCOLN 
225b a6 22			dw .DROP 
225d 02				db 2 
225e .. 00			db ";",0           
2260			; | ; ( -- )     Terminate new word and return exec to previous exec level | DONE 
2260					if DEBUG_FORTH_WORDS_KEY 
2260						DMARK "SCN" 
2260 f5				push af  
2261 3a 75 22			ld a, (.dmark)  
2264 32 71 ee			ld (debug_mark),a  
2267 3a 76 22			ld a, (.dmark+1)  
226a 32 72 ee			ld (debug_mark+1),a  
226d 3a 77 22			ld a, (.dmark+2)  
2270 32 73 ee			ld (debug_mark+2),a  
2273 18 03			jr .pastdmark  
2275 ..			.dmark: db "SCN"  
2278 f1			.pastdmark: pop af  
2279			endm  
# End of macro DMARK
2279						CALLMONITOR 
2279 cd 87 14			call break_point_state  
227c				endm  
# End of macro CALLMONITOR
227c					endif 
227c					FORTH_RSP_TOS 
227c cd 9f 1a			call macro_forth_rsp_tos 
227f				endm 
# End of macro FORTH_RSP_TOS
227f e5					push hl 
2280					FORTH_RSP_POP 
2280 cd a9 1a			call macro_forth_rsp_pop 
2283				endm 
# End of macro FORTH_RSP_POP
2283 e1					pop hl 
2284			;		ex de,hl 
2284 22 d8 e6				ld (os_tok_ptr),hl 
2287			 
2287			if DEBUG_FORTH_UWORD 
2287						DMARK "SCL" 
2287 f5				push af  
2288 3a 9c 22			ld a, (.dmark)  
228b 32 71 ee			ld (debug_mark),a  
228e 3a 9d 22			ld a, (.dmark+1)  
2291 32 72 ee			ld (debug_mark+1),a  
2294 3a 9e 22			ld a, (.dmark+2)  
2297 32 73 ee			ld (debug_mark+2),a  
229a 18 03			jr .pastdmark  
229c ..			.dmark: db "SCL"  
229f f1			.pastdmark: pop af  
22a0			endm  
# End of macro DMARK
22a0				CALLMONITOR 
22a0 cd 87 14			call break_point_state  
22a3				endm  
# End of macro CALLMONITOR
22a3			endif 
22a3					NEXTW 
22a3 c3 4a 1e			jp macro_next 
22a6				endm 
# End of macro NEXTW
22a6			 
22a6			.DROP: 
22a6				CWHEAD .DUP2 OPCODE_DROP "DROP" 4 WORD_FLAG_CODE 
22a6 1b				db WORD_SYS_CORE+OPCODE_DROP             
22a7 d1 22			dw .DUP2            
22a9 05				db 4 + 1 
22aa .. 00			db "DROP",0              
22af				endm 
# End of macro CWHEAD
22af			; | DROP ( w -- )   drop the TOS item   | DONE 
22af					if DEBUG_FORTH_WORDS_KEY 
22af						DMARK "DRP" 
22af f5				push af  
22b0 3a c4 22			ld a, (.dmark)  
22b3 32 71 ee			ld (debug_mark),a  
22b6 3a c5 22			ld a, (.dmark+1)  
22b9 32 72 ee			ld (debug_mark+1),a  
22bc 3a c6 22			ld a, (.dmark+2)  
22bf 32 73 ee			ld (debug_mark+2),a  
22c2 18 03			jr .pastdmark  
22c4 ..			.dmark: db "DRP"  
22c7 f1			.pastdmark: pop af  
22c8			endm  
# End of macro DMARK
22c8						CALLMONITOR 
22c8 cd 87 14			call break_point_state  
22cb				endm  
# End of macro CALLMONITOR
22cb					endif 
22cb					FORTH_DSP_POP 
22cb cd 90 1d			call macro_forth_dsp_pop 
22ce				endm 
# End of macro FORTH_DSP_POP
22ce					NEXTW 
22ce c3 4a 1e			jp macro_next 
22d1				endm 
# End of macro NEXTW
22d1			.DUP2: 
22d1				CWHEAD .DROP2 OPCODE_DUP2 "2DUP" 4 WORD_FLAG_CODE 
22d1 1c				db WORD_SYS_CORE+OPCODE_DUP2             
22d2 16 23			dw .DROP2            
22d4 05				db 4 + 1 
22d5 .. 00			db "2DUP",0              
22da				endm 
# End of macro CWHEAD
22da			; | 2DUP ( w1 w2 -- w1 w2 w1 w2 ) Duplicate the top two items on TOS  | DONE 
22da					if DEBUG_FORTH_WORDS_KEY 
22da						DMARK "2DU" 
22da f5				push af  
22db 3a ef 22			ld a, (.dmark)  
22de 32 71 ee			ld (debug_mark),a  
22e1 3a f0 22			ld a, (.dmark+1)  
22e4 32 72 ee			ld (debug_mark+1),a  
22e7 3a f1 22			ld a, (.dmark+2)  
22ea 32 73 ee			ld (debug_mark+2),a  
22ed 18 03			jr .pastdmark  
22ef ..			.dmark: db "2DU"  
22f2 f1			.pastdmark: pop af  
22f3			endm  
# End of macro DMARK
22f3						CALLMONITOR 
22f3 cd 87 14			call break_point_state  
22f6				endm  
# End of macro CALLMONITOR
22f6					endif 
22f6					FORTH_DSP_VALUEHL 
22f6 cd d8 1c			call macro_dsp_valuehl 
22f9				endm 
# End of macro FORTH_DSP_VALUEHL
22f9 e5					push hl      ; 2 
22fa			 
22fa					FORTH_DSP_POP 
22fa cd 90 1d			call macro_forth_dsp_pop 
22fd				endm 
# End of macro FORTH_DSP_POP
22fd					 
22fd					FORTH_DSP_VALUEHL 
22fd cd d8 1c			call macro_dsp_valuehl 
2300				endm 
# End of macro FORTH_DSP_VALUEHL
2300			;		push hl      ; 1 
2300			 
2300					FORTH_DSP_POP 
2300 cd 90 1d			call macro_forth_dsp_pop 
2303				endm 
# End of macro FORTH_DSP_POP
2303			 
2303			;		pop hl       ; 1 
2303 d1					pop de       ; 2 
2304			 
2304 cd e1 1a				call forth_push_numhl 
2307 eb					ex de, hl 
2308 cd e1 1a				call forth_push_numhl 
230b			 
230b					 
230b eb					ex de, hl 
230c			 
230c cd e1 1a				call forth_push_numhl 
230f eb					ex de, hl 
2310 cd e1 1a				call forth_push_numhl 
2313			 
2313			 
2313					NEXTW 
2313 c3 4a 1e			jp macro_next 
2316				endm 
# End of macro NEXTW
2316			.DROP2: 
2316				CWHEAD .SWAP2 OPCODE_DROP2 "2DROP" 5 WORD_FLAG_CODE 
2316 1d				db WORD_SYS_CORE+OPCODE_DROP2             
2317 45 23			dw .SWAP2            
2319 06				db 5 + 1 
231a .. 00			db "2DROP",0              
2320				endm 
# End of macro CWHEAD
2320			; | 2DROP ( w w -- )    Double drop | DONE 
2320					if DEBUG_FORTH_WORDS_KEY 
2320						DMARK "2DR" 
2320 f5				push af  
2321 3a 35 23			ld a, (.dmark)  
2324 32 71 ee			ld (debug_mark),a  
2327 3a 36 23			ld a, (.dmark+1)  
232a 32 72 ee			ld (debug_mark+1),a  
232d 3a 37 23			ld a, (.dmark+2)  
2330 32 73 ee			ld (debug_mark+2),a  
2333 18 03			jr .pastdmark  
2335 ..			.dmark: db "2DR"  
2338 f1			.pastdmark: pop af  
2339			endm  
# End of macro DMARK
2339						CALLMONITOR 
2339 cd 87 14			call break_point_state  
233c				endm  
# End of macro CALLMONITOR
233c					endif 
233c					FORTH_DSP_POP 
233c cd 90 1d			call macro_forth_dsp_pop 
233f				endm 
# End of macro FORTH_DSP_POP
233f					FORTH_DSP_POP 
233f cd 90 1d			call macro_forth_dsp_pop 
2342				endm 
# End of macro FORTH_DSP_POP
2342					NEXTW 
2342 c3 4a 1e			jp macro_next 
2345				endm 
# End of macro NEXTW
2345			.SWAP2: 
2345				CWHEAD .AT OPCODE_SWAP2 "2SWAP" 5 WORD_FLAG_CODE 
2345 1e				db WORD_SYS_CORE+OPCODE_SWAP2             
2346 6e 23			dw .AT            
2348 06				db 5 + 1 
2349 .. 00			db "2SWAP",0              
234f				endm 
# End of macro CWHEAD
234f			; | 2SWAP ( w1 w2 w3 w4 -- w3 w4 w1 w2 ) Swap top pair of items | TODO 
234f					if DEBUG_FORTH_WORDS_KEY 
234f						DMARK "2SW" 
234f f5				push af  
2350 3a 64 23			ld a, (.dmark)  
2353 32 71 ee			ld (debug_mark),a  
2356 3a 65 23			ld a, (.dmark+1)  
2359 32 72 ee			ld (debug_mark+1),a  
235c 3a 66 23			ld a, (.dmark+2)  
235f 32 73 ee			ld (debug_mark+2),a  
2362 18 03			jr .pastdmark  
2364 ..			.dmark: db "2SW"  
2367 f1			.pastdmark: pop af  
2368			endm  
# End of macro DMARK
2368						CALLMONITOR 
2368 cd 87 14			call break_point_state  
236b				endm  
# End of macro CALLMONITOR
236b					endif 
236b					NEXTW 
236b c3 4a 1e			jp macro_next 
236e				endm 
# End of macro NEXTW
236e			.AT: 
236e				CWHEAD .CAT OPCODE_AT "@" 1 WORD_FLAG_CODE 
236e 1f				db WORD_SYS_CORE+OPCODE_AT             
236f a0 23			dw .CAT            
2371 02				db 1 + 1 
2372 .. 00			db "@",0              
2374				endm 
# End of macro CWHEAD
2374			; | @ ( w -- ) Push onto TOS byte stored at address   | DONE 
2374			 
2374					if DEBUG_FORTH_WORDS_KEY 
2374						DMARK "AT." 
2374 f5				push af  
2375 3a 89 23			ld a, (.dmark)  
2378 32 71 ee			ld (debug_mark),a  
237b 3a 8a 23			ld a, (.dmark+1)  
237e 32 72 ee			ld (debug_mark+1),a  
2381 3a 8b 23			ld a, (.dmark+2)  
2384 32 73 ee			ld (debug_mark+2),a  
2387 18 03			jr .pastdmark  
2389 ..			.dmark: db "AT."  
238c f1			.pastdmark: pop af  
238d			endm  
# End of macro DMARK
238d						CALLMONITOR 
238d cd 87 14			call break_point_state  
2390				endm  
# End of macro CALLMONITOR
2390					endif 
2390			.getbyteat:	 
2390					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2390 cd d8 1c			call macro_dsp_valuehl 
2393				endm 
# End of macro FORTH_DSP_VALUEHL
2393					 
2393			;		push hl 
2393				 
2393					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2393 cd 90 1d			call macro_forth_dsp_pop 
2396				endm 
# End of macro FORTH_DSP_POP
2396			 
2396			;		pop hl 
2396			 
2396 7e					ld a, (hl) 
2397			 
2397 6f					ld l, a 
2398 26 00				ld h, 0 
239a cd e1 1a				call forth_push_numhl 
239d			 
239d					NEXTW 
239d c3 4a 1e			jp macro_next 
23a0				endm 
# End of macro NEXTW
23a0			.CAT: 
23a0				CWHEAD .BANG OPCODE_CAT "C@" 2 WORD_FLAG_CODE 
23a0 20				db WORD_SYS_CORE+OPCODE_CAT             
23a1 c9 23			dw .BANG            
23a3 03				db 2 + 1 
23a4 .. 00			db "C@",0              
23a7				endm 
# End of macro CWHEAD
23a7			; | C@  ( w -- ) Push onto TOS byte stored at address   | DONE 
23a7					if DEBUG_FORTH_WORDS_KEY 
23a7						DMARK "CAA" 
23a7 f5				push af  
23a8 3a bc 23			ld a, (.dmark)  
23ab 32 71 ee			ld (debug_mark),a  
23ae 3a bd 23			ld a, (.dmark+1)  
23b1 32 72 ee			ld (debug_mark+1),a  
23b4 3a be 23			ld a, (.dmark+2)  
23b7 32 73 ee			ld (debug_mark+2),a  
23ba 18 03			jr .pastdmark  
23bc ..			.dmark: db "CAA"  
23bf f1			.pastdmark: pop af  
23c0			endm  
# End of macro DMARK
23c0						CALLMONITOR 
23c0 cd 87 14			call break_point_state  
23c3				endm  
# End of macro CALLMONITOR
23c3					endif 
23c3 c3 90 23				jp .getbyteat 
23c6					NEXTW 
23c6 c3 4a 1e			jp macro_next 
23c9				endm 
# End of macro NEXTW
23c9			.BANG: 
23c9				CWHEAD .CBANG OPCODE_BANG "!" 1 WORD_FLAG_CODE 
23c9 21				db WORD_SYS_CORE+OPCODE_BANG             
23ca ff 23			dw .CBANG            
23cc 02				db 1 + 1 
23cd .. 00			db "!",0              
23cf				endm 
# End of macro CWHEAD
23cf			; | ! ( x w -- ) Store x at address w      | DONE 
23cf					if DEBUG_FORTH_WORDS_KEY 
23cf						DMARK "BNG" 
23cf f5				push af  
23d0 3a e4 23			ld a, (.dmark)  
23d3 32 71 ee			ld (debug_mark),a  
23d6 3a e5 23			ld a, (.dmark+1)  
23d9 32 72 ee			ld (debug_mark+1),a  
23dc 3a e6 23			ld a, (.dmark+2)  
23df 32 73 ee			ld (debug_mark+2),a  
23e2 18 03			jr .pastdmark  
23e4 ..			.dmark: db "BNG"  
23e7 f1			.pastdmark: pop af  
23e8			endm  
# End of macro DMARK
23e8						CALLMONITOR 
23e8 cd 87 14			call break_point_state  
23eb				endm  
# End of macro CALLMONITOR
23eb					endif 
23eb			 
23eb			.storebyteat:		 
23eb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23eb cd d8 1c			call macro_dsp_valuehl 
23ee				endm 
# End of macro FORTH_DSP_VALUEHL
23ee					 
23ee e5					push hl 
23ef				 
23ef					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23ef cd 90 1d			call macro_forth_dsp_pop 
23f2				endm 
# End of macro FORTH_DSP_POP
23f2			 
23f2					; get byte to poke 
23f2			 
23f2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
23f2 cd d8 1c			call macro_dsp_valuehl 
23f5				endm 
# End of macro FORTH_DSP_VALUEHL
23f5 e5					push hl 
23f6			 
23f6			 
23f6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
23f6 cd 90 1d			call macro_forth_dsp_pop 
23f9				endm 
# End of macro FORTH_DSP_POP
23f9			 
23f9			 
23f9 d1					pop de 
23fa e1					pop hl 
23fb			 
23fb 73					ld (hl),e 
23fc			 
23fc			 
23fc					NEXTW 
23fc c3 4a 1e			jp macro_next 
23ff				endm 
# End of macro NEXTW
23ff			.CBANG: 
23ff				CWHEAD .SCALL OPCODE_CBANG "C!" 2 WORD_FLAG_CODE 
23ff 22				db WORD_SYS_CORE+OPCODE_CBANG             
2400 28 24			dw .SCALL            
2402 03				db 2 + 1 
2403 .. 00			db "C!",0              
2406				endm 
# End of macro CWHEAD
2406			; | C!  ( x w -- ) Store x at address w  | DONE 
2406					if DEBUG_FORTH_WORDS_KEY 
2406						DMARK "CBA" 
2406 f5				push af  
2407 3a 1b 24			ld a, (.dmark)  
240a 32 71 ee			ld (debug_mark),a  
240d 3a 1c 24			ld a, (.dmark+1)  
2410 32 72 ee			ld (debug_mark+1),a  
2413 3a 1d 24			ld a, (.dmark+2)  
2416 32 73 ee			ld (debug_mark+2),a  
2419 18 03			jr .pastdmark  
241b ..			.dmark: db "CBA"  
241e f1			.pastdmark: pop af  
241f			endm  
# End of macro DMARK
241f						CALLMONITOR 
241f cd 87 14			call break_point_state  
2422				endm  
# End of macro CALLMONITOR
2422					endif 
2422 c3 eb 23				jp .storebyteat 
2425					NEXTW 
2425 c3 4a 1e			jp macro_next 
2428				endm 
# End of macro NEXTW
2428			.SCALL: 
2428				CWHEAD .DEPTH OPCODE_SCALL "CALL" 4 WORD_FLAG_CODE 
2428 23				db WORD_SYS_CORE+OPCODE_SCALL             
2429 5c 24			dw .DEPTH            
242b 05				db 4 + 1 
242c .. 00			db "CALL",0              
2431				endm 
# End of macro CWHEAD
2431			; | CALL ( w -- w  ) machine code call to address w  push the result of hl to stack | DONE 
2431					if DEBUG_FORTH_WORDS_KEY 
2431						DMARK "CLL" 
2431 f5				push af  
2432 3a 46 24			ld a, (.dmark)  
2435 32 71 ee			ld (debug_mark),a  
2438 3a 47 24			ld a, (.dmark+1)  
243b 32 72 ee			ld (debug_mark+1),a  
243e 3a 48 24			ld a, (.dmark+2)  
2441 32 73 ee			ld (debug_mark+2),a  
2444 18 03			jr .pastdmark  
2446 ..			.dmark: db "CLL"  
2449 f1			.pastdmark: pop af  
244a			endm  
# End of macro DMARK
244a						CALLMONITOR 
244a cd 87 14			call break_point_state  
244d				endm  
# End of macro CALLMONITOR
244d					endif 
244d			 
244d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
244d cd d8 1c			call macro_dsp_valuehl 
2450				endm 
# End of macro FORTH_DSP_VALUEHL
2450			 
2450			;		push hl 
2450			 
2450					; destroy value TOS 
2450			 
2450					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2450 cd 90 1d			call macro_forth_dsp_pop 
2453				endm 
# End of macro FORTH_DSP_POP
2453			 
2453						 
2453			;		pop hl 
2453			 
2453					; how to do a call with hl???? save SP? 
2453 cd f3 1d				call forth_call_hl 
2456			 
2456			 
2456					; TODO push value back onto stack for another op etc 
2456			 
2456 cd e1 1a				call forth_push_numhl 
2459					NEXTW 
2459 c3 4a 1e			jp macro_next 
245c				endm 
# End of macro NEXTW
245c			.DEPTH: 
245c				CWHEAD .OVER OPCODE_DEPTH "DEPTH" 5 WORD_FLAG_CODE 
245c 24				db WORD_SYS_CORE+OPCODE_DEPTH             
245d 99 24			dw .OVER            
245f 06				db 5 + 1 
2460 .. 00			db "DEPTH",0              
2466				endm 
# End of macro CWHEAD
2466			; | DEPTH ( -- u ) Push count of stack | DONE 
2466					; take current TOS and remove from base value div by two to get count 
2466					if DEBUG_FORTH_WORDS_KEY 
2466						DMARK "DEP" 
2466 f5				push af  
2467 3a 7b 24			ld a, (.dmark)  
246a 32 71 ee			ld (debug_mark),a  
246d 3a 7c 24			ld a, (.dmark+1)  
2470 32 72 ee			ld (debug_mark+1),a  
2473 3a 7d 24			ld a, (.dmark+2)  
2476 32 73 ee			ld (debug_mark+2),a  
2479 18 03			jr .pastdmark  
247b ..			.dmark: db "DEP"  
247e f1			.pastdmark: pop af  
247f			endm  
# End of macro DMARK
247f						CALLMONITOR 
247f cd 87 14			call break_point_state  
2482				endm  
# End of macro CALLMONITOR
2482					endif 
2482			 
2482			 
2482 2a 04 eb			ld hl, (cli_data_sp) 
2485 11 3e e9			ld de, cli_data_stack 
2488 ed 52			sbc hl,de 
248a				 
248a				; div by size of stack item 
248a			 
248a 5d				ld e,l 
248b 0e 03			ld c, 3 
248d cd 16 0c			call Div8 
2490			 
2490 6f				ld l,a 
2491 26 00			ld h,0 
2493			 
2493				;srl h 
2493				;rr l 
2493			 
2493 cd e1 1a				call forth_push_numhl 
2496					NEXTW 
2496 c3 4a 1e			jp macro_next 
2499				endm 
# End of macro NEXTW
2499			.OVER: 
2499				CWHEAD .PAUSE 46 "OVER" 4 WORD_FLAG_CODE 
2499 42				db WORD_SYS_CORE+46             
249a e0 24			dw .PAUSE            
249c 05				db 4 + 1 
249d .. 00			db "OVER",0              
24a2				endm 
# End of macro CWHEAD
24a2			; | OVER ( n1 n2 -- n1 n2 n1 )  Copy one below TOS onto TOS | DONE 
24a2					if DEBUG_FORTH_WORDS_KEY 
24a2						DMARK "OVR" 
24a2 f5				push af  
24a3 3a b7 24			ld a, (.dmark)  
24a6 32 71 ee			ld (debug_mark),a  
24a9 3a b8 24			ld a, (.dmark+1)  
24ac 32 72 ee			ld (debug_mark+1),a  
24af 3a b9 24			ld a, (.dmark+2)  
24b2 32 73 ee			ld (debug_mark+2),a  
24b5 18 03			jr .pastdmark  
24b7 ..			.dmark: db "OVR"  
24ba f1			.pastdmark: pop af  
24bb			endm  
# End of macro DMARK
24bb						CALLMONITOR 
24bb cd 87 14			call break_point_state  
24be				endm  
# End of macro CALLMONITOR
24be					endif 
24be			 
24be					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24be cd d8 1c			call macro_dsp_valuehl 
24c1				endm 
# End of macro FORTH_DSP_VALUEHL
24c1 e5					push hl    ; n2 
24c2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24c2 cd 90 1d			call macro_forth_dsp_pop 
24c5				endm 
# End of macro FORTH_DSP_POP
24c5			 
24c5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
24c5 cd d8 1c			call macro_dsp_valuehl 
24c8				endm 
# End of macro FORTH_DSP_VALUEHL
24c8 e5					push hl    ; n1 
24c9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
24c9 cd 90 1d			call macro_forth_dsp_pop 
24cc				endm 
# End of macro FORTH_DSP_POP
24cc			 
24cc d1					pop de     ; n1 
24cd e1					pop hl     ; n2 
24ce			 
24ce d5					push de 
24cf e5					push hl 
24d0 d5					push de 
24d1			 
24d1					; push back  
24d1			 
24d1 e1					pop hl 
24d2 cd e1 1a				call forth_push_numhl 
24d5 e1					pop hl 
24d6 cd e1 1a				call forth_push_numhl 
24d9 e1					pop hl 
24da cd e1 1a				call forth_push_numhl 
24dd					NEXTW 
24dd c3 4a 1e			jp macro_next 
24e0				endm 
# End of macro NEXTW
24e0			 
24e0			.PAUSE: 
24e0				CWHEAD .PAUSES 47 "PAUSEMS" 7 WORD_FLAG_CODE 
24e0 43				db WORD_SYS_CORE+47             
24e1 15 25			dw .PAUSES            
24e3 08				db 7 + 1 
24e4 .. 00			db "PAUSEMS",0              
24ec				endm 
# End of macro CWHEAD
24ec			; | PAUSEMS ( n -- )  Pause for n millisconds | DONE 
24ec					if DEBUG_FORTH_WORDS_KEY 
24ec						DMARK "PMS" 
24ec f5				push af  
24ed 3a 01 25			ld a, (.dmark)  
24f0 32 71 ee			ld (debug_mark),a  
24f3 3a 02 25			ld a, (.dmark+1)  
24f6 32 72 ee			ld (debug_mark+1),a  
24f9 3a 03 25			ld a, (.dmark+2)  
24fc 32 73 ee			ld (debug_mark+2),a  
24ff 18 03			jr .pastdmark  
2501 ..			.dmark: db "PMS"  
2504 f1			.pastdmark: pop af  
2505			endm  
# End of macro DMARK
2505						CALLMONITOR 
2505 cd 87 14			call break_point_state  
2508				endm  
# End of macro CALLMONITOR
2508					endif 
2508					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2508 cd d8 1c			call macro_dsp_valuehl 
250b				endm 
# End of macro FORTH_DSP_VALUEHL
250b			;		push hl    ; n2 
250b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
250b cd 90 1d			call macro_forth_dsp_pop 
250e				endm 
# End of macro FORTH_DSP_POP
250e			;		pop hl 
250e			 
250e 7d					ld a, l 
250f cd b0 09				call aDelayInMS 
2512				       NEXTW 
2512 c3 4a 1e			jp macro_next 
2515				endm 
# End of macro NEXTW
2515			.PAUSES:  
2515				CWHEAD .ROT 48 "PAUSE" 5 WORD_FLAG_CODE 
2515 44				db WORD_SYS_CORE+48             
2516 84 25			dw .ROT            
2518 06				db 5 + 1 
2519 .. 00			db "PAUSE",0              
251f				endm 
# End of macro CWHEAD
251f			; | PAUSE ( n -- )  Pause for n seconds | DONE 
251f					if DEBUG_FORTH_WORDS_KEY 
251f						DMARK "PAU" 
251f f5				push af  
2520 3a 34 25			ld a, (.dmark)  
2523 32 71 ee			ld (debug_mark),a  
2526 3a 35 25			ld a, (.dmark+1)  
2529 32 72 ee			ld (debug_mark+1),a  
252c 3a 36 25			ld a, (.dmark+2)  
252f 32 73 ee			ld (debug_mark+2),a  
2532 18 03			jr .pastdmark  
2534 ..			.dmark: db "PAU"  
2537 f1			.pastdmark: pop af  
2538			endm  
# End of macro DMARK
2538						CALLMONITOR 
2538 cd 87 14			call break_point_state  
253b				endm  
# End of macro CALLMONITOR
253b					endif 
253b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
253b cd d8 1c			call macro_dsp_valuehl 
253e				endm 
# End of macro FORTH_DSP_VALUEHL
253e			;		push hl    ; n2 
253e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
253e cd 90 1d			call macro_forth_dsp_pop 
2541				endm 
# End of macro FORTH_DSP_POP
2541			;		pop hl 
2541 45					ld b, l 
2542					if DEBUG_FORTH_WORDS 
2542						DMARK "PAU" 
2542 f5				push af  
2543 3a 57 25			ld a, (.dmark)  
2546 32 71 ee			ld (debug_mark),a  
2549 3a 58 25			ld a, (.dmark+1)  
254c 32 72 ee			ld (debug_mark+1),a  
254f 3a 59 25			ld a, (.dmark+2)  
2552 32 73 ee			ld (debug_mark+2),a  
2555 18 03			jr .pastdmark  
2557 ..			.dmark: db "PAU"  
255a f1			.pastdmark: pop af  
255b			endm  
# End of macro DMARK
255b						CALLMONITOR 
255b cd 87 14			call break_point_state  
255e				endm  
# End of macro CALLMONITOR
255e					endif 
255e c5			.pauses1:	push bc 
255f cd cb 09				call delay1s 
2562 c1					pop bc 
2563					if DEBUG_FORTH_WORDS 
2563						DMARK "PA1" 
2563 f5				push af  
2564 3a 78 25			ld a, (.dmark)  
2567 32 71 ee			ld (debug_mark),a  
256a 3a 79 25			ld a, (.dmark+1)  
256d 32 72 ee			ld (debug_mark+1),a  
2570 3a 7a 25			ld a, (.dmark+2)  
2573 32 73 ee			ld (debug_mark+2),a  
2576 18 03			jr .pastdmark  
2578 ..			.dmark: db "PA1"  
257b f1			.pastdmark: pop af  
257c			endm  
# End of macro DMARK
257c						CALLMONITOR 
257c cd 87 14			call break_point_state  
257f				endm  
# End of macro CALLMONITOR
257f					endif 
257f 10 dd				djnz .pauses1 
2581			 
2581				       NEXTW 
2581 c3 4a 1e			jp macro_next 
2584				endm 
# End of macro NEXTW
2584			.ROT: 
2584				CWHEAD .UWORDS 49 "ROT" 3 WORD_FLAG_CODE 
2584 45				db WORD_SYS_CORE+49             
2585 d2 25			dw .UWORDS            
2587 04				db 3 + 1 
2588 .. 00			db "ROT",0              
258c				endm 
# End of macro CWHEAD
258c			; | ROT ( u1 u2 u3 -- u2 u3 u1 ) Rotate top three items on stack | DONE 
258c					if DEBUG_FORTH_WORDS_KEY 
258c						DMARK "ROT" 
258c f5				push af  
258d 3a a1 25			ld a, (.dmark)  
2590 32 71 ee			ld (debug_mark),a  
2593 3a a2 25			ld a, (.dmark+1)  
2596 32 72 ee			ld (debug_mark+1),a  
2599 3a a3 25			ld a, (.dmark+2)  
259c 32 73 ee			ld (debug_mark+2),a  
259f 18 03			jr .pastdmark  
25a1 ..			.dmark: db "ROT"  
25a4 f1			.pastdmark: pop af  
25a5			endm  
# End of macro DMARK
25a5						CALLMONITOR 
25a5 cd 87 14			call break_point_state  
25a8				endm  
# End of macro CALLMONITOR
25a8					endif 
25a8			 
25a8					FORTH_DSP_VALUEHL 
25a8 cd d8 1c			call macro_dsp_valuehl 
25ab				endm 
# End of macro FORTH_DSP_VALUEHL
25ab e5					push hl    ; u3  
25ac			 
25ac					FORTH_DSP_POP 
25ac cd 90 1d			call macro_forth_dsp_pop 
25af				endm 
# End of macro FORTH_DSP_POP
25af			   
25af					FORTH_DSP_VALUEHL 
25af cd d8 1c			call macro_dsp_valuehl 
25b2				endm 
# End of macro FORTH_DSP_VALUEHL
25b2 e5					push hl     ; u2 
25b3			 
25b3					FORTH_DSP_POP 
25b3 cd 90 1d			call macro_forth_dsp_pop 
25b6				endm 
# End of macro FORTH_DSP_POP
25b6			 
25b6					FORTH_DSP_VALUEHL 
25b6 cd d8 1c			call macro_dsp_valuehl 
25b9				endm 
# End of macro FORTH_DSP_VALUEHL
25b9 e5					push hl     ; u1 
25ba			 
25ba					FORTH_DSP_POP 
25ba cd 90 1d			call macro_forth_dsp_pop 
25bd				endm 
# End of macro FORTH_DSP_POP
25bd			 
25bd c1					pop bc      ; u1 
25be e1					pop hl      ; u2 
25bf d1					pop de      ; u3 
25c0			 
25c0			 
25c0 c5					push bc 
25c1 d5					push de 
25c2 e5					push hl 
25c3			 
25c3			 
25c3 e1					pop hl 
25c4 cd e1 1a				call forth_push_numhl 
25c7			 
25c7 e1					pop hl 
25c8 cd e1 1a				call forth_push_numhl 
25cb			 
25cb e1					pop hl 
25cc cd e1 1a				call forth_push_numhl 
25cf					 
25cf			 
25cf			 
25cf			 
25cf			 
25cf			 
25cf				       NEXTW 
25cf c3 4a 1e			jp macro_next 
25d2				endm 
# End of macro NEXTW
25d2			 
25d2			.UWORDS: 
25d2				CWHEAD .BP 60 "UWORDS" 6 WORD_FLAG_CODE 
25d2 50				db WORD_SYS_CORE+60             
25d3 94 26			dw .BP            
25d5 07				db 6 + 1 
25d6 .. 00			db "UWORDS",0              
25dd				endm 
# End of macro CWHEAD
25dd			; | UWORDS (  -- s1 ... sn u )   List user word dict | DONE 
25dd			; | | After use the TOS will have a count of the number of user words that have been pushed to stack. 
25dd			; | | Following the count are the individual words. 
25dd			; | | 
25dd			; | | e.g. UWORDS 
25dd			; | | BOX DIRLIST 2 
25dd			; | |  
25dd			; | | Can be used to save the words to storage via: 
25dd			; | | UWORDS $01 DO $01 APPEND LOOP 
25dd				if DEBUG_FORTH_WORDS_KEY 
25dd					DMARK "UWR" 
25dd f5				push af  
25de 3a f2 25			ld a, (.dmark)  
25e1 32 71 ee			ld (debug_mark),a  
25e4 3a f3 25			ld a, (.dmark+1)  
25e7 32 72 ee			ld (debug_mark+1),a  
25ea 3a f4 25			ld a, (.dmark+2)  
25ed 32 73 ee			ld (debug_mark+2),a  
25f0 18 03			jr .pastdmark  
25f2 ..			.dmark: db "UWR"  
25f5 f1			.pastdmark: pop af  
25f6			endm  
# End of macro DMARK
25f6					CALLMONITOR 
25f6 cd 87 14			call break_point_state  
25f9				endm  
# End of macro CALLMONITOR
25f9				endif 
25f9 21 4e 5a				ld hl, baseram 
25fc					;ld hl, baseusermem 
25fc 01 00 00				ld bc, 0    ; start a counter 
25ff			 
25ff				; skip dict stub 
25ff			 
25ff cd 9b 1f				call forth_tok_next 
2602			 
2602			 
2602			; while we have words to look for 
2602			 
2602 7e			.douscan:	ld a, (hl)      
2603				if DEBUG_FORTH_WORDS 
2603					DMARK "UWs" 
2603 f5				push af  
2604 3a 18 26			ld a, (.dmark)  
2607 32 71 ee			ld (debug_mark),a  
260a 3a 19 26			ld a, (.dmark+1)  
260d 32 72 ee			ld (debug_mark+1),a  
2610 3a 1a 26			ld a, (.dmark+2)  
2613 32 73 ee			ld (debug_mark+2),a  
2616 18 03			jr .pastdmark  
2618 ..			.dmark: db "UWs"  
261b f1			.pastdmark: pop af  
261c			endm  
# End of macro DMARK
261c					CALLMONITOR 
261c cd 87 14			call break_point_state  
261f				endm  
# End of macro CALLMONITOR
261f				endif 
261f fe 00				cp WORD_SYS_END 
2621 28 4d				jr z, .udone 
2623 fe 01				cp WORD_SYS_UWORD 
2625 20 44				jr nz, .nuword 
2627			 
2627				if DEBUG_FORTH_WORDS 
2627					DMARK "UWu" 
2627 f5				push af  
2628 3a 3c 26			ld a, (.dmark)  
262b 32 71 ee			ld (debug_mark),a  
262e 3a 3d 26			ld a, (.dmark+1)  
2631 32 72 ee			ld (debug_mark+1),a  
2634 3a 3e 26			ld a, (.dmark+2)  
2637 32 73 ee			ld (debug_mark+2),a  
263a 18 03			jr .pastdmark  
263c ..			.dmark: db "UWu"  
263f f1			.pastdmark: pop af  
2640			endm  
# End of macro DMARK
2640					CALLMONITOR 
2640 cd 87 14			call break_point_state  
2643				endm  
# End of macro CALLMONITOR
2643				endif 
2643					; we have a uword so push its name to the stack 
2643			 
2643 e5				   	push hl  ; save so we can move to next dict block 
2644			 
2644					; skip opcode 
2644 23					inc hl  
2645					; skip next ptr 
2645 23					inc hl  
2646 23					inc hl 
2647					; skip len 
2647 23					inc hl 
2648				if DEBUG_FORTH_WORDS 
2648					DMARK "UWt" 
2648 f5				push af  
2649 3a 5d 26			ld a, (.dmark)  
264c 32 71 ee			ld (debug_mark),a  
264f 3a 5e 26			ld a, (.dmark+1)  
2652 32 72 ee			ld (debug_mark+1),a  
2655 3a 5f 26			ld a, (.dmark+2)  
2658 32 73 ee			ld (debug_mark+2),a  
265b 18 03			jr .pastdmark  
265d ..			.dmark: db "UWt"  
2660 f1			.pastdmark: pop af  
2661			endm  
# End of macro DMARK
2661					CALLMONITOR 
2661 cd 87 14			call break_point_state  
2664				endm  
# End of macro CALLMONITOR
2664				endif 
2664 03					inc bc 
2665			 
2665 c5					push bc 
2666 cd 4f 1b				call forth_push_str 
2669 c1					pop bc 
266a			 
266a e1					pop hl 	 
266b			 
266b cd 9b 1f		.nuword:	call forth_tok_next 
266e 18 92				jr .douscan  
2670			 
2670			.udone:		 ; push count of uwords found 
2670 c5					push bc 
2671 e1					pop hl 
2672			 
2672				if DEBUG_FORTH_WORDS 
2672					DMARK "UWc" 
2672 f5				push af  
2673 3a 87 26			ld a, (.dmark)  
2676 32 71 ee			ld (debug_mark),a  
2679 3a 88 26			ld a, (.dmark+1)  
267c 32 72 ee			ld (debug_mark+1),a  
267f 3a 89 26			ld a, (.dmark+2)  
2682 32 73 ee			ld (debug_mark+2),a  
2685 18 03			jr .pastdmark  
2687 ..			.dmark: db "UWc"  
268a f1			.pastdmark: pop af  
268b			endm  
# End of macro DMARK
268b					CALLMONITOR 
268b cd 87 14			call break_point_state  
268e				endm  
# End of macro CALLMONITOR
268e				endif 
268e cd e1 1a				call forth_push_numhl 
2691			 
2691			 
2691				       NEXTW 
2691 c3 4a 1e			jp macro_next 
2694				endm 
# End of macro NEXTW
2694			 
2694			.BP: 
2694				CWHEAD .MONITOR 64 "BP" 2 WORD_FLAG_CODE 
2694 54				db WORD_SYS_CORE+64             
2695 ca 26			dw .MONITOR            
2697 03				db 2 + 1 
2698 .. 00			db "BP",0              
269b				endm 
# End of macro CWHEAD
269b			; | BP ( u1 -- ) Enable or disable break point monitoring | DONE 
269b			; | | $00 Will enable the break points within specific code paths 
269b			; | | $01 Will disable break points 
269b			; | |  
269b			; | | By default break points are off. Either the above can be used to enable them 
269b			; | | or if a key is held down during start up the spashscreen will appear to freeze 
269b			; | | and on release of the pressed key a message will be disaplayed to notify 
269b			; | | that break points are enabled. Pressing any key will then continue boot process. 
269b					; get byte count 
269b					if DEBUG_FORTH_WORDS_KEY 
269b						DMARK "BP." 
269b f5				push af  
269c 3a b0 26			ld a, (.dmark)  
269f 32 71 ee			ld (debug_mark),a  
26a2 3a b1 26			ld a, (.dmark+1)  
26a5 32 72 ee			ld (debug_mark+1),a  
26a8 3a b2 26			ld a, (.dmark+2)  
26ab 32 73 ee			ld (debug_mark+2),a  
26ae 18 03			jr .pastdmark  
26b0 ..			.dmark: db "BP."  
26b3 f1			.pastdmark: pop af  
26b4			endm  
# End of macro DMARK
26b4						CALLMONITOR 
26b4 cd 87 14			call break_point_state  
26b7				endm  
# End of macro CALLMONITOR
26b7					endif 
26b7			 
26b7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
26b7 cd d8 1c			call macro_dsp_valuehl 
26ba				endm 
# End of macro FORTH_DSP_VALUEHL
26ba			 
26ba			;		push hl 
26ba			 
26ba					; destroy value TOS 
26ba			 
26ba					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
26ba cd 90 1d			call macro_forth_dsp_pop 
26bd				endm 
# End of macro FORTH_DSP_POP
26bd			 
26bd			;		pop hl 
26bd			 
26bd 3e 00				ld a,0 
26bf bd					cp l 
26c0 28 02				jr z, .bpset 
26c2 3e 2a				ld a, '*' 
26c4			 
26c4 32 c8 e3		.bpset:		ld (os_view_disable), a 
26c7			 
26c7			 
26c7					NEXTW 
26c7 c3 4a 1e			jp macro_next 
26ca				endm 
# End of macro NEXTW
26ca			 
26ca			 
26ca			.MONITOR: 
26ca				CWHEAD .MALLOC 65 "MONITOR" 7 WORD_FLAG_CODE 
26ca 55				db WORD_SYS_CORE+65             
26cb fd 26			dw .MALLOC            
26cd 08				db 7 + 1 
26ce .. 00			db "MONITOR",0              
26d6				endm 
# End of macro CWHEAD
26d6			; | MONITOR ( -- ) Display system breakpoint/monitor | DONE 
26d6			; | | At start the current various registers will be displayed with contents. 
26d6			; | | Top right corner will show the most recent debug marker seen. 
26d6			; | | The bottom of the screen will also show the values of the data stack pointer (DSP) 
26d6			; | | and the return stack pointer (RSP). 
26d6			; | | Pressing: 
26d6			; | |    1 - Initial screen 
26d6			; | |    2 - Display a data dump of HL 
26d6			; | |    3 - Display a data dump of DE 
26d6			; | |    4 - Display a data dump of BC 
26d6			; | |    5 - Display a data dump of HL 
26d6			; | |    6 - Display a data dump of DSP 
26d6			; | |    7 - Display a data dump of RSP 
26d6			; | |    8 - Display a data dump of what is at DSP 
26d6			; | |    9 - Display a data dump of what is at RSP 
26d6			; | |    0 - Exit monitor and continue running. This will also enable break points 
26d6			; | |    * - Disable break points 
26d6			; | |    # - Enter traditional monitor mode 
26d6			; | | 
26d6			; | | Monitor Mode 
26d6			; | | ------------ 
26d6			; | | A prompt of '>' will be shown for various commands: 
26d6			; | |    D xxxx - Display a data dump starting from hex address xxxx 
26d6			; | |    C - Continue display a data dump from the last set address 
26d6			; | |    M xxxx - Set start of memory edit at address xx 
26d6			; | |    U xx - Poke the hex byte xx into the address set by M and increment the address to the next location 
26d6			; | |    Q - Return to previous 
26d6					if DEBUG_FORTH_WORDS_KEY 
26d6						DMARK "MON" 
26d6 f5				push af  
26d7 3a eb 26			ld a, (.dmark)  
26da 32 71 ee			ld (debug_mark),a  
26dd 3a ec 26			ld a, (.dmark+1)  
26e0 32 72 ee			ld (debug_mark+1),a  
26e3 3a ed 26			ld a, (.dmark+2)  
26e6 32 73 ee			ld (debug_mark+2),a  
26e9 18 03			jr .pastdmark  
26eb ..			.dmark: db "MON"  
26ee f1			.pastdmark: pop af  
26ef			endm  
# End of macro DMARK
26ef						CALLMONITOR 
26ef cd 87 14			call break_point_state  
26f2				endm  
# End of macro CALLMONITOR
26f2					endif 
26f2 3e 00				ld a, 0 
26f4 32 c8 e3				ld (os_view_disable), a 
26f7			 
26f7					CALLMONITOR 
26f7 cd 87 14			call break_point_state  
26fa				endm  
# End of macro CALLMONITOR
26fa			 
26fa			;	call monitor 
26fa			 
26fa					NEXTW 
26fa c3 4a 1e			jp macro_next 
26fd				endm 
# End of macro NEXTW
26fd			 
26fd			 
26fd			.MALLOC: 
26fd				CWHEAD .MALLOC2 66 "ALLOT" 5 WORD_FLAG_CODE 
26fd 56				db WORD_SYS_CORE+66             
26fe 26 27			dw .MALLOC2            
2700 06				db 5 + 1 
2701 .. 00			db "ALLOT",0              
2707				endm 
# End of macro CWHEAD
2707			; | ALLOT ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2707					if DEBUG_FORTH_WORDS_KEY 
2707						DMARK "ALL" 
2707 f5				push af  
2708 3a 1c 27			ld a, (.dmark)  
270b 32 71 ee			ld (debug_mark),a  
270e 3a 1d 27			ld a, (.dmark+1)  
2711 32 72 ee			ld (debug_mark+1),a  
2714 3a 1e 27			ld a, (.dmark+2)  
2717 32 73 ee			ld (debug_mark+2),a  
271a 18 03			jr .pastdmark  
271c ..			.dmark: db "ALL"  
271f f1			.pastdmark: pop af  
2720			endm  
# End of macro DMARK
2720						CALLMONITOR 
2720 cd 87 14			call break_point_state  
2723				endm  
# End of macro CALLMONITOR
2723					endif 
2723 c3 4d 27				jp .mallocc 
2726			.MALLOC2: 
2726				CWHEAD .FREE 66 "MALLOC" 6 WORD_FLAG_CODE 
2726 56				db WORD_SYS_CORE+66             
2727 64 27			dw .FREE            
2729 07				db 6 + 1 
272a .. 00			db "MALLOC",0              
2731				endm 
# End of macro CWHEAD
2731			; | MALLOC ( u -- u ) Allocate u bytes of memory space and push the pointer TOS  | DONE 
2731					; get byte count 
2731					if DEBUG_FORTH_WORDS_KEY 
2731						DMARK "MAL" 
2731 f5				push af  
2732 3a 46 27			ld a, (.dmark)  
2735 32 71 ee			ld (debug_mark),a  
2738 3a 47 27			ld a, (.dmark+1)  
273b 32 72 ee			ld (debug_mark+1),a  
273e 3a 48 27			ld a, (.dmark+2)  
2741 32 73 ee			ld (debug_mark+2),a  
2744 18 03			jr .pastdmark  
2746 ..			.dmark: db "MAL"  
2749 f1			.pastdmark: pop af  
274a			endm  
# End of macro DMARK
274a						CALLMONITOR 
274a cd 87 14			call break_point_state  
274d				endm  
# End of macro CALLMONITOR
274d					endif 
274d			.mallocc: 
274d					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
274d cd d8 1c			call macro_dsp_valuehl 
2750				endm 
# End of macro FORTH_DSP_VALUEHL
2750			 
2750			;		push hl 
2750			 
2750					; destroy value TOS 
2750			 
2750					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
2750 cd 90 1d			call macro_forth_dsp_pop 
2753				endm 
# End of macro FORTH_DSP_POP
2753			 
2753			;		pop hl 
2753 cd 4d 11				call malloc 
2756				if DEBUG_FORTH_MALLOC_GUARD 
2756 f5					push af 
2757 cd af 0c				call ishlzero 
275a			;		ld a, l 
275a			;		add h 
275a			;		cp 0 
275a f1					pop af 
275b					 
275b cc 7c 46				call z,malloc_error 
275e				endif 
275e			 
275e cd e1 1a				call forth_push_numhl 
2761					NEXTW 
2761 c3 4a 1e			jp macro_next 
2764				endm 
# End of macro NEXTW
2764			 
2764			.FREE: 
2764				CWHEAD .LIST 67 "FREE" 4 WORD_FLAG_CODE 
2764 57				db WORD_SYS_CORE+67             
2765 95 27			dw .LIST            
2767 05				db 4 + 1 
2768 .. 00			db "FREE",0              
276d				endm 
# End of macro CWHEAD
276d			; | FREE ( u --  ) Free memory block from malloc given u address  | DONE 
276d					if DEBUG_FORTH_WORDS_KEY 
276d						DMARK "FRE" 
276d f5				push af  
276e 3a 82 27			ld a, (.dmark)  
2771 32 71 ee			ld (debug_mark),a  
2774 3a 83 27			ld a, (.dmark+1)  
2777 32 72 ee			ld (debug_mark+1),a  
277a 3a 84 27			ld a, (.dmark+2)  
277d 32 73 ee			ld (debug_mark+2),a  
2780 18 03			jr .pastdmark  
2782 ..			.dmark: db "FRE"  
2785 f1			.pastdmark: pop af  
2786			endm  
# End of macro DMARK
2786						CALLMONITOR 
2786 cd 87 14			call break_point_state  
2789				endm  
# End of macro CALLMONITOR
2789					endif 
2789					; get address 
2789			 
2789					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
2789 cd d8 1c			call macro_dsp_valuehl 
278c				endm 
# End of macro FORTH_DSP_VALUEHL
278c			 
278c			;		push hl 
278c			 
278c					; destroy value TOS 
278c			 
278c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
278c cd 90 1d			call macro_forth_dsp_pop 
278f				endm 
# End of macro FORTH_DSP_POP
278f			 
278f			;		pop hl 
278f			if FORTH_ENABLE_MALLOCFREE 
278f cd 17 12				call free 
2792			endif 
2792					NEXTW 
2792 c3 4a 1e			jp macro_next 
2795				endm 
# End of macro NEXTW
2795			.LIST: 
2795				CWHEAD .FORGET 72 "LIST" 4 WORD_FLAG_CODE 
2795 5c				db WORD_SYS_CORE+72             
2796 83 29			dw .FORGET            
2798 05				db 4 + 1 
2799 .. 00			db "LIST",0              
279e				endm 
# End of macro CWHEAD
279e			; | LIST ( uword -- u )    List the code to the word that is quoted (so as not to exec) on TOS | DONE 
279e			; | | The quoted word must be in upper case. 
279e				if DEBUG_FORTH_WORDS_KEY 
279e					DMARK "LST" 
279e f5				push af  
279f 3a b3 27			ld a, (.dmark)  
27a2 32 71 ee			ld (debug_mark),a  
27a5 3a b4 27			ld a, (.dmark+1)  
27a8 32 72 ee			ld (debug_mark+1),a  
27ab 3a b5 27			ld a, (.dmark+2)  
27ae 32 73 ee			ld (debug_mark+2),a  
27b1 18 03			jr .pastdmark  
27b3 ..			.dmark: db "LST"  
27b6 f1			.pastdmark: pop af  
27b7			endm  
# End of macro DMARK
27b7					CALLMONITOR 
27b7 cd 87 14			call break_point_state  
27ba				endm  
# End of macro CALLMONITOR
27ba				endif 
27ba			 
27ba					FORTH_DSP_VALUEHL 
27ba cd d8 1c			call macro_dsp_valuehl 
27bd				endm 
# End of macro FORTH_DSP_VALUEHL
27bd			 
27bd e5					push hl 
27be					FORTH_DSP_POP 
27be cd 90 1d			call macro_forth_dsp_pop 
27c1				endm 
# End of macro FORTH_DSP_POP
27c1 c1					pop bc 
27c2			 
27c2			; Start format of scratch string 
27c2			 
27c2 21 d7 e3				ld hl, scratch 
27c5			 
27c5 3e 3a				ld a, ':' 
27c7 77					ld (hl),a 
27c8 23					inc hl 
27c9 3e 20				ld a, ' ' 
27cb 77					ld (hl), a 
27cc			 
27cc					; Get ptr to the word we need to look up 
27cc			 
27cc			;		FORTH_DSP_VALUEHL 
27cc					;v5 FORTH_DSP_VALUE 
27cc				; TODO type check 
27cc			;		inc hl    ; Skip type check  
27cc			;		push hl 
27cc			;		ex de, hl    ; put into DE 
27cc			 
27cc			 
27cc 21 4e 5a				ld hl, baseram 
27cf					;ld hl, baseusermem 
27cf			 
27cf e5			push hl   ; sacreifical push 
27d0			 
27d0			.ldouscanm: 
27d0 e1				pop hl 
27d1			.ldouscan: 
27d1				if DEBUG_FORTH_WORDS 
27d1					DMARK "LSs" 
27d1 f5				push af  
27d2 3a e6 27			ld a, (.dmark)  
27d5 32 71 ee			ld (debug_mark),a  
27d8 3a e7 27			ld a, (.dmark+1)  
27db 32 72 ee			ld (debug_mark+1),a  
27de 3a e8 27			ld a, (.dmark+2)  
27e1 32 73 ee			ld (debug_mark+2),a  
27e4 18 03			jr .pastdmark  
27e6 ..			.dmark: db "LSs"  
27e9 f1			.pastdmark: pop af  
27ea			endm  
# End of macro DMARK
27ea					CALLMONITOR 
27ea cd 87 14			call break_point_state  
27ed				endm  
# End of macro CALLMONITOR
27ed				endif 
27ed				; skip dict stub 
27ed cd 9b 1f				call forth_tok_next 
27f0			 
27f0			 
27f0			; while we have words to look for 
27f0			 
27f0 7e				ld a, (hl)      
27f1				if DEBUG_FORTH_WORDS 
27f1					DMARK "LSk" 
27f1 f5				push af  
27f2 3a 06 28			ld a, (.dmark)  
27f5 32 71 ee			ld (debug_mark),a  
27f8 3a 07 28			ld a, (.dmark+1)  
27fb 32 72 ee			ld (debug_mark+1),a  
27fe 3a 08 28			ld a, (.dmark+2)  
2801 32 73 ee			ld (debug_mark+2),a  
2804 18 03			jr .pastdmark  
2806 ..			.dmark: db "LSk"  
2809 f1			.pastdmark: pop af  
280a			endm  
# End of macro DMARK
280a					CALLMONITOR 
280a cd 87 14			call break_point_state  
280d				endm  
# End of macro CALLMONITOR
280d				endif 
280d					;cp WORD_SYS_END 
280d					;jp z, .lunotfound 
280d			 
280d					; if we hit non uwords then gone too far 
280d fe 01				cp WORD_SYS_UWORD 
280f c2 3f 29				jp nz, .lunotfound 
2812			 
2812				if DEBUG_FORTH_WORDS 
2812					DMARK "LSu" 
2812 f5				push af  
2813 3a 27 28			ld a, (.dmark)  
2816 32 71 ee			ld (debug_mark),a  
2819 3a 28 28			ld a, (.dmark+1)  
281c 32 72 ee			ld (debug_mark+1),a  
281f 3a 29 28			ld a, (.dmark+2)  
2822 32 73 ee			ld (debug_mark+2),a  
2825 18 03			jr .pastdmark  
2827 ..			.dmark: db "LSu"  
282a f1			.pastdmark: pop af  
282b			endm  
# End of macro DMARK
282b					CALLMONITOR 
282b cd 87 14			call break_point_state  
282e				endm  
# End of macro CALLMONITOR
282e				endif 
282e			 
282e					; found a uword but is it the one we want... 
282e			 
282e c5					push bc     ; uword to find is on bc 
282f d1					pop de 
2830			 
2830 e5					push hl  ; to save the ptr 
2831			 
2831					; skip opcode 
2831 23					inc hl  
2832					; skip next ptr 
2832 23					inc hl  
2833 23					inc hl 
2834					; skip len 
2834 23					inc hl 
2835			 
2835				if DEBUG_FORTH_WORDS 
2835					DMARK "LSc" 
2835 f5				push af  
2836 3a 4a 28			ld a, (.dmark)  
2839 32 71 ee			ld (debug_mark),a  
283c 3a 4b 28			ld a, (.dmark+1)  
283f 32 72 ee			ld (debug_mark+1),a  
2842 3a 4c 28			ld a, (.dmark+2)  
2845 32 73 ee			ld (debug_mark+2),a  
2848 18 03			jr .pastdmark  
284a ..			.dmark: db "LSc"  
284d f1			.pastdmark: pop af  
284e			endm  
# End of macro DMARK
284e					CALLMONITOR 
284e cd 87 14			call break_point_state  
2851				endm  
# End of macro CALLMONITOR
2851				endif 
2851 cd 1c 11				call strcmp 
2854 c2 d0 27				jp nz, .ldouscanm 
2857				 
2857			 
2857			 
2857					; we have a uword so push its name to the stack 
2857			 
2857			;	   	push hl  ; save so we can move to next dict block 
2857 e1			pop hl 
2858			 
2858				if DEBUG_FORTH_WORDS 
2858					DMARK "LSm" 
2858 f5				push af  
2859 3a 6d 28			ld a, (.dmark)  
285c 32 71 ee			ld (debug_mark),a  
285f 3a 6e 28			ld a, (.dmark+1)  
2862 32 72 ee			ld (debug_mark+1),a  
2865 3a 6f 28			ld a, (.dmark+2)  
2868 32 73 ee			ld (debug_mark+2),a  
286b 18 03			jr .pastdmark  
286d ..			.dmark: db "LSm"  
2870 f1			.pastdmark: pop af  
2871			endm  
# End of macro DMARK
2871					CALLMONITOR 
2871 cd 87 14			call break_point_state  
2874				endm  
# End of macro CALLMONITOR
2874				endif 
2874			 
2874					; skip opcode 
2874 23					inc hl  
2875					; skip next ptr 
2875 23					inc hl  
2876 23					inc hl 
2877					; skip len 
2877 7e					ld a, (hl)   ; save length to add 
2878				if DEBUG_FORTH_WORDS 
2878					DMARK "LS2" 
2878 f5				push af  
2879 3a 8d 28			ld a, (.dmark)  
287c 32 71 ee			ld (debug_mark),a  
287f 3a 8e 28			ld a, (.dmark+1)  
2882 32 72 ee			ld (debug_mark+1),a  
2885 3a 8f 28			ld a, (.dmark+2)  
2888 32 73 ee			ld (debug_mark+2),a  
288b 18 03			jr .pastdmark  
288d ..			.dmark: db "LS2"  
2890 f1			.pastdmark: pop af  
2891			endm  
# End of macro DMARK
2891					CALLMONITOR 
2891 cd 87 14			call break_point_state  
2894				endm  
# End of macro CALLMONITOR
2894				endif 
2894			 
2894					; save this location 
2894				 
2894 e5					push hl 
2895			 
2895 23					inc hl 
2896 11 d9 e3				ld de, scratch+2 
2899 4f					ld c, a 
289a 06 00				ld b, 0 
289c			 
289c				if DEBUG_FORTH_WORDS 
289c					DMARK "LSn" 
289c f5				push af  
289d 3a b1 28			ld a, (.dmark)  
28a0 32 71 ee			ld (debug_mark),a  
28a3 3a b2 28			ld a, (.dmark+1)  
28a6 32 72 ee			ld (debug_mark+1),a  
28a9 3a b3 28			ld a, (.dmark+2)  
28ac 32 73 ee			ld (debug_mark+2),a  
28af 18 03			jr .pastdmark  
28b1 ..			.dmark: db "LSn"  
28b4 f1			.pastdmark: pop af  
28b5			endm  
# End of macro DMARK
28b5					CALLMONITOR 
28b5 cd 87 14			call break_point_state  
28b8				endm  
# End of macro CALLMONITOR
28b8				endif 
28b8			 
28b8					; copy uword name to scratch 
28b8			 
28b8 ed b0				ldir 
28ba			 
28ba 1b					dec de 
28bb 3e 20				ld a, ' '    ; change null to space 
28bd 12					ld (de), a 
28be			 
28be 13					inc de 
28bf			 
28bf d5					push de 
28c0 c1					pop bc     ; move scratch pointer to end of word name and save it 
28c1			 
28c1 e1					pop hl 
28c2 7e					ld a, (hl) 
28c3					;inc hl 
28c3					; skip word string 
28c3 cd 86 0c				call addatohl 
28c6			 
28c6 23					inc hl 
28c7			 
28c7				if DEBUG_FORTH_WORDS 
28c7					DMARK "LS3" 
28c7 f5				push af  
28c8 3a dc 28			ld a, (.dmark)  
28cb 32 71 ee			ld (debug_mark),a  
28ce 3a dd 28			ld a, (.dmark+1)  
28d1 32 72 ee			ld (debug_mark+1),a  
28d4 3a de 28			ld a, (.dmark+2)  
28d7 32 73 ee			ld (debug_mark+2),a  
28da 18 03			jr .pastdmark  
28dc ..			.dmark: db "LS3"  
28df f1			.pastdmark: pop af  
28e0			endm  
# End of macro DMARK
28e0					CALLMONITOR 
28e0 cd 87 14			call break_point_state  
28e3				endm  
# End of macro CALLMONITOR
28e3				endif 
28e3					; should now be at the start of the machine code to setup the eval of the uword 
28e3					; now locate the ptr to the string defintion 
28e3			 
28e3					; skip ld hl, 
28e3					; then load the ptr 
28e3			; TODO use get from hl ptr 
28e3 23					inc hl 
28e4 5e					ld e, (hl) 
28e5 23					inc hl 
28e6 56					ld d, (hl) 
28e7 eb					ex de, hl 
28e8			 
28e8			 
28e8				if DEBUG_FORTH_WORDS 
28e8					DMARK "LSt" 
28e8 f5				push af  
28e9 3a fd 28			ld a, (.dmark)  
28ec 32 71 ee			ld (debug_mark),a  
28ef 3a fe 28			ld a, (.dmark+1)  
28f2 32 72 ee			ld (debug_mark+1),a  
28f5 3a ff 28			ld a, (.dmark+2)  
28f8 32 73 ee			ld (debug_mark+2),a  
28fb 18 03			jr .pastdmark  
28fd ..			.dmark: db "LSt"  
2900 f1			.pastdmark: pop af  
2901			endm  
# End of macro DMARK
2901					CALLMONITOR 
2901 cd 87 14			call break_point_state  
2904				endm  
# End of macro CALLMONITOR
2904				endif 
2904			 
2904			; cant push right now due to tokenised strings  
2904			 
2904			; get the destination of where to copy this definition to. 
2904			 
2904 c5					push bc 
2905 d1					pop de 
2906			 
2906 7e			.listl:         ld a,(hl) 
2907 fe 00				cp 0 
2909 28 09				jr z, .lreplsp     ; replace zero with space 
290b					;cp FORTH_END_BUFFER 
290b fe 3b				cp ';'    ; No end buffer flag but the ';' will be a good sign of the end of definition 
290d 28 0a				jr z, .listdone    ; at end of uword defination to close of scratch and finish 
290f				 
290f					; just copy this char as is then 
290f			 
290f 12					ld (de), a 
2910			 
2910 23			.listnxt:	inc hl 
2911 13					inc de 
2912 18 f2				jr .listl 
2914			 
2914 3e 20		.lreplsp:	ld a,' ' 
2916 12					ld (de), a 
2917 18 f7				jr .listnxt 
2919			 
2919			; close up uword def 
2919			 
2919			.listdone: 
2919 12					ld (de), a 
291a 13					inc de 
291b 3e 00				ld a, 0 
291d 12					ld (de), a 
291e			 
291e			; now have def so clean up and push to stack 
291e			 
291e 21 d7 e3				ld hl, scratch 
2921				if DEBUG_FORTH_WORDS 
2921					DMARK "Ltp" 
2921 f5				push af  
2922 3a 36 29			ld a, (.dmark)  
2925 32 71 ee			ld (debug_mark),a  
2928 3a 37 29			ld a, (.dmark+1)  
292b 32 72 ee			ld (debug_mark+1),a  
292e 3a 38 29			ld a, (.dmark+2)  
2931 32 73 ee			ld (debug_mark+2),a  
2934 18 03			jr .pastdmark  
2936 ..			.dmark: db "Ltp"  
2939 f1			.pastdmark: pop af  
293a			endm  
# End of macro DMARK
293a					CALLMONITOR 
293a cd 87 14			call break_point_state  
293d				endm  
# End of macro CALLMONITOR
293d				endif 
293d			 
293d 18 1f			jr .listpush 
293f			 
293f			;.lnuword:	pop hl 
293f			;		call forth_tok_next 
293f			;		jp .ldouscan  
293f			 
293f			.lunotfound:		  
293f			 
293f				if DEBUG_FORTH_WORDS 
293f					DMARK "LSn" 
293f f5				push af  
2940 3a 54 29			ld a, (.dmark)  
2943 32 71 ee			ld (debug_mark),a  
2946 3a 55 29			ld a, (.dmark+1)  
2949 32 72 ee			ld (debug_mark+1),a  
294c 3a 56 29			ld a, (.dmark+2)  
294f 32 73 ee			ld (debug_mark+2),a  
2952 18 03			jr .pastdmark  
2954 ..			.dmark: db "LSn"  
2957 f1			.pastdmark: pop af  
2958			endm  
# End of macro DMARK
2958					CALLMONITOR 
2958 cd 87 14			call break_point_state  
295b				endm  
# End of macro CALLMONITOR
295b				endif 
295b			 
295b					 
295b			;		FORTH_DSP_POP 
295b			;		ld hl, .luno 
295b			 
295b					NEXTW			 
295b c3 4a 1e			jp macro_next 
295e				endm 
# End of macro NEXTW
295e			 
295e			.listpush: 
295e				if DEBUG_FORTH_WORDS 
295e					DMARK "LS>" 
295e f5				push af  
295f 3a 73 29			ld a, (.dmark)  
2962 32 71 ee			ld (debug_mark),a  
2965 3a 74 29			ld a, (.dmark+1)  
2968 32 72 ee			ld (debug_mark+1),a  
296b 3a 75 29			ld a, (.dmark+2)  
296e 32 73 ee			ld (debug_mark+2),a  
2971 18 03			jr .pastdmark  
2973 ..			.dmark: db "LS>"  
2976 f1			.pastdmark: pop af  
2977			endm  
# End of macro DMARK
2977					CALLMONITOR 
2977 cd 87 14			call break_point_state  
297a				endm  
# End of macro CALLMONITOR
297a				endif 
297a cd 4f 1b				call forth_push_str 
297d			 
297d			 
297d			 
297d					NEXTW 
297d c3 4a 1e			jp macro_next 
2980				endm 
# End of macro NEXTW
2980			 
2980			;.luno:    db "Word not found",0 
2980			 
2980			 
2980			 
2980			 
2980			 
2980			;		push hl   ; save pointer to start of uword def string 
2980			; 
2980			;; look for FORTH_EOL_LINE 
2980			;		ld a, FORTH_END_BUFFER 
2980			;		call strlent 
2980			; 
2980			;		inc hl		 ; space for coln def 
2980			;		inc hl 
2980			;		inc hl          ; space for terms 
2980			;		inc hl 
2980			; 
2980			;		ld a, 20   ; TODO get actual length 
2980			;		call addatohl    ; include a random amount of room for the uword name 
2980			; 
2980			;		 
2980			;	if DEBUG_FORTH_WORDS 
2980			;		DMARK "Lt1" 
2980			;		CALLMONITOR 
2980			;	endif 
2980			;		 
2980			; 
2980			;; malloc space for the string because we cant change it 
2980			; 
2980			;		call malloc 
2980			;	if DEBUG_FORTH_MALLOC_GUARD 
2980			;		push af 
2980			;		call ishlzero 
2980			;		pop af 
2980			;		 
2980			;		call z,malloc_error 
2980			;	endif 
2980			; 
2980			;	if DEBUG_FORTH_WORDS 
2980			;		DMARK "Lt2" 
2980			;		CALLMONITOR 
2980			;	endif 
2980			;		pop de 
2980			;		push hl    ; push the malloc to release later 
2980			;		push hl   ;  push back a copy for the later stack push 
2980			;		 
2980			;; copy the string swapping out the zero terms for spaces 
2980			; 
2980			;		; de has our source 
2980			;		; hl has our dest 
2980			; 
2980			;; add the coln def 
2980			; 
2980			;		ld a, ':' 
2980			;		ld (hl), a 
2980			;		inc hl 
2980			;		ld a, ' ' 
2980			;		ld (hl), a 
2980			;		inc hl 
2980			; 
2980			;; add the uname word 
2980			;		push de   ; save our string for now 
2980			;		ex de, hl 
2980			; 
2980			;		FORTH_DSP_VALUE 
2980			;		;v5 FORTH_DSP_VALUE 
2980			; 
2980			;		inc hl   ; skip type but we know by now this is OK 
2980			; 
2980			;.luword:	ld a,(hl) 
2980			;		cp 0 
2980			;		jr z, .luword2 
2980			;		ld (de), a 
2980			;		inc de 
2980			;		inc hl 
2980			;		jr .luword 
2980			; 
2980			;.luword2:	ld a, ' ' 
2980			;		ld (de), a 
2980			;;		inc hl 
2980			;;		inc de 
2980			;;		ld (de), a 
2980			;;		inc hl 
2980			;		inc de 
2980			; 
2980			;		ex de, hl 
2980			;		pop de 
2980			;		 
2980			;		 
2980			; 
2980			;; detoken that string and copy it 
2980			; 
2980			;	if DEBUG_FORTH_WORDS 
2980			;		DMARK "Lt2" 
2980			;		CALLMONITOR 
2980			;	endif 
2980			;.ldetok:	ld a, (de) 
2980			;		cp FORTH_END_BUFFER 
2980			;		jr z, .ldetokend 
2980			;		; swap out any zero term for space 
2980			;		cp 0 
2980			;		jr nz, .ldetoknext 
2980			;		ld a, ' ' 
2980			; 
2980			;	if DEBUG_FORTH_WORDS 
2980			;		DMARK "LtS" 
2980			;		CALLMONITOR 
2980			;	endif 
2980			;.ldetoknext:	ld (hl), a 
2980			;		inc de 
2980			;		inc hl 
2980			;		jr .ldetok 
2980			; 
2980			;.ldetokend:	ld a, 0    ; replace forth eol with string term for pushing 
2980			;		ld (hl), a  
2980			; 
2980			;; free that temp malloc 
2980			; 
2980			;		pop hl    
2980			; 
2980			;	if DEBUG_FORTH_WORDS 
2980			;		DMARK "Lt4" 
2980			;		CALLMONITOR 
2980			;	endif 
2980			;		call forth_apushstrhl 
2980			; 
2980			;		; get rid of temp malloc area 
2980			; 
2980			;		pop hl 
2980			;		call free 
2980			; 
2980			;		jr .ludone 
2980			; 
2980			;.lnuword:	pop hl 
2980			;		call forth_tok_next 
2980			;		jp .ldouscan  
2980			; 
2980			;.ludone:		 pop hl 
2980			; 
2980					NEXTW 
2980 c3 4a 1e			jp macro_next 
2983				endm 
# End of macro NEXTW
2983			 
2983			.FORGET: 
2983				CWHEAD .NOP 73 "FORGET" 6 WORD_FLAG_CODE 
2983 5d				db WORD_SYS_CORE+73             
2984 fc 29			dw .NOP            
2986 07				db 6 + 1 
2987 .. 00			db "FORGET",0              
298e				endm 
# End of macro CWHEAD
298e			; | FORGET ( uword -- )    Forget the uword on TOS | DONE 
298e			; | | Will flag the word's op code to be deleted as well as replace the first char of the word with '_'. Quote uword name must be in caps. 
298e			; | |  
298e			; | | e.g. "MORE" forget 
298e					if DEBUG_FORTH_WORDS_KEY 
298e						DMARK "FRG" 
298e f5				push af  
298f 3a a3 29			ld a, (.dmark)  
2992 32 71 ee			ld (debug_mark),a  
2995 3a a4 29			ld a, (.dmark+1)  
2998 32 72 ee			ld (debug_mark+1),a  
299b 3a a5 29			ld a, (.dmark+2)  
299e 32 73 ee			ld (debug_mark+2),a  
29a1 18 03			jr .pastdmark  
29a3 ..			.dmark: db "FRG"  
29a6 f1			.pastdmark: pop af  
29a7			endm  
# End of macro DMARK
29a7						CALLMONITOR 
29a7 cd 87 14			call break_point_state  
29aa				endm  
# End of macro CALLMONITOR
29aa					endif 
29aa			 
29aa				; find uword 
29aa			        ; update start of word with "_" 
29aa				; replace uword with deleted flag 
29aa			 
29aa			 
29aa			;	if DEBUG_FORTH_WORDS 
29aa			;		DMARK "FOG" 
29aa			;		CALLMONITOR 
29aa			;	endif 
29aa			 
29aa			 
29aa					; Get ptr to the word we need to look up 
29aa			 
29aa					FORTH_DSP_VALUEHL 
29aa cd d8 1c			call macro_dsp_valuehl 
29ad				endm 
# End of macro FORTH_DSP_VALUEHL
29ad					;v5 FORTH_DSP_VALUE 
29ad				; TODO type check 
29ad			;		inc hl    ; Skip type check  
29ad e5					push hl 
29ae c1					pop bc 
29af			;		ex de, hl    ; put into DE 
29af			 
29af			 
29af 21 4e 5a				ld hl, baseram 
29b2					;ld hl, baseusermem 
29b2			 
29b2				; skip dict stub 
29b2			;	call forth_tok_next 
29b2 e5			push hl   ; sacreifical push 
29b3			 
29b3			.fldouscanm: 
29b3 e1				pop hl 
29b4			.fldouscan: 
29b4			;	if DEBUG_FORTH_WORDS 
29b4			;		DMARK "LSs" 
29b4			;		CALLMONITOR 
29b4			;	endif 
29b4				; skip dict stub 
29b4 cd 9b 1f				call forth_tok_next 
29b7			 
29b7			 
29b7			; while we have words to look for 
29b7			 
29b7 7e				ld a, (hl)      
29b8			;	if DEBUG_FORTH_WORDS 
29b8			;		DMARK "LSk" 
29b8			;		CALLMONITOR 
29b8			;	endif 
29b8 fe 00				cp WORD_SYS_END 
29ba ca f6 29				jp z, .flunotfound 
29bd fe 01				cp WORD_SYS_UWORD 
29bf c2 b4 29				jp nz, .fldouscan 
29c2			 
29c2			;	if DEBUG_FORTH_WORDS 
29c2			;		DMARK "LSu" 
29c2			;		CALLMONITOR 
29c2			;	endif 
29c2			 
29c2					; found a uword but is it the one we want... 
29c2			 
29c2 c5					push bc     ; uword to find is on bc 
29c3 d1					pop de 
29c4			 
29c4 e5					push hl  ; to save the ptr 
29c5			 
29c5					; skip opcode 
29c5 23					inc hl  
29c6					; skip next ptr 
29c6 23					inc hl  
29c7 23					inc hl 
29c8					; skip len 
29c8 23					inc hl 
29c9			 
29c9			;	if DEBUG_FORTH_WORDS 
29c9			;		DMARK "LSc" 
29c9			;		CALLMONITOR 
29c9			;	endif 
29c9 cd 1c 11				call strcmp 
29cc c2 b3 29				jp nz, .fldouscanm 
29cf			; 
29cf			; 
29cf			;; while we have words to look for 
29cf			; 
29cf			;.fdouscan:	ld a, (hl)      
29cf			;	if DEBUG_FORTH_WORDS 
29cf			;		DMARK "LSs" 
29cf			;		CALLMONITOR 
29cf			;	endif 
29cf			;		cp WORD_SYS_END 
29cf			;		jp z, .fudone 
29cf			;		cp WORD_SYS_UWORD 
29cf			;		jp nz, .fnuword 
29cf			; 
29cf			;	if DEBUG_FORTH_WORDS 
29cf			;		DMARK "FGu" 
29cf			;		CALLMONITOR 
29cf			;	endif 
29cf			; 
29cf			;		; found a uword but is it the one we want... 
29cf			; 
29cf			; 
29cf			;	        pop de   ; get back the dsp name 
29cf			;		push de 
29cf			; 
29cf			;		push hl  ; to save the ptr 
29cf			; 
29cf			;		; skip opcode 
29cf			;		inc hl  
29cf			;		; skip next ptr 
29cf			;		inc hl  
29cf			;		inc hl 
29cf			;		; skip len 
29cf			;		inc hl 
29cf			; 
29cf			;	if DEBUG_FORTH_WORDS 
29cf			;		DMARK "FGc" 
29cf			;		CALLMONITOR 
29cf			;	endif 
29cf			;		call strcmp 
29cf			;		jp nz, .fnuword 
29cf			 
29cf			 
29cf e1			pop hl 
29d0			 
29d0				 
29d0				if DEBUG_FORTH_WORDS 
29d0					DMARK "FGm" 
29d0 f5				push af  
29d1 3a e5 29			ld a, (.dmark)  
29d4 32 71 ee			ld (debug_mark),a  
29d7 3a e6 29			ld a, (.dmark+1)  
29da 32 72 ee			ld (debug_mark+1),a  
29dd 3a e7 29			ld a, (.dmark+2)  
29e0 32 73 ee			ld (debug_mark+2),a  
29e3 18 03			jr .pastdmark  
29e5 ..			.dmark: db "FGm"  
29e8 f1			.pastdmark: pop af  
29e9			endm  
# End of macro DMARK
29e9					CALLMONITOR 
29e9 cd 87 14			call break_point_state  
29ec				endm  
# End of macro CALLMONITOR
29ec				endif 
29ec			 
29ec			 
29ec			 
29ec					; we have a uword so push its name to the stack 
29ec			 
29ec			;	   	push hl  ; save so we can move to next dict block 
29ec			;pop hl 
29ec			 
29ec					; update opcode to deleted 
29ec 3e 03				ld a, WORD_SYS_DELETED 
29ee 77					ld (hl), a 
29ef			 
29ef 23					inc hl  
29f0					; skip next ptr 
29f0 23					inc hl  
29f1 23					inc hl 
29f2					; skip len 
29f2 23					inc hl 
29f3			 
29f3					; TODO change parser to skip deleted words but for now mark it out 
29f3 3e 5f				ld a, "_" 
29f5 77					ld  (hl),a 
29f6			 
29f6			;		jr .fudone 
29f6			; 
29f6			;.fnuword:	pop hl 
29f6			;		call forth_tok_next 
29f6			;		jp .fdouscan  
29f6			 
29f6			.flunotfound:		  
29f6			 
29f6			 
29f6					 
29f6					FORTH_DSP_POP 
29f6 cd 90 1d			call macro_forth_dsp_pop 
29f9				endm 
# End of macro FORTH_DSP_POP
29f9			;		ld hl, .luno 
29f9			;.fudone:		 pop hl 
29f9					NEXTW 
29f9 c3 4a 1e			jp macro_next 
29fc				endm 
# End of macro NEXTW
29fc			.NOP: 
29fc				CWHEAD .COMO 77 "NOP" 3 WORD_FLAG_CODE 
29fc 61				db WORD_SYS_CORE+77             
29fd 23 2a			dw .COMO            
29ff 04				db 3 + 1 
2a00 .. 00			db "NOP",0              
2a04				endm 
# End of macro CWHEAD
2a04			; | NOP (  --  ) Do nothing | DONE 
2a04					if DEBUG_FORTH_WORDS_KEY 
2a04						DMARK "NOP" 
2a04 f5				push af  
2a05 3a 19 2a			ld a, (.dmark)  
2a08 32 71 ee			ld (debug_mark),a  
2a0b 3a 1a 2a			ld a, (.dmark+1)  
2a0e 32 72 ee			ld (debug_mark+1),a  
2a11 3a 1b 2a			ld a, (.dmark+2)  
2a14 32 73 ee			ld (debug_mark+2),a  
2a17 18 03			jr .pastdmark  
2a19 ..			.dmark: db "NOP"  
2a1c f1			.pastdmark: pop af  
2a1d			endm  
# End of macro DMARK
2a1d						CALLMONITOR 
2a1d cd 87 14			call break_point_state  
2a20				endm  
# End of macro CALLMONITOR
2a20					endif 
2a20				       NEXTW 
2a20 c3 4a 1e			jp macro_next 
2a23				endm 
# End of macro NEXTW
2a23			.COMO: 
2a23				CWHEAD .COMC 90 "(" 1 WORD_FLAG_CODE 
2a23 6e				db WORD_SYS_CORE+90             
2a24 75 2a			dw .COMC            
2a26 02				db 1 + 1 
2a27 .. 00			db "(",0              
2a29				endm 
# End of macro CWHEAD
2a29			; | ( ( -- )  Start of comment | DONE 
2a29			 
2a29			 
2a29 2a d8 e6				ld hl, ( os_tok_ptr) 
2a2c 11 70 2a			ld de, .closepar 
2a2f					 
2a2f					if DEBUG_FORTH_WORDS 
2a2f						DMARK ").." 
2a2f f5				push af  
2a30 3a 44 2a			ld a, (.dmark)  
2a33 32 71 ee			ld (debug_mark),a  
2a36 3a 45 2a			ld a, (.dmark+1)  
2a39 32 72 ee			ld (debug_mark+1),a  
2a3c 3a 46 2a			ld a, (.dmark+2)  
2a3f 32 73 ee			ld (debug_mark+2),a  
2a42 18 03			jr .pastdmark  
2a44 ..			.dmark: db ").."  
2a47 f1			.pastdmark: pop af  
2a48			endm  
# End of macro DMARK
2a48						CALLMONITOR 
2a48 cd 87 14			call break_point_state  
2a4b				endm  
# End of macro CALLMONITOR
2a4b					endif 
2a4b cd 65 1f			call findnexttok  
2a4e			 
2a4e					if DEBUG_FORTH_WORDS 
2a4e						DMARK "IF5" 
2a4e f5				push af  
2a4f 3a 63 2a			ld a, (.dmark)  
2a52 32 71 ee			ld (debug_mark),a  
2a55 3a 64 2a			ld a, (.dmark+1)  
2a58 32 72 ee			ld (debug_mark+1),a  
2a5b 3a 65 2a			ld a, (.dmark+2)  
2a5e 32 73 ee			ld (debug_mark+2),a  
2a61 18 03			jr .pastdmark  
2a63 ..			.dmark: db "IF5"  
2a66 f1			.pastdmark: pop af  
2a67			endm  
# End of macro DMARK
2a67						CALLMONITOR 
2a67 cd 87 14			call break_point_state  
2a6a				endm  
# End of macro CALLMONITOR
2a6a					endif 
2a6a				; replace below with ) exec using tok_ptr 
2a6a 22 d8 e6			ld (os_tok_ptr), hl 
2a6d c3 db 1e			jp exec1 
2a70			 
2a70 .. 00			.closepar:   db ")",0 
2a72			 
2a72				       NEXTW 
2a72 c3 4a 1e			jp macro_next 
2a75				endm 
# End of macro NEXTW
2a75			.COMC: 
2a75				CWHEAD .SCRATCH 91 ")" 1 WORD_FLAG_CODE 
2a75 6f				db WORD_SYS_CORE+91             
2a76 7e 2a			dw .SCRATCH            
2a78 02				db 1 + 1 
2a79 .. 00			db ")",0              
2a7b				endm 
# End of macro CWHEAD
2a7b			; | ) ( -- )  End of comment |  DONE  
2a7b				       NEXTW 
2a7b c3 4a 1e			jp macro_next 
2a7e				endm 
# End of macro NEXTW
2a7e			 
2a7e			.SCRATCH: 
2a7e				CWHEAD .INC 91 "SCRATCH" 7 WORD_FLAG_CODE 
2a7e 6f				db WORD_SYS_CORE+91             
2a7f b9 2a			dw .INC            
2a81 08				db 7 + 1 
2a82 .. 00			db "SCRATCH",0              
2a8a				endm 
# End of macro CWHEAD
2a8a			; | SCRATCH ( u -- addr ) Pushes address of offset u to stack | DONE 
2a8a			; | | The scratch area provides 32 word array. Can be used as single byte or as a word by passing the offset on stack. Pushes the resulting address to stack.  
2a8a			; | | When used with the direct storage writing/malloc and the !@ or word versions it is possible to construct an expanded and flexible variable system 
2a8a			; | |  
2a8a			; | | e.g.    : score $00 scratch ; 
2a8a			; | |  
2a8a			; | | $00 score ! 
2a8a			; | | $01 score +! 
2a8a			; | |  
2a8a			; | | e.g.   : varword $0a scratch ;  
2a8a			; | | 
2a8a			; | | $8000 varword ! 
2a8a					if DEBUG_FORTH_WORDS_KEY 
2a8a						DMARK "SCR" 
2a8a f5				push af  
2a8b 3a 9f 2a			ld a, (.dmark)  
2a8e 32 71 ee			ld (debug_mark),a  
2a91 3a a0 2a			ld a, (.dmark+1)  
2a94 32 72 ee			ld (debug_mark+1),a  
2a97 3a a1 2a			ld a, (.dmark+2)  
2a9a 32 73 ee			ld (debug_mark+2),a  
2a9d 18 03			jr .pastdmark  
2a9f ..			.dmark: db "SCR"  
2aa2 f1			.pastdmark: pop af  
2aa3			endm  
# End of macro DMARK
2aa3						CALLMONITOR 
2aa3 cd 87 14			call break_point_state  
2aa6				endm  
# End of macro CALLMONITOR
2aa6					endif 
2aa6			 
2aa6					FORTH_DSP_VALUEHL 
2aa6 cd d8 1c			call macro_dsp_valuehl 
2aa9				endm 
# End of macro FORTH_DSP_VALUEHL
2aa9				 
2aa9					FORTH_DSP_POP 
2aa9 cd 90 1d			call macro_forth_dsp_pop 
2aac				endm 
# End of macro FORTH_DSP_POP
2aac			 
2aac 7d					ld a, l 
2aad 21 fc e8				ld hl, os_var_array 
2ab0 cd 86 0c				call addatohl 
2ab3			 
2ab3 cd e1 1a				call forth_push_numhl 
2ab6			 
2ab6				       NEXTW 
2ab6 c3 4a 1e			jp macro_next 
2ab9				endm 
# End of macro NEXTW
2ab9			 
2ab9			.INC: 
2ab9				CWHEAD .DEC 91 "+!" 2 WORD_FLAG_CODE 
2ab9 6f				db WORD_SYS_CORE+91             
2aba 0d 2b			dw .DEC            
2abc 03				db 2 + 1 
2abd .. 00			db "+!",0              
2ac0				endm 
# End of macro CWHEAD
2ac0			; | +! ( u a -- )  Increment byte at address a by the value u | DONE 
2ac0					if DEBUG_FORTH_WORDS_KEY 
2ac0						DMARK "+s_" 
2ac0 f5				push af  
2ac1 3a d5 2a			ld a, (.dmark)  
2ac4 32 71 ee			ld (debug_mark),a  
2ac7 3a d6 2a			ld a, (.dmark+1)  
2aca 32 72 ee			ld (debug_mark+1),a  
2acd 3a d7 2a			ld a, (.dmark+2)  
2ad0 32 73 ee			ld (debug_mark+2),a  
2ad3 18 03			jr .pastdmark  
2ad5 ..			.dmark: db "+s_"  
2ad8 f1			.pastdmark: pop af  
2ad9			endm  
# End of macro DMARK
2ad9						CALLMONITOR 
2ad9 cd 87 14			call break_point_state  
2adc				endm  
# End of macro CALLMONITOR
2adc					endif 
2adc			 
2adc					FORTH_DSP_VALUEHL 
2adc cd d8 1c			call macro_dsp_valuehl 
2adf				endm 
# End of macro FORTH_DSP_VALUEHL
2adf			 
2adf e5					push hl   ; save address 
2ae0			 
2ae0					FORTH_DSP_POP 
2ae0 cd 90 1d			call macro_forth_dsp_pop 
2ae3				endm 
# End of macro FORTH_DSP_POP
2ae3			 
2ae3					FORTH_DSP_VALUEHL 
2ae3 cd d8 1c			call macro_dsp_valuehl 
2ae6				endm 
# End of macro FORTH_DSP_VALUEHL
2ae6			 
2ae6					FORTH_DSP_POP 
2ae6 cd 90 1d			call macro_forth_dsp_pop 
2ae9				endm 
# End of macro FORTH_DSP_POP
2ae9			 
2ae9					; hl contains value to add to byte at a 
2ae9				 
2ae9 eb					ex de, hl 
2aea			 
2aea e1					pop hl 
2aeb			 
2aeb					if DEBUG_FORTH_WORDS 
2aeb						DMARK "INC" 
2aeb f5				push af  
2aec 3a 00 2b			ld a, (.dmark)  
2aef 32 71 ee			ld (debug_mark),a  
2af2 3a 01 2b			ld a, (.dmark+1)  
2af5 32 72 ee			ld (debug_mark+1),a  
2af8 3a 02 2b			ld a, (.dmark+2)  
2afb 32 73 ee			ld (debug_mark+2),a  
2afe 18 03			jr .pastdmark  
2b00 ..			.dmark: db "INC"  
2b03 f1			.pastdmark: pop af  
2b04			endm  
# End of macro DMARK
2b04						CALLMONITOR 
2b04 cd 87 14			call break_point_state  
2b07				endm  
# End of macro CALLMONITOR
2b07					endif 
2b07			 
2b07 7e					ld a,(hl) 
2b08 83					add e 
2b09 77					ld (hl),a 
2b0a			 
2b0a			 
2b0a			 
2b0a				       NEXTW 
2b0a c3 4a 1e			jp macro_next 
2b0d				endm 
# End of macro NEXTW
2b0d			 
2b0d			.DEC: 
2b0d				CWHEAD .INC2 91 "-!" 2 WORD_FLAG_CODE 
2b0d 6f				db WORD_SYS_CORE+91             
2b0e 5e 2b			dw .INC2            
2b10 03				db 2 + 1 
2b11 .. 00			db "-!",0              
2b14				endm 
# End of macro CWHEAD
2b14			; | -! ( u a -- )  Decrement byte at address a by the value u | DONE 
2b14					if DEBUG_FORTH_WORDS_KEY 
2b14						DMARK "-s_" 
2b14 f5				push af  
2b15 3a 29 2b			ld a, (.dmark)  
2b18 32 71 ee			ld (debug_mark),a  
2b1b 3a 2a 2b			ld a, (.dmark+1)  
2b1e 32 72 ee			ld (debug_mark+1),a  
2b21 3a 2b 2b			ld a, (.dmark+2)  
2b24 32 73 ee			ld (debug_mark+2),a  
2b27 18 03			jr .pastdmark  
2b29 ..			.dmark: db "-s_"  
2b2c f1			.pastdmark: pop af  
2b2d			endm  
# End of macro DMARK
2b2d						CALLMONITOR 
2b2d cd 87 14			call break_point_state  
2b30				endm  
# End of macro CALLMONITOR
2b30					endif 
2b30			 
2b30					FORTH_DSP_VALUEHL 
2b30 cd d8 1c			call macro_dsp_valuehl 
2b33				endm 
# End of macro FORTH_DSP_VALUEHL
2b33			 
2b33 e5					push hl   ; save address 
2b34			 
2b34					FORTH_DSP_POP 
2b34 cd 90 1d			call macro_forth_dsp_pop 
2b37				endm 
# End of macro FORTH_DSP_POP
2b37			 
2b37					FORTH_DSP_VALUEHL 
2b37 cd d8 1c			call macro_dsp_valuehl 
2b3a				endm 
# End of macro FORTH_DSP_VALUEHL
2b3a			 
2b3a					; hl contains value to add to byte at a 
2b3a				 
2b3a eb					ex de, hl 
2b3b			 
2b3b e1					pop hl 
2b3c			 
2b3c					if DEBUG_FORTH_WORDS 
2b3c						DMARK "DEC" 
2b3c f5				push af  
2b3d 3a 51 2b			ld a, (.dmark)  
2b40 32 71 ee			ld (debug_mark),a  
2b43 3a 52 2b			ld a, (.dmark+1)  
2b46 32 72 ee			ld (debug_mark+1),a  
2b49 3a 53 2b			ld a, (.dmark+2)  
2b4c 32 73 ee			ld (debug_mark+2),a  
2b4f 18 03			jr .pastdmark  
2b51 ..			.dmark: db "DEC"  
2b54 f1			.pastdmark: pop af  
2b55			endm  
# End of macro DMARK
2b55						CALLMONITOR 
2b55 cd 87 14			call break_point_state  
2b58				endm  
# End of macro CALLMONITOR
2b58					endif 
2b58			 
2b58 7e					ld a,(hl) 
2b59 93					sub e 
2b5a 77					ld (hl),a 
2b5b			 
2b5b			 
2b5b			 
2b5b				       NEXTW 
2b5b c3 4a 1e			jp macro_next 
2b5e				endm 
# End of macro NEXTW
2b5e			 
2b5e			.INC2: 
2b5e				CWHEAD .DEC2 91 "+2!" 3 WORD_FLAG_CODE 
2b5e 6f				db WORD_SYS_CORE+91             
2b5f 08 2c			dw .DEC2            
2b61 04				db 3 + 1 
2b62 .. 00			db "+2!",0              
2b66				endm 
# End of macro CWHEAD
2b66			; | +2! ( u a -- )  Increment word at address a by the value u | DONE 
2b66			 
2b66					if DEBUG_FORTH_WORDS_KEY 
2b66						DMARK "+2s" 
2b66 f5				push af  
2b67 3a 7b 2b			ld a, (.dmark)  
2b6a 32 71 ee			ld (debug_mark),a  
2b6d 3a 7c 2b			ld a, (.dmark+1)  
2b70 32 72 ee			ld (debug_mark+1),a  
2b73 3a 7d 2b			ld a, (.dmark+2)  
2b76 32 73 ee			ld (debug_mark+2),a  
2b79 18 03			jr .pastdmark  
2b7b ..			.dmark: db "+2s"  
2b7e f1			.pastdmark: pop af  
2b7f			endm  
# End of macro DMARK
2b7f						CALLMONITOR 
2b7f cd 87 14			call break_point_state  
2b82				endm  
# End of macro CALLMONITOR
2b82					endif 
2b82			 
2b82					; Address 
2b82			 
2b82					FORTH_DSP_VALUEHL 
2b82 cd d8 1c			call macro_dsp_valuehl 
2b85				endm 
# End of macro FORTH_DSP_VALUEHL
2b85			 
2b85 e5					push hl    ; save address 
2b86			 
2b86					; load content into de 
2b86			 
2b86 5e					ld e,(hl) 
2b87 23					inc hl 
2b88 56					ld d, (hl) 
2b89			 
2b89					if DEBUG_FORTH_WORDS 
2b89						DMARK "+2a" 
2b89 f5				push af  
2b8a 3a 9e 2b			ld a, (.dmark)  
2b8d 32 71 ee			ld (debug_mark),a  
2b90 3a 9f 2b			ld a, (.dmark+1)  
2b93 32 72 ee			ld (debug_mark+1),a  
2b96 3a a0 2b			ld a, (.dmark+2)  
2b99 32 73 ee			ld (debug_mark+2),a  
2b9c 18 03			jr .pastdmark  
2b9e ..			.dmark: db "+2a"  
2ba1 f1			.pastdmark: pop af  
2ba2			endm  
# End of macro DMARK
2ba2						CALLMONITOR 
2ba2 cd 87 14			call break_point_state  
2ba5				endm  
# End of macro CALLMONITOR
2ba5					endif 
2ba5			 
2ba5					FORTH_DSP_POP 
2ba5 cd 90 1d			call macro_forth_dsp_pop 
2ba8				endm 
# End of macro FORTH_DSP_POP
2ba8			 
2ba8					; Get value to add 
2ba8			 
2ba8					FORTH_DSP_VALUE 
2ba8 cd c1 1c			call macro_forth_dsp_value 
2bab				endm 
# End of macro FORTH_DSP_VALUE
2bab			 
2bab					if DEBUG_FORTH_WORDS 
2bab						DMARK "+2v" 
2bab f5				push af  
2bac 3a c0 2b			ld a, (.dmark)  
2baf 32 71 ee			ld (debug_mark),a  
2bb2 3a c1 2b			ld a, (.dmark+1)  
2bb5 32 72 ee			ld (debug_mark+1),a  
2bb8 3a c2 2b			ld a, (.dmark+2)  
2bbb 32 73 ee			ld (debug_mark+2),a  
2bbe 18 03			jr .pastdmark  
2bc0 ..			.dmark: db "+2v"  
2bc3 f1			.pastdmark: pop af  
2bc4			endm  
# End of macro DMARK
2bc4						CALLMONITOR 
2bc4 cd 87 14			call break_point_state  
2bc7				endm  
# End of macro CALLMONITOR
2bc7					endif 
2bc7			 
2bc7 19					add hl, de 
2bc8			 
2bc8					if DEBUG_FORTH_WORDS 
2bc8						DMARK "+2+" 
2bc8 f5				push af  
2bc9 3a dd 2b			ld a, (.dmark)  
2bcc 32 71 ee			ld (debug_mark),a  
2bcf 3a de 2b			ld a, (.dmark+1)  
2bd2 32 72 ee			ld (debug_mark+1),a  
2bd5 3a df 2b			ld a, (.dmark+2)  
2bd8 32 73 ee			ld (debug_mark+2),a  
2bdb 18 03			jr .pastdmark  
2bdd ..			.dmark: db "+2+"  
2be0 f1			.pastdmark: pop af  
2be1			endm  
# End of macro DMARK
2be1						CALLMONITOR 
2be1 cd 87 14			call break_point_state  
2be4				endm  
# End of macro CALLMONITOR
2be4					endif 
2be4			 
2be4					; move result to de 
2be4			 
2be4 eb					ex de, hl 
2be5			 
2be5					; Address 
2be5			 
2be5 e1					pop hl 
2be6			 
2be6					; save it back 
2be6			 
2be6 73					ld (hl), e 
2be7 23					inc hl 
2be8 72					ld (hl), d 
2be9			 
2be9					if DEBUG_FORTH_WORDS 
2be9						DMARK "+2e" 
2be9 f5				push af  
2bea 3a fe 2b			ld a, (.dmark)  
2bed 32 71 ee			ld (debug_mark),a  
2bf0 3a ff 2b			ld a, (.dmark+1)  
2bf3 32 72 ee			ld (debug_mark+1),a  
2bf6 3a 00 2c			ld a, (.dmark+2)  
2bf9 32 73 ee			ld (debug_mark+2),a  
2bfc 18 03			jr .pastdmark  
2bfe ..			.dmark: db "+2e"  
2c01 f1			.pastdmark: pop af  
2c02			endm  
# End of macro DMARK
2c02						CALLMONITOR 
2c02 cd 87 14			call break_point_state  
2c05				endm  
# End of macro CALLMONITOR
2c05					endif 
2c05			 
2c05			 
2c05			 
2c05			 
2c05			 
2c05				       NEXTW 
2c05 c3 4a 1e			jp macro_next 
2c08				endm 
# End of macro NEXTW
2c08			 
2c08			.DEC2: 
2c08				CWHEAD .GET2 91 "-2!" 3 WORD_FLAG_CODE 
2c08 6f				db WORD_SYS_CORE+91             
2c09 b4 2c			dw .GET2            
2c0b 04				db 3 + 1 
2c0c .. 00			db "-2!",0              
2c10				endm 
# End of macro CWHEAD
2c10			; | -2! ( u a -- )  Decrement word at address a by the value u | DONE 
2c10			 
2c10			 
2c10					if DEBUG_FORTH_WORDS_KEY 
2c10						DMARK "-2s" 
2c10 f5				push af  
2c11 3a 25 2c			ld a, (.dmark)  
2c14 32 71 ee			ld (debug_mark),a  
2c17 3a 26 2c			ld a, (.dmark+1)  
2c1a 32 72 ee			ld (debug_mark+1),a  
2c1d 3a 27 2c			ld a, (.dmark+2)  
2c20 32 73 ee			ld (debug_mark+2),a  
2c23 18 03			jr .pastdmark  
2c25 ..			.dmark: db "-2s"  
2c28 f1			.pastdmark: pop af  
2c29			endm  
# End of macro DMARK
2c29						CALLMONITOR 
2c29 cd 87 14			call break_point_state  
2c2c				endm  
# End of macro CALLMONITOR
2c2c					endif 
2c2c			 
2c2c					; Address 
2c2c			 
2c2c					FORTH_DSP_VALUEHL 
2c2c cd d8 1c			call macro_dsp_valuehl 
2c2f				endm 
# End of macro FORTH_DSP_VALUEHL
2c2f			 
2c2f e5					push hl    ; save address 
2c30			 
2c30					; load content into de 
2c30			 
2c30 5e					ld e,(hl) 
2c31 23					inc hl 
2c32 56					ld d, (hl) 
2c33			 
2c33					if DEBUG_FORTH_WORDS 
2c33						DMARK "-2a" 
2c33 f5				push af  
2c34 3a 48 2c			ld a, (.dmark)  
2c37 32 71 ee			ld (debug_mark),a  
2c3a 3a 49 2c			ld a, (.dmark+1)  
2c3d 32 72 ee			ld (debug_mark+1),a  
2c40 3a 4a 2c			ld a, (.dmark+2)  
2c43 32 73 ee			ld (debug_mark+2),a  
2c46 18 03			jr .pastdmark  
2c48 ..			.dmark: db "-2a"  
2c4b f1			.pastdmark: pop af  
2c4c			endm  
# End of macro DMARK
2c4c						CALLMONITOR 
2c4c cd 87 14			call break_point_state  
2c4f				endm  
# End of macro CALLMONITOR
2c4f					endif 
2c4f			 
2c4f					FORTH_DSP_POP 
2c4f cd 90 1d			call macro_forth_dsp_pop 
2c52				endm 
# End of macro FORTH_DSP_POP
2c52			 
2c52					; Get value to remove 
2c52			 
2c52					FORTH_DSP_VALUE 
2c52 cd c1 1c			call macro_forth_dsp_value 
2c55				endm 
# End of macro FORTH_DSP_VALUE
2c55			 
2c55					if DEBUG_FORTH_WORDS 
2c55						DMARK "-2v" 
2c55 f5				push af  
2c56 3a 6a 2c			ld a, (.dmark)  
2c59 32 71 ee			ld (debug_mark),a  
2c5c 3a 6b 2c			ld a, (.dmark+1)  
2c5f 32 72 ee			ld (debug_mark+1),a  
2c62 3a 6c 2c			ld a, (.dmark+2)  
2c65 32 73 ee			ld (debug_mark+2),a  
2c68 18 03			jr .pastdmark  
2c6a ..			.dmark: db "-2v"  
2c6d f1			.pastdmark: pop af  
2c6e			endm  
# End of macro DMARK
2c6e						CALLMONITOR 
2c6e cd 87 14			call break_point_state  
2c71				endm  
# End of macro CALLMONITOR
2c71					endif 
2c71			 
2c71 eb					ex de, hl 
2c72 ed 52				sbc hl, de 
2c74			 
2c74					if DEBUG_FORTH_WORDS 
2c74						DMARK "-2d" 
2c74 f5				push af  
2c75 3a 89 2c			ld a, (.dmark)  
2c78 32 71 ee			ld (debug_mark),a  
2c7b 3a 8a 2c			ld a, (.dmark+1)  
2c7e 32 72 ee			ld (debug_mark+1),a  
2c81 3a 8b 2c			ld a, (.dmark+2)  
2c84 32 73 ee			ld (debug_mark+2),a  
2c87 18 03			jr .pastdmark  
2c89 ..			.dmark: db "-2d"  
2c8c f1			.pastdmark: pop af  
2c8d			endm  
# End of macro DMARK
2c8d						CALLMONITOR 
2c8d cd 87 14			call break_point_state  
2c90				endm  
# End of macro CALLMONITOR
2c90					endif 
2c90			 
2c90					; move result to de 
2c90			 
2c90 eb					ex de, hl 
2c91			 
2c91					; Address 
2c91			 
2c91 e1					pop hl 
2c92			 
2c92					; save it back 
2c92			 
2c92 73					ld (hl), e 
2c93 23					inc hl 
2c94 72					ld (hl), d 
2c95			 
2c95					if DEBUG_FORTH_WORDS 
2c95						DMARK "-2e" 
2c95 f5				push af  
2c96 3a aa 2c			ld a, (.dmark)  
2c99 32 71 ee			ld (debug_mark),a  
2c9c 3a ab 2c			ld a, (.dmark+1)  
2c9f 32 72 ee			ld (debug_mark+1),a  
2ca2 3a ac 2c			ld a, (.dmark+2)  
2ca5 32 73 ee			ld (debug_mark+2),a  
2ca8 18 03			jr .pastdmark  
2caa ..			.dmark: db "-2e"  
2cad f1			.pastdmark: pop af  
2cae			endm  
# End of macro DMARK
2cae						CALLMONITOR 
2cae cd 87 14			call break_point_state  
2cb1				endm  
# End of macro CALLMONITOR
2cb1					endif 
2cb1			 
2cb1			 
2cb1			 
2cb1			 
2cb1			 
2cb1				       NEXTW 
2cb1 c3 4a 1e			jp macro_next 
2cb4				endm 
# End of macro NEXTW
2cb4			.GET2: 
2cb4				CWHEAD .BANG2 91 "2@" 2 WORD_FLAG_CODE 
2cb4 6f				db WORD_SYS_CORE+91             
2cb5 e4 2c			dw .BANG2            
2cb7 03				db 2 + 1 
2cb8 .. 00			db "2@",0              
2cbb				endm 
# End of macro CWHEAD
2cbb			; | 2@ ( a -- u )  Push word at address a onto stack | DONE 
2cbb					if DEBUG_FORTH_WORDS_KEY 
2cbb						DMARK "2A_" 
2cbb f5				push af  
2cbc 3a d0 2c			ld a, (.dmark)  
2cbf 32 71 ee			ld (debug_mark),a  
2cc2 3a d1 2c			ld a, (.dmark+1)  
2cc5 32 72 ee			ld (debug_mark+1),a  
2cc8 3a d2 2c			ld a, (.dmark+2)  
2ccb 32 73 ee			ld (debug_mark+2),a  
2cce 18 03			jr .pastdmark  
2cd0 ..			.dmark: db "2A_"  
2cd3 f1			.pastdmark: pop af  
2cd4			endm  
# End of macro DMARK
2cd4						CALLMONITOR 
2cd4 cd 87 14			call break_point_state  
2cd7				endm  
# End of macro CALLMONITOR
2cd7					endif 
2cd7			 
2cd7					FORTH_DSP_VALUEHL 
2cd7 cd d8 1c			call macro_dsp_valuehl 
2cda				endm 
# End of macro FORTH_DSP_VALUEHL
2cda			 
2cda 5e					ld e, (hl) 
2cdb 23					inc hl 
2cdc 56					ld d, (hl) 
2cdd			 
2cdd eb					ex de, hl 
2cde			 
2cde cd e1 1a				call forth_push_numhl 
2ce1			 
2ce1				       NEXTW 
2ce1 c3 4a 1e			jp macro_next 
2ce4				endm 
# End of macro NEXTW
2ce4			.BANG2: 
2ce4				CWHEAD .CONFIG 91 "2!" 2 WORD_FLAG_CODE 
2ce4 6f				db WORD_SYS_CORE+91             
2ce5 1c 2d			dw .CONFIG            
2ce7 03				db 2 + 1 
2ce8 .. 00			db "2!",0              
2ceb				endm 
# End of macro CWHEAD
2ceb			; | 2! ( u a -- )  Store value u as a word at address a | DONE 
2ceb					if DEBUG_FORTH_WORDS_KEY 
2ceb						DMARK "2S_" 
2ceb f5				push af  
2cec 3a 00 2d			ld a, (.dmark)  
2cef 32 71 ee			ld (debug_mark),a  
2cf2 3a 01 2d			ld a, (.dmark+1)  
2cf5 32 72 ee			ld (debug_mark+1),a  
2cf8 3a 02 2d			ld a, (.dmark+2)  
2cfb 32 73 ee			ld (debug_mark+2),a  
2cfe 18 03			jr .pastdmark  
2d00 ..			.dmark: db "2S_"  
2d03 f1			.pastdmark: pop af  
2d04			endm  
# End of macro DMARK
2d04						CALLMONITOR 
2d04 cd 87 14			call break_point_state  
2d07				endm  
# End of macro CALLMONITOR
2d07					endif 
2d07			 
2d07					FORTH_DSP_VALUEHL 
2d07 cd d8 1c			call macro_dsp_valuehl 
2d0a				endm 
# End of macro FORTH_DSP_VALUEHL
2d0a			 
2d0a e5					push hl   ; save address 
2d0b			 
2d0b			 
2d0b					FORTH_DSP_POP 
2d0b cd 90 1d			call macro_forth_dsp_pop 
2d0e				endm 
# End of macro FORTH_DSP_POP
2d0e			 
2d0e					 
2d0e					FORTH_DSP_VALUEHL 
2d0e cd d8 1c			call macro_dsp_valuehl 
2d11				endm 
# End of macro FORTH_DSP_VALUEHL
2d11			 
2d11					FORTH_DSP_POP 
2d11 cd 90 1d			call macro_forth_dsp_pop 
2d14				endm 
# End of macro FORTH_DSP_POP
2d14			 
2d14 eb					ex de, hl    ; value now in de 
2d15			 
2d15 e1					pop hl 
2d16			 
2d16 73					ld (hl), e 
2d17			 
2d17 23					inc hl 
2d18			 
2d18 72					ld (hl), d 
2d19			 
2d19			 
2d19				       NEXTW 
2d19 c3 4a 1e			jp macro_next 
2d1c				endm 
# End of macro NEXTW
2d1c			.CONFIG: 
2d1c				CWHEAD .ENDCORE 91 "CONFIG" 6 WORD_FLAG_CODE 
2d1c 6f				db WORD_SYS_CORE+91             
2d1d 2d 2d			dw .ENDCORE            
2d1f 07				db 6 + 1 
2d20 .. 00			db "CONFIG",0              
2d27				endm 
# End of macro CWHEAD
2d27			; | CONFIG ( -- )  Access the system configuration menu. Set boot from file, hardware diags, and more! | DONE 
2d27			 
2d27 cd e6 12				call config 
2d2a					NEXTW 
2d2a c3 4a 1e			jp macro_next 
2d2d				endm 
# End of macro NEXTW
2d2d			.ENDCORE: 
2d2d			 
2d2d			; eof 
2d2d			 
2d2d			 
# End of file forth_words_core.asm
2d2d			include "forth_words_flow.asm" 
2d2d			 
2d2d			; | ## Program Flow Words 
2d2d			 
2d2d			.IF: 
2d2d				CWHEAD .THEN 10 "IF" 2 WORD_FLAG_CODE 
2d2d 1e				db WORD_SYS_CORE+10             
2d2e 22 2e			dw .THEN            
2d30 03				db 2 + 1 
2d31 .. 00			db "IF",0              
2d34				endm 
# End of macro CWHEAD
2d34			; | IF ( w -- f ) If TOS is true exec code following up to THEN - Note: currently not supporting ELSE or nested IF | DONE 
2d34			; 
2d34					if DEBUG_FORTH_WORDS_KEY 
2d34						DMARK "IF." 
2d34 f5				push af  
2d35 3a 49 2d			ld a, (.dmark)  
2d38 32 71 ee			ld (debug_mark),a  
2d3b 3a 4a 2d			ld a, (.dmark+1)  
2d3e 32 72 ee			ld (debug_mark+1),a  
2d41 3a 4b 2d			ld a, (.dmark+2)  
2d44 32 73 ee			ld (debug_mark+2),a  
2d47 18 03			jr .pastdmark  
2d49 ..			.dmark: db "IF."  
2d4c f1			.pastdmark: pop af  
2d4d			endm  
# End of macro DMARK
2d4d						CALLMONITOR 
2d4d cd 87 14			call break_point_state  
2d50				endm  
# End of macro CALLMONITOR
2d50					endif 
2d50			; eval TOS 
2d50			 
2d50				FORTH_DSP_VALUEHL 
2d50 cd d8 1c			call macro_dsp_valuehl 
2d53				endm 
# End of macro FORTH_DSP_VALUEHL
2d53			 
2d53			;	push hl 
2d53				FORTH_DSP_POP 
2d53 cd 90 1d			call macro_forth_dsp_pop 
2d56				endm 
# End of macro FORTH_DSP_POP
2d56			;	pop hl 
2d56			 
2d56					if DEBUG_FORTH_WORDS 
2d56						DMARK "IF1" 
2d56 f5				push af  
2d57 3a 6b 2d			ld a, (.dmark)  
2d5a 32 71 ee			ld (debug_mark),a  
2d5d 3a 6c 2d			ld a, (.dmark+1)  
2d60 32 72 ee			ld (debug_mark+1),a  
2d63 3a 6d 2d			ld a, (.dmark+2)  
2d66 32 73 ee			ld (debug_mark+2),a  
2d69 18 03			jr .pastdmark  
2d6b ..			.dmark: db "IF1"  
2d6e f1			.pastdmark: pop af  
2d6f			endm  
# End of macro DMARK
2d6f						CALLMONITOR 
2d6f cd 87 14			call break_point_state  
2d72				endm  
# End of macro CALLMONITOR
2d72					endif 
2d72 b7				or a        ; clear carry flag 
2d73 11 00 00			ld de, 0 
2d76 eb				ex de,hl 
2d77 ed 52			sbc hl, de 
2d79 c2 03 2e			jp nz, .iftrue 
2d7c			 
2d7c					if DEBUG_FORTH_WORDS 
2d7c						DMARK "IF2" 
2d7c f5				push af  
2d7d 3a 91 2d			ld a, (.dmark)  
2d80 32 71 ee			ld (debug_mark),a  
2d83 3a 92 2d			ld a, (.dmark+1)  
2d86 32 72 ee			ld (debug_mark+1),a  
2d89 3a 93 2d			ld a, (.dmark+2)  
2d8c 32 73 ee			ld (debug_mark+2),a  
2d8f 18 03			jr .pastdmark  
2d91 ..			.dmark: db "IF2"  
2d94 f1			.pastdmark: pop af  
2d95			endm  
# End of macro DMARK
2d95						CALLMONITOR 
2d95 cd 87 14			call break_point_state  
2d98				endm  
# End of macro CALLMONITOR
2d98					endif 
2d98			 
2d98			; if not true then skip to THEN 
2d98			 
2d98				; TODO get tok_ptr 
2d98				; TODO consume toks until we get to THEN 
2d98			 
2d98 2a d8 e6			ld hl, (os_tok_ptr) 
2d9b					if DEBUG_FORTH_WORDS 
2d9b						DMARK "IF3" 
2d9b f5				push af  
2d9c 3a b0 2d			ld a, (.dmark)  
2d9f 32 71 ee			ld (debug_mark),a  
2da2 3a b1 2d			ld a, (.dmark+1)  
2da5 32 72 ee			ld (debug_mark+1),a  
2da8 3a b2 2d			ld a, (.dmark+2)  
2dab 32 73 ee			ld (debug_mark+2),a  
2dae 18 03			jr .pastdmark  
2db0 ..			.dmark: db "IF3"  
2db3 f1			.pastdmark: pop af  
2db4			endm  
# End of macro DMARK
2db4						CALLMONITOR 
2db4 cd 87 14			call break_point_state  
2db7				endm  
# End of macro CALLMONITOR
2db7						 
2db7					endif 
2db7 11 fe 2d			ld de, .ifthen 
2dba					if DEBUG_FORTH_WORDS 
2dba						DMARK "IF4" 
2dba f5				push af  
2dbb 3a cf 2d			ld a, (.dmark)  
2dbe 32 71 ee			ld (debug_mark),a  
2dc1 3a d0 2d			ld a, (.dmark+1)  
2dc4 32 72 ee			ld (debug_mark+1),a  
2dc7 3a d1 2d			ld a, (.dmark+2)  
2dca 32 73 ee			ld (debug_mark+2),a  
2dcd 18 03			jr .pastdmark  
2dcf ..			.dmark: db "IF4"  
2dd2 f1			.pastdmark: pop af  
2dd3			endm  
# End of macro DMARK
2dd3						CALLMONITOR 
2dd3 cd 87 14			call break_point_state  
2dd6				endm  
# End of macro CALLMONITOR
2dd6					endif 
2dd6 cd 65 1f			call findnexttok  
2dd9			 
2dd9					if DEBUG_FORTH_WORDS 
2dd9						DMARK "IF5" 
2dd9 f5				push af  
2dda 3a ee 2d			ld a, (.dmark)  
2ddd 32 71 ee			ld (debug_mark),a  
2de0 3a ef 2d			ld a, (.dmark+1)  
2de3 32 72 ee			ld (debug_mark+1),a  
2de6 3a f0 2d			ld a, (.dmark+2)  
2de9 32 73 ee			ld (debug_mark+2),a  
2dec 18 03			jr .pastdmark  
2dee ..			.dmark: db "IF5"  
2df1 f1			.pastdmark: pop af  
2df2			endm  
# End of macro DMARK
2df2						CALLMONITOR 
2df2 cd 87 14			call break_point_state  
2df5				endm  
# End of macro CALLMONITOR
2df5					endif 
2df5				; TODO replace below with ; exec using tok_ptr 
2df5 22 d8 e6			ld (os_tok_ptr), hl 
2df8 c3 db 1e			jp exec1 
2dfb				NEXTW 
2dfb c3 4a 1e			jp macro_next 
2dfe				endm 
# End of macro NEXTW
2dfe			 
2dfe .. 00		.ifthen:  db "THEN",0 
2e03			 
2e03			.iftrue:		 
2e03				; Exec next words normally 
2e03			 
2e03				; if true then exec following IF as normal 
2e03					if DEBUG_FORTH_WORDS 
2e03						DMARK "IFT" 
2e03 f5				push af  
2e04 3a 18 2e			ld a, (.dmark)  
2e07 32 71 ee			ld (debug_mark),a  
2e0a 3a 19 2e			ld a, (.dmark+1)  
2e0d 32 72 ee			ld (debug_mark+1),a  
2e10 3a 1a 2e			ld a, (.dmark+2)  
2e13 32 73 ee			ld (debug_mark+2),a  
2e16 18 03			jr .pastdmark  
2e18 ..			.dmark: db "IFT"  
2e1b f1			.pastdmark: pop af  
2e1c			endm  
# End of macro DMARK
2e1c						CALLMONITOR 
2e1c cd 87 14			call break_point_state  
2e1f				endm  
# End of macro CALLMONITOR
2e1f					endif 
2e1f			 
2e1f					NEXTW 
2e1f c3 4a 1e			jp macro_next 
2e22				endm 
# End of macro NEXTW
2e22			.THEN: 
2e22				CWHEAD .ELSE 11 "THEN" 4 WORD_FLAG_CODE 
2e22 1f				db WORD_SYS_CORE+11             
2e23 4a 2e			dw .ELSE            
2e25 05				db 4 + 1 
2e26 .. 00			db "THEN",0              
2e2b				endm 
# End of macro CWHEAD
2e2b			; | THEN ( -- ) Does nothing. It is a marker for the end of an IF block | DONE 
2e2b					if DEBUG_FORTH_WORDS_KEY 
2e2b						DMARK "THN" 
2e2b f5				push af  
2e2c 3a 40 2e			ld a, (.dmark)  
2e2f 32 71 ee			ld (debug_mark),a  
2e32 3a 41 2e			ld a, (.dmark+1)  
2e35 32 72 ee			ld (debug_mark+1),a  
2e38 3a 42 2e			ld a, (.dmark+2)  
2e3b 32 73 ee			ld (debug_mark+2),a  
2e3e 18 03			jr .pastdmark  
2e40 ..			.dmark: db "THN"  
2e43 f1			.pastdmark: pop af  
2e44			endm  
# End of macro DMARK
2e44						CALLMONITOR 
2e44 cd 87 14			call break_point_state  
2e47				endm  
# End of macro CALLMONITOR
2e47					endif 
2e47					NEXTW 
2e47 c3 4a 1e			jp macro_next 
2e4a				endm 
# End of macro NEXTW
2e4a			.ELSE: 
2e4a				CWHEAD .DO 12 "ELSE" 2 WORD_FLAG_CODE 
2e4a 20				db WORD_SYS_CORE+12             
2e4b 72 2e			dw .DO            
2e4d 03				db 2 + 1 
2e4e .. 00			db "ELSE",0              
2e53				endm 
# End of macro CWHEAD
2e53			; | ELSE ( -- ) Not supported - does nothing | TODO 
2e53			 
2e53					if DEBUG_FORTH_WORDS_KEY 
2e53						DMARK "ELS" 
2e53 f5				push af  
2e54 3a 68 2e			ld a, (.dmark)  
2e57 32 71 ee			ld (debug_mark),a  
2e5a 3a 69 2e			ld a, (.dmark+1)  
2e5d 32 72 ee			ld (debug_mark+1),a  
2e60 3a 6a 2e			ld a, (.dmark+2)  
2e63 32 73 ee			ld (debug_mark+2),a  
2e66 18 03			jr .pastdmark  
2e68 ..			.dmark: db "ELS"  
2e6b f1			.pastdmark: pop af  
2e6c			endm  
# End of macro DMARK
2e6c						CALLMONITOR 
2e6c cd 87 14			call break_point_state  
2e6f				endm  
# End of macro CALLMONITOR
2e6f					endif 
2e6f			 
2e6f			 
2e6f					NEXTW 
2e6f c3 4a 1e			jp macro_next 
2e72				endm 
# End of macro NEXTW
2e72			.DO: 
2e72				CWHEAD .LOOP 13 "DO" 2 WORD_FLAG_CODE 
2e72 21				db WORD_SYS_CORE+13             
2e73 99 2f			dw .LOOP            
2e75 03				db 2 + 1 
2e76 .. 00			db "DO",0              
2e79				endm 
# End of macro CWHEAD
2e79			; | DO ( u1 u2 -- ) Loop starting at u2 with a limit of u1 | DONE 
2e79			 
2e79					if DEBUG_FORTH_WORDS_KEY 
2e79						DMARK "DO." 
2e79 f5				push af  
2e7a 3a 8e 2e			ld a, (.dmark)  
2e7d 32 71 ee			ld (debug_mark),a  
2e80 3a 8f 2e			ld a, (.dmark+1)  
2e83 32 72 ee			ld (debug_mark+1),a  
2e86 3a 90 2e			ld a, (.dmark+2)  
2e89 32 73 ee			ld (debug_mark+2),a  
2e8c 18 03			jr .pastdmark  
2e8e ..			.dmark: db "DO."  
2e91 f1			.pastdmark: pop af  
2e92			endm  
# End of macro DMARK
2e92						CALLMONITOR 
2e92 cd 87 14			call break_point_state  
2e95				endm  
# End of macro CALLMONITOR
2e95					endif 
2e95			;  push pc to rsp stack past the DO 
2e95			 
2e95 2a d8 e6				ld hl, (os_tok_ptr) 
2e98 23					inc hl   ; D 
2e99 23					inc hl  ; O 
2e9a 23					inc hl   ; null 
2e9b					if DEBUG_FORTH_WORDS 
2e9b						DMARK "DO2" 
2e9b f5				push af  
2e9c 3a b0 2e			ld a, (.dmark)  
2e9f 32 71 ee			ld (debug_mark),a  
2ea2 3a b1 2e			ld a, (.dmark+1)  
2ea5 32 72 ee			ld (debug_mark+1),a  
2ea8 3a b2 2e			ld a, (.dmark+2)  
2eab 32 73 ee			ld (debug_mark+2),a  
2eae 18 03			jr .pastdmark  
2eb0 ..			.dmark: db "DO2"  
2eb3 f1			.pastdmark: pop af  
2eb4			endm  
# End of macro DMARK
2eb4						CALLMONITOR 
2eb4 cd 87 14			call break_point_state  
2eb7				endm  
# End of macro CALLMONITOR
2eb7					endif 
2eb7					FORTH_RSP_NEXT 
2eb7 cd 88 1a			call macro_forth_rsp_next 
2eba				endm 
# End of macro FORTH_RSP_NEXT
2eba					if DEBUG_FORTH_WORDS 
2eba						DMARK "DO3" 
2eba f5				push af  
2ebb 3a cf 2e			ld a, (.dmark)  
2ebe 32 71 ee			ld (debug_mark),a  
2ec1 3a d0 2e			ld a, (.dmark+1)  
2ec4 32 72 ee			ld (debug_mark+1),a  
2ec7 3a d1 2e			ld a, (.dmark+2)  
2eca 32 73 ee			ld (debug_mark+2),a  
2ecd 18 03			jr .pastdmark  
2ecf ..			.dmark: db "DO3"  
2ed2 f1			.pastdmark: pop af  
2ed3			endm  
# End of macro DMARK
2ed3						CALLMONITOR 
2ed3 cd 87 14			call break_point_state  
2ed6				endm  
# End of macro CALLMONITOR
2ed6					endif 
2ed6			 
2ed6					;if DEBUG_FORTH_WORDS 
2ed6				;		push hl 
2ed6			;		endif  
2ed6			 
2ed6			; get counters from data stack 
2ed6			 
2ed6			 
2ed6					FORTH_DSP_VALUEHL 
2ed6 cd d8 1c			call macro_dsp_valuehl 
2ed9				endm 
# End of macro FORTH_DSP_VALUEHL
2ed9 e5					push hl		 ; hl now has starting counter which needs to be tos 
2eda			 
2eda					if DEBUG_FORTH_WORDS 
2eda						DMARK "DO4" 
2eda f5				push af  
2edb 3a ef 2e			ld a, (.dmark)  
2ede 32 71 ee			ld (debug_mark),a  
2ee1 3a f0 2e			ld a, (.dmark+1)  
2ee4 32 72 ee			ld (debug_mark+1),a  
2ee7 3a f1 2e			ld a, (.dmark+2)  
2eea 32 73 ee			ld (debug_mark+2),a  
2eed 18 03			jr .pastdmark  
2eef ..			.dmark: db "DO4"  
2ef2 f1			.pastdmark: pop af  
2ef3			endm  
# End of macro DMARK
2ef3						CALLMONITOR 
2ef3 cd 87 14			call break_point_state  
2ef6				endm  
# End of macro CALLMONITOR
2ef6					endif 
2ef6					FORTH_DSP_POP 
2ef6 cd 90 1d			call macro_forth_dsp_pop 
2ef9				endm 
# End of macro FORTH_DSP_POP
2ef9			 
2ef9					if DEBUG_FORTH_WORDS 
2ef9						DMARK "DO5" 
2ef9 f5				push af  
2efa 3a 0e 2f			ld a, (.dmark)  
2efd 32 71 ee			ld (debug_mark),a  
2f00 3a 0f 2f			ld a, (.dmark+1)  
2f03 32 72 ee			ld (debug_mark+1),a  
2f06 3a 10 2f			ld a, (.dmark+2)  
2f09 32 73 ee			ld (debug_mark+2),a  
2f0c 18 03			jr .pastdmark  
2f0e ..			.dmark: db "DO5"  
2f11 f1			.pastdmark: pop af  
2f12			endm  
# End of macro DMARK
2f12						CALLMONITOR 
2f12 cd 87 14			call break_point_state  
2f15				endm  
# End of macro CALLMONITOR
2f15					endif 
2f15			 
2f15					FORTH_DSP_VALUEHL 
2f15 cd d8 1c			call macro_dsp_valuehl 
2f18				endm 
# End of macro FORTH_DSP_VALUEHL
2f18			;		push hl		 ; hl now has starting limit counter 
2f18			 
2f18					if DEBUG_FORTH_WORDS 
2f18						DMARK "DO6" 
2f18 f5				push af  
2f19 3a 2d 2f			ld a, (.dmark)  
2f1c 32 71 ee			ld (debug_mark),a  
2f1f 3a 2e 2f			ld a, (.dmark+1)  
2f22 32 72 ee			ld (debug_mark+1),a  
2f25 3a 2f 2f			ld a, (.dmark+2)  
2f28 32 73 ee			ld (debug_mark+2),a  
2f2b 18 03			jr .pastdmark  
2f2d ..			.dmark: db "DO6"  
2f30 f1			.pastdmark: pop af  
2f31			endm  
# End of macro DMARK
2f31						CALLMONITOR 
2f31 cd 87 14			call break_point_state  
2f34				endm  
# End of macro CALLMONITOR
2f34					endif 
2f34					FORTH_DSP_POP 
2f34 cd 90 1d			call macro_forth_dsp_pop 
2f37				endm 
# End of macro FORTH_DSP_POP
2f37			 
2f37			; put counters on the loop stack 
2f37			 
2f37			;		pop hl			 ; limit counter 
2f37 d1					pop de			; start counter 
2f38			 
2f38					; push limit counter 
2f38			 
2f38					if DEBUG_FORTH_WORDS 
2f38						DMARK "DO7" 
2f38 f5				push af  
2f39 3a 4d 2f			ld a, (.dmark)  
2f3c 32 71 ee			ld (debug_mark),a  
2f3f 3a 4e 2f			ld a, (.dmark+1)  
2f42 32 72 ee			ld (debug_mark+1),a  
2f45 3a 4f 2f			ld a, (.dmark+2)  
2f48 32 73 ee			ld (debug_mark+2),a  
2f4b 18 03			jr .pastdmark  
2f4d ..			.dmark: db "DO7"  
2f50 f1			.pastdmark: pop af  
2f51			endm  
# End of macro DMARK
2f51						CALLMONITOR 
2f51 cd 87 14			call break_point_state  
2f54				endm  
# End of macro CALLMONITOR
2f54					endif 
2f54					FORTH_LOOP_NEXT 
2f54 cd 09 1d			call macro_forth_loop_next 
2f57				endm 
# End of macro FORTH_LOOP_NEXT
2f57			 
2f57					; push start counter 
2f57			 
2f57 eb					ex de, hl 
2f58					if DEBUG_FORTH_WORDS 
2f58						DMARK "DO7" 
2f58 f5				push af  
2f59 3a 6d 2f			ld a, (.dmark)  
2f5c 32 71 ee			ld (debug_mark),a  
2f5f 3a 6e 2f			ld a, (.dmark+1)  
2f62 32 72 ee			ld (debug_mark+1),a  
2f65 3a 6f 2f			ld a, (.dmark+2)  
2f68 32 73 ee			ld (debug_mark+2),a  
2f6b 18 03			jr .pastdmark  
2f6d ..			.dmark: db "DO7"  
2f70 f1			.pastdmark: pop af  
2f71			endm  
# End of macro DMARK
2f71						CALLMONITOR 
2f71 cd 87 14			call break_point_state  
2f74				endm  
# End of macro CALLMONITOR
2f74					endif 
2f74					FORTH_LOOP_NEXT 
2f74 cd 09 1d			call macro_forth_loop_next 
2f77				endm 
# End of macro FORTH_LOOP_NEXT
2f77			 
2f77			 
2f77					; init first round of I counter 
2f77			 
2f77 22 fc e6				ld (os_current_i), hl 
2f7a			 
2f7a					if DEBUG_FORTH_WORDS 
2f7a						DMARK "DO8" 
2f7a f5				push af  
2f7b 3a 8f 2f			ld a, (.dmark)  
2f7e 32 71 ee			ld (debug_mark),a  
2f81 3a 90 2f			ld a, (.dmark+1)  
2f84 32 72 ee			ld (debug_mark+1),a  
2f87 3a 91 2f			ld a, (.dmark+2)  
2f8a 32 73 ee			ld (debug_mark+2),a  
2f8d 18 03			jr .pastdmark  
2f8f ..			.dmark: db "DO8"  
2f92 f1			.pastdmark: pop af  
2f93			endm  
# End of macro DMARK
2f93						CALLMONITOR 
2f93 cd 87 14			call break_point_state  
2f96				endm  
# End of macro CALLMONITOR
2f96					endif 
2f96			 
2f96					NEXTW 
2f96 c3 4a 1e			jp macro_next 
2f99				endm 
# End of macro NEXTW
2f99			.LOOP: 
2f99				CWHEAD .I 14 "LOOP" 4 WORD_FLAG_CODE 
2f99 22				db WORD_SYS_CORE+14             
2f9a b1 30			dw .I            
2f9c 05				db 4 + 1 
2f9d .. 00			db "LOOP",0              
2fa2				endm 
# End of macro CWHEAD
2fa2			; | LOOP ( -- ) Increment and test loop counter  | DONE 
2fa2			 
2fa2				; pop tos as current loop count to hl 
2fa2			 
2fa2				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
2fa2			 
2fa2				FORTH_LOOP_TOS 
2fa2 cd 3c 1d			call macro_forth_loop_tos 
2fa5				endm 
# End of macro FORTH_LOOP_TOS
2fa5 e5				push hl 
2fa6			 
2fa6					if DEBUG_FORTH_WORDS_KEY 
2fa6						DMARK "LOP" 
2fa6 f5				push af  
2fa7 3a bb 2f			ld a, (.dmark)  
2faa 32 71 ee			ld (debug_mark),a  
2fad 3a bc 2f			ld a, (.dmark+1)  
2fb0 32 72 ee			ld (debug_mark+1),a  
2fb3 3a bd 2f			ld a, (.dmark+2)  
2fb6 32 73 ee			ld (debug_mark+2),a  
2fb9 18 03			jr .pastdmark  
2fbb ..			.dmark: db "LOP"  
2fbe f1			.pastdmark: pop af  
2fbf			endm  
# End of macro DMARK
2fbf						CALLMONITOR 
2fbf cd 87 14			call break_point_state  
2fc2				endm  
# End of macro CALLMONITOR
2fc2					endif 
2fc2				; next item on the stack is the limit. get it 
2fc2			 
2fc2			 
2fc2				FORTH_LOOP_POP 
2fc2 cd 46 1d			call macro_forth_loop_pop 
2fc5				endm 
# End of macro FORTH_LOOP_POP
2fc5			 
2fc5				FORTH_LOOP_TOS 
2fc5 cd 3c 1d			call macro_forth_loop_tos 
2fc8				endm 
# End of macro FORTH_LOOP_TOS
2fc8			 
2fc8 d1				pop de		 ; de = i, hl = limit 
2fc9			 
2fc9					if DEBUG_FORTH_WORDS 
2fc9						DMARK "LP1" 
2fc9 f5				push af  
2fca 3a de 2f			ld a, (.dmark)  
2fcd 32 71 ee			ld (debug_mark),a  
2fd0 3a df 2f			ld a, (.dmark+1)  
2fd3 32 72 ee			ld (debug_mark+1),a  
2fd6 3a e0 2f			ld a, (.dmark+2)  
2fd9 32 73 ee			ld (debug_mark+2),a  
2fdc 18 03			jr .pastdmark  
2fde ..			.dmark: db "LP1"  
2fe1 f1			.pastdmark: pop af  
2fe2			endm  
# End of macro DMARK
2fe2						CALLMONITOR 
2fe2 cd 87 14			call break_point_state  
2fe5				endm  
# End of macro CALLMONITOR
2fe5					endif 
2fe5			 
2fe5				; go back to previous word 
2fe5			 
2fe5 d5				push de    ; save I for inc later 
2fe6			 
2fe6			 
2fe6				; get limit 
2fe6				;  is I at limit? 
2fe6			 
2fe6			 
2fe6					if DEBUG_FORTH_WORDS 
2fe6						DMARK "LP1" 
2fe6 f5				push af  
2fe7 3a fb 2f			ld a, (.dmark)  
2fea 32 71 ee			ld (debug_mark),a  
2fed 3a fc 2f			ld a, (.dmark+1)  
2ff0 32 72 ee			ld (debug_mark+1),a  
2ff3 3a fd 2f			ld a, (.dmark+2)  
2ff6 32 73 ee			ld (debug_mark+2),a  
2ff9 18 03			jr .pastdmark  
2ffb ..			.dmark: db "LP1"  
2ffe f1			.pastdmark: pop af  
2fff			endm  
# End of macro DMARK
2fff						CALLMONITOR 
2fff cd 87 14			call break_point_state  
3002				endm  
# End of macro CALLMONITOR
3002					endif 
3002			 
3002 ed 52			sbc hl, de 
3004			 
3004			 
3004				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3004			 
3004 20 26				jr nz, .loopnotdone 
3006			 
3006 e1				pop hl   ; get rid of saved I 
3007				FORTH_LOOP_POP     ; get rid of limit 
3007 cd 46 1d			call macro_forth_loop_pop 
300a				endm 
# End of macro FORTH_LOOP_POP
300a			 
300a				FORTH_RSP_POP     ; get rid of DO ptr 
300a cd a9 1a			call macro_forth_rsp_pop 
300d				endm 
# End of macro FORTH_RSP_POP
300d			 
300d			if DEBUG_FORTH_WORDS 
300d						DMARK "LP>" 
300d f5				push af  
300e 3a 22 30			ld a, (.dmark)  
3011 32 71 ee			ld (debug_mark),a  
3014 3a 23 30			ld a, (.dmark+1)  
3017 32 72 ee			ld (debug_mark+1),a  
301a 3a 24 30			ld a, (.dmark+2)  
301d 32 73 ee			ld (debug_mark+2),a  
3020 18 03			jr .pastdmark  
3022 ..			.dmark: db "LP>"  
3025 f1			.pastdmark: pop af  
3026			endm  
# End of macro DMARK
3026				CALLMONITOR 
3026 cd 87 14			call break_point_state  
3029				endm  
# End of macro CALLMONITOR
3029			endif 
3029			 
3029					NEXTW 
3029 c3 4a 1e			jp macro_next 
302c				endm 
# End of macro NEXTW
302c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
302c			 
302c			.loopnotdone: 
302c			 
302c e1				pop hl    ; get I 
302d 23				inc hl 
302e			 
302e			   	; save new I 
302e			 
302e			 
302e					; set I counter 
302e			 
302e 22 fc e6				ld (os_current_i), hl 
3031			 
3031					if DEBUG_FORTH_WORDS 
3031						DMARK "LPN" 
3031 f5				push af  
3032 3a 46 30			ld a, (.dmark)  
3035 32 71 ee			ld (debug_mark),a  
3038 3a 47 30			ld a, (.dmark+1)  
303b 32 72 ee			ld (debug_mark+1),a  
303e 3a 48 30			ld a, (.dmark+2)  
3041 32 73 ee			ld (debug_mark+2),a  
3044 18 03			jr .pastdmark  
3046 ..			.dmark: db "LPN"  
3049 f1			.pastdmark: pop af  
304a			endm  
# End of macro DMARK
304a					CALLMONITOR 
304a cd 87 14			call break_point_state  
304d				endm  
# End of macro CALLMONITOR
304d					endif 
304d					 
304d				FORTH_LOOP_NEXT 
304d cd 09 1d			call macro_forth_loop_next 
3050				endm 
# End of macro FORTH_LOOP_NEXT
3050			 
3050			 
3050					if DEBUG_FORTH_WORDS 
3050 eb						ex de,hl 
3051					endif 
3051			 
3051			;	; get DO ptr 
3051			; 
3051					if DEBUG_FORTH_WORDS 
3051						DMARK "LP7" 
3051 f5				push af  
3052 3a 66 30			ld a, (.dmark)  
3055 32 71 ee			ld (debug_mark),a  
3058 3a 67 30			ld a, (.dmark+1)  
305b 32 72 ee			ld (debug_mark+1),a  
305e 3a 68 30			ld a, (.dmark+2)  
3061 32 73 ee			ld (debug_mark+2),a  
3064 18 03			jr .pastdmark  
3066 ..			.dmark: db "LP7"  
3069 f1			.pastdmark: pop af  
306a			endm  
# End of macro DMARK
306a					CALLMONITOR 
306a cd 87 14			call break_point_state  
306d				endm  
# End of macro CALLMONITOR
306d					endif 
306d				FORTH_RSP_TOS 
306d cd 9f 1a			call macro_forth_rsp_tos 
3070				endm 
# End of macro FORTH_RSP_TOS
3070			 
3070					if DEBUG_FORTH_WORDS 
3070						DMARK "LP8" 
3070 f5				push af  
3071 3a 85 30			ld a, (.dmark)  
3074 32 71 ee			ld (debug_mark),a  
3077 3a 86 30			ld a, (.dmark+1)  
307a 32 72 ee			ld (debug_mark+1),a  
307d 3a 87 30			ld a, (.dmark+2)  
3080 32 73 ee			ld (debug_mark+2),a  
3083 18 03			jr .pastdmark  
3085 ..			.dmark: db "LP8"  
3088 f1			.pastdmark: pop af  
3089			endm  
# End of macro DMARK
3089					CALLMONITOR 
3089 cd 87 14			call break_point_state  
308c				endm  
# End of macro CALLMONITOR
308c					endif 
308c				;push hl 
308c			 
308c				; not going to DO any more 
308c				; get rid of the RSP pointer as DO will add it back in 
308c				;FORTH_RSP_POP 
308c				;pop hl 
308c			 
308c				;ld hl,(cli_ret_sp) 
308c				;ld e, (hl) 
308c				;inc hl 
308c				;ld d, (hl) 
308c				;ex de,hl 
308c 22 d8 e6			ld (os_tok_ptr), hl 
308f					if DEBUG_FORTH_WORDS 
308f						DMARK "LP<" 
308f f5				push af  
3090 3a a4 30			ld a, (.dmark)  
3093 32 71 ee			ld (debug_mark),a  
3096 3a a5 30			ld a, (.dmark+1)  
3099 32 72 ee			ld (debug_mark+1),a  
309c 3a a6 30			ld a, (.dmark+2)  
309f 32 73 ee			ld (debug_mark+2),a  
30a2 18 03			jr .pastdmark  
30a4 ..			.dmark: db "LP<"  
30a7 f1			.pastdmark: pop af  
30a8			endm  
# End of macro DMARK
30a8					CALLMONITOR 
30a8 cd 87 14			call break_point_state  
30ab				endm  
# End of macro CALLMONITOR
30ab				endif 
30ab c3 db 1e			jp exec1 
30ae			 
30ae					 
30ae			 
30ae			 
30ae					NEXTW 
30ae c3 4a 1e			jp macro_next 
30b1				endm 
# End of macro NEXTW
30b1			.I:  
30b1			 
30b1				CWHEAD .DLOOP 74 "I" 1 WORD_FLAG_CODE 
30b1 5e				db WORD_SYS_CORE+74             
30b2 dc 30			dw .DLOOP            
30b4 02				db 1 + 1 
30b5 .. 00			db "I",0              
30b7				endm 
# End of macro CWHEAD
30b7			; | I ( -- ) Current loop counter | DONE 
30b7					if DEBUG_FORTH_WORDS_KEY 
30b7						DMARK "I.." 
30b7 f5				push af  
30b8 3a cc 30			ld a, (.dmark)  
30bb 32 71 ee			ld (debug_mark),a  
30be 3a cd 30			ld a, (.dmark+1)  
30c1 32 72 ee			ld (debug_mark+1),a  
30c4 3a ce 30			ld a, (.dmark+2)  
30c7 32 73 ee			ld (debug_mark+2),a  
30ca 18 03			jr .pastdmark  
30cc ..			.dmark: db "I.."  
30cf f1			.pastdmark: pop af  
30d0			endm  
# End of macro DMARK
30d0						CALLMONITOR 
30d0 cd 87 14			call break_point_state  
30d3				endm  
# End of macro CALLMONITOR
30d3					endif 
30d3			 
30d3 2a fc e6				ld hl,(os_current_i) 
30d6 cd e1 1a				call forth_push_numhl 
30d9			 
30d9					NEXTW 
30d9 c3 4a 1e			jp macro_next 
30dc				endm 
# End of macro NEXTW
30dc			.DLOOP: 
30dc				CWHEAD .REPEAT 75 "-LOOP" 5 WORD_FLAG_CODE 
30dc 5f				db WORD_SYS_CORE+75             
30dd bd 31			dw .REPEAT            
30df 06				db 5 + 1 
30e0 .. 00			db "-LOOP",0              
30e6				endm 
# End of macro CWHEAD
30e6			; | -LOOP ( -- ) Decrement and test loop counter  | DONE 
30e6				; pop tos as current loop count to hl 
30e6					if DEBUG_FORTH_WORDS_KEY 
30e6						DMARK "-LP" 
30e6 f5				push af  
30e7 3a fb 30			ld a, (.dmark)  
30ea 32 71 ee			ld (debug_mark),a  
30ed 3a fc 30			ld a, (.dmark+1)  
30f0 32 72 ee			ld (debug_mark+1),a  
30f3 3a fd 30			ld a, (.dmark+2)  
30f6 32 73 ee			ld (debug_mark+2),a  
30f9 18 03			jr .pastdmark  
30fb ..			.dmark: db "-LP"  
30fe f1			.pastdmark: pop af  
30ff			endm  
# End of macro DMARK
30ff						CALLMONITOR 
30ff cd 87 14			call break_point_state  
3102				endm  
# End of macro CALLMONITOR
3102					endif 
3102			 
3102				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
3102			 
3102				FORTH_LOOP_TOS 
3102 cd 3c 1d			call macro_forth_loop_tos 
3105				endm 
# End of macro FORTH_LOOP_TOS
3105 e5				push hl 
3106			 
3106					if DEBUG_FORTH_WORDS 
3106						DMARK "-LP" 
3106 f5				push af  
3107 3a 1b 31			ld a, (.dmark)  
310a 32 71 ee			ld (debug_mark),a  
310d 3a 1c 31			ld a, (.dmark+1)  
3110 32 72 ee			ld (debug_mark+1),a  
3113 3a 1d 31			ld a, (.dmark+2)  
3116 32 73 ee			ld (debug_mark+2),a  
3119 18 03			jr .pastdmark  
311b ..			.dmark: db "-LP"  
311e f1			.pastdmark: pop af  
311f			endm  
# End of macro DMARK
311f						CALLMONITOR 
311f cd 87 14			call break_point_state  
3122				endm  
# End of macro CALLMONITOR
3122					endif 
3122				; next item on the stack is the limit. get it 
3122			 
3122			 
3122				FORTH_LOOP_POP 
3122 cd 46 1d			call macro_forth_loop_pop 
3125				endm 
# End of macro FORTH_LOOP_POP
3125			 
3125				FORTH_LOOP_TOS 
3125 cd 3c 1d			call macro_forth_loop_tos 
3128				endm 
# End of macro FORTH_LOOP_TOS
3128			 
3128 d1				pop de		 ; de = i, hl = limit 
3129			 
3129					if DEBUG_FORTH_WORDS 
3129						DMARK "-L1" 
3129 f5				push af  
312a 3a 3e 31			ld a, (.dmark)  
312d 32 71 ee			ld (debug_mark),a  
3130 3a 3f 31			ld a, (.dmark+1)  
3133 32 72 ee			ld (debug_mark+1),a  
3136 3a 40 31			ld a, (.dmark+2)  
3139 32 73 ee			ld (debug_mark+2),a  
313c 18 03			jr .pastdmark  
313e ..			.dmark: db "-L1"  
3141 f1			.pastdmark: pop af  
3142			endm  
# End of macro DMARK
3142						CALLMONITOR 
3142 cd 87 14			call break_point_state  
3145				endm  
# End of macro CALLMONITOR
3145					endif 
3145			 
3145				; go back to previous word 
3145			 
3145 d5				push de    ; save I for inc later 
3146			 
3146			 
3146				; get limit 
3146				;  is I at limit? 
3146			 
3146			 
3146					if DEBUG_FORTH_WORDS 
3146						DMARK "-L1" 
3146 f5				push af  
3147 3a 5b 31			ld a, (.dmark)  
314a 32 71 ee			ld (debug_mark),a  
314d 3a 5c 31			ld a, (.dmark+1)  
3150 32 72 ee			ld (debug_mark+1),a  
3153 3a 5d 31			ld a, (.dmark+2)  
3156 32 73 ee			ld (debug_mark+2),a  
3159 18 03			jr .pastdmark  
315b ..			.dmark: db "-L1"  
315e f1			.pastdmark: pop af  
315f			endm  
# End of macro DMARK
315f						CALLMONITOR 
315f cd 87 14			call break_point_state  
3162				endm  
# End of macro CALLMONITOR
3162					endif 
3162			 
3162 ed 52			sbc hl, de 
3164			 
3164			 
3164				;  if at limit pop both limit and current off stack do NEXT and get rid of saved DO 
3164			 
3164 20 26				jr nz, .mloopnotdone 
3166			 
3166 e1				pop hl   ; get rid of saved I 
3167				FORTH_LOOP_POP     ; get rid of limit 
3167 cd 46 1d			call macro_forth_loop_pop 
316a				endm 
# End of macro FORTH_LOOP_POP
316a			 
316a				FORTH_RSP_POP     ; get rid of DO ptr 
316a cd a9 1a			call macro_forth_rsp_pop 
316d				endm 
# End of macro FORTH_RSP_POP
316d			 
316d			if DEBUG_FORTH_WORDS 
316d						DMARK "-L>" 
316d f5				push af  
316e 3a 82 31			ld a, (.dmark)  
3171 32 71 ee			ld (debug_mark),a  
3174 3a 83 31			ld a, (.dmark+1)  
3177 32 72 ee			ld (debug_mark+1),a  
317a 3a 84 31			ld a, (.dmark+2)  
317d 32 73 ee			ld (debug_mark+2),a  
3180 18 03			jr .pastdmark  
3182 ..			.dmark: db "-L>"  
3185 f1			.pastdmark: pop af  
3186			endm  
# End of macro DMARK
3186				CALLMONITOR 
3186 cd 87 14			call break_point_state  
3189				endm  
# End of macro CALLMONITOR
3189			endif 
3189			 
3189					NEXTW 
3189 c3 4a 1e			jp macro_next 
318c				endm 
# End of macro NEXTW
318c				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
318c			 
318c			.mloopnotdone: 
318c			 
318c e1				pop hl    ; get I 
318d 2b				dec hl 
318e			 
318e			   	; save new I 
318e			 
318e			 
318e					; set I counter 
318e			 
318e 22 fc e6				ld (os_current_i), hl 
3191			 
3191					 
3191				FORTH_LOOP_NEXT 
3191 cd 09 1d			call macro_forth_loop_next 
3194				endm 
# End of macro FORTH_LOOP_NEXT
3194			 
3194			 
3194					if DEBUG_FORTH_WORDS 
3194 eb						ex de,hl 
3195					endif 
3195			 
3195			;	; get DO ptr 
3195			; 
3195				FORTH_RSP_TOS 
3195 cd 9f 1a			call macro_forth_rsp_tos 
3198				endm 
# End of macro FORTH_RSP_TOS
3198			 
3198				;push hl 
3198			 
3198				; not going to DO any more 
3198				; get rid of the RSP pointer as DO will add it back in 
3198				;FORTH_RSP_POP 
3198				;pop hl 
3198			 
3198			 
3198 22 d8 e6			ld (os_tok_ptr), hl 
319b					if DEBUG_FORTH_WORDS 
319b						DMARK "-L<" 
319b f5				push af  
319c 3a b0 31			ld a, (.dmark)  
319f 32 71 ee			ld (debug_mark),a  
31a2 3a b1 31			ld a, (.dmark+1)  
31a5 32 72 ee			ld (debug_mark+1),a  
31a8 3a b2 31			ld a, (.dmark+2)  
31ab 32 73 ee			ld (debug_mark+2),a  
31ae 18 03			jr .pastdmark  
31b0 ..			.dmark: db "-L<"  
31b3 f1			.pastdmark: pop af  
31b4			endm  
# End of macro DMARK
31b4					CALLMONITOR 
31b4 cd 87 14			call break_point_state  
31b7				endm  
# End of macro CALLMONITOR
31b7				endif 
31b7 c3 db 1e			jp exec1 
31ba			 
31ba					 
31ba			 
31ba			 
31ba			 
31ba				NEXTW 
31ba c3 4a 1e			jp macro_next 
31bd				endm 
# End of macro NEXTW
31bd			 
31bd			 
31bd			 
31bd			 
31bd			.REPEAT: 
31bd				CWHEAD .UNTIL 93 "REPEAT" 5 WORD_FLAG_CODE 
31bd 71				db WORD_SYS_CORE+93             
31be 10 32			dw .UNTIL            
31c0 06				db 5 + 1 
31c1 .. 00			db "REPEAT",0              
31c8				endm 
# End of macro CWHEAD
31c8			; | REPEAT ( --  ) Start REPEAT...UNTIL loop  | DONE 
31c8			;  push pc to rsp stack past the REPEAT 
31c8					if DEBUG_FORTH_WORDS_KEY 
31c8						DMARK "REP" 
31c8 f5				push af  
31c9 3a dd 31			ld a, (.dmark)  
31cc 32 71 ee			ld (debug_mark),a  
31cf 3a de 31			ld a, (.dmark+1)  
31d2 32 72 ee			ld (debug_mark+1),a  
31d5 3a df 31			ld a, (.dmark+2)  
31d8 32 73 ee			ld (debug_mark+2),a  
31db 18 03			jr .pastdmark  
31dd ..			.dmark: db "REP"  
31e0 f1			.pastdmark: pop af  
31e1			endm  
# End of macro DMARK
31e1						CALLMONITOR 
31e1 cd 87 14			call break_point_state  
31e4				endm  
# End of macro CALLMONITOR
31e4					endif 
31e4			 
31e4 2a d8 e6				ld hl, (os_tok_ptr) 
31e7 23					inc hl   ; R 
31e8 23					inc hl  ; E 
31e9 23					inc hl   ; P 
31ea 23					inc hl   ; E 
31eb 23					inc hl   ; A 
31ec 23					inc hl   ; T 
31ed 23					inc hl   ; zero 
31ee					FORTH_RSP_NEXT 
31ee cd 88 1a			call macro_forth_rsp_next 
31f1				endm 
# End of macro FORTH_RSP_NEXT
31f1			 
31f1			 
31f1					if DEBUG_FORTH_WORDS 
31f1						DMARK "REP" 
31f1 f5				push af  
31f2 3a 06 32			ld a, (.dmark)  
31f5 32 71 ee			ld (debug_mark),a  
31f8 3a 07 32			ld a, (.dmark+1)  
31fb 32 72 ee			ld (debug_mark+1),a  
31fe 3a 08 32			ld a, (.dmark+2)  
3201 32 73 ee			ld (debug_mark+2),a  
3204 18 03			jr .pastdmark  
3206 ..			.dmark: db "REP"  
3209 f1			.pastdmark: pop af  
320a			endm  
# End of macro DMARK
320a						;pop bc    ; TODO BUG ?????? what is this for???? 
320a						CALLMONITOR 
320a cd 87 14			call break_point_state  
320d				endm  
# End of macro CALLMONITOR
320d					endif 
320d			 
320d					NEXTW 
320d c3 4a 1e			jp macro_next 
3210				endm 
# End of macro NEXTW
3210			;	       NEXTW 
3210			 
3210			.UNTIL: 
3210				CWHEAD .ENDFLOW 94 "UNTIL" 5 WORD_FLAG_CODE 
3210 72				db WORD_SYS_CORE+94             
3211 a7 32			dw .ENDFLOW            
3213 06				db 5 + 1 
3214 .. 00			db "UNTIL",0              
321a				endm 
# End of macro CWHEAD
321a			; | UNTIL ( u -- ) Exit REPEAT...UNTIL loop if TOS is false  | DONE 
321a			 
321a				; pop tos as check 
321a			 
321a				; if new tos (loop limit) is not same as hl, inc hl, push hl to tos, pop rsp and set pc to it 
321a			 
321a				FORTH_DSP_VALUEHL 
321a cd d8 1c			call macro_dsp_valuehl 
321d				endm 
# End of macro FORTH_DSP_VALUEHL
321d			 
321d					if DEBUG_FORTH_WORDS_KEY 
321d						DMARK "UNT" 
321d f5				push af  
321e 3a 32 32			ld a, (.dmark)  
3221 32 71 ee			ld (debug_mark),a  
3224 3a 33 32			ld a, (.dmark+1)  
3227 32 72 ee			ld (debug_mark+1),a  
322a 3a 34 32			ld a, (.dmark+2)  
322d 32 73 ee			ld (debug_mark+2),a  
3230 18 03			jr .pastdmark  
3232 ..			.dmark: db "UNT"  
3235 f1			.pastdmark: pop af  
3236			endm  
# End of macro DMARK
3236						CALLMONITOR 
3236 cd 87 14			call break_point_state  
3239				endm  
# End of macro CALLMONITOR
3239					endif 
3239			 
3239			;	push hl 
3239				FORTH_DSP_POP 
3239 cd 90 1d			call macro_forth_dsp_pop 
323c				endm 
# End of macro FORTH_DSP_POP
323c			 
323c			;	pop hl 
323c			 
323c				; test if true 
323c			 
323c cd af 0c			call ishlzero 
323f			;	ld a,l 
323f			;	add h 
323f			; 
323f			;	cp 0 
323f			 
323f 20 3e			jr nz, .untilnotdone 
3241			 
3241					if DEBUG_FORTH_WORDS 
3241						DMARK "UNf" 
3241 f5				push af  
3242 3a 56 32			ld a, (.dmark)  
3245 32 71 ee			ld (debug_mark),a  
3248 3a 57 32			ld a, (.dmark+1)  
324b 32 72 ee			ld (debug_mark+1),a  
324e 3a 58 32			ld a, (.dmark+2)  
3251 32 73 ee			ld (debug_mark+2),a  
3254 18 03			jr .pastdmark  
3256 ..			.dmark: db "UNf"  
3259 f1			.pastdmark: pop af  
325a			endm  
# End of macro DMARK
325a						CALLMONITOR 
325a cd 87 14			call break_point_state  
325d				endm  
# End of macro CALLMONITOR
325d					endif 
325d			 
325d			 
325d			 
325d				FORTH_RSP_POP     ; get rid of DO ptr 
325d cd a9 1a			call macro_forth_rsp_pop 
3260				endm 
# End of macro FORTH_RSP_POP
3260			 
3260			if DEBUG_FORTH_WORDS 
3260						DMARK "UN>" 
3260 f5				push af  
3261 3a 75 32			ld a, (.dmark)  
3264 32 71 ee			ld (debug_mark),a  
3267 3a 76 32			ld a, (.dmark+1)  
326a 32 72 ee			ld (debug_mark+1),a  
326d 3a 77 32			ld a, (.dmark+2)  
3270 32 73 ee			ld (debug_mark+2),a  
3273 18 03			jr .pastdmark  
3275 ..			.dmark: db "UN>"  
3278 f1			.pastdmark: pop af  
3279			endm  
# End of macro DMARK
3279				CALLMONITOR 
3279 cd 87 14			call break_point_state  
327c				endm  
# End of macro CALLMONITOR
327c			endif 
327c			 
327c					NEXTW 
327c c3 4a 1e			jp macro_next 
327f				endm 
# End of macro NEXTW
327f				; if not at limit. Inc I and update TOS get RTS off stack and reset parser 
327f			 
327f			.untilnotdone: 
327f			 
327f			 
327f			;	; get DO ptr 
327f			; 
327f				FORTH_RSP_TOS 
327f cd 9f 1a			call macro_forth_rsp_tos 
3282				endm 
# End of macro FORTH_RSP_TOS
3282			 
3282				;push hl 
3282			 
3282				; not going to DO any more 
3282				; get rid of the RSP pointer as DO will add it back in 
3282				;FORTH_RSP_POP 
3282				;pop hl 
3282			 
3282			 
3282 22 d8 e6			ld (os_tok_ptr), hl 
3285					if DEBUG_FORTH_WORDS 
3285						DMARK "UN<" 
3285 f5				push af  
3286 3a 9a 32			ld a, (.dmark)  
3289 32 71 ee			ld (debug_mark),a  
328c 3a 9b 32			ld a, (.dmark+1)  
328f 32 72 ee			ld (debug_mark+1),a  
3292 3a 9c 32			ld a, (.dmark+2)  
3295 32 73 ee			ld (debug_mark+2),a  
3298 18 03			jr .pastdmark  
329a ..			.dmark: db "UN<"  
329d f1			.pastdmark: pop af  
329e			endm  
# End of macro DMARK
329e					CALLMONITOR 
329e cd 87 14			call break_point_state  
32a1				endm  
# End of macro CALLMONITOR
32a1				endif 
32a1 c3 db 1e			jp exec1 
32a4			 
32a4					 
32a4			 
32a4			 
32a4					NEXTW 
32a4 c3 4a 1e			jp macro_next 
32a7				endm 
# End of macro NEXTW
32a7			 
32a7			 
32a7			.ENDFLOW: 
32a7			 
32a7			; eof 
32a7			 
# End of file forth_words_flow.asm
32a7			; TODO something wrong with the first word of the next word group. no matter which group applies. On device, sc114 is fine. bad memory? 
32a7			include "forth_words_logic.asm" 
32a7			 
32a7			; | ## Logic Words 
32a7			 
32a7			.NOT: 
32a7				CWHEAD .IS 25 "NOT" 3 WORD_FLAG_CODE 
32a7 2d				db WORD_SYS_CORE+25             
32a8 ef 32			dw .IS            
32aa 04				db 3 + 1 
32ab .. 00			db "NOT",0              
32af				endm 
# End of macro CWHEAD
32af			; | NOT ( u  -- u ) Inverse true/false on stack | DONE 
32af					if DEBUG_FORTH_WORDS_KEY 
32af						DMARK "NOT" 
32af f5				push af  
32b0 3a c4 32			ld a, (.dmark)  
32b3 32 71 ee			ld (debug_mark),a  
32b6 3a c5 32			ld a, (.dmark+1)  
32b9 32 72 ee			ld (debug_mark+1),a  
32bc 3a c6 32			ld a, (.dmark+2)  
32bf 32 73 ee			ld (debug_mark+2),a  
32c2 18 03			jr .pastdmark  
32c4 ..			.dmark: db "NOT"  
32c7 f1			.pastdmark: pop af  
32c8			endm  
# End of macro DMARK
32c8						CALLMONITOR 
32c8 cd 87 14			call break_point_state  
32cb				endm  
# End of macro CALLMONITOR
32cb					endif 
32cb					FORTH_DSP 
32cb cd 9e 1c			call macro_forth_dsp 
32ce				endm 
# End of macro FORTH_DSP
32ce 7e					ld a,(hl)	; get type of value on TOS 
32cf fe 02				cp DS_TYPE_INUM  
32d1 28 03				jr z, .noti 
32d3					NEXTW 
32d3 c3 4a 1e			jp macro_next 
32d6				endm 
# End of macro NEXTW
32d6			.noti:          FORTH_DSP_VALUEHL 
32d6 cd d8 1c			call macro_dsp_valuehl 
32d9				endm 
# End of macro FORTH_DSP_VALUEHL
32d9			;		push hl 
32d9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
32d9 cd 90 1d			call macro_forth_dsp_pop 
32dc				endm 
# End of macro FORTH_DSP_POP
32dc			;		pop hl 
32dc 3e 00				ld a,0 
32de bd					cp l 
32df 28 04				jr z, .not2t 
32e1 2e 00				ld l, 0 
32e3 18 02				jr .notip 
32e5			 
32e5 2e ff		.not2t:		ld l, 255 
32e7			 
32e7 26 00		.notip:		ld h, 0	 
32e9			 
32e9 cd e1 1a				call forth_push_numhl 
32ec					NEXTW 
32ec c3 4a 1e			jp macro_next 
32ef				endm 
# End of macro NEXTW
32ef			 
32ef			.IS: 
32ef				CWHEAD .LZERO 25 "IS" 2 WORD_FLAG_CODE 
32ef 2d				db WORD_SYS_CORE+25             
32f0 15 33			dw .LZERO            
32f2 03				db 2 + 1 
32f3 .. 00			db "IS",0              
32f6				endm 
# End of macro CWHEAD
32f6			; | IS ( s1 s2  -- f ) Push true if string s1 is the same as s2 | TODO 
32f6					if DEBUG_FORTH_WORDS_KEY 
32f6						DMARK "IS." 
32f6 f5				push af  
32f7 3a 0b 33			ld a, (.dmark)  
32fa 32 71 ee			ld (debug_mark),a  
32fd 3a 0c 33			ld a, (.dmark+1)  
3300 32 72 ee			ld (debug_mark+1),a  
3303 3a 0d 33			ld a, (.dmark+2)  
3306 32 73 ee			ld (debug_mark+2),a  
3309 18 03			jr .pastdmark  
330b ..			.dmark: db "IS."  
330e f1			.pastdmark: pop af  
330f			endm  
# End of macro DMARK
330f						CALLMONITOR 
330f cd 87 14			call break_point_state  
3312				endm  
# End of macro CALLMONITOR
3312					endif 
3312					NEXTW 
3312 c3 4a 1e			jp macro_next 
3315				endm 
# End of macro NEXTW
3315			.LZERO: 
3315				CWHEAD .TZERO 25 "0<" 2 WORD_FLAG_CODE 
3315 2d				db WORD_SYS_CORE+25             
3316 1f 33			dw .TZERO            
3318 03				db 2 + 1 
3319 .. 00			db "0<",0              
331c				endm 
# End of macro CWHEAD
331c			; | 0< ( u -- f ) Push true if u is less than o | CANT DO UNTIL FLOAT 
331c					NEXTW 
331c c3 4a 1e			jp macro_next 
331f				endm 
# End of macro NEXTW
331f			.TZERO: 
331f				CWHEAD .LESS 26 "0=" 2 WORD_FLAG_CODE 
331f 2e				db WORD_SYS_CORE+26             
3320 66 33			dw .LESS            
3322 03				db 2 + 1 
3323 .. 00			db "0=",0              
3326				endm 
# End of macro CWHEAD
3326			; | 0= ( u -- f ) Push true if u equals 0 | TEST NO DEBUG 
3326				; TODO add floating point number detection 
3326					;v5 FORTH_DSP_VALUE 
3326					if DEBUG_FORTH_WORDS_KEY 
3326						DMARK "0=." 
3326 f5				push af  
3327 3a 3b 33			ld a, (.dmark)  
332a 32 71 ee			ld (debug_mark),a  
332d 3a 3c 33			ld a, (.dmark+1)  
3330 32 72 ee			ld (debug_mark+1),a  
3333 3a 3d 33			ld a, (.dmark+2)  
3336 32 73 ee			ld (debug_mark+2),a  
3339 18 03			jr .pastdmark  
333b ..			.dmark: db "0=."  
333e f1			.pastdmark: pop af  
333f			endm  
# End of macro DMARK
333f						CALLMONITOR 
333f cd 87 14			call break_point_state  
3342				endm  
# End of macro CALLMONITOR
3342					endif 
3342					FORTH_DSP 
3342 cd 9e 1c			call macro_forth_dsp 
3345				endm 
# End of macro FORTH_DSP
3345 7e					ld a,(hl)	; get type of value on TOS 
3346 fe 02				cp DS_TYPE_INUM  
3348 28 00				jr z, .tz_inum 
334a			 
334a				if FORTH_ENABLE_FLOATMATH 
334a					jr .tz_done 
334a			 
334a				endif 
334a					 
334a			 
334a			.tz_inum: 
334a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
334a cd d8 1c			call macro_dsp_valuehl 
334d				endm 
# End of macro FORTH_DSP_VALUEHL
334d			 
334d			;		push hl 
334d			 
334d					; destroy value TOS 
334d			 
334d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
334d cd 90 1d			call macro_forth_dsp_pop 
3350				endm 
# End of macro FORTH_DSP_POP
3350			 
3350			;		pop hl 
3350			 
3350 3e 00				ld a,0 
3352			 
3352 bd					cp l 
3353 20 08				jr nz, .tz_notzero 
3355			 
3355 bc					cp h 
3356			 
3356 20 05				jr nz, .tz_notzero 
3358			 
3358			 
3358 21 01 00				ld hl, FORTH_TRUE 
335b 18 03				jr .tz_done 
335d			 
335d 21 00 00		.tz_notzero:	ld hl, FORTH_FALSE 
3360			 
3360					; push value back onto stack for another op etc 
3360			 
3360			.tz_done: 
3360 cd e1 1a				call forth_push_numhl 
3363			 
3363					NEXTW 
3363 c3 4a 1e			jp macro_next 
3366				endm 
# End of macro NEXTW
3366			.LESS: 
3366				CWHEAD .GT 27 "<" 1 WORD_FLAG_CODE 
3366 2f				db WORD_SYS_CORE+27             
3367 cf 33			dw .GT            
3369 02				db 1 + 1 
336a .. 00			db "<",0              
336c				endm 
# End of macro CWHEAD
336c			; | < ( u1 u2 -- f ) True if u1 is less than u2 | DONE 
336c				; TODO add floating point number detection 
336c					if DEBUG_FORTH_WORDS_KEY 
336c						DMARK "LES" 
336c f5				push af  
336d 3a 81 33			ld a, (.dmark)  
3370 32 71 ee			ld (debug_mark),a  
3373 3a 82 33			ld a, (.dmark+1)  
3376 32 72 ee			ld (debug_mark+1),a  
3379 3a 83 33			ld a, (.dmark+2)  
337c 32 73 ee			ld (debug_mark+2),a  
337f 18 03			jr .pastdmark  
3381 ..			.dmark: db "LES"  
3384 f1			.pastdmark: pop af  
3385			endm  
# End of macro DMARK
3385						CALLMONITOR 
3385 cd 87 14			call break_point_state  
3388				endm  
# End of macro CALLMONITOR
3388					endif 
3388					FORTH_DSP 
3388 cd 9e 1c			call macro_forth_dsp 
338b				endm 
# End of macro FORTH_DSP
338b					;v5 FORTH_DSP_VALUE 
338b 7e					ld a,(hl)	; get type of value on TOS 
338c fe 02				cp DS_TYPE_INUM  
338e 28 00				jr z, .less_inum 
3390			 
3390				if FORTH_ENABLE_FLOATMATH 
3390					jr .less_done 
3390			 
3390				endif 
3390					 
3390			 
3390			.less_inum: 
3390					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3390 cd d8 1c			call macro_dsp_valuehl 
3393				endm 
# End of macro FORTH_DSP_VALUEHL
3393			 
3393 e5					push hl  ; u2 
3394			 
3394					; destroy value TOS 
3394			 
3394					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3394 cd 90 1d			call macro_forth_dsp_pop 
3397				endm 
# End of macro FORTH_DSP_POP
3397			 
3397			 
3397					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3397 cd d8 1c			call macro_dsp_valuehl 
339a				endm 
# End of macro FORTH_DSP_VALUEHL
339a			 
339a e5					push hl    ; u1 
339b			 
339b					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
339b cd 90 1d			call macro_forth_dsp_pop 
339e				endm 
# End of macro FORTH_DSP_POP
339e			 
339e			 
339e b7			 or a      ;clear carry flag 
339f 01 00 00		 ld bc, FORTH_FALSE 
33a2 e1			  pop hl    ; u1 
33a3 d1			  pop de    ; u2 
33a4 ed 52		  sbc hl,de 
33a6 30 03		  jr nc,.lscont   	;	if hl >= de, carry flag will be cleared 
33a8			 
33a8 01 01 00		 ld bc, FORTH_TRUE 
33ab			.lscont:  
33ab c5					push bc 
33ac e1					pop hl 
33ad			 
33ad					if DEBUG_FORTH_WORDS 
33ad						DMARK "LT1" 
33ad f5				push af  
33ae 3a c2 33			ld a, (.dmark)  
33b1 32 71 ee			ld (debug_mark),a  
33b4 3a c3 33			ld a, (.dmark+1)  
33b7 32 72 ee			ld (debug_mark+1),a  
33ba 3a c4 33			ld a, (.dmark+2)  
33bd 32 73 ee			ld (debug_mark+2),a  
33c0 18 03			jr .pastdmark  
33c2 ..			.dmark: db "LT1"  
33c5 f1			.pastdmark: pop af  
33c6			endm  
# End of macro DMARK
33c6						CALLMONITOR 
33c6 cd 87 14			call break_point_state  
33c9				endm  
# End of macro CALLMONITOR
33c9					endif 
33c9 cd e1 1a				call forth_push_numhl 
33cc			 
33cc					NEXTW 
33cc c3 4a 1e			jp macro_next 
33cf				endm 
# End of macro NEXTW
33cf			.GT: 
33cf				CWHEAD .EQUAL 28 ">" 1 WORD_FLAG_CODE 
33cf 30				db WORD_SYS_CORE+28             
33d0 38 34			dw .EQUAL            
33d2 02				db 1 + 1 
33d3 .. 00			db ">",0              
33d5				endm 
# End of macro CWHEAD
33d5			; | > ( u1 u2 -- f ) True if u1 is greater than u2 | DONE 
33d5				; TODO add floating point number detection 
33d5					if DEBUG_FORTH_WORDS_KEY 
33d5						DMARK "GRT" 
33d5 f5				push af  
33d6 3a ea 33			ld a, (.dmark)  
33d9 32 71 ee			ld (debug_mark),a  
33dc 3a eb 33			ld a, (.dmark+1)  
33df 32 72 ee			ld (debug_mark+1),a  
33e2 3a ec 33			ld a, (.dmark+2)  
33e5 32 73 ee			ld (debug_mark+2),a  
33e8 18 03			jr .pastdmark  
33ea ..			.dmark: db "GRT"  
33ed f1			.pastdmark: pop af  
33ee			endm  
# End of macro DMARK
33ee						CALLMONITOR 
33ee cd 87 14			call break_point_state  
33f1				endm  
# End of macro CALLMONITOR
33f1					endif 
33f1					FORTH_DSP 
33f1 cd 9e 1c			call macro_forth_dsp 
33f4				endm 
# End of macro FORTH_DSP
33f4					;FORTH_DSP_VALUE 
33f4 7e					ld a,(hl)	; get type of value on TOS 
33f5 fe 02				cp DS_TYPE_INUM  
33f7 28 00				jr z, .gt_inum 
33f9			 
33f9				if FORTH_ENABLE_FLOATMATH 
33f9					jr .gt_done 
33f9			 
33f9				endif 
33f9					 
33f9			 
33f9			.gt_inum: 
33f9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
33f9 cd d8 1c			call macro_dsp_valuehl 
33fc				endm 
# End of macro FORTH_DSP_VALUEHL
33fc			 
33fc e5					push hl  ; u2 
33fd			 
33fd					; destroy value TOS 
33fd			 
33fd					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
33fd cd 90 1d			call macro_forth_dsp_pop 
3400				endm 
# End of macro FORTH_DSP_POP
3400			 
3400			 
3400					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3400 cd d8 1c			call macro_dsp_valuehl 
3403				endm 
# End of macro FORTH_DSP_VALUEHL
3403			 
3403 e5					push hl    ; u1 
3404			 
3404					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3404 cd 90 1d			call macro_forth_dsp_pop 
3407				endm 
# End of macro FORTH_DSP_POP
3407			 
3407			 
3407 b7			 or a      ;clear carry flag 
3408 01 00 00		 ld bc, FORTH_FALSE 
340b e1			  pop hl    ; u1 
340c d1			  pop de    ; u2 
340d ed 52		  sbc hl,de 
340f 38 03		  jr c,.gtcont   	;	if hl >= de, carry flag will be cleared 
3411			 
3411 01 01 00		 ld bc, FORTH_TRUE 
3414			.gtcont:  
3414 c5					push bc 
3415 e1					pop hl 
3416			 
3416					if DEBUG_FORTH_WORDS 
3416						DMARK "GT1" 
3416 f5				push af  
3417 3a 2b 34			ld a, (.dmark)  
341a 32 71 ee			ld (debug_mark),a  
341d 3a 2c 34			ld a, (.dmark+1)  
3420 32 72 ee			ld (debug_mark+1),a  
3423 3a 2d 34			ld a, (.dmark+2)  
3426 32 73 ee			ld (debug_mark+2),a  
3429 18 03			jr .pastdmark  
342b ..			.dmark: db "GT1"  
342e f1			.pastdmark: pop af  
342f			endm  
# End of macro DMARK
342f						CALLMONITOR 
342f cd 87 14			call break_point_state  
3432				endm  
# End of macro CALLMONITOR
3432					endif 
3432 cd e1 1a				call forth_push_numhl 
3435			 
3435					NEXTW 
3435 c3 4a 1e			jp macro_next 
3438				endm 
# End of macro NEXTW
3438			.EQUAL: 
3438				CWHEAD .ENDLOGIC 29 "=" 1 WORD_FLAG_CODE 
3438 31				db WORD_SYS_CORE+29             
3439 a3 34			dw .ENDLOGIC            
343b 02				db 1 + 1 
343c .. 00			db "=",0              
343e				endm 
# End of macro CWHEAD
343e			; | = ( u1 u2 -- f ) True if u1 equals u2 | DONE 
343e				; TODO add floating point number detection 
343e					if DEBUG_FORTH_WORDS_KEY 
343e						DMARK "EQ." 
343e f5				push af  
343f 3a 53 34			ld a, (.dmark)  
3442 32 71 ee			ld (debug_mark),a  
3445 3a 54 34			ld a, (.dmark+1)  
3448 32 72 ee			ld (debug_mark+1),a  
344b 3a 55 34			ld a, (.dmark+2)  
344e 32 73 ee			ld (debug_mark+2),a  
3451 18 03			jr .pastdmark  
3453 ..			.dmark: db "EQ."  
3456 f1			.pastdmark: pop af  
3457			endm  
# End of macro DMARK
3457						CALLMONITOR 
3457 cd 87 14			call break_point_state  
345a				endm  
# End of macro CALLMONITOR
345a					endif 
345a					FORTH_DSP 
345a cd 9e 1c			call macro_forth_dsp 
345d				endm 
# End of macro FORTH_DSP
345d					;v5 FORTH_DSP_VALUE 
345d 7e					ld a,(hl)	; get type of value on TOS 
345e fe 02				cp DS_TYPE_INUM  
3460 28 00				jr z, .eq_inum 
3462			 
3462				if FORTH_ENABLE_FLOATMATH 
3462					jr .eq_done 
3462			 
3462				endif 
3462					 
3462			 
3462			.eq_inum: 
3462					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3462 cd d8 1c			call macro_dsp_valuehl 
3465				endm 
# End of macro FORTH_DSP_VALUEHL
3465			 
3465 e5					push hl 
3466			 
3466					; destroy value TOS 
3466			 
3466					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3466 cd 90 1d			call macro_forth_dsp_pop 
3469				endm 
# End of macro FORTH_DSP_POP
3469			 
3469			 
3469					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3469 cd d8 1c			call macro_dsp_valuehl 
346c				endm 
# End of macro FORTH_DSP_VALUEHL
346c			 
346c					; one value on hl get other one back 
346c			 
346c e5					push hl 
346d			 
346d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
346d cd 90 1d			call macro_forth_dsp_pop 
3470				endm 
# End of macro FORTH_DSP_POP
3470			 
3470 0e 00				ld c, FORTH_FALSE 
3472			 
3472 e1					pop hl 
3473 d1					pop de 
3474			 
3474 7b					ld a, e 
3475 bd					cp l 
3476			 
3476 20 06				jr nz, .eq_done 
3478			 
3478 7a					ld a, d 
3479 bc					cp h 
347a			 
347a 20 02				jr nz, .eq_done 
347c			 
347c 0e 01				ld c, FORTH_TRUE 
347e					 
347e			 
347e			 
347e			.eq_done: 
347e			 
347e					; TODO push value back onto stack for another op etc 
347e			 
347e 26 00				ld h, 0 
3480 69					ld l, c 
3481					if DEBUG_FORTH_WORDS 
3481						DMARK "EQ1" 
3481 f5				push af  
3482 3a 96 34			ld a, (.dmark)  
3485 32 71 ee			ld (debug_mark),a  
3488 3a 97 34			ld a, (.dmark+1)  
348b 32 72 ee			ld (debug_mark+1),a  
348e 3a 98 34			ld a, (.dmark+2)  
3491 32 73 ee			ld (debug_mark+2),a  
3494 18 03			jr .pastdmark  
3496 ..			.dmark: db "EQ1"  
3499 f1			.pastdmark: pop af  
349a			endm  
# End of macro DMARK
349a						CALLMONITOR 
349a cd 87 14			call break_point_state  
349d				endm  
# End of macro CALLMONITOR
349d					endif 
349d cd e1 1a				call forth_push_numhl 
34a0			 
34a0					NEXTW 
34a0 c3 4a 1e			jp macro_next 
34a3				endm 
# End of macro NEXTW
34a3			 
34a3			 
34a3			.ENDLOGIC: 
34a3			; eof 
34a3			 
34a3			 
# End of file forth_words_logic.asm
34a3			include "forth_words_maths.asm" 
34a3			 
34a3			; | ## Maths Words 
34a3			 
34a3			.PLUS:	 
34a3				CWHEAD .NEG 1 "+" 1 WORD_FLAG_CODE 
34a3 15				db WORD_SYS_CORE+1             
34a4 e5 34			dw .NEG            
34a6 02				db 1 + 1 
34a7 .. 00			db "+",0              
34a9				endm 
# End of macro CWHEAD
34a9			; | + ( u u -- u )    Add two numbers and push result   | INT DONE 
34a9					if DEBUG_FORTH_WORDS_KEY 
34a9						DMARK "PLU" 
34a9 f5				push af  
34aa 3a be 34			ld a, (.dmark)  
34ad 32 71 ee			ld (debug_mark),a  
34b0 3a bf 34			ld a, (.dmark+1)  
34b3 32 72 ee			ld (debug_mark+1),a  
34b6 3a c0 34			ld a, (.dmark+2)  
34b9 32 73 ee			ld (debug_mark+2),a  
34bc 18 03			jr .pastdmark  
34be ..			.dmark: db "PLU"  
34c1 f1			.pastdmark: pop af  
34c2			endm  
# End of macro DMARK
34c2						CALLMONITOR 
34c2 cd 87 14			call break_point_state  
34c5				endm  
# End of macro CALLMONITOR
34c5					endif 
34c5					; add top two values and push back result 
34c5			 
34c5					;for v5 FORTH_DSP_VALUE 
34c5					FORTH_DSP 
34c5 cd 9e 1c			call macro_forth_dsp 
34c8				endm 
# End of macro FORTH_DSP
34c8 7e					ld a,(hl)	; get type of value on TOS 
34c9 fe 02				cp DS_TYPE_INUM  
34cb 28 03				jr z, .dot_inum 
34cd			 
34cd					NEXTW 
34cd c3 4a 1e			jp macro_next 
34d0				endm 
# End of macro NEXTW
34d0			 
34d0			; float maths 
34d0			 
34d0				if FORTH_ENABLE_FLOATMATH 
34d0						inc hl      ; now at start of numeric as string 
34d0			 
34d0					if DEBUG_FORTH_MATHS 
34d0						DMARK "ADD" 
34d0				CALLMONITOR 
34d0					endif 
34d0			 
34d0					;ld ix, hl 
34d0					call CON 
34d0			 
34d0			 
34d0					push hl 
34d0					 
34d0					 
34d0			 
34d0						FORTH_DSP_POP      ; TODO add stock underflow checks and throws  
34d0			 
34d0					; get next number 
34d0			 
34d0						FORTH_DSP_VALUE 
34d0			 
34d0						inc hl      ; now at start of numeric as string 
34d0			 
34d0					;ld ix, hl 
34d0					call CON 
34d0			 
34d0					push hl 
34d0			 
34d0			 
34d0						FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d0			 
34d0						; TODO do add 
34d0			 
34d0						call IADD 
34d0			 
34d0						; TODO get result back as ascii 
34d0			 
34d0						; TODO push result  
34d0			 
34d0			 
34d0			 
34d0						jr .dot_done 
34d0				endif 
34d0			 
34d0			.dot_inum: 
34d0			 
34d0			 
34d0					if DEBUG_FORTH_DOT 
34d0						DMARK "+IT" 
34d0				CALLMONITOR 
34d0					endif 
34d0			 
34d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d0 cd d8 1c			call macro_dsp_valuehl 
34d3				endm 
# End of macro FORTH_DSP_VALUEHL
34d3			 
34d3				; TODO add floating point number detection 
34d3			 
34d3 e5					push hl 
34d4			 
34d4					; destroy value TOS 
34d4			 
34d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34d4 cd 90 1d			call macro_forth_dsp_pop 
34d7				endm 
# End of macro FORTH_DSP_POP
34d7			 
34d7			 
34d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
34d7 cd d8 1c			call macro_dsp_valuehl 
34da				endm 
# End of macro FORTH_DSP_VALUEHL
34da			 
34da					; one value on hl get other one back 
34da			 
34da d1					pop de 
34db			 
34db					; do the add 
34db			 
34db 19					add hl,de 
34dc			 
34dc					; save it 
34dc			 
34dc			;		push hl	 
34dc			 
34dc					; 
34dc			 
34dc					; destroy value TOS 
34dc			 
34dc					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
34dc cd 90 1d			call macro_forth_dsp_pop 
34df				endm 
# End of macro FORTH_DSP_POP
34df			 
34df					; TODO push value back onto stack for another op etc 
34df			 
34df			;		pop hl 
34df			 
34df			.dot_done: 
34df cd e1 1a				call forth_push_numhl 
34e2			 
34e2					NEXTW 
34e2 c3 4a 1e			jp macro_next 
34e5				endm 
# End of macro NEXTW
34e5			.NEG: 
34e5			 
34e5				CWHEAD .DIV 3 "-" 1 WORD_FLAG_CODE 
34e5 17				db WORD_SYS_CORE+3             
34e6 28 35			dw .DIV            
34e8 02				db 1 + 1 
34e9 .. 00			db "-",0              
34eb				endm 
# End of macro CWHEAD
34eb			; | - ( u1 u2 -- u )    Subtract u2 from u1 and push result  | INT DONE 
34eb					if DEBUG_FORTH_WORDS_KEY 
34eb						DMARK "SUB" 
34eb f5				push af  
34ec 3a 00 35			ld a, (.dmark)  
34ef 32 71 ee			ld (debug_mark),a  
34f2 3a 01 35			ld a, (.dmark+1)  
34f5 32 72 ee			ld (debug_mark+1),a  
34f8 3a 02 35			ld a, (.dmark+2)  
34fb 32 73 ee			ld (debug_mark+2),a  
34fe 18 03			jr .pastdmark  
3500 ..			.dmark: db "SUB"  
3503 f1			.pastdmark: pop af  
3504			endm  
# End of macro DMARK
3504						CALLMONITOR 
3504 cd 87 14			call break_point_state  
3507				endm  
# End of macro CALLMONITOR
3507					endif 
3507			 
3507			 
3507				; TODO add floating point number detection 
3507					; v5 FORTH_DSP_VALUE 
3507					FORTH_DSP 
3507 cd 9e 1c			call macro_forth_dsp 
350a				endm 
# End of macro FORTH_DSP
350a 7e					ld a,(hl)	; get type of value on TOS 
350b fe 02				cp DS_TYPE_INUM  
350d 28 03				jr z, .neg_inum 
350f			 
350f					NEXTW 
350f c3 4a 1e			jp macro_next 
3512				endm 
# End of macro NEXTW
3512			 
3512			; float maths 
3512			 
3512				if FORTH_ENABLE_FLOATMATH 
3512					jr .neg_done 
3512			 
3512				endif 
3512					 
3512			 
3512			.neg_inum: 
3512					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3512 cd d8 1c			call macro_dsp_valuehl 
3515				endm 
# End of macro FORTH_DSP_VALUEHL
3515			 
3515 e5					push hl 
3516			 
3516					; destroy value TOS 
3516			 
3516					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3516 cd 90 1d			call macro_forth_dsp_pop 
3519				endm 
# End of macro FORTH_DSP_POP
3519			 
3519			 
3519					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3519 cd d8 1c			call macro_dsp_valuehl 
351c				endm 
# End of macro FORTH_DSP_VALUEHL
351c			 
351c					; one value on hl get other one back 
351c			 
351c d1					pop de 
351d			 
351d					; do the sub 
351d			;		ex de, hl 
351d			 
351d ed 52				sbc hl,de 
351f			 
351f					; save it 
351f			 
351f			;		push hl	 
351f			 
351f					; 
351f			 
351f					; destroy value TOS 
351f			 
351f					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
351f cd 90 1d			call macro_forth_dsp_pop 
3522				endm 
# End of macro FORTH_DSP_POP
3522			 
3522					; TODO push value back onto stack for another op etc 
3522			 
3522			;		pop hl 
3522			 
3522 cd e1 1a				call forth_push_numhl 
3525			.neg_done: 
3525			 
3525					NEXTW 
3525 c3 4a 1e			jp macro_next 
3528				endm 
# End of macro NEXTW
3528			.DIV: 
3528				CWHEAD .MUL 4 "/" 1 WORD_FLAG_CODE 
3528 18				db WORD_SYS_CORE+4             
3529 75 35			dw .MUL            
352b 02				db 1 + 1 
352c .. 00			db "/",0              
352e				endm 
# End of macro CWHEAD
352e			; | / ( u1 u2 -- result remainder )     Divide u1 by u2 and push result | INT DONE 
352e					if DEBUG_FORTH_WORDS_KEY 
352e						DMARK "DIV" 
352e f5				push af  
352f 3a 43 35			ld a, (.dmark)  
3532 32 71 ee			ld (debug_mark),a  
3535 3a 44 35			ld a, (.dmark+1)  
3538 32 72 ee			ld (debug_mark+1),a  
353b 3a 45 35			ld a, (.dmark+2)  
353e 32 73 ee			ld (debug_mark+2),a  
3541 18 03			jr .pastdmark  
3543 ..			.dmark: db "DIV"  
3546 f1			.pastdmark: pop af  
3547			endm  
# End of macro DMARK
3547						CALLMONITOR 
3547 cd 87 14			call break_point_state  
354a				endm  
# End of macro CALLMONITOR
354a					endif 
354a				; TODO add floating point number detection 
354a					; v5 FORTH_DSP_VALUE 
354a					FORTH_DSP 
354a cd 9e 1c			call macro_forth_dsp 
354d				endm 
# End of macro FORTH_DSP
354d 7e					ld a,(hl)	; get type of value on TOS 
354e fe 02				cp DS_TYPE_INUM  
3550 28 03				jr z, .div_inum 
3552			 
3552				if FORTH_ENABLE_FLOATMATH 
3552					jr .div_done 
3552			 
3552				endif 
3552					NEXTW 
3552 c3 4a 1e			jp macro_next 
3555				endm 
# End of macro NEXTW
3555			.div_inum: 
3555			 
3555					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3555 cd d8 1c			call macro_dsp_valuehl 
3558				endm 
# End of macro FORTH_DSP_VALUEHL
3558			 
3558 e5					push hl    ; to go to bc 
3559			 
3559					; destroy value TOS 
3559			 
3559					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3559 cd 90 1d			call macro_forth_dsp_pop 
355c				endm 
# End of macro FORTH_DSP_POP
355c			 
355c			 
355c					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
355c cd d8 1c			call macro_dsp_valuehl 
355f				endm 
# End of macro FORTH_DSP_VALUEHL
355f			 
355f					; hl to go to de 
355f			 
355f e5					push hl 
3560			 
3560 c1					pop bc 
3561 d1					pop de		 
3562			 
3562			 
3562					if DEBUG_FORTH_MATHS 
3562						DMARK "DIV" 
3562				CALLMONITOR 
3562					endif 
3562					; one value on hl but move to a get other one back 
3562			 
3562			        
3562 cd e3 0b			call Div16 
3565			 
3565			;	push af	 
3565 e5				push hl 
3566 c5				push bc 
3567			 
3567					if DEBUG_FORTH_MATHS 
3567						DMARK "DI1" 
3567				CALLMONITOR 
3567					endif 
3567			 
3567					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3567 cd 90 1d			call macro_forth_dsp_pop 
356a				endm 
# End of macro FORTH_DSP_POP
356a			 
356a			 
356a			 
356a e1					pop hl    ; result 
356b			 
356b cd e1 1a				call forth_push_numhl 
356e			 
356e e1					pop hl    ; reminder 
356f			;		ld h,0 
356f			;		ld l,d 
356f			 
356f cd e1 1a				call forth_push_numhl 
3572			.div_done: 
3572					NEXTW 
3572 c3 4a 1e			jp macro_next 
3575				endm 
# End of macro NEXTW
3575			.MUL: 
3575				CWHEAD .MIN 5 "*" 1 WORD_FLAG_CODE 
3575 19				db WORD_SYS_CORE+5             
3576 ba 35			dw .MIN            
3578 02				db 1 + 1 
3579 .. 00			db "*",0              
357b				endm 
# End of macro CWHEAD
357b			; | * ( u1 u2 -- u )     Multiply TOS and push result | INT DONE 
357b				; TODO add floating point number detection 
357b					if DEBUG_FORTH_WORDS_KEY 
357b						DMARK "MUL" 
357b f5				push af  
357c 3a 90 35			ld a, (.dmark)  
357f 32 71 ee			ld (debug_mark),a  
3582 3a 91 35			ld a, (.dmark+1)  
3585 32 72 ee			ld (debug_mark+1),a  
3588 3a 92 35			ld a, (.dmark+2)  
358b 32 73 ee			ld (debug_mark+2),a  
358e 18 03			jr .pastdmark  
3590 ..			.dmark: db "MUL"  
3593 f1			.pastdmark: pop af  
3594			endm  
# End of macro DMARK
3594						CALLMONITOR 
3594 cd 87 14			call break_point_state  
3597				endm  
# End of macro CALLMONITOR
3597					endif 
3597					FORTH_DSP 
3597 cd 9e 1c			call macro_forth_dsp 
359a				endm 
# End of macro FORTH_DSP
359a					; v5 FORTH_DSP_VALUE 
359a 7e					ld a,(hl)	; get type of value on TOS 
359b fe 02				cp DS_TYPE_INUM  
359d 28 03				jr z, .mul_inum 
359f			 
359f				if FORTH_ENABLE_FLOATMATH 
359f					jr .mul_done 
359f			 
359f				endif 
359f			 
359f					NEXTW 
359f c3 4a 1e			jp macro_next 
35a2				endm 
# End of macro NEXTW
35a2			.mul_inum:	 
35a2			 
35a2					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a2 cd d8 1c			call macro_dsp_valuehl 
35a5				endm 
# End of macro FORTH_DSP_VALUEHL
35a5			 
35a5 e5					push hl 
35a6			 
35a6					; destroy value TOS 
35a6			 
35a6					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35a6 cd 90 1d			call macro_forth_dsp_pop 
35a9				endm 
# End of macro FORTH_DSP_POP
35a9			 
35a9			 
35a9					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35a9 cd d8 1c			call macro_dsp_valuehl 
35ac				endm 
# End of macro FORTH_DSP_VALUEHL
35ac			 
35ac					; one value on hl but move to a get other one back 
35ac			 
35ac 7d					ld a, l 
35ad			 
35ad d1					pop de 
35ae			 
35ae					; do the mull 
35ae			;		ex de, hl 
35ae			 
35ae cd 09 0c				call Mult16 
35b1					; save it 
35b1			 
35b1			;		push hl	 
35b1			 
35b1					; 
35b1			 
35b1					; destroy value TOS 
35b1			 
35b1					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35b1 cd 90 1d			call macro_forth_dsp_pop 
35b4				endm 
# End of macro FORTH_DSP_POP
35b4			 
35b4					; TODO push value back onto stack for another op etc 
35b4			 
35b4			;		pop hl 
35b4			 
35b4 cd e1 1a				call forth_push_numhl 
35b7			 
35b7			.mul_done: 
35b7					NEXTW 
35b7 c3 4a 1e			jp macro_next 
35ba				endm 
# End of macro NEXTW
35ba			 
35ba			 
35ba			 
35ba			 
35ba			.MIN: 
35ba				CWHEAD .MAX 53 "MIN" 3 WORD_FLAG_CODE 
35ba 49				db WORD_SYS_CORE+53             
35bb 3b 36			dw .MAX            
35bd 04				db 3 + 1 
35be .. 00			db "MIN",0              
35c2				endm 
# End of macro CWHEAD
35c2			; | MIN (  u1 u2 -- u3 ) Whichever is the smallest value is pushed back onto the stack | DONE 
35c2					if DEBUG_FORTH_WORDS_KEY 
35c2						DMARK "MIN" 
35c2 f5				push af  
35c3 3a d7 35			ld a, (.dmark)  
35c6 32 71 ee			ld (debug_mark),a  
35c9 3a d8 35			ld a, (.dmark+1)  
35cc 32 72 ee			ld (debug_mark+1),a  
35cf 3a d9 35			ld a, (.dmark+2)  
35d2 32 73 ee			ld (debug_mark+2),a  
35d5 18 03			jr .pastdmark  
35d7 ..			.dmark: db "MIN"  
35da f1			.pastdmark: pop af  
35db			endm  
# End of macro DMARK
35db						CALLMONITOR 
35db cd 87 14			call break_point_state  
35de				endm  
# End of macro CALLMONITOR
35de					endif 
35de					; get u2 
35de			 
35de					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35de cd d8 1c			call macro_dsp_valuehl 
35e1				endm 
# End of macro FORTH_DSP_VALUEHL
35e1			 
35e1 e5					push hl   ; u2 
35e2			 
35e2					; destroy value TOS 
35e2			 
35e2					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e2 cd 90 1d			call macro_forth_dsp_pop 
35e5				endm 
# End of macro FORTH_DSP_POP
35e5			 
35e5					; get u1 
35e5			 
35e5					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
35e5 cd d8 1c			call macro_dsp_valuehl 
35e8				endm 
# End of macro FORTH_DSP_VALUEHL
35e8			 
35e8 e5					push hl  ; u1 
35e9			 
35e9					; destroy value TOS 
35e9			 
35e9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
35e9 cd 90 1d			call macro_forth_dsp_pop 
35ec				endm 
# End of macro FORTH_DSP_POP
35ec			 
35ec b7			 or a      ;clear carry flag 
35ed e1			  pop hl    ; u1 
35ee d1			  pop de    ; u2 
35ef e5				push hl   ; saved in case hl is lowest 
35f0 ed 52		  sbc hl,de 
35f2 30 23		  jr nc,.mincont   	;	if hl >= de, carry flag will be cleared 
35f4			 
35f4 e1				pop hl 
35f5					if DEBUG_FORTH_WORDS 
35f5						DMARK "MIN" 
35f5 f5				push af  
35f6 3a 0a 36			ld a, (.dmark)  
35f9 32 71 ee			ld (debug_mark),a  
35fc 3a 0b 36			ld a, (.dmark+1)  
35ff 32 72 ee			ld (debug_mark+1),a  
3602 3a 0c 36			ld a, (.dmark+2)  
3605 32 73 ee			ld (debug_mark+2),a  
3608 18 03			jr .pastdmark  
360a ..			.dmark: db "MIN"  
360d f1			.pastdmark: pop af  
360e			endm  
# End of macro DMARK
360e						CALLMONITOR 
360e cd 87 14			call break_point_state  
3611				endm  
# End of macro CALLMONITOR
3611					endif 
3611 cd e1 1a				call forth_push_numhl 
3614			 
3614				       NEXTW 
3614 c3 4a 1e			jp macro_next 
3617				endm 
# End of macro NEXTW
3617			 
3617			.mincont:  
3617 c1				pop bc   ; tidy up 
3618 eb				ex de , hl  
3619					if DEBUG_FORTH_WORDS 
3619						DMARK "MI1" 
3619 f5				push af  
361a 3a 2e 36			ld a, (.dmark)  
361d 32 71 ee			ld (debug_mark),a  
3620 3a 2f 36			ld a, (.dmark+1)  
3623 32 72 ee			ld (debug_mark+1),a  
3626 3a 30 36			ld a, (.dmark+2)  
3629 32 73 ee			ld (debug_mark+2),a  
362c 18 03			jr .pastdmark  
362e ..			.dmark: db "MI1"  
3631 f1			.pastdmark: pop af  
3632			endm  
# End of macro DMARK
3632						CALLMONITOR 
3632 cd 87 14			call break_point_state  
3635				endm  
# End of macro CALLMONITOR
3635					endif 
3635 cd e1 1a				call forth_push_numhl 
3638			 
3638				       NEXTW 
3638 c3 4a 1e			jp macro_next 
363b				endm 
# End of macro NEXTW
363b			.MAX: 
363b				CWHEAD .RND16 54 "MAX" 3 WORD_FLAG_CODE 
363b 4a				db WORD_SYS_CORE+54             
363c bc 36			dw .RND16            
363e 04				db 3 + 1 
363f .. 00			db "MAX",0              
3643				endm 
# End of macro CWHEAD
3643			; | MAX (  u1 u2 -- u3 )  Whichever is the largest value is pushed back onto the stack | DONE 
3643					if DEBUG_FORTH_WORDS_KEY 
3643						DMARK "MAX" 
3643 f5				push af  
3644 3a 58 36			ld a, (.dmark)  
3647 32 71 ee			ld (debug_mark),a  
364a 3a 59 36			ld a, (.dmark+1)  
364d 32 72 ee			ld (debug_mark+1),a  
3650 3a 5a 36			ld a, (.dmark+2)  
3653 32 73 ee			ld (debug_mark+2),a  
3656 18 03			jr .pastdmark  
3658 ..			.dmark: db "MAX"  
365b f1			.pastdmark: pop af  
365c			endm  
# End of macro DMARK
365c						CALLMONITOR 
365c cd 87 14			call break_point_state  
365f				endm  
# End of macro CALLMONITOR
365f					endif 
365f					; get u2 
365f			 
365f					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
365f cd d8 1c			call macro_dsp_valuehl 
3662				endm 
# End of macro FORTH_DSP_VALUEHL
3662			 
3662 e5					push hl   ; u2 
3663			 
3663					; destroy value TOS 
3663			 
3663					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3663 cd 90 1d			call macro_forth_dsp_pop 
3666				endm 
# End of macro FORTH_DSP_POP
3666			 
3666					; get u1 
3666			 
3666					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3666 cd d8 1c			call macro_dsp_valuehl 
3669				endm 
# End of macro FORTH_DSP_VALUEHL
3669			 
3669 e5					push hl  ; u1 
366a			 
366a					; destroy value TOS 
366a			 
366a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
366a cd 90 1d			call macro_forth_dsp_pop 
366d				endm 
# End of macro FORTH_DSP_POP
366d			 
366d b7			 or a      ;clear carry flag 
366e e1			  pop hl    ; u1 
366f d1			  pop de    ; u2 
3670 e5				push hl   ; saved in case hl is lowest 
3671 ed 52		  sbc hl,de 
3673 38 23		  jr c,.maxcont   	;	if hl <= de, carry flag will be cleared 
3675			 
3675 e1				pop hl 
3676					if DEBUG_FORTH_WORDS 
3676						DMARK "MAX" 
3676 f5				push af  
3677 3a 8b 36			ld a, (.dmark)  
367a 32 71 ee			ld (debug_mark),a  
367d 3a 8c 36			ld a, (.dmark+1)  
3680 32 72 ee			ld (debug_mark+1),a  
3683 3a 8d 36			ld a, (.dmark+2)  
3686 32 73 ee			ld (debug_mark+2),a  
3689 18 03			jr .pastdmark  
368b ..			.dmark: db "MAX"  
368e f1			.pastdmark: pop af  
368f			endm  
# End of macro DMARK
368f						CALLMONITOR 
368f cd 87 14			call break_point_state  
3692				endm  
# End of macro CALLMONITOR
3692					endif 
3692 cd e1 1a				call forth_push_numhl 
3695			 
3695				       NEXTW 
3695 c3 4a 1e			jp macro_next 
3698				endm 
# End of macro NEXTW
3698			 
3698			.maxcont:  
3698 c1				pop bc   ; tidy up 
3699 eb				ex de , hl  
369a					if DEBUG_FORTH_WORDS 
369a						DMARK "MA1" 
369a f5				push af  
369b 3a af 36			ld a, (.dmark)  
369e 32 71 ee			ld (debug_mark),a  
36a1 3a b0 36			ld a, (.dmark+1)  
36a4 32 72 ee			ld (debug_mark+1),a  
36a7 3a b1 36			ld a, (.dmark+2)  
36aa 32 73 ee			ld (debug_mark+2),a  
36ad 18 03			jr .pastdmark  
36af ..			.dmark: db "MA1"  
36b2 f1			.pastdmark: pop af  
36b3			endm  
# End of macro DMARK
36b3						CALLMONITOR 
36b3 cd 87 14			call break_point_state  
36b6				endm  
# End of macro CALLMONITOR
36b6					endif 
36b6 cd e1 1a				call forth_push_numhl 
36b9				       NEXTW 
36b9 c3 4a 1e			jp macro_next 
36bc				endm 
# End of macro NEXTW
36bc			 
36bc			.RND16: 
36bc				CWHEAD .RND8 58 "RND16" 5 WORD_FLAG_CODE 
36bc 4e				db WORD_SYS_CORE+58             
36bd eb 36			dw .RND8            
36bf 06				db 5 + 1 
36c0 .. 00			db "RND16",0              
36c6				endm 
# End of macro CWHEAD
36c6			; | RND16 (  -- n ) Generate a random 16bit number and push to stack | DONE 
36c6					if DEBUG_FORTH_WORDS_KEY 
36c6						DMARK "R16" 
36c6 f5				push af  
36c7 3a db 36			ld a, (.dmark)  
36ca 32 71 ee			ld (debug_mark),a  
36cd 3a dc 36			ld a, (.dmark+1)  
36d0 32 72 ee			ld (debug_mark+1),a  
36d3 3a dd 36			ld a, (.dmark+2)  
36d6 32 73 ee			ld (debug_mark+2),a  
36d9 18 03			jr .pastdmark  
36db ..			.dmark: db "R16"  
36de f1			.pastdmark: pop af  
36df			endm  
# End of macro DMARK
36df						CALLMONITOR 
36df cd 87 14			call break_point_state  
36e2				endm  
# End of macro CALLMONITOR
36e2					endif 
36e2 cd ad 0b				call prng16  
36e5 cd e1 1a				call forth_push_numhl 
36e8				       NEXTW 
36e8 c3 4a 1e			jp macro_next 
36eb				endm 
# End of macro NEXTW
36eb			.RND8: 
36eb				CWHEAD .RND 76 "RND8" 4 WORD_FLAG_CODE 
36eb 60				db WORD_SYS_CORE+76             
36ec 20 37			dw .RND            
36ee 05				db 4 + 1 
36ef .. 00			db "RND8",0              
36f4				endm 
# End of macro CWHEAD
36f4			; | RND8 (  -- n ) Generate a random 8bit number and push to stack | DONE 
36f4					if DEBUG_FORTH_WORDS_KEY 
36f4						DMARK "RN8" 
36f4 f5				push af  
36f5 3a 09 37			ld a, (.dmark)  
36f8 32 71 ee			ld (debug_mark),a  
36fb 3a 0a 37			ld a, (.dmark+1)  
36fe 32 72 ee			ld (debug_mark+1),a  
3701 3a 0b 37			ld a, (.dmark+2)  
3704 32 73 ee			ld (debug_mark+2),a  
3707 18 03			jr .pastdmark  
3709 ..			.dmark: db "RN8"  
370c f1			.pastdmark: pop af  
370d			endm  
# End of macro DMARK
370d						CALLMONITOR 
370d cd 87 14			call break_point_state  
3710				endm  
# End of macro CALLMONITOR
3710					endif 
3710 2a b2 eb				ld hl,(xrandc) 
3713 23					inc hl 
3714 cd c7 0b				call xrnd 
3717 6f					ld l,a	 
3718 26 00				ld h,0 
371a cd e1 1a				call forth_push_numhl 
371d				       NEXTW 
371d c3 4a 1e			jp macro_next 
3720				endm 
# End of macro NEXTW
3720			.RND: 
3720				CWHEAD .ENDMATHS 76 "RND" 3 WORD_FLAG_CODE 
3720 60				db WORD_SYS_CORE+76             
3721 26 38			dw .ENDMATHS            
3723 04				db 3 + 1 
3724 .. 00			db "RND",0              
3728				endm 
# End of macro CWHEAD
3728			; | RND ( u1 u2 -- u ) Generate a random number no lower than u1 and no higher than u2 and push to stack | DONE 
3728			 
3728					if DEBUG_FORTH_WORDS_KEY 
3728						DMARK "RND" 
3728 f5				push af  
3729 3a 3d 37			ld a, (.dmark)  
372c 32 71 ee			ld (debug_mark),a  
372f 3a 3e 37			ld a, (.dmark+1)  
3732 32 72 ee			ld (debug_mark+1),a  
3735 3a 3f 37			ld a, (.dmark+2)  
3738 32 73 ee			ld (debug_mark+2),a  
373b 18 03			jr .pastdmark  
373d ..			.dmark: db "RND"  
3740 f1			.pastdmark: pop af  
3741			endm  
# End of macro DMARK
3741						CALLMONITOR 
3741 cd 87 14			call break_point_state  
3744				endm  
# End of macro CALLMONITOR
3744					endif 
3744					 
3744					FORTH_DSP_VALUEHL    ; upper range 
3744 cd d8 1c			call macro_dsp_valuehl 
3747				endm 
# End of macro FORTH_DSP_VALUEHL
3747			 
3747 22 b6 eb				ld (LFSRSeed), hl	 
374a			 
374a					if DEBUG_FORTH_WORDS 
374a						DMARK "RN1" 
374a f5				push af  
374b 3a 5f 37			ld a, (.dmark)  
374e 32 71 ee			ld (debug_mark),a  
3751 3a 60 37			ld a, (.dmark+1)  
3754 32 72 ee			ld (debug_mark+1),a  
3757 3a 61 37			ld a, (.dmark+2)  
375a 32 73 ee			ld (debug_mark+2),a  
375d 18 03			jr .pastdmark  
375f ..			.dmark: db "RN1"  
3762 f1			.pastdmark: pop af  
3763			endm  
# End of macro DMARK
3763						CALLMONITOR 
3763 cd 87 14			call break_point_state  
3766				endm  
# End of macro CALLMONITOR
3766					endif 
3766					FORTH_DSP_POP 
3766 cd 90 1d			call macro_forth_dsp_pop 
3769				endm 
# End of macro FORTH_DSP_POP
3769			 
3769					FORTH_DSP_VALUEHL    ; low range 
3769 cd d8 1c			call macro_dsp_valuehl 
376c				endm 
# End of macro FORTH_DSP_VALUEHL
376c			 
376c					if DEBUG_FORTH_WORDS 
376c						DMARK "RN2" 
376c f5				push af  
376d 3a 81 37			ld a, (.dmark)  
3770 32 71 ee			ld (debug_mark),a  
3773 3a 82 37			ld a, (.dmark+1)  
3776 32 72 ee			ld (debug_mark+1),a  
3779 3a 83 37			ld a, (.dmark+2)  
377c 32 73 ee			ld (debug_mark+2),a  
377f 18 03			jr .pastdmark  
3781 ..			.dmark: db "RN2"  
3784 f1			.pastdmark: pop af  
3785			endm  
# End of macro DMARK
3785						CALLMONITOR 
3785 cd 87 14			call break_point_state  
3788				endm  
# End of macro CALLMONITOR
3788					endif 
3788 22 b8 eb				ld (LFSRSeed+2), hl 
378b			 
378b					FORTH_DSP_POP 
378b cd 90 1d			call macro_forth_dsp_pop 
378e				endm 
# End of macro FORTH_DSP_POP
378e			 
378e e5					push hl 
378f			 
378f e1			.inrange:	pop hl 
3790 cd ad 0b				call prng16  
3793					if DEBUG_FORTH_WORDS 
3793						DMARK "RN3" 
3793 f5				push af  
3794 3a a8 37			ld a, (.dmark)  
3797 32 71 ee			ld (debug_mark),a  
379a 3a a9 37			ld a, (.dmark+1)  
379d 32 72 ee			ld (debug_mark+1),a  
37a0 3a aa 37			ld a, (.dmark+2)  
37a3 32 73 ee			ld (debug_mark+2),a  
37a6 18 03			jr .pastdmark  
37a8 ..			.dmark: db "RN3"  
37ab f1			.pastdmark: pop af  
37ac			endm  
# End of macro DMARK
37ac						CALLMONITOR 
37ac cd 87 14			call break_point_state  
37af				endm  
# End of macro CALLMONITOR
37af					endif 
37af					 
37af					; if the range is 8bit knock out the high byte 
37af			 
37af ed 5b b6 eb			ld de, (LFSRSeed)     ; check high level 
37b3			 
37b3 3e 00				ld a, 0 
37b5 ba					cp d  
37b6 20 1e				jr nz, .hirange 
37b8 26 00				ld h, 0   ; knock it down to 8bit 
37ba			 
37ba					if DEBUG_FORTH_WORDS 
37ba						DMARK "RNk" 
37ba f5				push af  
37bb 3a cf 37			ld a, (.dmark)  
37be 32 71 ee			ld (debug_mark),a  
37c1 3a d0 37			ld a, (.dmark+1)  
37c4 32 72 ee			ld (debug_mark+1),a  
37c7 3a d1 37			ld a, (.dmark+2)  
37ca 32 73 ee			ld (debug_mark+2),a  
37cd 18 03			jr .pastdmark  
37cf ..			.dmark: db "RNk"  
37d2 f1			.pastdmark: pop af  
37d3			endm  
# End of macro DMARK
37d3						CALLMONITOR 
37d3 cd 87 14			call break_point_state  
37d6				endm  
# End of macro CALLMONITOR
37d6					endif 
37d6			.hirange:   
37d6 e5					push hl  
37d7 b7					or a  
37d8 ed 52		                sbc hl, de 
37da			 
37da					;call cmp16 
37da			 
37da 30 b3				jr nc, .inrange      ; if hl >= de, carry flag is cleared 
37dc e1					pop hl 
37dd e5					push hl 
37de			 
37de					if DEBUG_FORTH_WORDS 
37de						DMARK "RN4" 
37de f5				push af  
37df 3a f3 37			ld a, (.dmark)  
37e2 32 71 ee			ld (debug_mark),a  
37e5 3a f4 37			ld a, (.dmark+1)  
37e8 32 72 ee			ld (debug_mark+1),a  
37eb 3a f5 37			ld a, (.dmark+2)  
37ee 32 73 ee			ld (debug_mark+2),a  
37f1 18 03			jr .pastdmark  
37f3 ..			.dmark: db "RN4"  
37f6 f1			.pastdmark: pop af  
37f7			endm  
# End of macro DMARK
37f7						CALLMONITOR 
37f7 cd 87 14			call break_point_state  
37fa				endm  
# End of macro CALLMONITOR
37fa					endif 
37fa ed 5b b8 eb			ld de, (LFSRSeed+2)   ; check low range 
37fe					;call cmp16 
37fe				 
37fe b7					or a  
37ff ed 52		                sbc hl, de 
3801 38 8c				jr c, .inrange 
3803			 
3803 e1					pop hl 
3804					 
3804					if DEBUG_FORTH_WORDS 
3804						DMARK "RNd" 
3804 f5				push af  
3805 3a 19 38			ld a, (.dmark)  
3808 32 71 ee			ld (debug_mark),a  
380b 3a 1a 38			ld a, (.dmark+1)  
380e 32 72 ee			ld (debug_mark+1),a  
3811 3a 1b 38			ld a, (.dmark+2)  
3814 32 73 ee			ld (debug_mark+2),a  
3817 18 03			jr .pastdmark  
3819 ..			.dmark: db "RNd"  
381c f1			.pastdmark: pop af  
381d			endm  
# End of macro DMARK
381d						CALLMONITOR 
381d cd 87 14			call break_point_state  
3820				endm  
# End of macro CALLMONITOR
3820					endif 
3820			 
3820			 
3820 cd e1 1a				call forth_push_numhl 
3823				       NEXTW 
3823 c3 4a 1e			jp macro_next 
3826				endm 
# End of macro NEXTW
3826			 
3826			.ENDMATHS: 
3826			 
3826			; eof 
3826			 
# End of file forth_words_maths.asm
3826			include "forth_words_display.asm" 
3826			 
3826			; | ## Display Words 
3826			 
3826			.INFO: 
3826			 
3826				CWHEAD .ATP 78 "INFO" 4 WORD_FLAG_CODE 
3826 62				db WORD_SYS_CORE+78             
3827 43 38			dw .ATP            
3829 05				db 4 + 1 
382a .. 00			db "INFO",0              
382f				endm 
# End of macro CWHEAD
382f			; | INFO ( u1 u2 -- )  Use the top two strings on stack to fill in an info window over two lines. Causes a wait for key press to continue. | DONE 
382f					FORTH_DSP_VALUEHL 
382f cd d8 1c			call macro_dsp_valuehl 
3832				endm 
# End of macro FORTH_DSP_VALUEHL
3832			 
3832					FORTH_DSP_POP 
3832 cd 90 1d			call macro_forth_dsp_pop 
3835				endm 
# End of macro FORTH_DSP_POP
3835			 
3835 e5					push hl 
3836			 
3836					FORTH_DSP_VALUEHL 
3836 cd d8 1c			call macro_dsp_valuehl 
3839				endm 
# End of macro FORTH_DSP_VALUEHL
3839			 
3839					FORTH_DSP_POP 
3839 cd 90 1d			call macro_forth_dsp_pop 
383c				endm 
# End of macro FORTH_DSP_POP
383c			 
383c d1					pop de 
383d			 
383d cd ea 09				call info_panel 
3840			 
3840			 
3840					NEXTW 
3840 c3 4a 1e			jp macro_next 
3843				endm 
# End of macro NEXTW
3843			.ATP: 
3843				CWHEAD .FB 78 "AT?" 3 WORD_FLAG_CODE 
3843 62				db WORD_SYS_CORE+78             
3844 ba 38			dw .FB            
3846 04				db 3 + 1 
3847 .. 00			db "AT?",0              
384b				endm 
# End of macro CWHEAD
384b			; | AT? ( -- c r )  Push to stack the current position of the next print | TO TEST 
384b					if DEBUG_FORTH_WORDS_KEY 
384b						DMARK "AT?" 
384b f5				push af  
384c 3a 60 38			ld a, (.dmark)  
384f 32 71 ee			ld (debug_mark),a  
3852 3a 61 38			ld a, (.dmark+1)  
3855 32 72 ee			ld (debug_mark+1),a  
3858 3a 62 38			ld a, (.dmark+2)  
385b 32 73 ee			ld (debug_mark+2),a  
385e 18 03			jr .pastdmark  
3860 ..			.dmark: db "AT?"  
3863 f1			.pastdmark: pop af  
3864			endm  
# End of macro DMARK
3864						CALLMONITOR 
3864 cd 87 14			call break_point_state  
3867				endm  
# End of macro CALLMONITOR
3867					endif 
3867 3a 40 eb				ld a, (f_cursor_ptr) 
386a			 
386a			if DEBUG_FORTH_WORDS 
386a				DMARK "AT?" 
386a f5				push af  
386b 3a 7f 38			ld a, (.dmark)  
386e 32 71 ee			ld (debug_mark),a  
3871 3a 80 38			ld a, (.dmark+1)  
3874 32 72 ee			ld (debug_mark+1),a  
3877 3a 81 38			ld a, (.dmark+2)  
387a 32 73 ee			ld (debug_mark+2),a  
387d 18 03			jr .pastdmark  
387f ..			.dmark: db "AT?"  
3882 f1			.pastdmark: pop af  
3883			endm  
# End of macro DMARK
3883				CALLMONITOR 
3883 cd 87 14			call break_point_state  
3886				endm  
# End of macro CALLMONITOR
3886			endif	 
3886					; count the number of rows 
3886			 
3886 06 00				ld b, 0 
3888 4f			.atpr:		ld c, a    ; save in case we go below zero 
3889 d6 28				sub display_cols 
388b f2 91 38				jp p, .atprunder 
388e 04					inc b 
388f 18 f7				jr .atpr 
3891			.atprunder:	 
3891			if DEBUG_FORTH_WORDS 
3891				DMARK "A?2" 
3891 f5				push af  
3892 3a a6 38			ld a, (.dmark)  
3895 32 71 ee			ld (debug_mark),a  
3898 3a a7 38			ld a, (.dmark+1)  
389b 32 72 ee			ld (debug_mark+1),a  
389e 3a a8 38			ld a, (.dmark+2)  
38a1 32 73 ee			ld (debug_mark+2),a  
38a4 18 03			jr .pastdmark  
38a6 ..			.dmark: db "A?2"  
38a9 f1			.pastdmark: pop af  
38aa			endm  
# End of macro DMARK
38aa				CALLMONITOR 
38aa cd 87 14			call break_point_state  
38ad				endm  
# End of macro CALLMONITOR
38ad			endif	 
38ad 26 00				ld h, 0 
38af 69					ld l, c 
38b0 cd e1 1a				call forth_push_numhl 
38b3 68					ld l, b  
38b4 cd e1 1a				call forth_push_numhl 
38b7			 
38b7			 
38b7				NEXTW 
38b7 c3 4a 1e			jp macro_next 
38ba				endm 
# End of macro NEXTW
38ba			 
38ba			.FB: 
38ba				CWHEAD .EMIT 7 "FB" 2 WORD_FLAG_CODE 
38ba 1b				db WORD_SYS_CORE+7             
38bb 08 39			dw .EMIT            
38bd 03				db 2 + 1 
38be .. 00			db "FB",0              
38c1				endm 
# End of macro CWHEAD
38c1			; | FB ( u -- ) Select frame buffer ID u (1-3)  |  DONE 
38c1			; | | Default frame buffer is 1. System uses 0 which can't be selected for system messages etc. 
38c1			; | | Selecting the frame buffer wont display unless automatic display is setup (default). 
38c1			; | | If automatic display is off then updates will not be shown until DRAW is used. 
38c1					if DEBUG_FORTH_WORDS_KEY 
38c1						DMARK "FB." 
38c1 f5				push af  
38c2 3a d6 38			ld a, (.dmark)  
38c5 32 71 ee			ld (debug_mark),a  
38c8 3a d7 38			ld a, (.dmark+1)  
38cb 32 72 ee			ld (debug_mark+1),a  
38ce 3a d8 38			ld a, (.dmark+2)  
38d1 32 73 ee			ld (debug_mark+2),a  
38d4 18 03			jr .pastdmark  
38d6 ..			.dmark: db "FB."  
38d9 f1			.pastdmark: pop af  
38da			endm  
# End of macro DMARK
38da						CALLMONITOR 
38da cd 87 14			call break_point_state  
38dd				endm  
# End of macro CALLMONITOR
38dd					endif 
38dd			 
38dd					FORTH_DSP_VALUEHL 
38dd cd d8 1c			call macro_dsp_valuehl 
38e0				endm 
# End of macro FORTH_DSP_VALUEHL
38e0			 
38e0 7d					ld a, l 
38e1 fe 01				cp 1 
38e3 20 05				jr nz, .fbn1 
38e5 21 16 ed				ld hl, display_fb1 
38e8 18 15				jr .fbset 
38ea fe 02		.fbn1:		cp 2 
38ec 20 05				jr nz, .fbn2 
38ee 21 d4 eb				ld hl, display_fb2 
38f1 18 0c				jr .fbset 
38f3 fe 03		.fbn2:		cp 3 
38f5 20 05				jr nz, .fbn3 
38f7 21 75 ec				ld hl, display_fb3 
38fa 18 03				jr .fbset 
38fc			.fbn3:		 ; if invalid number select first 
38fc 21 16 ed				ld hl, display_fb1 
38ff 22 d2 eb		.fbset:		ld (display_fb_active), hl 
3902			 
3902					FORTH_DSP_POP 
3902 cd 90 1d			call macro_forth_dsp_pop 
3905				endm 
# End of macro FORTH_DSP_POP
3905			 
3905					NEXTW 
3905 c3 4a 1e			jp macro_next 
3908				endm 
# End of macro NEXTW
3908			 
3908			 
3908			.EMIT: 
3908				CWHEAD .DOTH 7 "EMIT" 4 WORD_FLAG_CODE 
3908 1b				db WORD_SYS_CORE+7             
3909 59 39			dw .DOTH            
390b 05				db 4 + 1 
390c .. 00			db "EMIT",0              
3911				endm 
# End of macro CWHEAD
3911			; |  EMIT ( u -- ) Display ascii character  TOS   | DONE 
3911					; get value off TOS and display it 
3911			 
3911					if DEBUG_FORTH_WORDS_KEY 
3911						DMARK "EMT" 
3911 f5				push af  
3912 3a 26 39			ld a, (.dmark)  
3915 32 71 ee			ld (debug_mark),a  
3918 3a 27 39			ld a, (.dmark+1)  
391b 32 72 ee			ld (debug_mark+1),a  
391e 3a 28 39			ld a, (.dmark+2)  
3921 32 73 ee			ld (debug_mark+2),a  
3924 18 03			jr .pastdmark  
3926 ..			.dmark: db "EMT"  
3929 f1			.pastdmark: pop af  
392a			endm  
# End of macro DMARK
392a						CALLMONITOR 
392a cd 87 14			call break_point_state  
392d				endm  
# End of macro CALLMONITOR
392d					endif 
392d			 
392d					FORTH_DSP_VALUEHL 
392d cd d8 1c			call macro_dsp_valuehl 
3930				endm 
# End of macro FORTH_DSP_VALUEHL
3930			 
3930 7d					ld a,l 
3931			 
3931					; TODO write to display 
3931			 
3931 32 d5 e5				ld (os_input), a 
3934 3e 00				ld a, 0 
3936 32 d6 e5				ld (os_input+1), a 
3939					 
3939 3a 40 eb				ld a, (f_cursor_ptr) 
393c 11 d5 e5				ld de, os_input 
393f cd 6c 0a				call str_at_display 
3942			 
3942			 
3942 3a 1e eb				ld a,(cli_autodisplay) 
3945 fe 00				cp 0 
3947 28 03				jr z, .enoupdate 
3949 cd 7c 0a						call update_display 
394c					.enoupdate: 
394c			 
394c 3a 40 eb				ld a, (f_cursor_ptr) 
394f 3c					inc a 
3950 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
3953			 
3953			 
3953					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3953 cd 90 1d			call macro_forth_dsp_pop 
3956				endm 
# End of macro FORTH_DSP_POP
3956			  
3956			 
3956					NEXTW 
3956 c3 4a 1e			jp macro_next 
3959				endm 
# End of macro NEXTW
3959			.DOTH: 
3959				CWHEAD .DOTF 8 ".-" 2 WORD_FLAG_CODE 
3959 1c				db WORD_SYS_CORE+8             
395a 89 39			dw .DOTF            
395c 03				db 2 + 1 
395d .. 00			db ".-",0              
3960				endm 
# End of macro CWHEAD
3960			        ; | .- ( u -- ) Display TOS replacing any dashes with spaces. Means you dont need to wrap strings in double quotes!   | DONE 
3960					; get value off TOS and display it 
3960					if DEBUG_FORTH_WORDS_KEY 
3960						DMARK "DTD" 
3960 f5				push af  
3961 3a 75 39			ld a, (.dmark)  
3964 32 71 ee			ld (debug_mark),a  
3967 3a 76 39			ld a, (.dmark+1)  
396a 32 72 ee			ld (debug_mark+1),a  
396d 3a 77 39			ld a, (.dmark+2)  
3970 32 73 ee			ld (debug_mark+2),a  
3973 18 03			jr .pastdmark  
3975 ..			.dmark: db "DTD"  
3978 f1			.pastdmark: pop af  
3979			endm  
# End of macro DMARK
3979						CALLMONITOR 
3979 cd 87 14			call break_point_state  
397c				endm  
# End of macro CALLMONITOR
397c					endif 
397c 0e 01			ld c, 1	  ; flag for removal of '-' enabled 
397e 3e 00			ld a, 0 
3980 32 1f eb			ld (cli_mvdot), a 
3983 c3 e0 39			jp .dotgo 
3986				NEXTW 
3986 c3 4a 1e			jp macro_next 
3989				endm 
# End of macro NEXTW
3989			.DOTF: 
3989				CWHEAD .DOT 8 ".>" 2 WORD_FLAG_CODE 
3989 1c				db WORD_SYS_CORE+8             
398a b7 39			dw .DOT            
398c 03				db 2 + 1 
398d .. 00			db ".>",0              
3990				endm 
# End of macro CWHEAD
3990			        ; | .> ( u -- ) Display TOS and move the next display point with display  | WIP 
3990					; get value off TOS and display it 
3990			        ; TODO BUG adds extra spaces 
3990			        ; TODO BUG handle numerics? 
3990					if DEBUG_FORTH_WORDS_KEY 
3990						DMARK "DTC" 
3990 f5				push af  
3991 3a a5 39			ld a, (.dmark)  
3994 32 71 ee			ld (debug_mark),a  
3997 3a a6 39			ld a, (.dmark+1)  
399a 32 72 ee			ld (debug_mark+1),a  
399d 3a a7 39			ld a, (.dmark+2)  
39a0 32 73 ee			ld (debug_mark+2),a  
39a3 18 03			jr .pastdmark  
39a5 ..			.dmark: db "DTC"  
39a8 f1			.pastdmark: pop af  
39a9			endm  
# End of macro DMARK
39a9						CALLMONITOR 
39a9 cd 87 14			call break_point_state  
39ac				endm  
# End of macro CALLMONITOR
39ac					endif 
39ac 3e 01			ld a, 1 
39ae 32 1f eb			ld (cli_mvdot), a 
39b1 c3 e0 39			jp .dotgo 
39b4				NEXTW 
39b4 c3 4a 1e			jp macro_next 
39b7				endm 
# End of macro NEXTW
39b7			 
39b7			.DOT: 
39b7				CWHEAD .CLS 8 "." 1 WORD_FLAG_CODE 
39b7 1c				db WORD_SYS_CORE+8             
39b8 43 3a			dw .CLS            
39ba 02				db 1 + 1 
39bb .. 00			db ".",0              
39bd				endm 
# End of macro CWHEAD
39bd			        ; | . ( u -- ) Display TOS | DONE 
39bd					; get value off TOS and display it 
39bd			 
39bd					if DEBUG_FORTH_WORDS_KEY 
39bd						DMARK "DOT" 
39bd f5				push af  
39be 3a d2 39			ld a, (.dmark)  
39c1 32 71 ee			ld (debug_mark),a  
39c4 3a d3 39			ld a, (.dmark+1)  
39c7 32 72 ee			ld (debug_mark+1),a  
39ca 3a d4 39			ld a, (.dmark+2)  
39cd 32 73 ee			ld (debug_mark+2),a  
39d0 18 03			jr .pastdmark  
39d2 ..			.dmark: db "DOT"  
39d5 f1			.pastdmark: pop af  
39d6			endm  
# End of macro DMARK
39d6						CALLMONITOR 
39d6 cd 87 14			call break_point_state  
39d9				endm  
# End of macro CALLMONITOR
39d9					endif 
39d9 3e 00			ld a, 0 
39db 32 1f eb			ld (cli_mvdot), a 
39de 0e 00		ld c, 0	  ; flag for removal of '-' disabled 
39e0				 
39e0			 
39e0			.dotgo: 
39e0			 
39e0			; move up type to on stack for parserv5 
39e0					FORTH_DSP 
39e0 cd 9e 1c			call macro_forth_dsp 
39e3				endm 
# End of macro FORTH_DSP
39e3				;FORTH_DSP_VALUE  
39e3			 
39e3			if DEBUG_FORTH_DOT 
39e3				DMARK "DOT" 
39e3				CALLMONITOR 
39e3			endif	 
39e3			;		.print: 
39e3			 
39e3 7e				ld a,(hl)  ; work out what type of value is on the TOS 
39e4 23				inc hl   ; position to the actual value 
39e5 fe 01			cp DS_TYPE_STR 
39e7 20 06			jr nz, .dotnum1  
39e9			 
39e9			; display string 
39e9				FORTH_DSP_VALUE  
39e9 cd c1 1c			call macro_forth_dsp_value 
39ec				endm 
# End of macro FORTH_DSP_VALUE
39ec eb				ex de,hl 
39ed 18 11			jr .dotwrite 
39ef			 
39ef			.dotnum1: 
39ef fe 02			cp DS_TYPE_INUM 
39f1 20 0c			jr nz, .dotflot 
39f3			 
39f3			 
39f3			; display number 
39f3			 
39f3			;	push hl 
39f3			;	call clear_display 
39f3			;	pop hl 
39f3			 
39f3 5e				ld e, (hl) 
39f4 23				inc hl 
39f5 56				ld d, (hl) 
39f6 21 d7 e3			ld hl, scratch 
39f9			if DEBUG_FORTH_DOT 
39f9				DMARK "DT1" 
39f9				CALLMONITOR 
39f9			endif	 
39f9			 
39f9 cd 93 10			call uitoa_16 
39fc eb				ex de,hl 
39fd			 
39fd			if DEBUG_FORTH_DOT 
39fd				DMARK "DT2" 
39fd				CALLMONITOR 
39fd			endif	 
39fd			 
39fd			;	ld de, os_word_scratch 
39fd 18 01			jr .dotwrite 
39ff			 
39ff 00			.dotflot:   nop 
3a00			; TODO print floating point number 
3a00			 
3a00			.dotwrite:		 
3a00			 
3a00					; if c is set then set all '-' to spaces 
3a00					; need to also take into account .>  
3a00			 
3a00 3e 01				ld a, 1 
3a02 b9					cp c 
3a03 20 13				jr nz, .nodashswap 
3a05			 
3a05					; DE has the string to write, working with HL 
3a05			 
3a05 06 ff				ld b, 255 
3a07 d5					push de 
3a08 e1					pop hl 
3a09			 
3a09			if DEBUG_FORTH_DOT 
3a09				DMARK "DT-" 
3a09				CALLMONITOR 
3a09			endif	 
3a09 7e			.dashscan:	ld a, (hl) 
3a0a fe 00				cp 0 
3a0c 28 0a				jr z, .nodashswap 
3a0e fe 2d				cp '-' 
3a10 20 03				jr nz, .dashskip 
3a12 3e 20				ld a, ' ' 
3a14 77					ld (hl), a 
3a15 23			.dashskip:	inc hl 
3a16			if DEBUG_FORTH_DOT 
3a16				DMARK "D-2" 
3a16				CALLMONITOR 
3a16			endif	 
3a16 10 f1				djnz .dashscan 
3a18			 
3a18			if DEBUG_FORTH_DOT 
3a18				DMARK "D-1" 
3a18				CALLMONITOR 
3a18			endif	 
3a18			 
3a18			.nodashswap: 
3a18			 
3a18 e5					push hl   ; save string start in case we need to advance print 
3a19			 
3a19 3a 40 eb				ld a, (f_cursor_ptr) 
3a1c cd 6c 0a				call str_at_display 
3a1f 3a 1e eb				ld a,(cli_autodisplay) 
3a22 fe 00				cp 0 
3a24 28 03				jr z, .noupdate 
3a26 cd 7c 0a						call update_display 
3a29					.noupdate: 
3a29			 
3a29			 
3a29					; see if we need to advance the print position 
3a29			 
3a29 e1					pop hl   ; get back string 
3a2a			 
3a2a 3a 1f eb				ld a, (cli_mvdot) 
3a2d			if DEBUG_FORTH_DOT 
3a2d					ld e,a 
3a2d				DMARK "D>1" 
3a2d				CALLMONITOR 
3a2d			endif	 
3a2d fe 00				cp 0 
3a2f 28 0c				jr z, .noadv 
3a31					; yes, lets advance the print position 
3a31 3e 00				ld a, 0 
3a33 cd ef 10				call strlent 
3a36 3a 40 eb				ld a, (f_cursor_ptr) 
3a39 85					add a,l 
3a3a					;call addatohl 
3a3a					;ld a, l 
3a3a 32 40 eb				ld (f_cursor_ptr), a   ; save new pos 
3a3d			 
3a3d			if DEBUG_FORTH_DOT 
3a3d				DMARK "D->" 
3a3d				CALLMONITOR 
3a3d			endif	 
3a3d			 
3a3d			.noadv:	 
3a3d			 
3a3d					if DEBUG_FORTH_DOT_WAIT 
3a3d							call next_page_prompt 
3a3d					endif	 
3a3d			; TODO this pop off the stack causes a crash. i dont know why 
3a3d			 
3a3d			 
3a3d			if DEBUG_FORTH_DOT 
3a3d				DMARK "DTh" 
3a3d				CALLMONITOR 
3a3d			endif	 
3a3d			 
3a3d					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3a3d cd 90 1d			call macro_forth_dsp_pop 
3a40				endm 
# End of macro FORTH_DSP_POP
3a40			 
3a40			if DEBUG_FORTH_DOT 
3a40				DMARK "DTi" 
3a40				CALLMONITOR 
3a40			endif	 
3a40			 
3a40			 
3a40					NEXTW 
3a40 c3 4a 1e			jp macro_next 
3a43				endm 
# End of macro NEXTW
3a43			 
3a43			.CLS: 
3a43				CWHEAD .DRAW 33 "CLS" 3 WORD_FLAG_CODE 
3a43 35				db WORD_SYS_CORE+33             
3a44 70 3a			dw .DRAW            
3a46 04				db 3 + 1 
3a47 .. 00			db "CLS",0              
3a4b				endm 
# End of macro CWHEAD
3a4b			; | CLS ( -- ) Clear current frame buffer and set next print position to top left corner  | DONE 
3a4b					if DEBUG_FORTH_WORDS_KEY 
3a4b						DMARK "CLS" 
3a4b f5				push af  
3a4c 3a 60 3a			ld a, (.dmark)  
3a4f 32 71 ee			ld (debug_mark),a  
3a52 3a 61 3a			ld a, (.dmark+1)  
3a55 32 72 ee			ld (debug_mark+1),a  
3a58 3a 62 3a			ld a, (.dmark+2)  
3a5b 32 73 ee			ld (debug_mark+2),a  
3a5e 18 03			jr .pastdmark  
3a60 ..			.dmark: db "CLS"  
3a63 f1			.pastdmark: pop af  
3a64			endm  
# End of macro DMARK
3a64						CALLMONITOR 
3a64 cd 87 14			call break_point_state  
3a67				endm  
# End of macro CALLMONITOR
3a67					endif 
3a67 cd 59 0a				call clear_display 
3a6a c3 7e 3b				jp .home		; and home cursor 
3a6d					NEXTW 
3a6d c3 4a 1e			jp macro_next 
3a70				endm 
# End of macro NEXTW
3a70			 
3a70			.DRAW: 
3a70				CWHEAD .DUMP 34 "DRAW" 4 WORD_FLAG_CODE 
3a70 36				db WORD_SYS_CORE+34             
3a71 9b 3a			dw .DUMP            
3a73 05				db 4 + 1 
3a74 .. 00			db "DRAW",0              
3a79				endm 
# End of macro CWHEAD
3a79			; | DRAW ( -- ) Draw contents of current frame buffer  | DONE 
3a79					if DEBUG_FORTH_WORDS_KEY 
3a79						DMARK "DRW" 
3a79 f5				push af  
3a7a 3a 8e 3a			ld a, (.dmark)  
3a7d 32 71 ee			ld (debug_mark),a  
3a80 3a 8f 3a			ld a, (.dmark+1)  
3a83 32 72 ee			ld (debug_mark+1),a  
3a86 3a 90 3a			ld a, (.dmark+2)  
3a89 32 73 ee			ld (debug_mark+2),a  
3a8c 18 03			jr .pastdmark  
3a8e ..			.dmark: db "DRW"  
3a91 f1			.pastdmark: pop af  
3a92			endm  
# End of macro DMARK
3a92						CALLMONITOR 
3a92 cd 87 14			call break_point_state  
3a95				endm  
# End of macro CALLMONITOR
3a95					endif 
3a95 cd 7c 0a				call update_display 
3a98					NEXTW 
3a98 c3 4a 1e			jp macro_next 
3a9b				endm 
# End of macro NEXTW
3a9b			 
3a9b			.DUMP: 
3a9b				CWHEAD .CDUMP 35 "DUMP" 4 WORD_FLAG_CODE 
3a9b 37				db WORD_SYS_CORE+35             
3a9c d3 3a			dw .CDUMP            
3a9e 05				db 4 + 1 
3a9f .. 00			db "DUMP",0              
3aa4				endm 
# End of macro CWHEAD
3aa4			; | DUMP ( x -- ) With address x display dump   | DONE 
3aa4			; TODO pop address to use off of the stack 
3aa4					if DEBUG_FORTH_WORDS_KEY 
3aa4						DMARK "DUM" 
3aa4 f5				push af  
3aa5 3a b9 3a			ld a, (.dmark)  
3aa8 32 71 ee			ld (debug_mark),a  
3aab 3a ba 3a			ld a, (.dmark+1)  
3aae 32 72 ee			ld (debug_mark+1),a  
3ab1 3a bb 3a			ld a, (.dmark+2)  
3ab4 32 73 ee			ld (debug_mark+2),a  
3ab7 18 03			jr .pastdmark  
3ab9 ..			.dmark: db "DUM"  
3abc f1			.pastdmark: pop af  
3abd			endm  
# End of macro DMARK
3abd						CALLMONITOR 
3abd cd 87 14			call break_point_state  
3ac0				endm  
# End of macro CALLMONITOR
3ac0					endif 
3ac0 cd 59 0a				call clear_display 
3ac3			 
3ac3					; get address 
3ac3			 
3ac3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3ac3 cd d8 1c			call macro_dsp_valuehl 
3ac6				endm 
# End of macro FORTH_DSP_VALUEHL
3ac6				 
3ac6					; save it for cdump 
3ac6			 
3ac6 22 fa e6				ld (os_cur_ptr),hl 
3ac9			 
3ac9					; destroy value TOS 
3ac9			 
3ac9					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3ac9 cd 90 1d			call macro_forth_dsp_pop 
3acc				endm 
# End of macro FORTH_DSP_POP
3acc			 
3acc cd 61 19				call dumpcont	; skip old style of param parsing	 
3acf c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP $8000 DUMP 
3ad0					NEXTW 
3ad0 c3 4a 1e			jp macro_next 
3ad3				endm 
# End of macro NEXTW
3ad3			.CDUMP: 
3ad3				CWHEAD .DAT 36 "CDUMP" 5 WORD_FLAG_CODE 
3ad3 38				db WORD_SYS_CORE+36             
3ad4 03 3b			dw .DAT            
3ad6 06				db 5 + 1 
3ad7 .. 00			db "CDUMP",0              
3add				endm 
# End of macro CWHEAD
3add			; | CDUMP ( -- ) Continue dump of memory from DUMP | DONE 
3add					if DEBUG_FORTH_WORDS_KEY 
3add						DMARK "CDP" 
3add f5				push af  
3ade 3a f2 3a			ld a, (.dmark)  
3ae1 32 71 ee			ld (debug_mark),a  
3ae4 3a f3 3a			ld a, (.dmark+1)  
3ae7 32 72 ee			ld (debug_mark+1),a  
3aea 3a f4 3a			ld a, (.dmark+2)  
3aed 32 73 ee			ld (debug_mark+2),a  
3af0 18 03			jr .pastdmark  
3af2 ..			.dmark: db "CDP"  
3af5 f1			.pastdmark: pop af  
3af6			endm  
# End of macro DMARK
3af6						CALLMONITOR 
3af6 cd 87 14			call break_point_state  
3af9				endm  
# End of macro CALLMONITOR
3af9					endif 
3af9 cd 59 0a				call clear_display 
3afc cd 61 19				call dumpcont	 
3aff c9					ret			; TODO command causes end of remaining parsing so cant do: $0000 DUMP CDUMP $8000 DUMP 
3b00					NEXTW 
3b00 c3 4a 1e			jp macro_next 
3b03				endm 
# End of macro NEXTW
3b03			 
3b03			 
3b03			 
3b03			 
3b03			.DAT: 
3b03				CWHEAD .HOME 41 "AT" 2 WORD_FLAG_CODE 
3b03 3d				db WORD_SYS_CORE+41             
3b04 59 3b			dw .HOME            
3b06 03				db 2 + 1 
3b07 .. 00			db "AT",0              
3b0a				endm 
# End of macro CWHEAD
3b0a			; | AT ( u1 u2 -- ) Set next output via . or emit at row u2 col u1 | DONE 
3b0a					if DEBUG_FORTH_WORDS_KEY 
3b0a						DMARK "AT." 
3b0a f5				push af  
3b0b 3a 1f 3b			ld a, (.dmark)  
3b0e 32 71 ee			ld (debug_mark),a  
3b11 3a 20 3b			ld a, (.dmark+1)  
3b14 32 72 ee			ld (debug_mark+1),a  
3b17 3a 21 3b			ld a, (.dmark+2)  
3b1a 32 73 ee			ld (debug_mark+2),a  
3b1d 18 03			jr .pastdmark  
3b1f ..			.dmark: db "AT."  
3b22 f1			.pastdmark: pop af  
3b23			endm  
# End of macro DMARK
3b23						CALLMONITOR 
3b23 cd 87 14			call break_point_state  
3b26				endm  
# End of macro CALLMONITOR
3b26					endif 
3b26					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b26 cd d8 1c			call macro_dsp_valuehl 
3b29				endm 
# End of macro FORTH_DSP_VALUEHL
3b29			 
3b29			 
3b29					; TODO save cursor row 
3b29 7d					ld a,l 
3b2a fe 02				cp 2 
3b2c 20 04				jr nz, .crow3 
3b2e 3e 28				ld a, display_row_2 
3b30 18 12				jr .ccol1 
3b32 fe 03		.crow3:		cp 3 
3b34 20 04				jr nz, .crow4 
3b36 3e 50				ld a, display_row_3 
3b38 18 0a				jr .ccol1 
3b3a fe 04		.crow4:		cp 4 
3b3c 20 04				jr nz, .crow1 
3b3e 3e 78				ld a, display_row_4 
3b40 18 02				jr .ccol1 
3b42 3e 00		.crow1:		ld a,display_row_1 
3b44 f5			.ccol1:		push af			; got row offset 
3b45 6f					ld l,a 
3b46 26 00				ld h,0 
3b48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b48 cd 90 1d			call macro_forth_dsp_pop 
3b4b				endm 
# End of macro FORTH_DSP_POP
3b4b					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3b4b cd d8 1c			call macro_dsp_valuehl 
3b4e				endm 
# End of macro FORTH_DSP_VALUEHL
3b4e					; TODO save cursor col 
3b4e f1					pop af 
3b4f 85					add l		; add col offset 
3b50 32 40 eb				ld (f_cursor_ptr), a 
3b53					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3b53 cd 90 1d			call macro_forth_dsp_pop 
3b56				endm 
# End of macro FORTH_DSP_POP
3b56			 
3b56					; calculate  
3b56			 
3b56					NEXTW 
3b56 c3 4a 1e			jp macro_next 
3b59				endm 
# End of macro NEXTW
3b59			 
3b59			 
3b59			.HOME: 
3b59				CWHEAD .SPACE 45 "HOME" 4 WORD_FLAG_CODE 
3b59 41				db WORD_SYS_CORE+45             
3b5a 86 3b			dw .SPACE            
3b5c 05				db 4 + 1 
3b5d .. 00			db "HOME",0              
3b62				endm 
# End of macro CWHEAD
3b62			; | HOME ( -- ) Reset the current cursor for output to home | DONE 
3b62					if DEBUG_FORTH_WORDS_KEY 
3b62						DMARK "HOM" 
3b62 f5				push af  
3b63 3a 77 3b			ld a, (.dmark)  
3b66 32 71 ee			ld (debug_mark),a  
3b69 3a 78 3b			ld a, (.dmark+1)  
3b6c 32 72 ee			ld (debug_mark+1),a  
3b6f 3a 79 3b			ld a, (.dmark+2)  
3b72 32 73 ee			ld (debug_mark+2),a  
3b75 18 03			jr .pastdmark  
3b77 ..			.dmark: db "HOM"  
3b7a f1			.pastdmark: pop af  
3b7b			endm  
# End of macro DMARK
3b7b						CALLMONITOR 
3b7b cd 87 14			call break_point_state  
3b7e				endm  
# End of macro CALLMONITOR
3b7e					endif 
3b7e 3e 00		.home:		ld a, 0		; and home cursor 
3b80 32 40 eb				ld (f_cursor_ptr), a 
3b83					NEXTW 
3b83 c3 4a 1e			jp macro_next 
3b86				endm 
# End of macro NEXTW
3b86			 
3b86			 
3b86			.SPACE: 
3b86				CWHEAD .SPACES 50 "BL" 2 WORD_FLAG_CODE 
3b86 46				db WORD_SYS_CORE+50             
3b87 b4 3b			dw .SPACES            
3b89 03				db 2 + 1 
3b8a .. 00			db "BL",0              
3b8d				endm 
# End of macro CWHEAD
3b8d			; | BL (  -- c ) Push the value of space onto the stack as a string  | DONE 
3b8d					if DEBUG_FORTH_WORDS_KEY 
3b8d						DMARK "BL." 
3b8d f5				push af  
3b8e 3a a2 3b			ld a, (.dmark)  
3b91 32 71 ee			ld (debug_mark),a  
3b94 3a a3 3b			ld a, (.dmark+1)  
3b97 32 72 ee			ld (debug_mark+1),a  
3b9a 3a a4 3b			ld a, (.dmark+2)  
3b9d 32 73 ee			ld (debug_mark+2),a  
3ba0 18 03			jr .pastdmark  
3ba2 ..			.dmark: db "BL."  
3ba5 f1			.pastdmark: pop af  
3ba6			endm  
# End of macro DMARK
3ba6						CALLMONITOR 
3ba6 cd 87 14			call break_point_state  
3ba9				endm  
# End of macro CALLMONITOR
3ba9					endif 
3ba9 21 b2 3b				ld hl, .blstr 
3bac cd 4f 1b				call forth_push_str 
3baf					 
3baf				       NEXTW 
3baf c3 4a 1e			jp macro_next 
3bb2				endm 
# End of macro NEXTW
3bb2			 
3bb2 .. 00		.blstr: db " ", 0 
3bb4			 
3bb4			.SPACES: 
3bb4				CWHEAD .SCROLL 51 "SPACES" 6 WORD_FLAG_CODE 
3bb4 47				db WORD_SYS_CORE+51             
3bb5 4f 3c			dw .SCROLL            
3bb7 07				db 6 + 1 
3bb8 .. 00			db "SPACES",0              
3bbf				endm 
# End of macro CWHEAD
3bbf			; | SPACES ( u -- str ) A string of u spaces is pushed onto the stack | TO TEST 
3bbf					if DEBUG_FORTH_WORDS_KEY 
3bbf						DMARK "SPS" 
3bbf f5				push af  
3bc0 3a d4 3b			ld a, (.dmark)  
3bc3 32 71 ee			ld (debug_mark),a  
3bc6 3a d5 3b			ld a, (.dmark+1)  
3bc9 32 72 ee			ld (debug_mark+1),a  
3bcc 3a d6 3b			ld a, (.dmark+2)  
3bcf 32 73 ee			ld (debug_mark+2),a  
3bd2 18 03			jr .pastdmark  
3bd4 ..			.dmark: db "SPS"  
3bd7 f1			.pastdmark: pop af  
3bd8			endm  
# End of macro DMARK
3bd8						CALLMONITOR 
3bd8 cd 87 14			call break_point_state  
3bdb				endm  
# End of macro CALLMONITOR
3bdb					endif 
3bdb			 
3bdb			 
3bdb					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3bdb cd d8 1c			call macro_dsp_valuehl 
3bde				endm 
# End of macro FORTH_DSP_VALUEHL
3bde			 
3bde			;		push hl    ; u 
3bde					if DEBUG_FORTH_WORDS 
3bde						DMARK "SPA" 
3bde f5				push af  
3bdf 3a f3 3b			ld a, (.dmark)  
3be2 32 71 ee			ld (debug_mark),a  
3be5 3a f4 3b			ld a, (.dmark+1)  
3be8 32 72 ee			ld (debug_mark+1),a  
3beb 3a f5 3b			ld a, (.dmark+2)  
3bee 32 73 ee			ld (debug_mark+2),a  
3bf1 18 03			jr .pastdmark  
3bf3 ..			.dmark: db "SPA"  
3bf6 f1			.pastdmark: pop af  
3bf7			endm  
# End of macro DMARK
3bf7						CALLMONITOR 
3bf7 cd 87 14			call break_point_state  
3bfa				endm  
# End of macro CALLMONITOR
3bfa					endif 
3bfa			 
3bfa					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3bfa cd 90 1d			call macro_forth_dsp_pop 
3bfd				endm 
# End of macro FORTH_DSP_POP
3bfd			;		pop hl 
3bfd 4d					ld c, l 
3bfe 06 00				ld b, 0 
3c00 21 d7 e3				ld hl, scratch  
3c03			 
3c03					if DEBUG_FORTH_WORDS 
3c03						DMARK "SP2" 
3c03 f5				push af  
3c04 3a 18 3c			ld a, (.dmark)  
3c07 32 71 ee			ld (debug_mark),a  
3c0a 3a 19 3c			ld a, (.dmark+1)  
3c0d 32 72 ee			ld (debug_mark+1),a  
3c10 3a 1a 3c			ld a, (.dmark+2)  
3c13 32 73 ee			ld (debug_mark+2),a  
3c16 18 03			jr .pastdmark  
3c18 ..			.dmark: db "SP2"  
3c1b f1			.pastdmark: pop af  
3c1c			endm  
# End of macro DMARK
3c1c						CALLMONITOR 
3c1c cd 87 14			call break_point_state  
3c1f				endm  
# End of macro CALLMONITOR
3c1f					endif 
3c1f 3e 20				ld a, ' ' 
3c21 c5			.spaces1:	push bc 
3c22 77					ld (hl),a 
3c23 23					inc hl 
3c24 c1					pop bc 
3c25 10 fa				djnz .spaces1 
3c27 3e 00				ld a,0 
3c29 77					ld (hl),a 
3c2a 21 d7 e3				ld hl, scratch 
3c2d					if DEBUG_FORTH_WORDS 
3c2d						DMARK "SP3" 
3c2d f5				push af  
3c2e 3a 42 3c			ld a, (.dmark)  
3c31 32 71 ee			ld (debug_mark),a  
3c34 3a 43 3c			ld a, (.dmark+1)  
3c37 32 72 ee			ld (debug_mark+1),a  
3c3a 3a 44 3c			ld a, (.dmark+2)  
3c3d 32 73 ee			ld (debug_mark+2),a  
3c40 18 03			jr .pastdmark  
3c42 ..			.dmark: db "SP3"  
3c45 f1			.pastdmark: pop af  
3c46			endm  
# End of macro DMARK
3c46						CALLMONITOR 
3c46 cd 87 14			call break_point_state  
3c49				endm  
# End of macro CALLMONITOR
3c49					endif 
3c49 cd 4a 1c				call forth_apush 
3c4c			 
3c4c				       NEXTW 
3c4c c3 4a 1e			jp macro_next 
3c4f				endm 
# End of macro NEXTW
3c4f			 
3c4f			 
3c4f			 
3c4f			.SCROLL: 
3c4f				CWHEAD .SCROLLD 63 "SCROLL" 6 WORD_FLAG_CODE 
3c4f 53				db WORD_SYS_CORE+63             
3c50 7c 3c			dw .SCROLLD            
3c52 07				db 6 + 1 
3c53 .. 00			db "SCROLL",0              
3c5a				endm 
# End of macro CWHEAD
3c5a			; | SCROLL ( -- ) Scroll up one line - next write will update if required | DONE 
3c5a					if DEBUG_FORTH_WORDS_KEY 
3c5a						DMARK "SCR" 
3c5a f5				push af  
3c5b 3a 6f 3c			ld a, (.dmark)  
3c5e 32 71 ee			ld (debug_mark),a  
3c61 3a 70 3c			ld a, (.dmark+1)  
3c64 32 72 ee			ld (debug_mark+1),a  
3c67 3a 71 3c			ld a, (.dmark+2)  
3c6a 32 73 ee			ld (debug_mark+2),a  
3c6d 18 03			jr .pastdmark  
3c6f ..			.dmark: db "SCR"  
3c72 f1			.pastdmark: pop af  
3c73			endm  
# End of macro DMARK
3c73						CALLMONITOR 
3c73 cd 87 14			call break_point_state  
3c76				endm  
# End of macro CALLMONITOR
3c76					endif 
3c76			 
3c76 cd 1b 0a			call scroll_up 
3c79			;	call update_display 
3c79			 
3c79					NEXTW 
3c79 c3 4a 1e			jp macro_next 
3c7c				endm 
# End of macro NEXTW
3c7c			 
3c7c			 
3c7c			 
3c7c			;		; get dir 
3c7c			; 
3c7c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c7c			; 
3c7c			;		push hl 
3c7c			; 
3c7c			;		; destroy value TOS 
3c7c			; 
3c7c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7c			; 
3c7c			;		; get count 
3c7c			; 
3c7c			;		FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3c7c			; 
3c7c			;		push hl 
3c7c			; 
3c7c			;		; destroy value TOS 
3c7c			; 
3c7c			;		FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3c7c			; 
3c7c			;		; one value on hl get other one back 
3c7c			; 
3c7c			;		pop bc    ; count 
3c7c			; 
3c7c			;		pop de   ; dir 
3c7c			; 
3c7c			; 
3c7c			;		ld b, c 
3c7c			; 
3c7c			;.scrolldir:     push bc 
3c7c			;		push de 
3c7c			; 
3c7c			;		ld a, 0 
3c7c			;		cp e 
3c7c			;		jr z, .scrollup  
3c7c			;		call scroll_down 
3c7c			;		jr .scrollnext 
3c7c			;.scrollup:	call scroll_up 
3c7c			; 
3c7c			;		 
3c7c			;.scrollnext: 
3c7c			;		pop de 
3c7c			;		pop bc 
3c7c			;		djnz .scrolldir 
3c7c			; 
3c7c			; 
3c7c			; 
3c7c			; 
3c7c			; 
3c7c			;		NEXTW 
3c7c			 
3c7c			.SCROLLD: 
3c7c				CWHEAD .ATQ 63 "SCROLLD" 7 WORD_FLAG_CODE 
3c7c 53				db WORD_SYS_CORE+63             
3c7d aa 3c			dw .ATQ            
3c7f 08				db 7 + 1 
3c80 .. 00			db "SCROLLD",0              
3c88				endm 
# End of macro CWHEAD
3c88			; | SCROLLD ( -- ) Scroll down one line - next write will update if required | TO DO 
3c88					if DEBUG_FORTH_WORDS_KEY 
3c88						DMARK "SCD" 
3c88 f5				push af  
3c89 3a 9d 3c			ld a, (.dmark)  
3c8c 32 71 ee			ld (debug_mark),a  
3c8f 3a 9e 3c			ld a, (.dmark+1)  
3c92 32 72 ee			ld (debug_mark+1),a  
3c95 3a 9f 3c			ld a, (.dmark+2)  
3c98 32 73 ee			ld (debug_mark+2),a  
3c9b 18 03			jr .pastdmark  
3c9d ..			.dmark: db "SCD"  
3ca0 f1			.pastdmark: pop af  
3ca1			endm  
# End of macro DMARK
3ca1						CALLMONITOR 
3ca1 cd 87 14			call break_point_state  
3ca4				endm  
# End of macro CALLMONITOR
3ca4					endif 
3ca4			 
3ca4 cd 3f 0a			call scroll_down 
3ca7			;	call update_display 
3ca7			 
3ca7					NEXTW 
3ca7 c3 4a 1e			jp macro_next 
3caa				endm 
# End of macro NEXTW
3caa			 
3caa			 
3caa			.ATQ: 
3caa				CWHEAD .AUTODSP 78 "AT@" 3 WORD_FLAG_CODE 
3caa 62				db WORD_SYS_CORE+78             
3cab 08 3d			dw .AUTODSP            
3cad 04				db 3 + 1 
3cae .. 00			db "AT@",0              
3cb2				endm 
# End of macro CWHEAD
3cb2			; | AT@ ( u1 u2 -- n ) Push to stack ASCII value at row u2 col u1 | DONE 
3cb2					if DEBUG_FORTH_WORDS_KEY 
3cb2						DMARK "ATA" 
3cb2 f5				push af  
3cb3 3a c7 3c			ld a, (.dmark)  
3cb6 32 71 ee			ld (debug_mark),a  
3cb9 3a c8 3c			ld a, (.dmark+1)  
3cbc 32 72 ee			ld (debug_mark+1),a  
3cbf 3a c9 3c			ld a, (.dmark+2)  
3cc2 32 73 ee			ld (debug_mark+2),a  
3cc5 18 03			jr .pastdmark  
3cc7 ..			.dmark: db "ATA"  
3cca f1			.pastdmark: pop af  
3ccb			endm  
# End of macro DMARK
3ccb						CALLMONITOR 
3ccb cd 87 14			call break_point_state  
3cce				endm  
# End of macro CALLMONITOR
3cce					endif 
3cce			 
3cce			 
3cce					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cce cd d8 1c			call macro_dsp_valuehl 
3cd1				endm 
# End of macro FORTH_DSP_VALUEHL
3cd1			 
3cd1					; TODO save cursor row 
3cd1 7d					ld a,l 
3cd2 fe 02				cp 2 
3cd4 20 04				jr nz, .crow3aq 
3cd6 3e 28				ld a, display_row_2 
3cd8 18 12				jr .ccol1aq 
3cda fe 03		.crow3aq:		cp 3 
3cdc 20 04				jr nz, .crow4aq 
3cde 3e 50				ld a, display_row_3 
3ce0 18 0a				jr .ccol1aq 
3ce2 fe 04		.crow4aq:		cp 4 
3ce4 20 04				jr nz, .crow1aq 
3ce6 3e 78				ld a, display_row_4 
3ce8 18 02				jr .ccol1aq 
3cea 3e 00		.crow1aq:		ld a,display_row_1 
3cec f5			.ccol1aq:		push af			; got row offset 
3ced 6f					ld l,a 
3cee 26 00				ld h,0 
3cf0					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3cf0 cd 90 1d			call macro_forth_dsp_pop 
3cf3				endm 
# End of macro FORTH_DSP_POP
3cf3					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3cf3 cd d8 1c			call macro_dsp_valuehl 
3cf6				endm 
# End of macro FORTH_DSP_VALUEHL
3cf6					; TODO save cursor col 
3cf6 f1					pop af 
3cf7 85					add l		; add col offset 
3cf8			 
3cf8					; add current frame buffer address 
3cf8 2a d2 eb				ld hl, (display_fb_active) 
3cfb cd 86 0c				call addatohl 
3cfe			 
3cfe			 
3cfe			 
3cfe			 
3cfe					; get char frame buffer location offset in hl 
3cfe			 
3cfe 7e					ld a,(hl) 
3cff 26 00				ld h, 0 
3d01 6f					ld l, a 
3d02			 
3d02 cd e1 1a				call forth_push_numhl 
3d05			 
3d05			 
3d05					NEXTW 
3d05 c3 4a 1e			jp macro_next 
3d08				endm 
# End of macro NEXTW
3d08			 
3d08			.AUTODSP: 
3d08				CWHEAD .MENU 79 "ADSP" 4 WORD_FLAG_CODE 
3d08 63				db WORD_SYS_CORE+79             
3d09 1e 3d			dw .MENU            
3d0b 05				db 4 + 1 
3d0c .. 00			db "ADSP",0              
3d11				endm 
# End of macro CWHEAD
3d11			; | ADSP ( u1 --  ) Enable/Disable Auto screen updates (SLOW). | DONE 
3d11			; | | If off, use DRAW to refresh. Default is on. $0003 will enable direct screen writes (TODO)  
3d11			 
3d11					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
3d11 cd d8 1c			call macro_dsp_valuehl 
3d14				endm 
# End of macro FORTH_DSP_VALUEHL
3d14			 
3d14			;		push hl 
3d14			 
3d14					; destroy value TOS 
3d14			 
3d14					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d14 cd 90 1d			call macro_forth_dsp_pop 
3d17				endm 
# End of macro FORTH_DSP_POP
3d17			 
3d17			;		pop hl 
3d17			 
3d17 7d					ld a,l 
3d18 32 1e eb				ld (cli_autodisplay), a 
3d1b				       NEXTW 
3d1b c3 4a 1e			jp macro_next 
3d1e				endm 
# End of macro NEXTW
3d1e			 
3d1e			.MENU: 
3d1e				CWHEAD .ENDDISPLAY 92 "MENU" 4 WORD_FLAG_CODE 
3d1e 70				db WORD_SYS_CORE+92             
3d1f c7 3d			dw .ENDDISPLAY            
3d21 05				db 4 + 1 
3d22 .. 00			db "MENU",0              
3d27				endm 
# End of macro CWHEAD
3d27			; | MENU ( u1....ux n -- n ) Create a menu. n is the number of menu items on stack. Push number selection to TOS | TODO 
3d27			 
3d27			;		; get number of items on the stack 
3d27			; 
3d27				 
3d27					FORTH_DSP_VALUEHL 
3d27 cd d8 1c			call macro_dsp_valuehl 
3d2a				endm 
# End of macro FORTH_DSP_VALUEHL
3d2a				 
3d2a					if DEBUG_FORTH_WORDS_KEY 
3d2a						DMARK "MNU" 
3d2a f5				push af  
3d2b 3a 3f 3d			ld a, (.dmark)  
3d2e 32 71 ee			ld (debug_mark),a  
3d31 3a 40 3d			ld a, (.dmark+1)  
3d34 32 72 ee			ld (debug_mark+1),a  
3d37 3a 41 3d			ld a, (.dmark+2)  
3d3a 32 73 ee			ld (debug_mark+2),a  
3d3d 18 03			jr .pastdmark  
3d3f ..			.dmark: db "MNU"  
3d42 f1			.pastdmark: pop af  
3d43			endm  
# End of macro DMARK
3d43						CALLMONITOR 
3d43 cd 87 14			call break_point_state  
3d46				endm  
# End of macro CALLMONITOR
3d46					endif 
3d46			 
3d46 45					ld b, l	 
3d47 05					dec b 
3d48			 
3d48					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d48 cd 90 1d			call macro_forth_dsp_pop 
3d4b				endm 
# End of macro FORTH_DSP_POP
3d4b			 
3d4b			 
3d4b					; go directly through the stack to pluck out the string pointers and build an array 
3d4b			 
3d4b			;		FORTH_DSP 
3d4b			 
3d4b					; hl contains top most stack item 
3d4b				 
3d4b 11 d7 e3				ld de, scratch 
3d4e			 
3d4e			.mbuild: 
3d4e			 
3d4e					FORTH_DSP_VALUEHL 
3d4e cd d8 1c			call macro_dsp_valuehl 
3d51				endm 
# End of macro FORTH_DSP_VALUEHL
3d51			 
3d51					if DEBUG_FORTH_WORDS 
3d51						DMARK "MN3" 
3d51 f5				push af  
3d52 3a 66 3d			ld a, (.dmark)  
3d55 32 71 ee			ld (debug_mark),a  
3d58 3a 67 3d			ld a, (.dmark+1)  
3d5b 32 72 ee			ld (debug_mark+1),a  
3d5e 3a 68 3d			ld a, (.dmark+2)  
3d61 32 73 ee			ld (debug_mark+2),a  
3d64 18 03			jr .pastdmark  
3d66 ..			.dmark: db "MN3"  
3d69 f1			.pastdmark: pop af  
3d6a			endm  
# End of macro DMARK
3d6a						CALLMONITOR 
3d6a cd 87 14			call break_point_state  
3d6d				endm  
# End of macro CALLMONITOR
3d6d					endif 
3d6d eb					ex de, hl 
3d6e 73					ld (hl), e 
3d6f 23					inc hl 
3d70 72					ld (hl), d 
3d71 23					inc hl 
3d72 eb					ex de, hl 
3d73			 
3d73					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
3d73 cd 90 1d			call macro_forth_dsp_pop 
3d76				endm 
# End of macro FORTH_DSP_POP
3d76			 
3d76 10 d6				djnz .mbuild 
3d78			 
3d78					; done add term 
3d78			 
3d78 eb					ex de, hl 
3d79 36 00				ld (hl), 0 
3d7b 23					inc hl 
3d7c 36 00				ld (hl), 0 
3d7e			 
3d7e				 
3d7e					 
3d7e 21 d7 e3				ld hl, scratch 
3d81			 
3d81					if DEBUG_FORTH_WORDS 
3d81						DMARK "MNx" 
3d81 f5				push af  
3d82 3a 96 3d			ld a, (.dmark)  
3d85 32 71 ee			ld (debug_mark),a  
3d88 3a 97 3d			ld a, (.dmark+1)  
3d8b 32 72 ee			ld (debug_mark+1),a  
3d8e 3a 98 3d			ld a, (.dmark+2)  
3d91 32 73 ee			ld (debug_mark+2),a  
3d94 18 03			jr .pastdmark  
3d96 ..			.dmark: db "MNx"  
3d99 f1			.pastdmark: pop af  
3d9a			endm  
# End of macro DMARK
3d9a						CALLMONITOR 
3d9a cd 87 14			call break_point_state  
3d9d				endm  
# End of macro CALLMONITOR
3d9d					endif 
3d9d			 
3d9d			 
3d9d			 
3d9d 3e 00				ld a, 0 
3d9f cd 8a 0a				call menu 
3da2			 
3da2			 
3da2 6f					ld l, a 
3da3 26 00				ld h, 0 
3da5			 
3da5					if DEBUG_FORTH_WORDS 
3da5						DMARK "MNr" 
3da5 f5				push af  
3da6 3a ba 3d			ld a, (.dmark)  
3da9 32 71 ee			ld (debug_mark),a  
3dac 3a bb 3d			ld a, (.dmark+1)  
3daf 32 72 ee			ld (debug_mark+1),a  
3db2 3a bc 3d			ld a, (.dmark+2)  
3db5 32 73 ee			ld (debug_mark+2),a  
3db8 18 03			jr .pastdmark  
3dba ..			.dmark: db "MNr"  
3dbd f1			.pastdmark: pop af  
3dbe			endm  
# End of macro DMARK
3dbe						CALLMONITOR 
3dbe cd 87 14			call break_point_state  
3dc1				endm  
# End of macro CALLMONITOR
3dc1					endif 
3dc1			 
3dc1 cd e1 1a				call forth_push_numhl 
3dc4			 
3dc4			 
3dc4			 
3dc4			 
3dc4				       NEXTW 
3dc4 c3 4a 1e			jp macro_next 
3dc7				endm 
# End of macro NEXTW
3dc7			 
3dc7			 
3dc7			.ENDDISPLAY: 
3dc7			 
3dc7			; eof 
# End of file forth_words_display.asm
3dc7			include "forth_words_str.asm" 
3dc7			 
3dc7			; | ## String Words 
3dc7			 
3dc7			.PTR:   
3dc7			 
3dc7				CWHEAD .STYPE 52 "PTR" 3 WORD_FLAG_CODE 
3dc7 48				db WORD_SYS_CORE+52             
3dc8 f4 3d			dw .STYPE            
3dca 04				db 3 + 1 
3dcb .. 00			db "PTR",0              
3dcf				endm 
# End of macro CWHEAD
3dcf			; | PTR ( -- addr ) Low level push pointer to the value on TOS | DONE 
3dcf			; | | If a string will give the address of the string without dropping it. Handy for direct string access 
3dcf			; | | If a number can then use 2@ and 2! for direct value update without using stack words  
3dcf			 
3dcf					if DEBUG_FORTH_WORDS_KEY 
3dcf						DMARK "PTR" 
3dcf f5				push af  
3dd0 3a e4 3d			ld a, (.dmark)  
3dd3 32 71 ee			ld (debug_mark),a  
3dd6 3a e5 3d			ld a, (.dmark+1)  
3dd9 32 72 ee			ld (debug_mark+1),a  
3ddc 3a e6 3d			ld a, (.dmark+2)  
3ddf 32 73 ee			ld (debug_mark+2),a  
3de2 18 03			jr .pastdmark  
3de4 ..			.dmark: db "PTR"  
3de7 f1			.pastdmark: pop af  
3de8			endm  
# End of macro DMARK
3de8						CALLMONITOR 
3de8 cd 87 14			call break_point_state  
3deb				endm  
# End of macro CALLMONITOR
3deb					endif 
3deb					FORTH_DSP_VALUEHL 
3deb cd d8 1c			call macro_dsp_valuehl 
3dee				endm 
# End of macro FORTH_DSP_VALUEHL
3dee cd e1 1a				call forth_push_numhl 
3df1			 
3df1			 
3df1					NEXTW 
3df1 c3 4a 1e			jp macro_next 
3df4				endm 
# End of macro NEXTW
3df4			.STYPE: 
3df4				CWHEAD .UPPER 52 "STYPE" 5 WORD_FLAG_CODE 
3df4 48				db WORD_SYS_CORE+52             
3df5 43 3e			dw .UPPER            
3df7 06				db 5 + 1 
3df8 .. 00			db "STYPE",0              
3dfe				endm 
# End of macro CWHEAD
3dfe			; | STYPE ( u -- u type ) Push type of value on TOS - 's' string, 'i' integer...   | DONE 
3dfe					if DEBUG_FORTH_WORDS_KEY 
3dfe						DMARK "STY" 
3dfe f5				push af  
3dff 3a 13 3e			ld a, (.dmark)  
3e02 32 71 ee			ld (debug_mark),a  
3e05 3a 14 3e			ld a, (.dmark+1)  
3e08 32 72 ee			ld (debug_mark+1),a  
3e0b 3a 15 3e			ld a, (.dmark+2)  
3e0e 32 73 ee			ld (debug_mark+2),a  
3e11 18 03			jr .pastdmark  
3e13 ..			.dmark: db "STY"  
3e16 f1			.pastdmark: pop af  
3e17			endm  
# End of macro DMARK
3e17						CALLMONITOR 
3e17 cd 87 14			call break_point_state  
3e1a				endm  
# End of macro CALLMONITOR
3e1a					endif 
3e1a					FORTH_DSP 
3e1a cd 9e 1c			call macro_forth_dsp 
3e1d				endm 
# End of macro FORTH_DSP
3e1d					;v5 FORTH_DSP_VALUE 
3e1d			 
3e1d 7e					ld a, (hl) 
3e1e			 
3e1e f5					push af 
3e1f			 
3e1f			; Dont destroy TOS		FORTH_DSP_POP 
3e1f			 
3e1f f1					pop af 
3e20			 
3e20 fe 01				cp DS_TYPE_STR 
3e22 28 09				jr z, .typestr 
3e24			 
3e24 fe 02				cp DS_TYPE_INUM 
3e26 28 0a				jr z, .typeinum 
3e28			 
3e28 21 41 3e				ld hl, .tna 
3e2b 18 0a				jr .tpush 
3e2d			 
3e2d 21 3d 3e		.typestr:	ld hl, .tstr 
3e30 18 05				jr .tpush 
3e32 21 3f 3e		.typeinum:	ld hl, .tinum 
3e35 18 00				jr .tpush 
3e37			 
3e37			.tpush: 
3e37			 
3e37 cd 4f 1b				call forth_push_str 
3e3a			 
3e3a					NEXTW 
3e3a c3 4a 1e			jp macro_next 
3e3d				endm 
# End of macro NEXTW
3e3d .. 00		.tstr:	db "s",0 
3e3f .. 00		.tinum:  db "i",0 
3e41 .. 00		.tna:   db "?", 0 
3e43			 
3e43			 
3e43			.UPPER: 
3e43				CWHEAD .LOWER 52 "UPPER" 5 WORD_FLAG_CODE 
3e43 48				db WORD_SYS_CORE+52             
3e44 7e 3e			dw .LOWER            
3e46 06				db 5 + 1 
3e47 .. 00			db "UPPER",0              
3e4d				endm 
# End of macro CWHEAD
3e4d			; | UPPER ( s -- s ) Upper case string s  | DONE 
3e4d					if DEBUG_FORTH_WORDS_KEY 
3e4d						DMARK "UPR" 
3e4d f5				push af  
3e4e 3a 62 3e			ld a, (.dmark)  
3e51 32 71 ee			ld (debug_mark),a  
3e54 3a 63 3e			ld a, (.dmark+1)  
3e57 32 72 ee			ld (debug_mark+1),a  
3e5a 3a 64 3e			ld a, (.dmark+2)  
3e5d 32 73 ee			ld (debug_mark+2),a  
3e60 18 03			jr .pastdmark  
3e62 ..			.dmark: db "UPR"  
3e65 f1			.pastdmark: pop af  
3e66			endm  
# End of macro DMARK
3e66						CALLMONITOR 
3e66 cd 87 14			call break_point_state  
3e69				endm  
# End of macro CALLMONITOR
3e69					endif 
3e69			 
3e69					FORTH_DSP 
3e69 cd 9e 1c			call macro_forth_dsp 
3e6c				endm 
# End of macro FORTH_DSP
3e6c					 
3e6c			; TODO check is string type 
3e6c			 
3e6c					FORTH_DSP_VALUEHL 
3e6c cd d8 1c			call macro_dsp_valuehl 
3e6f				endm 
# End of macro FORTH_DSP_VALUEHL
3e6f			; get pointer to string in hl 
3e6f			 
3e6f 7e			.toup:		ld a, (hl) 
3e70 fe 00				cp 0 
3e72 28 07				jr z, .toupdone 
3e74			 
3e74 cd f3 0f				call to_upper 
3e77			 
3e77 77					ld (hl), a 
3e78 23					inc hl 
3e79 18 f4				jr .toup 
3e7b			 
3e7b					 
3e7b			 
3e7b			 
3e7b			; for each char convert to upper 
3e7b					 
3e7b			.toupdone: 
3e7b			 
3e7b			 
3e7b					NEXTW 
3e7b c3 4a 1e			jp macro_next 
3e7e				endm 
# End of macro NEXTW
3e7e			.LOWER: 
3e7e				CWHEAD .TCASE 52 "LOWER" 5 WORD_FLAG_CODE 
3e7e 48				db WORD_SYS_CORE+52             
3e7f b9 3e			dw .TCASE            
3e81 06				db 5 + 1 
3e82 .. 00			db "LOWER",0              
3e88				endm 
# End of macro CWHEAD
3e88			; | LOWER ( s -- s ) Lower case string s  | DONE 
3e88					if DEBUG_FORTH_WORDS_KEY 
3e88						DMARK "LWR" 
3e88 f5				push af  
3e89 3a 9d 3e			ld a, (.dmark)  
3e8c 32 71 ee			ld (debug_mark),a  
3e8f 3a 9e 3e			ld a, (.dmark+1)  
3e92 32 72 ee			ld (debug_mark+1),a  
3e95 3a 9f 3e			ld a, (.dmark+2)  
3e98 32 73 ee			ld (debug_mark+2),a  
3e9b 18 03			jr .pastdmark  
3e9d ..			.dmark: db "LWR"  
3ea0 f1			.pastdmark: pop af  
3ea1			endm  
# End of macro DMARK
3ea1						CALLMONITOR 
3ea1 cd 87 14			call break_point_state  
3ea4				endm  
# End of macro CALLMONITOR
3ea4					endif 
3ea4			 
3ea4					FORTH_DSP 
3ea4 cd 9e 1c			call macro_forth_dsp 
3ea7				endm 
# End of macro FORTH_DSP
3ea7					 
3ea7			; TODO check is string type 
3ea7			 
3ea7					FORTH_DSP_VALUEHL 
3ea7 cd d8 1c			call macro_dsp_valuehl 
3eaa				endm 
# End of macro FORTH_DSP_VALUEHL
3eaa			; get pointer to string in hl 
3eaa			 
3eaa 7e			.tolow:		ld a, (hl) 
3eab fe 00				cp 0 
3ead 28 07				jr z, .tolowdone 
3eaf			 
3eaf cd fc 0f				call to_lower 
3eb2			 
3eb2 77					ld (hl), a 
3eb3 23					inc hl 
3eb4 18 f4				jr .tolow 
3eb6			 
3eb6					 
3eb6			 
3eb6			 
3eb6			; for each char convert to low 
3eb6					 
3eb6			.tolowdone: 
3eb6					NEXTW 
3eb6 c3 4a 1e			jp macro_next 
3eb9				endm 
# End of macro NEXTW
3eb9			.TCASE: 
3eb9				CWHEAD .SUBSTR 52 "TCASE" 5 WORD_FLAG_CODE 
3eb9 48				db WORD_SYS_CORE+52             
3eba ef 3f			dw .SUBSTR            
3ebc 06				db 5 + 1 
3ebd .. 00			db "TCASE",0              
3ec3				endm 
# End of macro CWHEAD
3ec3			; | TCASE ( s -- s ) Title case string s  | DONE 
3ec3					if DEBUG_FORTH_WORDS_KEY 
3ec3						DMARK "TCS" 
3ec3 f5				push af  
3ec4 3a d8 3e			ld a, (.dmark)  
3ec7 32 71 ee			ld (debug_mark),a  
3eca 3a d9 3e			ld a, (.dmark+1)  
3ecd 32 72 ee			ld (debug_mark+1),a  
3ed0 3a da 3e			ld a, (.dmark+2)  
3ed3 32 73 ee			ld (debug_mark+2),a  
3ed6 18 03			jr .pastdmark  
3ed8 ..			.dmark: db "TCS"  
3edb f1			.pastdmark: pop af  
3edc			endm  
# End of macro DMARK
3edc						CALLMONITOR 
3edc cd 87 14			call break_point_state  
3edf				endm  
# End of macro CALLMONITOR
3edf					endif 
3edf			 
3edf					FORTH_DSP 
3edf cd 9e 1c			call macro_forth_dsp 
3ee2				endm 
# End of macro FORTH_DSP
3ee2					 
3ee2			; TODO check is string type 
3ee2			 
3ee2					FORTH_DSP_VALUEHL 
3ee2 cd d8 1c			call macro_dsp_valuehl 
3ee5				endm 
# End of macro FORTH_DSP_VALUEHL
3ee5			; get pointer to string in hl 
3ee5			 
3ee5					if DEBUG_FORTH_WORDS 
3ee5						DMARK "TC1" 
3ee5 f5				push af  
3ee6 3a fa 3e			ld a, (.dmark)  
3ee9 32 71 ee			ld (debug_mark),a  
3eec 3a fb 3e			ld a, (.dmark+1)  
3eef 32 72 ee			ld (debug_mark+1),a  
3ef2 3a fc 3e			ld a, (.dmark+2)  
3ef5 32 73 ee			ld (debug_mark+2),a  
3ef8 18 03			jr .pastdmark  
3efa ..			.dmark: db "TC1"  
3efd f1			.pastdmark: pop af  
3efe			endm  
# End of macro DMARK
3efe						CALLMONITOR 
3efe cd 87 14			call break_point_state  
3f01				endm  
# End of macro CALLMONITOR
3f01					endif 
3f01			 
3f01					; first time in turn to upper case first char 
3f01			 
3f01 7e					ld a, (hl) 
3f02 c3 8c 3f				jp .totsiptou 
3f05			 
3f05			 
3f05 7e			.tot:		ld a, (hl) 
3f06 fe 00				cp 0 
3f08 ca d0 3f				jp z, .totdone 
3f0b			 
3f0b					if DEBUG_FORTH_WORDS 
3f0b						DMARK "TC2" 
3f0b f5				push af  
3f0c 3a 20 3f			ld a, (.dmark)  
3f0f 32 71 ee			ld (debug_mark),a  
3f12 3a 21 3f			ld a, (.dmark+1)  
3f15 32 72 ee			ld (debug_mark+1),a  
3f18 3a 22 3f			ld a, (.dmark+2)  
3f1b 32 73 ee			ld (debug_mark+2),a  
3f1e 18 03			jr .pastdmark  
3f20 ..			.dmark: db "TC2"  
3f23 f1			.pastdmark: pop af  
3f24			endm  
# End of macro DMARK
3f24						CALLMONITOR 
3f24 cd 87 14			call break_point_state  
3f27				endm  
# End of macro CALLMONITOR
3f27					endif 
3f27					; check to see if current char is a space 
3f27			 
3f27 fe 20				cp ' ' 
3f29 28 21				jr z, .totsp 
3f2b cd fc 0f				call to_lower 
3f2e					if DEBUG_FORTH_WORDS 
3f2e						DMARK "TC3" 
3f2e f5				push af  
3f2f 3a 43 3f			ld a, (.dmark)  
3f32 32 71 ee			ld (debug_mark),a  
3f35 3a 44 3f			ld a, (.dmark+1)  
3f38 32 72 ee			ld (debug_mark+1),a  
3f3b 3a 45 3f			ld a, (.dmark+2)  
3f3e 32 73 ee			ld (debug_mark+2),a  
3f41 18 03			jr .pastdmark  
3f43 ..			.dmark: db "TC3"  
3f46 f1			.pastdmark: pop af  
3f47			endm  
# End of macro DMARK
3f47						CALLMONITOR 
3f47 cd 87 14			call break_point_state  
3f4a				endm  
# End of macro CALLMONITOR
3f4a					endif 
3f4a 18 63				jr .totnxt 
3f4c			 
3f4c			.totsp:         ; on a space, find next char which should be upper 
3f4c			 
3f4c					if DEBUG_FORTH_WORDS 
3f4c						DMARK "TC4" 
3f4c f5				push af  
3f4d 3a 61 3f			ld a, (.dmark)  
3f50 32 71 ee			ld (debug_mark),a  
3f53 3a 62 3f			ld a, (.dmark+1)  
3f56 32 72 ee			ld (debug_mark+1),a  
3f59 3a 63 3f			ld a, (.dmark+2)  
3f5c 32 73 ee			ld (debug_mark+2),a  
3f5f 18 03			jr .pastdmark  
3f61 ..			.dmark: db "TC4"  
3f64 f1			.pastdmark: pop af  
3f65			endm  
# End of macro DMARK
3f65						CALLMONITOR 
3f65 cd 87 14			call break_point_state  
3f68				endm  
# End of macro CALLMONITOR
3f68					endif 
3f68					;; 
3f68			 
3f68 fe 20				cp ' ' 
3f6a 20 20				jr nz, .totsiptou 
3f6c 23					inc hl 
3f6d 7e					ld a, (hl) 
3f6e					if DEBUG_FORTH_WORDS 
3f6e						DMARK "TC5" 
3f6e f5				push af  
3f6f 3a 83 3f			ld a, (.dmark)  
3f72 32 71 ee			ld (debug_mark),a  
3f75 3a 84 3f			ld a, (.dmark+1)  
3f78 32 72 ee			ld (debug_mark+1),a  
3f7b 3a 85 3f			ld a, (.dmark+2)  
3f7e 32 73 ee			ld (debug_mark+2),a  
3f81 18 03			jr .pastdmark  
3f83 ..			.dmark: db "TC5"  
3f86 f1			.pastdmark: pop af  
3f87			endm  
# End of macro DMARK
3f87						CALLMONITOR 
3f87 cd 87 14			call break_point_state  
3f8a				endm  
# End of macro CALLMONITOR
3f8a					endif 
3f8a 18 c0				jr .totsp 
3f8c fe 00		.totsiptou:    cp 0 
3f8e 28 40				jr z, .totdone 
3f90					; not space and not zero term so upper case it 
3f90 cd f3 0f				call to_upper 
3f93			 
3f93					if DEBUG_FORTH_WORDS 
3f93						DMARK "TC6" 
3f93 f5				push af  
3f94 3a a8 3f			ld a, (.dmark)  
3f97 32 71 ee			ld (debug_mark),a  
3f9a 3a a9 3f			ld a, (.dmark+1)  
3f9d 32 72 ee			ld (debug_mark+1),a  
3fa0 3a aa 3f			ld a, (.dmark+2)  
3fa3 32 73 ee			ld (debug_mark+2),a  
3fa6 18 03			jr .pastdmark  
3fa8 ..			.dmark: db "TC6"  
3fab f1			.pastdmark: pop af  
3fac			endm  
# End of macro DMARK
3fac						CALLMONITOR 
3fac cd 87 14			call break_point_state  
3faf				endm  
# End of macro CALLMONITOR
3faf					endif 
3faf			 
3faf			 
3faf			.totnxt: 
3faf			 
3faf 77					ld (hl), a 
3fb0 23					inc hl 
3fb1					if DEBUG_FORTH_WORDS 
3fb1						DMARK "TC7" 
3fb1 f5				push af  
3fb2 3a c6 3f			ld a, (.dmark)  
3fb5 32 71 ee			ld (debug_mark),a  
3fb8 3a c7 3f			ld a, (.dmark+1)  
3fbb 32 72 ee			ld (debug_mark+1),a  
3fbe 3a c8 3f			ld a, (.dmark+2)  
3fc1 32 73 ee			ld (debug_mark+2),a  
3fc4 18 03			jr .pastdmark  
3fc6 ..			.dmark: db "TC7"  
3fc9 f1			.pastdmark: pop af  
3fca			endm  
# End of macro DMARK
3fca						CALLMONITOR 
3fca cd 87 14			call break_point_state  
3fcd				endm  
# End of macro CALLMONITOR
3fcd					endif 
3fcd c3 05 3f				jp .tot 
3fd0			 
3fd0					 
3fd0			 
3fd0			 
3fd0			; for each char convert to low 
3fd0					 
3fd0			.totdone: 
3fd0					if DEBUG_FORTH_WORDS 
3fd0						DMARK "TCd" 
3fd0 f5				push af  
3fd1 3a e5 3f			ld a, (.dmark)  
3fd4 32 71 ee			ld (debug_mark),a  
3fd7 3a e6 3f			ld a, (.dmark+1)  
3fda 32 72 ee			ld (debug_mark+1),a  
3fdd 3a e7 3f			ld a, (.dmark+2)  
3fe0 32 73 ee			ld (debug_mark+2),a  
3fe3 18 03			jr .pastdmark  
3fe5 ..			.dmark: db "TCd"  
3fe8 f1			.pastdmark: pop af  
3fe9			endm  
# End of macro DMARK
3fe9						CALLMONITOR 
3fe9 cd 87 14			call break_point_state  
3fec				endm  
# End of macro CALLMONITOR
3fec					endif 
3fec					NEXTW 
3fec c3 4a 1e			jp macro_next 
3fef				endm 
# End of macro NEXTW
3fef			 
3fef			.SUBSTR: 
3fef				CWHEAD .LEFT 52 "SUBSTR" 6 WORD_FLAG_CODE 
3fef 48				db WORD_SYS_CORE+52             
3ff0 4d 40			dw .LEFT            
3ff2 07				db 6 + 1 
3ff3 .. 00			db "SUBSTR",0              
3ffa				endm 
# End of macro CWHEAD
3ffa			; | SUBSTR ( s u1 u2 -- s sb ) Push to TOS chars starting at position u1 and with length u2 from string s  | DONE 
3ffa			 
3ffa					if DEBUG_FORTH_WORDS_KEY 
3ffa						DMARK "SST" 
3ffa f5				push af  
3ffb 3a 0f 40			ld a, (.dmark)  
3ffe 32 71 ee			ld (debug_mark),a  
4001 3a 10 40			ld a, (.dmark+1)  
4004 32 72 ee			ld (debug_mark+1),a  
4007 3a 11 40			ld a, (.dmark+2)  
400a 32 73 ee			ld (debug_mark+2),a  
400d 18 03			jr .pastdmark  
400f ..			.dmark: db "SST"  
4012 f1			.pastdmark: pop af  
4013			endm  
# End of macro DMARK
4013						CALLMONITOR 
4013 cd 87 14			call break_point_state  
4016				endm  
# End of macro CALLMONITOR
4016					endif 
4016			; TODO check string type 
4016					FORTH_DSP_VALUEHL 
4016 cd d8 1c			call macro_dsp_valuehl 
4019				endm 
# End of macro FORTH_DSP_VALUEHL
4019			 
4019 e5					push hl      ; string length 
401a			 
401a					FORTH_DSP_POP 
401a cd 90 1d			call macro_forth_dsp_pop 
401d				endm 
# End of macro FORTH_DSP_POP
401d			 
401d					FORTH_DSP_VALUEHL 
401d cd d8 1c			call macro_dsp_valuehl 
4020				endm 
# End of macro FORTH_DSP_VALUEHL
4020			 
4020 e5					push hl     ; start char 
4021			 
4021					FORTH_DSP_POP 
4021 cd 90 1d			call macro_forth_dsp_pop 
4024				endm 
# End of macro FORTH_DSP_POP
4024			 
4024			 
4024					FORTH_DSP_VALUE 
4024 cd c1 1c			call macro_forth_dsp_value 
4027				endm 
# End of macro FORTH_DSP_VALUE
4027			 
4027 d1					pop de    ; get start post offset 
4028			 
4028 19					add hl, de    ; starting offset 
4029			 
4029 c1					pop bc 
402a c5					push bc      ; grab size of string 
402b			 
402b e5					push hl    ; save string start  
402c			 
402c 26 00				ld h, 0 
402e 69					ld l, c 
402f 23					inc hl 
4030 23					inc hl 
4031			 
4031 cd 4d 11				call malloc 
4034				if DEBUG_FORTH_MALLOC_GUARD 
4034 cc 7c 46				call z,malloc_error 
4037				endif 
4037			 
4037 eb					ex de, hl      ; save malloc area for string copy 
4038 e1					pop hl    ; get back source 
4039 c1					pop bc    ; get length of string back 
403a			 
403a d5					push de    ; save malloc area for after we push 
403b ed b0				ldir     ; copy substr 
403d			 
403d			 
403d eb					ex de, hl 
403e 3e 00				ld a, 0 
4040 77					ld (hl), a   ; term substr 
4041			 
4041					 
4041 e1					pop hl    ; get malloc so we can push it 
4042 e5					push hl   ; save so we can free it afterwards 
4043			 
4043 cd 4f 1b				call forth_push_str 
4046			 
4046 e1					pop hl 
4047 cd 17 12				call free 
404a			 
404a					 
404a					 
404a			 
404a			 
404a					NEXTW 
404a c3 4a 1e			jp macro_next 
404d				endm 
# End of macro NEXTW
404d			 
404d			.LEFT: 
404d				CWHEAD .RIGHT 52 "LEFT" 4 WORD_FLAG_CODE 
404d 48				db WORD_SYS_CORE+52             
404e 75 40			dw .RIGHT            
4050 05				db 4 + 1 
4051 .. 00			db "LEFT",0              
4056				endm 
# End of macro CWHEAD
4056			; | LEFT ( s u -- s sub ) Push to TOS string u long starting from left of s  | TODO 
4056					if DEBUG_FORTH_WORDS_KEY 
4056						DMARK "LEF" 
4056 f5				push af  
4057 3a 6b 40			ld a, (.dmark)  
405a 32 71 ee			ld (debug_mark),a  
405d 3a 6c 40			ld a, (.dmark+1)  
4060 32 72 ee			ld (debug_mark+1),a  
4063 3a 6d 40			ld a, (.dmark+2)  
4066 32 73 ee			ld (debug_mark+2),a  
4069 18 03			jr .pastdmark  
406b ..			.dmark: db "LEF"  
406e f1			.pastdmark: pop af  
406f			endm  
# End of macro DMARK
406f						CALLMONITOR 
406f cd 87 14			call break_point_state  
4072				endm  
# End of macro CALLMONITOR
4072					endif 
4072			 
4072					NEXTW 
4072 c3 4a 1e			jp macro_next 
4075				endm 
# End of macro NEXTW
4075			.RIGHT: 
4075				CWHEAD .STR2NUM 52 "RIGHT" 5 WORD_FLAG_CODE 
4075 48				db WORD_SYS_CORE+52             
4076 9e 40			dw .STR2NUM            
4078 06				db 5 + 1 
4079 .. 00			db "RIGHT",0              
407f				endm 
# End of macro CWHEAD
407f			; | RIGHT ( s u -- s sub ) Push to TOS string u long starting from right of s  | TODO 
407f					if DEBUG_FORTH_WORDS_KEY 
407f						DMARK "RIG" 
407f f5				push af  
4080 3a 94 40			ld a, (.dmark)  
4083 32 71 ee			ld (debug_mark),a  
4086 3a 95 40			ld a, (.dmark+1)  
4089 32 72 ee			ld (debug_mark+1),a  
408c 3a 96 40			ld a, (.dmark+2)  
408f 32 73 ee			ld (debug_mark+2),a  
4092 18 03			jr .pastdmark  
4094 ..			.dmark: db "RIG"  
4097 f1			.pastdmark: pop af  
4098			endm  
# End of macro DMARK
4098						CALLMONITOR 
4098 cd 87 14			call break_point_state  
409b				endm  
# End of macro CALLMONITOR
409b					endif 
409b			 
409b					NEXTW 
409b c3 4a 1e			jp macro_next 
409e				endm 
# End of macro NEXTW
409e			 
409e			 
409e			.STR2NUM: 
409e				CWHEAD .NUM2STR 52 "STR2NUM" 7 WORD_FLAG_CODE 
409e 48				db WORD_SYS_CORE+52             
409f 2a 41			dw .NUM2STR            
40a1 08				db 7 + 1 
40a2 .. 00			db "STR2NUM",0              
40aa				endm 
# End of macro CWHEAD
40aa			; | STR2NUM ( s -- n ) Convert a string on TOS to number | DONE 
40aa			 
40aa			 
40aa			; TODO STR type check to do 
40aa					if DEBUG_FORTH_WORDS_KEY 
40aa						DMARK "S2N" 
40aa f5				push af  
40ab 3a bf 40			ld a, (.dmark)  
40ae 32 71 ee			ld (debug_mark),a  
40b1 3a c0 40			ld a, (.dmark+1)  
40b4 32 72 ee			ld (debug_mark+1),a  
40b7 3a c1 40			ld a, (.dmark+2)  
40ba 32 73 ee			ld (debug_mark+2),a  
40bd 18 03			jr .pastdmark  
40bf ..			.dmark: db "S2N"  
40c2 f1			.pastdmark: pop af  
40c3			endm  
# End of macro DMARK
40c3						CALLMONITOR 
40c3 cd 87 14			call break_point_state  
40c6				endm  
# End of macro CALLMONITOR
40c6					endif 
40c6			 
40c6					;FORTH_DSP 
40c6					FORTH_DSP_VALUE 
40c6 cd c1 1c			call macro_forth_dsp_value 
40c9				endm 
# End of macro FORTH_DSP_VALUE
40c9					;inc hl 
40c9			 
40c9 eb					ex de, hl 
40ca					if DEBUG_FORTH_WORDS 
40ca						DMARK "S2a" 
40ca f5				push af  
40cb 3a df 40			ld a, (.dmark)  
40ce 32 71 ee			ld (debug_mark),a  
40d1 3a e0 40			ld a, (.dmark+1)  
40d4 32 72 ee			ld (debug_mark+1),a  
40d7 3a e1 40			ld a, (.dmark+2)  
40da 32 73 ee			ld (debug_mark+2),a  
40dd 18 03			jr .pastdmark  
40df ..			.dmark: db "S2a"  
40e2 f1			.pastdmark: pop af  
40e3			endm  
# End of macro DMARK
40e3						CALLMONITOR 
40e3 cd 87 14			call break_point_state  
40e6				endm  
# End of macro CALLMONITOR
40e6					endif 
40e6 cd 7b 10				call string_to_uint16 
40e9			 
40e9					if DEBUG_FORTH_WORDS 
40e9						DMARK "S2b" 
40e9 f5				push af  
40ea 3a fe 40			ld a, (.dmark)  
40ed 32 71 ee			ld (debug_mark),a  
40f0 3a ff 40			ld a, (.dmark+1)  
40f3 32 72 ee			ld (debug_mark+1),a  
40f6 3a 00 41			ld a, (.dmark+2)  
40f9 32 73 ee			ld (debug_mark+2),a  
40fc 18 03			jr .pastdmark  
40fe ..			.dmark: db "S2b"  
4101 f1			.pastdmark: pop af  
4102			endm  
# End of macro DMARK
4102						CALLMONITOR 
4102 cd 87 14			call break_point_state  
4105				endm  
# End of macro CALLMONITOR
4105					endif 
4105			;		push hl 
4105					FORTH_DSP_POP 
4105 cd 90 1d			call macro_forth_dsp_pop 
4108				endm 
# End of macro FORTH_DSP_POP
4108			;		pop hl 
4108					 
4108					if DEBUG_FORTH_WORDS 
4108						DMARK "S2b" 
4108 f5				push af  
4109 3a 1d 41			ld a, (.dmark)  
410c 32 71 ee			ld (debug_mark),a  
410f 3a 1e 41			ld a, (.dmark+1)  
4112 32 72 ee			ld (debug_mark+1),a  
4115 3a 1f 41			ld a, (.dmark+2)  
4118 32 73 ee			ld (debug_mark+2),a  
411b 18 03			jr .pastdmark  
411d ..			.dmark: db "S2b"  
4120 f1			.pastdmark: pop af  
4121			endm  
# End of macro DMARK
4121						CALLMONITOR 
4121 cd 87 14			call break_point_state  
4124				endm  
# End of macro CALLMONITOR
4124					endif 
4124 cd e1 1a				call forth_push_numhl	 
4127			 
4127				 
4127				       NEXTW 
4127 c3 4a 1e			jp macro_next 
412a				endm 
# End of macro NEXTW
412a			.NUM2STR: 
412a				CWHEAD .CONCAT 52 "NUM2STR" 7 WORD_FLAG_CODE 
412a 48				db WORD_SYS_CORE+52             
412b 39 41			dw .CONCAT            
412d 08				db 7 + 1 
412e .. 00			db "NUM2STR",0              
4136				endm 
# End of macro CWHEAD
4136			; | NUM2STR ( n -- s ) Convert a number on TOS to string | NOT DOING 
4136			 
4136			;		; malloc a string to target 
4136			;		ld hl, 10     ; TODO max string size should be fine 
4136			;		call malloc 
4136			;		push hl    ; save malloc location 
4136			; 
4136			; 
4136			;; TODO check int type 
4136			;		FORTH_DSP_VALUEHL 
4136			;		ld a, l 
4136			;		call DispAToASCII   
4136			;;TODO need to chage above call to dump into string 
4136			; 
4136			; 
4136			 
4136				       NEXTW 
4136 c3 4a 1e			jp macro_next 
4139				endm 
# End of macro NEXTW
4139			 
4139			.CONCAT: 
4139				CWHEAD .FIND 52 "CONCAT" 6 WORD_FLAG_CODE 
4139 48				db WORD_SYS_CORE+52             
413a ec 41			dw .FIND            
413c 07				db 6 + 1 
413d .. 00			db "CONCAT",0              
4144				endm 
# End of macro CWHEAD
4144			; | CONCAT ( s1 s2 -- s3 ) A s1 + s2 is pushed onto the stack | DONE 
4144			 
4144			; TODO check string type 
4144			; TODO create macro to get pointer for next item on stack. Handy for lots of things 
4144			 
4144					if DEBUG_FORTH_WORDS_KEY 
4144						DMARK "CON" 
4144 f5				push af  
4145 3a 59 41			ld a, (.dmark)  
4148 32 71 ee			ld (debug_mark),a  
414b 3a 5a 41			ld a, (.dmark+1)  
414e 32 72 ee			ld (debug_mark+1),a  
4151 3a 5b 41			ld a, (.dmark+2)  
4154 32 73 ee			ld (debug_mark+2),a  
4157 18 03			jr .pastdmark  
4159 ..			.dmark: db "CON"  
415c f1			.pastdmark: pop af  
415d			endm  
# End of macro DMARK
415d						CALLMONITOR 
415d cd 87 14			call break_point_state  
4160				endm  
# End of macro CALLMONITOR
4160					endif 
4160			 
4160			 
4160					FORTH_DSP_VALUE 
4160 cd c1 1c			call macro_forth_dsp_value 
4163				endm 
# End of macro FORTH_DSP_VALUE
4163 e5					push hl   ; s2 
4164			 
4164					FORTH_DSP_POP 
4164 cd 90 1d			call macro_forth_dsp_pop 
4167				endm 
# End of macro FORTH_DSP_POP
4167			 
4167					FORTH_DSP_VALUE 
4167 cd c1 1c			call macro_forth_dsp_value 
416a				endm 
# End of macro FORTH_DSP_VALUE
416a			 
416a e5					push hl   ; s1 
416b			 
416b					FORTH_DSP_POP 
416b cd 90 1d			call macro_forth_dsp_pop 
416e				endm 
# End of macro FORTH_DSP_POP
416e					 
416e			 
416e					; copy s1 
416e			 
416e				 
416e					; save ptr 
416e e1					pop hl  
416f e5					push hl 
4170 3e 00				ld a, 0 
4172 cd ef 10				call strlent 
4175					;inc hl    ; zer0 
4175 06 00				ld b, 0 
4177 4d					ld c, l 
4178 e1					pop hl		 
4179 11 d7 e3				ld de, scratch	 
417c					if DEBUG_FORTH_WORDS 
417c						DMARK "CO1" 
417c f5				push af  
417d 3a 91 41			ld a, (.dmark)  
4180 32 71 ee			ld (debug_mark),a  
4183 3a 92 41			ld a, (.dmark+1)  
4186 32 72 ee			ld (debug_mark+1),a  
4189 3a 93 41			ld a, (.dmark+2)  
418c 32 73 ee			ld (debug_mark+2),a  
418f 18 03			jr .pastdmark  
4191 ..			.dmark: db "CO1"  
4194 f1			.pastdmark: pop af  
4195			endm  
# End of macro DMARK
4195						CALLMONITOR 
4195 cd 87 14			call break_point_state  
4198				endm  
# End of macro CALLMONITOR
4198					endif 
4198 ed b0				ldir 
419a			 
419a e1					pop hl 
419b e5					push hl 
419c d5					push de 
419d			 
419d			 
419d 3e 00				ld a, 0 
419f cd ef 10				call strlent 
41a2 23					inc hl    ; zer0 
41a3 23					inc hl 
41a4 06 00				ld b, 0 
41a6 4d					ld c, l 
41a7 d1					pop de 
41a8 e1					pop hl		 
41a9					if DEBUG_FORTH_WORDS 
41a9						DMARK "CO2" 
41a9 f5				push af  
41aa 3a be 41			ld a, (.dmark)  
41ad 32 71 ee			ld (debug_mark),a  
41b0 3a bf 41			ld a, (.dmark+1)  
41b3 32 72 ee			ld (debug_mark+1),a  
41b6 3a c0 41			ld a, (.dmark+2)  
41b9 32 73 ee			ld (debug_mark+2),a  
41bc 18 03			jr .pastdmark  
41be ..			.dmark: db "CO2"  
41c1 f1			.pastdmark: pop af  
41c2			endm  
# End of macro DMARK
41c2						CALLMONITOR 
41c2 cd 87 14			call break_point_state  
41c5				endm  
# End of macro CALLMONITOR
41c5					endif 
41c5 ed b0				ldir 
41c7			 
41c7			 
41c7			 
41c7 21 d7 e3				ld hl, scratch 
41ca					if DEBUG_FORTH_WORDS 
41ca						DMARK "CO5" 
41ca f5				push af  
41cb 3a df 41			ld a, (.dmark)  
41ce 32 71 ee			ld (debug_mark),a  
41d1 3a e0 41			ld a, (.dmark+1)  
41d4 32 72 ee			ld (debug_mark+1),a  
41d7 3a e1 41			ld a, (.dmark+2)  
41da 32 73 ee			ld (debug_mark+2),a  
41dd 18 03			jr .pastdmark  
41df ..			.dmark: db "CO5"  
41e2 f1			.pastdmark: pop af  
41e3			endm  
# End of macro DMARK
41e3						CALLMONITOR 
41e3 cd 87 14			call break_point_state  
41e6				endm  
# End of macro CALLMONITOR
41e6					endif 
41e6			 
41e6 cd 4f 1b				call forth_push_str 
41e9			 
41e9			 
41e9			 
41e9			 
41e9				       NEXTW 
41e9 c3 4a 1e			jp macro_next 
41ec				endm 
# End of macro NEXTW
41ec			 
41ec			 
41ec			.FIND: 
41ec				CWHEAD .LEN 55 "FIND" 4 WORD_FLAG_CODE 
41ec 4b				db WORD_SYS_CORE+55             
41ed aa 42			dw .LEN            
41ef 05				db 4 + 1 
41f0 .. 00			db "FIND",0              
41f5				endm 
# End of macro CWHEAD
41f5			; | FIND ( s c -- s u ) Search the string s for the char c and push the position of the first occurance to TOS | DONE 
41f5			 
41f5					if DEBUG_FORTH_WORDS_KEY 
41f5						DMARK "FND" 
41f5 f5				push af  
41f6 3a 0a 42			ld a, (.dmark)  
41f9 32 71 ee			ld (debug_mark),a  
41fc 3a 0b 42			ld a, (.dmark+1)  
41ff 32 72 ee			ld (debug_mark+1),a  
4202 3a 0c 42			ld a, (.dmark+2)  
4205 32 73 ee			ld (debug_mark+2),a  
4208 18 03			jr .pastdmark  
420a ..			.dmark: db "FND"  
420d f1			.pastdmark: pop af  
420e			endm  
# End of macro DMARK
420e						CALLMONITOR 
420e cd 87 14			call break_point_state  
4211				endm  
# End of macro CALLMONITOR
4211					endif 
4211			 
4211			; TODO check string type 
4211					FORTH_DSP_VALUE 
4211 cd c1 1c			call macro_forth_dsp_value 
4214				endm 
# End of macro FORTH_DSP_VALUE
4214			 
4214 e5					push hl    
4215 7e					ld a,(hl)    ; char to find   
4216			; TODO change char to substr 
4216			 
4216 f5					push af 
4217					 
4217			 
4217			 
4217					if DEBUG_FORTH_WORDS 
4217						DMARK "FN1" 
4217 f5				push af  
4218 3a 2c 42			ld a, (.dmark)  
421b 32 71 ee			ld (debug_mark),a  
421e 3a 2d 42			ld a, (.dmark+1)  
4221 32 72 ee			ld (debug_mark+1),a  
4224 3a 2e 42			ld a, (.dmark+2)  
4227 32 73 ee			ld (debug_mark+2),a  
422a 18 03			jr .pastdmark  
422c ..			.dmark: db "FN1"  
422f f1			.pastdmark: pop af  
4230			endm  
# End of macro DMARK
4230						CALLMONITOR 
4230 cd 87 14			call break_point_state  
4233				endm  
# End of macro CALLMONITOR
4233					endif 
4233			 
4233					FORTH_DSP_POP 
4233 cd 90 1d			call macro_forth_dsp_pop 
4236				endm 
# End of macro FORTH_DSP_POP
4236			 
4236					; string to search 
4236			 
4236					FORTH_DSP_VALUE 
4236 cd c1 1c			call macro_forth_dsp_value 
4239				endm 
# End of macro FORTH_DSP_VALUE
4239			 
4239 d1					pop de  ; d is char to find  
423a			 
423a					if DEBUG_FORTH_WORDS 
423a						DMARK "FN2" 
423a f5				push af  
423b 3a 4f 42			ld a, (.dmark)  
423e 32 71 ee			ld (debug_mark),a  
4241 3a 50 42			ld a, (.dmark+1)  
4244 32 72 ee			ld (debug_mark+1),a  
4247 3a 51 42			ld a, (.dmark+2)  
424a 32 73 ee			ld (debug_mark+2),a  
424d 18 03			jr .pastdmark  
424f ..			.dmark: db "FN2"  
4252 f1			.pastdmark: pop af  
4253			endm  
# End of macro DMARK
4253						CALLMONITOR 
4253 cd 87 14			call break_point_state  
4256				endm  
# End of macro CALLMONITOR
4256					endif 
4256					 
4256 01 00 00				ld bc, 0 
4259 7e			.findchar:      ld a,(hl) 
425a fe 00				cp 0   		 
425c 28 27				jr z, .finddone     
425e ba					cp d 
425f 28 20				jr z, .foundchar 
4261 03					inc bc 
4262 23					inc hl 
4263					if DEBUG_FORTH_WORDS 
4263						DMARK "FN3" 
4263 f5				push af  
4264 3a 78 42			ld a, (.dmark)  
4267 32 71 ee			ld (debug_mark),a  
426a 3a 79 42			ld a, (.dmark+1)  
426d 32 72 ee			ld (debug_mark+1),a  
4270 3a 7a 42			ld a, (.dmark+2)  
4273 32 73 ee			ld (debug_mark+2),a  
4276 18 03			jr .pastdmark  
4278 ..			.dmark: db "FN3"  
427b f1			.pastdmark: pop af  
427c			endm  
# End of macro DMARK
427c						CALLMONITOR 
427c cd 87 14			call break_point_state  
427f				endm  
# End of macro CALLMONITOR
427f					endif 
427f 18 d8				jr .findchar 
4281			 
4281			 
4281 c5			.foundchar:	push bc 
4282 e1					pop hl 
4283 18 03				jr .findexit 
4285			 
4285			 
4285							 
4285			 
4285			.finddone:     ; got to end of string with no find 
4285 21 00 00				ld hl, 0 
4288			.findexit: 
4288			 
4288					if DEBUG_FORTH_WORDS 
4288						DMARK "FNd" 
4288 f5				push af  
4289 3a 9d 42			ld a, (.dmark)  
428c 32 71 ee			ld (debug_mark),a  
428f 3a 9e 42			ld a, (.dmark+1)  
4292 32 72 ee			ld (debug_mark+1),a  
4295 3a 9f 42			ld a, (.dmark+2)  
4298 32 73 ee			ld (debug_mark+2),a  
429b 18 03			jr .pastdmark  
429d ..			.dmark: db "FNd"  
42a0 f1			.pastdmark: pop af  
42a1			endm  
# End of macro DMARK
42a1						CALLMONITOR 
42a1 cd 87 14			call break_point_state  
42a4				endm  
# End of macro CALLMONITOR
42a4					endif 
42a4 cd e1 1a			call forth_push_numhl 
42a7			 
42a7				       NEXTW 
42a7 c3 4a 1e			jp macro_next 
42aa				endm 
# End of macro NEXTW
42aa			 
42aa			.LEN: 
42aa				CWHEAD .CHAR 56 "COUNT" 5 WORD_FLAG_CODE 
42aa 4c				db WORD_SYS_CORE+56             
42ab df 42			dw .CHAR            
42ad 06				db 5 + 1 
42ae .. 00			db "COUNT",0              
42b4				endm 
# End of macro CWHEAD
42b4			; | COUNT (  u1 -- u2 ) Push the length of the string on TOS | DONE 
42b4			 
42b4					if DEBUG_FORTH_WORDS_KEY 
42b4						DMARK "CNT" 
42b4 f5				push af  
42b5 3a c9 42			ld a, (.dmark)  
42b8 32 71 ee			ld (debug_mark),a  
42bb 3a ca 42			ld a, (.dmark+1)  
42be 32 72 ee			ld (debug_mark+1),a  
42c1 3a cb 42			ld a, (.dmark+2)  
42c4 32 73 ee			ld (debug_mark+2),a  
42c7 18 03			jr .pastdmark  
42c9 ..			.dmark: db "CNT"  
42cc f1			.pastdmark: pop af  
42cd			endm  
# End of macro DMARK
42cd						CALLMONITOR 
42cd cd 87 14			call break_point_state  
42d0				endm  
# End of macro CALLMONITOR
42d0					endif 
42d0			; TODO check string type 
42d0					FORTH_DSP 
42d0 cd 9e 1c			call macro_forth_dsp 
42d3				endm 
# End of macro FORTH_DSP
42d3					;v5FORTH_DSP_VALUE 
42d3			 
42d3 23					inc hl 
42d4			 
42d4 3e 00				ld a, 0 
42d6 cd ef 10				call strlent 
42d9			 
42d9 cd e1 1a				call forth_push_numhl 
42dc			 
42dc			 
42dc			 
42dc				       NEXTW 
42dc c3 4a 1e			jp macro_next 
42df				endm 
# End of macro NEXTW
42df			.CHAR: 
42df				CWHEAD .ENDSTR 57 "CHAR" 4 WORD_FLAG_CODE 
42df 4d				db WORD_SYS_CORE+57             
42e0 15 43			dw .ENDSTR            
42e2 05				db 4 + 1 
42e3 .. 00			db "CHAR",0              
42e8				endm 
# End of macro CWHEAD
42e8			; | CHAR ( u -- n ) Get the ascii value of the first character of the string on the stack | DONE 
42e8					if DEBUG_FORTH_WORDS_KEY 
42e8						DMARK "CHR" 
42e8 f5				push af  
42e9 3a fd 42			ld a, (.dmark)  
42ec 32 71 ee			ld (debug_mark),a  
42ef 3a fe 42			ld a, (.dmark+1)  
42f2 32 72 ee			ld (debug_mark+1),a  
42f5 3a ff 42			ld a, (.dmark+2)  
42f8 32 73 ee			ld (debug_mark+2),a  
42fb 18 03			jr .pastdmark  
42fd ..			.dmark: db "CHR"  
4300 f1			.pastdmark: pop af  
4301			endm  
# End of macro DMARK
4301						CALLMONITOR 
4301 cd 87 14			call break_point_state  
4304				endm  
# End of macro CALLMONITOR
4304					endif 
4304					FORTH_DSP 
4304 cd 9e 1c			call macro_forth_dsp 
4307				endm 
# End of macro FORTH_DSP
4307					;v5 FORTH_DSP_VALUE 
4307 23					inc hl      ; now at start of numeric as string 
4308			 
4308			;		push hl 
4308			 
4308					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4308 cd 90 1d			call macro_forth_dsp_pop 
430b				endm 
# End of macro FORTH_DSP_POP
430b			 
430b			;		pop hl 
430b			 
430b					; push the content of a onto the stack as a value 
430b			 
430b 7e					ld a,(hl)   ; get char 
430c 26 00				ld h,0 
430e 6f					ld l,a 
430f cd e1 1a				call forth_push_numhl 
4312			 
4312				       NEXTW 
4312 c3 4a 1e			jp macro_next 
4315				endm 
# End of macro NEXTW
4315			 
4315			 
4315			 
4315			 
4315			.ENDSTR: 
4315			; eof 
4315			 
# End of file forth_words_str.asm
4315			include "forth_words_key.asm" 
4315			 
4315			; | ## Keyboard Words 
4315			 
4315			.KEY: 
4315				CWHEAD .WAITK 42 "KEY" 3 WORD_FLAG_CODE 
4315 3e				db WORD_SYS_CORE+42             
4316 45 43			dw .WAITK            
4318 04				db 3 + 1 
4319 .. 00			db "KEY",0              
431d				endm 
# End of macro CWHEAD
431d			; | KEY ( -- w f ) Scan for keypress but do not wait true if next item on stack is key press | TODO 
431d			 
431d					if DEBUG_FORTH_WORDS_KEY 
431d						DMARK "KEY" 
431d f5				push af  
431e 3a 32 43			ld a, (.dmark)  
4321 32 71 ee			ld (debug_mark),a  
4324 3a 33 43			ld a, (.dmark+1)  
4327 32 72 ee			ld (debug_mark+1),a  
432a 3a 34 43			ld a, (.dmark+2)  
432d 32 73 ee			ld (debug_mark+2),a  
4330 18 03			jr .pastdmark  
4332 ..			.dmark: db "KEY"  
4335 f1			.pastdmark: pop af  
4336			endm  
# End of macro DMARK
4336						CALLMONITOR 
4336 cd 87 14			call break_point_state  
4339				endm  
# End of macro CALLMONITOR
4339					endif 
4339			; TODO currently waits 
4339 cd 35 5a				call cin 
433c					;call cin_wait 
433c 6f					ld l, a 
433d 26 00				ld h, 0 
433f cd e1 1a				call forth_push_numhl 
4342					NEXTW 
4342 c3 4a 1e			jp macro_next 
4345				endm 
# End of macro NEXTW
4345			.WAITK: 
4345				CWHEAD .ACCEPT 43 "WAITK" 5 WORD_FLAG_CODE 
4345 3f				db WORD_SYS_CORE+43             
4346 77 43			dw .ACCEPT            
4348 06				db 5 + 1 
4349 .. 00			db "WAITK",0              
434f				endm 
# End of macro CWHEAD
434f			; | WAITK ( -- w ) Wait for keypress TOS is key press | DONE 
434f					if DEBUG_FORTH_WORDS_KEY 
434f						DMARK "WAI" 
434f f5				push af  
4350 3a 64 43			ld a, (.dmark)  
4353 32 71 ee			ld (debug_mark),a  
4356 3a 65 43			ld a, (.dmark+1)  
4359 32 72 ee			ld (debug_mark+1),a  
435c 3a 66 43			ld a, (.dmark+2)  
435f 32 73 ee			ld (debug_mark+2),a  
4362 18 03			jr .pastdmark  
4364 ..			.dmark: db "WAI"  
4367 f1			.pastdmark: pop af  
4368			endm  
# End of macro DMARK
4368						CALLMONITOR 
4368 cd 87 14			call break_point_state  
436b				endm  
# End of macro CALLMONITOR
436b					endif 
436b cd 2d 5a				call cin_wait 
436e 6f					ld l, a 
436f 26 00				ld h, 0 
4371 cd e1 1a				call forth_push_numhl 
4374					NEXTW 
4374 c3 4a 1e			jp macro_next 
4377				endm 
# End of macro NEXTW
4377			.ACCEPT: 
4377				CWHEAD .EDIT 44 "ACCEPT" 6 WORD_FLAG_CODE 
4377 40				db WORD_SYS_CORE+44             
4378 d5 43			dw .EDIT            
437a 07				db 6 + 1 
437b .. 00			db "ACCEPT",0              
4382				endm 
# End of macro CWHEAD
4382			; | ACCEPT ( -- w ) Prompt for text input and push pointer to string | DONE 
4382					; TODO crashes on push 
4382					if DEBUG_FORTH_WORDS_KEY 
4382						DMARK "ACC" 
4382 f5				push af  
4383 3a 97 43			ld a, (.dmark)  
4386 32 71 ee			ld (debug_mark),a  
4389 3a 98 43			ld a, (.dmark+1)  
438c 32 72 ee			ld (debug_mark+1),a  
438f 3a 99 43			ld a, (.dmark+2)  
4392 32 73 ee			ld (debug_mark+2),a  
4395 18 03			jr .pastdmark  
4397 ..			.dmark: db "ACC"  
439a f1			.pastdmark: pop af  
439b			endm  
# End of macro DMARK
439b						CALLMONITOR 
439b cd 87 14			call break_point_state  
439e				endm  
# End of macro CALLMONITOR
439e					endif 
439e 21 d5 e5				ld hl, os_input 
43a1 3e 00				ld a, 0 
43a3 77					ld (hl),a 
43a4 3a 40 eb				ld a,(f_cursor_ptr) 
43a7 16 64				ld d, 100 
43a9 0e 00				ld c, 0 
43ab 1e 28				ld e, 40 
43ad cd b3 0c				call input_str 
43b0					; TODO perhaps do a type check and wrap in quotes if not a number 
43b0 21 d5 e5				ld hl, os_input 
43b3					if DEBUG_FORTH_WORDS 
43b3						DMARK "AC1" 
43b3 f5				push af  
43b4 3a c8 43			ld a, (.dmark)  
43b7 32 71 ee			ld (debug_mark),a  
43ba 3a c9 43			ld a, (.dmark+1)  
43bd 32 72 ee			ld (debug_mark+1),a  
43c0 3a ca 43			ld a, (.dmark+2)  
43c3 32 73 ee			ld (debug_mark+2),a  
43c6 18 03			jr .pastdmark  
43c8 ..			.dmark: db "AC1"  
43cb f1			.pastdmark: pop af  
43cc			endm  
# End of macro DMARK
43cc						CALLMONITOR 
43cc cd 87 14			call break_point_state  
43cf				endm  
# End of macro CALLMONITOR
43cf					endif 
43cf cd 4f 1b				call forth_push_str 
43d2					NEXTW 
43d2 c3 4a 1e			jp macro_next 
43d5				endm 
# End of macro NEXTW
43d5			 
43d5			.EDIT: 
43d5				CWHEAD .ENDKEY 44 "EDIT" 4 WORD_FLAG_CODE 
43d5 40				db WORD_SYS_CORE+44             
43d6 77 44			dw .ENDKEY            
43d8 05				db 4 + 1 
43d9 .. 00			db "EDIT",0              
43de				endm 
# End of macro CWHEAD
43de			; | EDIT ( u -- u ) Takes string on TOS and allows editing of it. Pushes it back once done. | DONE 
43de			 
43de					; TODO does not copy from stack 
43de					if DEBUG_FORTH_WORDS_KEY 
43de						DMARK "EDT" 
43de f5				push af  
43df 3a f3 43			ld a, (.dmark)  
43e2 32 71 ee			ld (debug_mark),a  
43e5 3a f4 43			ld a, (.dmark+1)  
43e8 32 72 ee			ld (debug_mark+1),a  
43eb 3a f5 43			ld a, (.dmark+2)  
43ee 32 73 ee			ld (debug_mark+2),a  
43f1 18 03			jr .pastdmark  
43f3 ..			.dmark: db "EDT"  
43f6 f1			.pastdmark: pop af  
43f7			endm  
# End of macro DMARK
43f7						CALLMONITOR 
43f7 cd 87 14			call break_point_state  
43fa				endm  
# End of macro CALLMONITOR
43fa					endif 
43fa			 
43fa					;FORTH_DSP 
43fa					FORTH_DSP_VALUEHL 
43fa cd d8 1c			call macro_dsp_valuehl 
43fd				endm 
# End of macro FORTH_DSP_VALUEHL
43fd			;		inc hl    ; TODO do type check 
43fd			 
43fd			;		call get_word_hl 
43fd e5					push hl 
43fe					if DEBUG_FORTH_WORDS 
43fe						DMARK "EDp" 
43fe f5				push af  
43ff 3a 13 44			ld a, (.dmark)  
4402 32 71 ee			ld (debug_mark),a  
4405 3a 14 44			ld a, (.dmark+1)  
4408 32 72 ee			ld (debug_mark+1),a  
440b 3a 15 44			ld a, (.dmark+2)  
440e 32 73 ee			ld (debug_mark+2),a  
4411 18 03			jr .pastdmark  
4413 ..			.dmark: db "EDp"  
4416 f1			.pastdmark: pop af  
4417			endm  
# End of macro DMARK
4417						CALLMONITOR 
4417 cd 87 14			call break_point_state  
441a				endm  
# End of macro CALLMONITOR
441a					endif 
441a				;	ld a, 0 
441a cd e4 10				call strlenz 
441d 23					inc hl 
441e			 
441e 06 00				ld b, 0 
4420 4d					ld c, l 
4421			 
4421 e1					pop hl 
4422 11 d5 e5				ld de, os_input 
4425					if DEBUG_FORTH_WORDS_KEY 
4425						DMARK "EDc" 
4425 f5				push af  
4426 3a 3a 44			ld a, (.dmark)  
4429 32 71 ee			ld (debug_mark),a  
442c 3a 3b 44			ld a, (.dmark+1)  
442f 32 72 ee			ld (debug_mark+1),a  
4432 3a 3c 44			ld a, (.dmark+2)  
4435 32 73 ee			ld (debug_mark+2),a  
4438 18 03			jr .pastdmark  
443a ..			.dmark: db "EDc"  
443d f1			.pastdmark: pop af  
443e			endm  
# End of macro DMARK
443e						CALLMONITOR 
443e cd 87 14			call break_point_state  
4441				endm  
# End of macro CALLMONITOR
4441					endif 
4441 ed b0				ldir 
4443			 
4443			 
4443 21 d5 e5				ld hl, os_input 
4446					;ld a, 0 
4446					;ld (hl),a 
4446 3a 40 eb				ld a,(f_cursor_ptr) 
4449 16 64				ld d, 100 
444b 0e 00				ld c, 0 
444d 1e 28				ld e, 40 
444f cd b3 0c				call input_str 
4452					; TODO perhaps do a type check and wrap in quotes if not a number 
4452 21 d5 e5				ld hl, os_input 
4455					if DEBUG_FORTH_WORDS 
4455						DMARK "ED1" 
4455 f5				push af  
4456 3a 6a 44			ld a, (.dmark)  
4459 32 71 ee			ld (debug_mark),a  
445c 3a 6b 44			ld a, (.dmark+1)  
445f 32 72 ee			ld (debug_mark+1),a  
4462 3a 6c 44			ld a, (.dmark+2)  
4465 32 73 ee			ld (debug_mark+2),a  
4468 18 03			jr .pastdmark  
446a ..			.dmark: db "ED1"  
446d f1			.pastdmark: pop af  
446e			endm  
# End of macro DMARK
446e						CALLMONITOR 
446e cd 87 14			call break_point_state  
4471				endm  
# End of macro CALLMONITOR
4471					endif 
4471 cd 4f 1b				call forth_push_str 
4474					NEXTW 
4474 c3 4a 1e			jp macro_next 
4477				endm 
# End of macro NEXTW
4477			 
4477			 
4477			 
4477			.ENDKEY: 
4477			; eof 
4477			 
# End of file forth_words_key.asm
4477			 
4477			if STORAGE_SE 
4477			   	include "forth_words_storage.asm" 
4477			endif 
4477				include "forth_words_device.asm" 
4477			; Device related words 
4477			 
4477			; | ## Device Words 
4477			 
4477			if SOUND_ENABLE 
4477			.NOTE: 
4477				CWHEAD .AFTERSOUND 31 "NOTE" 4 WORD_FLAG_CODE 
4477			; | NOTE ( ud uf --  )  Plays a note of frequency uf for the duration of ud millseconds | TODO 
4477					if DEBUG_FORTH_WORDS_KEY 
4477						DMARK "NTE" 
4477						CALLMONITOR 
4477					endif 
4477			 
4477				 
4477			 
4477					NEXTW 
4477			.AFTERSOUND: 
4477			endif 
4477			 
4477			 
4477			USE_GPIO: equ 0 
4477			 
4477			if USE_GPIO 
4477			.GP1: 
4477				CWHEAD .GP2 31 "IOIN" 4 WORD_FLAG_CODE 
4477			; | IOIN ( u1 -- u )    Perform a GPIO read of pin u1 and push result  |  
4477					NEXTW 
4477			.GP2: 
4477				CWHEAD .GP3 31 "IOOUT" 5 WORD_FLAG_CODE 
4477			; | IOOUT ( u1 u2 --  )    Perform a GPIO write of pin u1 with pin set to 0 or 1 in u2  |  
4477			 
4477					NEXTW 
4477			 
4477			.GP3: 
4477				CWHEAD .GP4 31 "IOBYTE" 5 WORD_FLAG_CODE 
4477			; | IOBYTE ( u1 --  )    Perform a GPIO write of byte u1  |  
4477			 
4477					NEXTW 
4477			 
4477			.GP4: 
4477				CWHEAD .SIN 31 "IOSET" 5 WORD_FLAG_CODE 
4477			; | IOSET ( u1 --  )    Setup GPIO pins for I/O direction. Bit is set for write else read pin  |  
4477			 
4477					NEXTW 
4477			.SIN: 
4477			 
4477			 
4477			endif 
4477			 
4477			 
4477				CWHEAD .SOUT 31 "IN" 2 WORD_FLAG_CODE 
4477 33				db WORD_SYS_CORE+31             
4478 ac 44			dw .SOUT            
447a 03				db 2 + 1 
447b .. 00			db "IN",0              
447e				endm 
# End of macro CWHEAD
447e			; | IN ( u1 -- u )    Perform Z80 IN with u1 being the port number. Push result to TOS | TO TEST 
447e					if DEBUG_FORTH_WORDS_KEY 
447e						DMARK "IN." 
447e f5				push af  
447f 3a 93 44			ld a, (.dmark)  
4482 32 71 ee			ld (debug_mark),a  
4485 3a 94 44			ld a, (.dmark+1)  
4488 32 72 ee			ld (debug_mark+1),a  
448b 3a 95 44			ld a, (.dmark+2)  
448e 32 73 ee			ld (debug_mark+2),a  
4491 18 03			jr .pastdmark  
4493 ..			.dmark: db "IN."  
4496 f1			.pastdmark: pop af  
4497			endm  
# End of macro DMARK
4497						CALLMONITOR 
4497 cd 87 14			call break_point_state  
449a				endm  
# End of macro CALLMONITOR
449a					endif 
449a					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
449a cd d8 1c			call macro_dsp_valuehl 
449d				endm 
# End of macro FORTH_DSP_VALUEHL
449d			 
449d e5					push hl 
449e			 
449e					; destroy value TOS 
449e			 
449e					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
449e cd 90 1d			call macro_forth_dsp_pop 
44a1				endm 
# End of macro FORTH_DSP_POP
44a1			 
44a1					; one value on hl get other one back 
44a1			 
44a1 c1					pop bc 
44a2			 
44a2					; do the sub 
44a2			;		ex de, hl 
44a2			 
44a2 ed 68				in l,(c) 
44a4			 
44a4					; save it 
44a4			 
44a4 26 00				ld h,0 
44a6			 
44a6					; TODO push value back onto stack for another op etc 
44a6			 
44a6 cd e1 1a				call forth_push_numhl 
44a9					NEXTW 
44a9 c3 4a 1e			jp macro_next 
44ac				endm 
# End of macro NEXTW
44ac			.SOUT: 
44ac				CWHEAD .SPIO 32 "OUT" 3 WORD_FLAG_CODE 
44ac 34				db WORD_SYS_CORE+32             
44ad ff 44			dw .SPIO            
44af 04				db 3 + 1 
44b0 .. 00			db "OUT",0              
44b4				endm 
# End of macro CWHEAD
44b4			; | OUT ( u1 u2 -- ) Perform Z80 OUT to port u2 sending byte u1 | DONE 
44b4					if DEBUG_FORTH_WORDS_KEY 
44b4						DMARK "OUT" 
44b4 f5				push af  
44b5 3a c9 44			ld a, (.dmark)  
44b8 32 71 ee			ld (debug_mark),a  
44bb 3a ca 44			ld a, (.dmark+1)  
44be 32 72 ee			ld (debug_mark+1),a  
44c1 3a cb 44			ld a, (.dmark+2)  
44c4 32 73 ee			ld (debug_mark+2),a  
44c7 18 03			jr .pastdmark  
44c9 ..			.dmark: db "OUT"  
44cc f1			.pastdmark: pop af  
44cd			endm  
# End of macro DMARK
44cd						CALLMONITOR 
44cd cd 87 14			call break_point_state  
44d0				endm  
# End of macro CALLMONITOR
44d0					endif 
44d0			 
44d0					; get port 
44d0			 
44d0					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44d0 cd d8 1c			call macro_dsp_valuehl 
44d3				endm 
# End of macro FORTH_DSP_VALUEHL
44d3			 
44d3 e5					push hl 
44d4			 
44d4					; destroy value TOS 
44d4			 
44d4					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44d4 cd 90 1d			call macro_forth_dsp_pop 
44d7				endm 
# End of macro FORTH_DSP_POP
44d7			 
44d7					; get byte to send 
44d7			 
44d7					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44d7 cd d8 1c			call macro_dsp_valuehl 
44da				endm 
# End of macro FORTH_DSP_VALUEHL
44da			 
44da			;		push hl 
44da			 
44da					; destroy value TOS 
44da			 
44da					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44da cd 90 1d			call macro_forth_dsp_pop 
44dd				endm 
# End of macro FORTH_DSP_POP
44dd			 
44dd					; one value on hl get other one back 
44dd			 
44dd			;		pop hl 
44dd			 
44dd c1					pop bc 
44de			 
44de					if DEBUG_FORTH_WORDS 
44de						DMARK "OUT" 
44de f5				push af  
44df 3a f3 44			ld a, (.dmark)  
44e2 32 71 ee			ld (debug_mark),a  
44e5 3a f4 44			ld a, (.dmark+1)  
44e8 32 72 ee			ld (debug_mark+1),a  
44eb 3a f5 44			ld a, (.dmark+2)  
44ee 32 73 ee			ld (debug_mark+2),a  
44f1 18 03			jr .pastdmark  
44f3 ..			.dmark: db "OUT"  
44f6 f1			.pastdmark: pop af  
44f7			endm  
# End of macro DMARK
44f7						CALLMONITOR 
44f7 cd 87 14			call break_point_state  
44fa				endm  
# End of macro CALLMONITOR
44fa					endif 
44fa			 
44fa ed 69				out (c), l 
44fc			 
44fc					NEXTW 
44fc c3 4a 1e			jp macro_next 
44ff				endm 
# End of macro NEXTW
44ff			 
44ff			 
44ff			.SPIO: 
44ff			 
44ff			if STORAGE_SE 
44ff				CWHEAD .SPICEH 61 "SPICEL" 6 WORD_FLAG_CODE 
44ff			; | SPICEL ( -- ) Set SPI CE low for the currently selected device |  DONE 
44ff			 
44ff					call spi_ce_low 
44ff			    NEXTW 
44ff			 
44ff			.SPICEH: 
44ff				CWHEAD .SPIOb 61 "SPICEH" 6 WORD_FLAG_CODE 
44ff			; | SPICEH ( -- ) Set SPI CE high for the currently selected device |  DONE 
44ff			 
44ff					call spi_ce_high 
44ff			    NEXTW 
44ff			 
44ff			 
44ff			.SPIOb: 
44ff			 
44ff				CWHEAD .SPII 61 "SPIO" 4 WORD_FLAG_CODE 
44ff			; | SPIO ( u1 -- ) Send byte u1 to SPI  |  DONE 
44ff			 
44ff					; get port 
44ff			 
44ff			 
44ff					; get byte to send 
44ff			 
44ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44ff			 
44ff			;		push hl    ; u1  
44ff			 
44ff					; destroy value TOS 
44ff			 
44ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44ff			 
44ff					; one value on hl get other one back 
44ff			 
44ff			;		pop hl   ; u2 - addr 
44ff			 
44ff					; TODO Send SPI byte 
44ff			 
44ff					ld a, l 
44ff					call spi_send_byte 
44ff			 
44ff					NEXTW 
44ff			 
44ff			.SPII: 
44ff				CWHEAD .SESEL 62 "SPII" 5 WORD_FLAG_CODE 
44ff			; | SPII ( -- u1 ) Get a byte from SPI  | DONE 
44ff			 
44ff					; TODO Get SPI byte 
44ff			 
44ff					call spi_read_byte 
44ff			 
44ff					ld h, 0 
44ff					ld l, a 
44ff					call forth_push_numhl 
44ff			 
44ff					NEXTW 
44ff			 
44ff			 
44ff			 
44ff			.SESEL: 
44ff				CWHEAD .CARTDEV 82 "BANK" 4 WORD_FLAG_CODE 
44ff			; | BANK ( u1 -- ) Select Serial EEPROM Bank Device at bank address u1 1-5 (disables CARTDEV). Set to zero to disable storage. | DONE 
44ff					if DEBUG_FORTH_WORDS_KEY 
44ff						DMARK "BNK" 
44ff						CALLMONITOR 
44ff					endif 
44ff			 
44ff					ld a, 255 
44ff					ld (spi_cartdev), a 
44ff			 
44ff					; get bank 
44ff			 
44ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44ff			 
44ff			;		push hl 
44ff			 
44ff					; destroy value TOS 
44ff			 
44ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44ff			 
44ff					; one value on hl get other one back 
44ff			 
44ff			;		pop hl 
44ff			 
44ff			 
44ff					ld c, SPI_CE_HIGH 
44ff					ld b, '0'    ; human readable bank number 
44ff			 
44ff					ld a, l 
44ff			 
44ff					if DEBUG_FORTH_WORDS 
44ff						DMARK "BNK" 
44ff						CALLMONITOR 
44ff					endif 
44ff			 
44ff					; active low 
44ff			 
44ff					cp 0 
44ff					jr z, .bset 
44ff					cp 1 
44ff					jr nz, .b2 
44ff					res 0, c 
44ff					ld b, '1'    ; human readable bank number 
44ff			.b2:		cp 2 
44ff					jr nz, .b3 
44ff					res 1, c 
44ff					ld b, '2'    ; human readable bank number 
44ff			.b3:		cp 3 
44ff					jr nz, .b4 
44ff					res 2, c 
44ff					ld b, '3'    ; human readable bank number 
44ff			.b4:		cp 4 
44ff					jr nz, .b5 
44ff					res 3, c 
44ff					ld b, '4'    ; human readable bank number 
44ff			.b5:		cp 5 
44ff					jr nz, .bset 
44ff					res 4, c 
44ff					ld b, '5'    ; human readable bank number 
44ff			 
44ff			.bset: 
44ff					ld a, c 
44ff					ld (spi_device),a 
44ff					ld a, b 
44ff					ld (spi_device_id),a 
44ff					if DEBUG_FORTH_WORDS 
44ff						DMARK "BN2" 
44ff						CALLMONITOR 
44ff					endif 
44ff			 
44ff					NEXTW 
44ff			 
44ff			.CARTDEV: 
44ff				CWHEAD .ENDDEVICE 82 "CARTDEV" 7 WORD_FLAG_CODE 
44ff			; | CARTDEV ( u1 -- ) Select cart device 1-8 (Disables BANK). Set to zero to disable devices. |  DONE 
44ff					if DEBUG_FORTH_WORDS_KEY 
44ff						DMARK "CDV" 
44ff						CALLMONITOR 
44ff					endif 
44ff			 
44ff					; disable se storage bank selection 
44ff			 
44ff					ld a, SPI_CE_HIGH		; ce high 
44ff					ld (spi_device), a 
44ff			 
44ff					; get bank 
44ff			 
44ff					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
44ff			 
44ff			;		push hl 
44ff			 
44ff					; destroy value TOS 
44ff			 
44ff					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
44ff			 
44ff					; one value on hl get other one back 
44ff			 
44ff			;		pop hl 
44ff			 
44ff					; active low 
44ff			 
44ff					ld c, 255 
44ff			 
44ff					ld a, l 
44ff					if DEBUG_FORTH_WORDS 
44ff						DMARK "CDV" 
44ff						CALLMONITOR 
44ff					endif 
44ff					cp 0 
44ff					jr z, .cset 
44ff					cp 1 
44ff					jr nz, .c2 
44ff					res 0, c 
44ff			.c2:		cp 2 
44ff					jr nz, .c3 
44ff					res 1, c 
44ff			.c3:		cp 3 
44ff					jr nz, .c4 
44ff					res 2, c 
44ff			.c4:		cp 4 
44ff					jr nz, .c5 
44ff					res 3, c 
44ff			.c5:		cp 5 
44ff					jr nz, .c6 
44ff					res 4, c 
44ff			.c6:		cp 6 
44ff					jr nz, .c7 
44ff					res 5, c 
44ff			.c7:		cp 7 
44ff					jr nz, .c8 
44ff					res 6, c 
44ff			.c8:		cp 8 
44ff					jr nz, .cset 
44ff					res 7, c 
44ff			.cset:		ld a, c 
44ff					ld (spi_cartdev),a 
44ff			 
44ff					if DEBUG_FORTH_WORDS 
44ff						DMARK "CD2" 
44ff						CALLMONITOR 
44ff					endif 
44ff					NEXTW 
44ff			endif 
44ff			 
44ff			.ENDDEVICE: 
44ff			; eof 
44ff			 
# End of file forth_words_device.asm
44ff			 
44ff			; var handler 
44ff			 
44ff			 
44ff			.VARS: 
44ff				CWHEAD .V0Q 100 "V0!" 3 WORD_FLAG_CODE 
44ff 78				db WORD_SYS_CORE+100             
4500 17 45			dw .V0Q            
4502 04				db 3 + 1 
4503 .. 00			db "V0!",0              
4507				endm 
# End of macro CWHEAD
4507			;| V0! ( u1 -- )  Store value to v0  | DONE 
4507			 
4507					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4507 cd d8 1c			call macro_dsp_valuehl 
450a				endm 
# End of macro FORTH_DSP_VALUEHL
450a			 
450a 11 0a eb				ld de, cli_var_array 
450d			 
450d eb					ex de, hl 
450e 73					ld (hl), e 
450f 23					inc hl 
4510 72					ld (hl), d 
4511			 
4511					; destroy value TOS 
4511			 
4511					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4511 cd 90 1d			call macro_forth_dsp_pop 
4514				endm 
# End of macro FORTH_DSP_POP
4514			 
4514				       NEXTW 
4514 c3 4a 1e			jp macro_next 
4517				endm 
# End of macro NEXTW
4517			.V0Q: 
4517				CWHEAD .V1S 101 "V0@" 3 WORD_FLAG_CODE 
4517 79				db WORD_SYS_CORE+101             
4518 28 45			dw .V1S            
451a 04				db 3 + 1 
451b .. 00			db "V0@",0              
451f				endm 
# End of macro CWHEAD
451f			;| V0@ ( --u )  Put value of v0 onto stack | DONE 
451f 2a 0a eb				ld hl, (cli_var_array) 
4522 cd e1 1a				call forth_push_numhl 
4525			 
4525				       NEXTW 
4525 c3 4a 1e			jp macro_next 
4528				endm 
# End of macro NEXTW
4528			.V1S: 
4528				CWHEAD .V1Q 102 "V1!" 3 WORD_FLAG_CODE 
4528 7a				db WORD_SYS_CORE+102             
4529 40 45			dw .V1Q            
452b 04				db 3 + 1 
452c .. 00			db "V1!",0              
4530				endm 
# End of macro CWHEAD
4530			;| V1! ( u1 -- )  Store value to v1 | DONE 
4530					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4530 cd d8 1c			call macro_dsp_valuehl 
4533				endm 
# End of macro FORTH_DSP_VALUEHL
4533			 
4533 11 0c eb				ld de, cli_var_array+2 
4536				 
4536 eb					ex de, hl 
4537 73					ld (hl), e 
4538 23					inc hl 
4539 72					ld (hl), d 
453a			 
453a					; destroy value TOS 
453a			 
453a					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
453a cd 90 1d			call macro_forth_dsp_pop 
453d				endm 
# End of macro FORTH_DSP_POP
453d				       NEXTW 
453d c3 4a 1e			jp macro_next 
4540				endm 
# End of macro NEXTW
4540			.V1Q: 
4540				CWHEAD .V2S 103 "V1@" 3 WORD_FLAG_CODE 
4540 7b				db WORD_SYS_CORE+103             
4541 51 45			dw .V2S            
4543 04				db 3 + 1 
4544 .. 00			db "V1@",0              
4548				endm 
# End of macro CWHEAD
4548			;| V1@ ( --u )  Put value of v1 onto stack | DONE 
4548 2a 0c eb				ld hl, (cli_var_array+2) 
454b cd e1 1a				call forth_push_numhl 
454e				       NEXTW 
454e c3 4a 1e			jp macro_next 
4551				endm 
# End of macro NEXTW
4551			.V2S: 
4551				CWHEAD .V2Q 104 "V2!" 3 WORD_FLAG_CODE 
4551 7c				db WORD_SYS_CORE+104             
4552 69 45			dw .V2Q            
4554 04				db 3 + 1 
4555 .. 00			db "V2!",0              
4559				endm 
# End of macro CWHEAD
4559			;| V2! ( u1 -- )  Store value to v2 | DONE 
4559					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4559 cd d8 1c			call macro_dsp_valuehl 
455c				endm 
# End of macro FORTH_DSP_VALUEHL
455c			 
455c 11 0e eb				ld de, cli_var_array+4 
455f				 
455f eb					ex de, hl 
4560 73					ld (hl), e 
4561 23					inc hl 
4562 72					ld (hl), d 
4563			 
4563					; destroy value TOS 
4563			 
4563					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
4563 cd 90 1d			call macro_forth_dsp_pop 
4566				endm 
# End of macro FORTH_DSP_POP
4566				       NEXTW 
4566 c3 4a 1e			jp macro_next 
4569				endm 
# End of macro NEXTW
4569			.V2Q: 
4569				CWHEAD .V3S 105 "V2@" 3 WORD_FLAG_CODE 
4569 7d				db WORD_SYS_CORE+105             
456a 7a 45			dw .V3S            
456c 04				db 3 + 1 
456d .. 00			db "V2@",0              
4571				endm 
# End of macro CWHEAD
4571			;| V2@ ( --u )  Put value of v2 onto stack | DONE 
4571 2a 0e eb				ld hl, (cli_var_array+4) 
4574 cd e1 1a				call forth_push_numhl 
4577				       NEXTW 
4577 c3 4a 1e			jp macro_next 
457a				endm 
# End of macro NEXTW
457a			.V3S: 
457a				CWHEAD .V3Q 104 "V3!" 3 WORD_FLAG_CODE 
457a 7c				db WORD_SYS_CORE+104             
457b 92 45			dw .V3Q            
457d 04				db 3 + 1 
457e .. 00			db "V3!",0              
4582				endm 
# End of macro CWHEAD
4582			;| V3! ( u1 -- )  Store value to v3 | DONE 
4582					FORTH_DSP_VALUEHL     			; TODO skip type check and assume number.... lol 
4582 cd d8 1c			call macro_dsp_valuehl 
4585				endm 
# End of macro FORTH_DSP_VALUEHL
4585			 
4585 11 10 eb				ld de, cli_var_array+6 
4588				 
4588 eb					ex de, hl 
4589 73					ld (hl), e 
458a 23					inc hl 
458b 72					ld (hl), d 
458c			 
458c					; destroy value TOS 
458c			 
458c					FORTH_DSP_POP  ; TODO add stock underflow checks and throws  
458c cd 90 1d			call macro_forth_dsp_pop 
458f				endm 
# End of macro FORTH_DSP_POP
458f				       NEXTW 
458f c3 4a 1e			jp macro_next 
4592				endm 
# End of macro NEXTW
4592			.V3Q: 
4592				CWHEAD .END 105 "V3@" 3 WORD_FLAG_CODE 
4592 7d				db WORD_SYS_CORE+105             
4593 a3 45			dw .END            
4595 04				db 3 + 1 
4596 .. 00			db "V3@",0              
459a				endm 
# End of macro CWHEAD
459a			;| V3@ ( --u )  Put value of v3 onto stack | DONE 
459a 2a 10 eb				ld hl, (cli_var_array+6) 
459d cd e1 1a				call forth_push_numhl 
45a0				       NEXTW 
45a0 c3 4a 1e			jp macro_next 
45a3				endm 
# End of macro NEXTW
45a3			 
45a3			 
45a3			 
45a3			 
45a3			 
45a3			; end of dict marker 
45a3			 
45a3 00			.END:    db WORD_SYS_END 
45a4 00 00			dw 0 
45a6 00				db 0 
45a7			 
45a7			; use to jp here for user dict words to save on macro expansion  
45a7			 
45a7			user_dict_next: 
45a7				NEXTW 
45a7 c3 4a 1e			jp macro_next 
45aa				endm 
# End of macro NEXTW
45aa			 
45aa			 
45aa			user_exec: 
45aa				;    ld hl, <word code> 
45aa				;    FORTH_RSP_NEXT - call macro_forth_rsp_next 
45aa				;    call forthexec 
45aa				;    jp user_dict_next   (NEXT) 
45aa			        ;    <word code bytes> 
45aa eb				ex de, hl 
45ab 2a d8 e6			ld hl,(os_tok_ptr) 
45ae				 
45ae				FORTH_RSP_NEXT 
45ae cd 88 1a			call macro_forth_rsp_next 
45b1				endm 
# End of macro FORTH_RSP_NEXT
45b1			 
45b1			if DEBUG_FORTH_UWORD 
45b1						DMARK "UEX" 
45b1 f5				push af  
45b2 3a c6 45			ld a, (.dmark)  
45b5 32 71 ee			ld (debug_mark),a  
45b8 3a c7 45			ld a, (.dmark+1)  
45bb 32 72 ee			ld (debug_mark+1),a  
45be 3a c8 45			ld a, (.dmark+2)  
45c1 32 73 ee			ld (debug_mark+2),a  
45c4 18 03			jr .pastdmark  
45c6 ..			.dmark: db "UEX"  
45c9 f1			.pastdmark: pop af  
45ca			endm  
# End of macro DMARK
45ca				CALLMONITOR 
45ca cd 87 14			call break_point_state  
45cd				endm  
# End of macro CALLMONITOR
45cd			endif 
45cd			 
45cd			 
45cd			 
45cd eb				ex de, hl 
45ce 22 d8 e6			ld (os_tok_ptr), hl 
45d1				 
45d1				; Don't use next - Skips the first word in uword. 
45d1			 
45d1 c3 db 1e			jp exec1 
45d4			;	NEXT 
45d4			 
45d4			 
45d4			; eof 
# End of file forth_wordsv4.asm
45d4			endif 
45d4			;;;;;;;;;;;;;; Debug code 
45d4			 
45d4			 
45d4			;if DEBUG_FORTH_PARSE 
45d4 .. 00		.nowordfound: db "No match",0 
45dd .. 00		.compword:	db "Comparing word ",0 
45ed .. 00		.nextwordat:	db "Next word at",0 
45fa .. 00		.charmatch:	db "Char match",0 
4605			;endif 
4605			if DEBUG_FORTH_JP 
4605			.foundword:	db "Word match. Exec..",0 
4605			endif 
4605			;if DEBUG_FORTH_PUSH 
4605 .. 00		.enddict:	db "Dict end. Push.",0 
4615 .. 00		.push_str:	db "Pushing string",0 
4624 .. 00		.push_num:	db "Pushing number",0 
4633 .. 00		.data_sp:	db "SP:",0 
4637 .. 00		.wordinhl:	db "Word in HL (2/0):",0 
4649 .. 00		.wordinde:	db "Word in DE (3/0):",0 
465b .. 00		.wordinbc:	db "Word in BC (4/0):",0 
466d			;endif 
466d			;if DEBUG_FORTH_MALLOC 
466d .. 00		.push_malloc:	db "Malloc address",0 
467c			;endif 
467c			 
467c			 
467c			 
467c			; display malloc address and current data stack pointer  
467c			 
467c			malloc_error: 
467c d5				push de 
467d f5				push af 
467e e5				push hl 
467f cd 59 0a			call clear_display 
4682 11 a4 46			ld de, .mallocerr 
4685 3e 00			ld a,0 
4687			;	ld de,os_word_scratch 
4687 cd 6c 0a			call str_at_display 
468a 3e 11			ld a, display_row_1+17 
468c 11 71 ee			ld de, debug_mark 
468f cd 6c 0a			call str_at_display 
4692 cd 7c 0a			call update_display 
4695				;call break_point_state 
4695 cd 2d 5a			call cin_wait 
4698			 
4698 3e 20			ld a, ' ' 
469a 32 c8 e3			ld (os_view_disable), a 
469d e1				pop hl 
469e f1				pop af 
469f d1				pop de	 
46a0				CALLMONITOR 
46a0 cd 87 14			call break_point_state  
46a3				endm  
# End of macro CALLMONITOR
46a3 c9				ret 
46a4			 
46a4 .. 00		.mallocerr: 	db "Malloc Error",0 
46b1			;if DEBUG_FORTH_PUSH 
46b1			display_data_sp: 
46b1 f5				push af 
46b2			 
46b2				; see if disabled 
46b2			 
46b2 3a c8 e3			ld a, (os_view_disable) 
46b5 fe 2a			cp '*' 
46b7 28 67			jr z, .skipdsp 
46b9			 
46b9 e5				push hl 
46ba e5				push hl 
46bb e5			push hl 
46bc cd 59 0a			call clear_display 
46bf e1			pop hl 
46c0 7c				ld a,h 
46c1 21 dc e6			ld hl, os_word_scratch 
46c4 cd 87 0f			call hexout 
46c7 e1				pop hl 
46c8 7d				ld a,l 
46c9 21 de e6			ld hl, os_word_scratch+2 
46cc cd 87 0f			call hexout 
46cf 21 e0 e6			ld hl, os_word_scratch+4 
46d2 3e 00			ld a,0 
46d4 77				ld (hl),a 
46d5 11 dc e6			ld de,os_word_scratch 
46d8 3e 28				ld a, display_row_2 
46da cd 6c 0a				call str_at_display 
46dd 11 37 46			ld de, .wordinhl 
46e0 3e 00			ld a, display_row_1 
46e2			 
46e2 cd 6c 0a				call str_at_display 
46e5 11 71 ee			ld de, debug_mark 
46e8 3e 11			ld a, display_row_1+17 
46ea			 
46ea cd 6c 0a				call str_at_display 
46ed			 
46ed				; display current data stack pointer 
46ed 11 33 46			ld de,.data_sp 
46f0 3e 30				ld a, display_row_2 + 8 
46f2 cd 6c 0a				call str_at_display 
46f5			 
46f5 2a 04 eb			ld hl,(cli_data_sp) 
46f8 e5				push hl 
46f9 7c				ld a,h 
46fa 21 dc e6			ld hl, os_word_scratch 
46fd cd 87 0f			call hexout 
4700 e1				pop hl 
4701 7d				ld a,l 
4702 21 de e6			ld hl, os_word_scratch+2 
4705 cd 87 0f			call hexout 
4708 21 e0 e6			ld hl, os_word_scratch+4 
470b 3e 00			ld a,0 
470d 77				ld (hl),a 
470e 11 dc e6			ld de,os_word_scratch 
4711 3e 33				ld a, display_row_2 + 11 
4713 cd 6c 0a				call str_at_display 
4716			 
4716			 
4716 cd 7c 0a			call update_display 
4719 cd cb 09			call delay1s 
471c cd cb 09			call delay1s 
471f e1				pop hl 
4720			.skipdsp: 
4720 f1				pop af 
4721 c9				ret 
4722			 
4722			display_data_malloc: 
4722			 
4722 f5				push af 
4723 e5				push hl 
4724 e5				push hl 
4725 e5			push hl 
4726 cd 59 0a			call clear_display 
4729 e1			pop hl 
472a 7c				ld a,h 
472b 21 dc e6			ld hl, os_word_scratch 
472e cd 87 0f			call hexout 
4731 e1				pop hl 
4732 7d				ld a,l 
4733 21 de e6			ld hl, os_word_scratch+2 
4736 cd 87 0f			call hexout 
4739 21 e0 e6			ld hl, os_word_scratch+4 
473c 3e 00			ld a,0 
473e 77				ld (hl),a 
473f 11 dc e6			ld de,os_word_scratch 
4742 3e 28				ld a, display_row_2 
4744 cd 6c 0a				call str_at_display 
4747 11 6d 46			ld de, .push_malloc 
474a 3e 00			ld a, display_row_1 
474c			 
474c cd 6c 0a				call str_at_display 
474f			 
474f				; display current data stack pointer 
474f 11 33 46			ld de,.data_sp 
4752 3e 30				ld a, display_row_2 + 8 
4754 cd 6c 0a				call str_at_display 
4757			 
4757 2a 04 eb			ld hl,(cli_data_sp) 
475a e5				push hl 
475b 7c				ld a,h 
475c 21 dc e6			ld hl, os_word_scratch 
475f cd 87 0f			call hexout 
4762 e1				pop hl 
4763 7d				ld a,l 
4764 21 de e6			ld hl, os_word_scratch+2 
4767 cd 87 0f			call hexout 
476a 21 e0 e6			ld hl, os_word_scratch+4 
476d 3e 00			ld a,0 
476f 77				ld (hl),a 
4770 11 dc e6			ld de,os_word_scratch 
4773 3e 33				ld a, display_row_2 + 11 
4775 cd 6c 0a				call str_at_display 
4778			 
4778 cd 7c 0a			call update_display 
477b cd cb 09			call delay1s 
477e cd cb 09			call delay1s 
4781 e1				pop hl 
4782 f1				pop af 
4783 c9				ret 
4784			;endif 
4784			 
4784			include "forth_autostart.asm" 
4784			; list of commands to perform at system start up 
4784			 
4784			startcmds: 
4784			;	dw test11 
4784			;	dw test12 
4784			;	dw test13 
4784			;	dw test14 
4784			;	dw test15 
4784			;	dw test16 
4784			;	dw test17 
4784			;	dw ifthtest1 
4784			;	dw ifthtest2 
4784			;	dw ifthtest3 
4784			;	dw mmtest1 
4784			;	dw mmtest2 
4784			;	dw mmtest3 
4784			;	dw mmtest4 
4784			;	dw mmtest5 
4784			;	dw mmtest6 
4784			;	dw iftest1 
4784			;	dw iftest2 
4784			;	dw iftest3 
4784			;	dw looptest1 
4784			;	dw looptest2 
4784			;	dw test1 
4784			;	dw test2 
4784			;	dw test3 
4784			;	dw test4 
4784			;	dw game2r 
4784			;	dw game2b1 
4784			;	dw game2b2 
4784			 
4784				; start up words that are actually useful 
4784			 
4784 e2 47			dw clrstack 
4786 15 48			dw type 
4788 05 4a			dw stest 
478a 39 48			dw strncpy 
478c 9b 49			dw list 
478e 9a 48			dw start1 
4790 ac 48			dw start2 
4792			;	dw start3 
4792 bf 48			dw start3b 
4794 3b 49			dw start3c 
4796			 
4796				; (unit) testing words 
4796			 
4796 7c 4a			dw mtesta 
4798 31 4b			dw mtestb 
479a d4 4b			dw mtestc 
479c 89 4c			dw mtestd 
479e 2d 4d			dw mteste 
47a0			 
47a0				; demo/game words 
47a0			 
47a0 39 54		        dw game3w 
47a2 67 54		        dw game3p 
47a4 85 54		        dw game3sc 
47a6 b6 54		        dw game3vsi 
47a8 e2 54		        dw game3vs 
47aa				 
47aa 2c 52			dw game2b 
47ac 9a 52			dw game2bf 
47ae e4 52			dw game2mba 
47b0 7a 53			dw game2mbas 
47b2 bc 53			dw game2mb 
47b4			 
47b4 ed 4e			dw game1 
47b6 fe 4e			dw game1a 
47b8 60 4f			dw game1b 
47ba 95 4f			dw game1c 
47bc cb 4f			dw game1d 
47be fc 4f			dw game1s 
47c0 10 50			dw game1t 
47c2 25 50			dw game1f 
47c4 59 50			dw game1z 
47c6 9d 50			dw game1zz 
47c8			 
47c8 e3 4d			dw test5 
47ca 1b 4e			dw test6 
47cc 53 4e			dw test7 
47ce 67 4e			dw test8 
47d0 93 4e			dw test9 
47d2 a9 4e			dw test10 
47d4				 
47d4 74 51		        dw ssv5 
47d6 58 51		        dw ssv4 
47d8 3c 51		        dw ssv3 
47da 06 51		        dw ssv2 
47dc 8d 51		        dw ssv1 
47de d5 51		        dw ssv1cpm 
47e0			;	dw keyup 
47e0			;	dw keydown 
47e0			;	dw keyleft 
47e0			;	dw keyright 
47e0			;	dw 	keyf1 
47e0			;	dw keyf2 
47e0			;	dw keyf3 
47e0			;	dw keyf4 
47e0			;	dw keyf5 
47e0			;	dw keyf6 
47e0			;	dw keyf7 
47e0			;	dw keyf8 
47e0			;	dw keyf9 
47e0			;	dw keyf10 
47e0			;	dw keyf11 
47e0			;	dw keyf12 
47e0			;	dw keytab 
47e0			;	dw keycr 
47e0			;	dw keyhome 
47e0			;	dw keyend 
47e0			;	dw keybs 
47e0 00 00			db 0, 0	 
47e2			 
47e2			 
47e2			; clear stack  
47e2			 
47e2 .. 00		clrstack:  db ": clrstk depth ?dup if $01 do drop loop then nop ;", 0 
4815			 
4815			; type ( addr count - ) 
4815 .. 00		type:     db ": type $00 do dup i + @ emit loop ;", 0 
4839			 
4839			; some direct memory words 
4839			; strncpy ( len t f -- t ) 
4839			 
4839 .. 00		strncpy:   db ": strncpy $00 scratch 2! $02 scratch 2! do $00 scratch 2@ i + @ $02 scratch 2@ i + ! loop nop  ;",0 
489a			 
489a .. 00		start1:     	db ": bpon $0000 bp ;",0 
48ac .. 00		start2:     	db ": bpoff $0001 bp ;",0 
48bf .. 00		start3b:         db ": dla dir cls drop dup $00 > if $01 do $08 $04 at . $01 $04 at . $04 $04 at . $23 $04 at accept drop scroll loop then nop ;",0 
493b .. 00		start3c:         db ": dirlist dir cls drop dup $00 > if $01 do \"/\" .> .> \"Ext:\" .> .> \"Id: \" .> .>  loop then nop ;",0 
499b			 
499b			 
499b			; a handy word to list items on the stack 
499b			 
499b .. 00		list:            db ": more cls repeat scroll $01 $04 at depth . $0a $04 at .> $01 $01 at accept drop depth 0= not until nop ;",0 
4a05			 
4a05			 
4a05			; test stack  
4a05			; rnd8 stest 
4a05			 
4a05 .. 00		stest:   db ": stest cls  v0! v0@ $00 do rnd8 $01 $01 at i . $01 pause loop v0@ $00 do drop $12 $01 at depth . $01 pause loop nop ;",0  
4a7c			 
4a7c			; random malloc and free cycles 
4a7c			 
4a7c .. 00		mtesta:      db ": mtesta $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup $13 $01 at . malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4b31			 
4b31			; fixed malloc and free cycles 
4b31			 
4b31 .. 00		mtestb:      db ": mtestb $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 malloc heap $1f $01 at . $1f $02 at . $01 pause free $01 until nop ;", 0 
4bd4			 
4bd4			; fixed double string push and drop cycle  
4bd4			 
4bd4 .. 00		mtestc:      db ": mtestc $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces $2f spaces  heap $1f $01 at . $1f $02 at . $01 pause drop drop $01 until nop ; ", 0 
4c89			 
4c89			; consistent fixed string push and drop cycle  
4c89			 
4c89 .. 00		mtestd:      db ": mtestd $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . $80 spaces heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4d2d			 
4d2d .. 00		mteste:      db ": mteste $01 v0! repeat heap cls $01 $01 at v0@ . v0@ $01 + v0! $08 $01 at . $08 $02 at . rnd8 dup spaces $0f $02 at . heap $1f $01 at . $1f $02 at . $01 pause drop $01 until nop ; ", 0 
4de3			 
4de3			;test1:		db ": aa 1 2 3 ;", 0 
4de3			;test2:     	db "111 aa 888 999",0 
4de3			;test3:     	db ": bb 77 ;",0 
4de3			;test4:     	db "$02 $01 do i . loop bb",0 
4de3			 
4de3 .. 00		test5:     	db ": hline $13 $00 do i $01 at 1 . i $04 at 1 . loop nop ;",0 
4e1b .. 00		test6:     	db ": vline $04 $01 do $00 i at 1 . $13 i at 1 . loop nop ;",0 
4e53 .. 00		test7:     	db ": box hline vline ;",0 
4e67 .. 00		test8:     	db ": world cls box $03 $03 at Hello-World! . ;",0 
4e93 .. 00		test9:     	db ": sw $01 adsp world ;",0 
4ea9 .. 00		test10:     	db ": fw $00 adsp world draw $05 pause ;",0 
4ece .. 00		test11:     	db "hello create .",0 
4edd .. 00		test12:     	db "hello2 create .",0 
4eed			 
4eed			;mmtest1:     	db "cls $0001 $0008 MIN . $0002 pause",0 
4eed			;mmtest2:     	db "cls $0101 $0008 MIN . $0002 pause",0 
4eed			;mmtest3:     	db "cls $0001 $0008 MAX . $0002 pause",0 
4eed			;mmtest4:     	db "cls $0101 $0008 MAX . $0002 pause",0 
4eed			;mmtest5:     	db "cls $0001 $0001 MIN . $0002 pause",0 
4eed			;mmtest6:     	db "cls $0001 $0001 MAX . $0002 pause",0 
4eed			 
4eed			;iftest1:     	db "$0001 IF cls .",0 
4eed			;iftest2:     	db "$0000 IF cls .",0 
4eed			;iftest3:     	db "$0002 $0003 - IF cls .",0 
4eed			;looptest1:     	db "$0003 $0001 do i . loop 8",0 
4eed			;looptest2:     	db "$0003 $0001 do i . $0001 pause loop 8",0 
4eed			 
4eed			;ifthtest1:     	db "$0001 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4eed			;ifthtest2:     	db "$0000 IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4eed			;ifthtest3:     	db "$0002 $0003 - IF is-true . $0005 pause THEN next-word . $0005 pause",0 
4eed			 
4eed			 
4eed			 
4eed			; a small guess the number game 
4eed			 
4eed .. 00		game1:          db ": gsn rnd8 v1! ;",0 
4efe .. 00		game1a:          db ": gs $00 $00 at Enter-a-number .- $00 $02 at between-1-and-255 .- $00 $03 at accept str2num v2! ;",0 
4f60			 
4f60 .. 00		game1b:          db ": gcb v2@ v1@ < if $00 $00 at Too-low! .- $01 then ;",0 
4f95 .. 00		game1c:          db ": gcc v2@ v1@ > if $00 $00 at Too-high! .- $01 then ;",0 
4fcb .. 00		game1d:          db ": gcd v2@ v1@ = if $00 $00 at Yes! .- $00 then ;",0 
4ffc .. 00		game1s:          db ": gck gcb gcc gcd ;",0 
5010 .. 00		game1t:          db ": sc v3@ $01 + v3! ;",0 
5025 .. 00		game1f:          db ": fsc v3@ cls $01 $01 at You-Took .- $02 $03 at . ;",0 
5059 .. 00		game1z:         db ": ga $00 v3! gsn repeat cls gs cls gck $02 pause sc until fsc nop ;",0 
509d			 
509d			; Using 'ga' save a high score across multiple runs using external storage 
509d			 
509d .. 00		game1zz:         db ": gas ga $01 bank $80 bread $01 $04 at Prev-Score .> storepage ptr $02 + dup 2@ . v3@ swap 2! $80 bupd ;",0 
5106			 
5106			 
5106			;game2r:          db ": m2r rnd8 v1! ;  ",0, 0, 0, FORTH_END_BUFFER 
5106			;game2b1:          db ": m2b1 $1f $00 do i v2@ at rnd8 $30 < if A . then loop nop ;  ",0, 0, 0, FORTH_END_BUFFER 
5106			;game2b2:          db ": m2b cls $04 $01 do i v2! m2b1 loop ;  ",0, 0, 0, FORTH_END_BUFFER 
5106			 
5106			; simple screen saver to test code memory reuse to destruction 
5106			 
5106 .. 00		ssv2:            db ": ssvchr $2a $2d rnd dup $2c = if drop $20 then nop ;",0 
513c .. 00		ssv3:            db ": ssvposx $01 $27 rnd v0! ;",0 
5158 .. 00		ssv4:            db ": ssvposy $01 $05 rnd v1! ;",0 
5174 .. 00		ssv5:            db ": ssvt ssvposx ssvposy ;",0 
518d .. 00		ssv1:          db ": ssv cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 until nop ;",0 
51d5 .. 00		ssv1cpm:          db ": ssvcpm cls repeat ssvposx ssvposy v0@ v1@ at ssvchr emit $01 pausems $01 until nop ;",0 
522c			;ssv1:          db ": ssv cls repeat ssvt v0@ v1@ at ssvchr emit $01 until nop ;",0 
522c			;ssv1:          db ": ssv ssvposx ssvposy at ssvchr ;",0 
522c			;ssv1:            db ": ssv repeat ssvpos rnd8 $10 if               $01 until nop ;",0 
522c			;ssv2:            db ": ssvchr v0! v1! at? ;",0 
522c			;ssv5:            db ": ssvt ssvposx ssvposy v0@ .> v1@ .> ;",0 
522c			;ssv2:            db ": ssvchr $2a $2d rnd  ;",0 
522c			 
522c			 
522c			 
522c			; minesweeper/battleship finding game 
522c			; draws a game board of random ship/mine positions 
522c			; user enters coords to see if it hits on 
522c			; game ends when all are hit 
522c			; when hit or miss says how many may be in the area 
522c			 
522c			; setup the game board and then hide it 
522c .. 00		game2b:          db ": mbsetup $02 fb cls $04 $01 do i v2! $10 $01 do i v2@ at rnd8 $30 < if A . then loop loop $05 pause $01 fb ;",0 
529a .. 00		game2bf:         db ": mbsetupf cls $04 $01 do i v2! $10 $01 do i v2@ at \"+\" . loop loop nop ;",0 
52e4			; prompt for where to target 
52e4 .. 00		game2mba:        db ": mbp $12 $04 at Turns .> v3@ . $12 $03 at Score .> v0@ . $12 $01 at Enter-X-__ .- $1a $01 at accept $12 $02 at Enter-Y-__ .- $1a $02 at accept nop ;", 0  
537a .. 00		game2mbas:        db ": mbsv str2num v2! str2num v1! nop ;", 0  
539f			; TODO see if the entered coords hits or misses pushes char hit of miss 
539f .. 00		game2mbht:      db ": mbckht nop ;",0 
53ae .. 00		game2mbms:      db ": mbcms nop ;",0 
53bc			; TODO how many might be near by 
53bc .. 00		game2mb:          db ": mb $00 v0! $00 v3! mbsetup mbsetupf repeat mbp mbsv $02 fb mbckht mbcms v1@ v2@ at@ $01 fb v1@ v2@ at emit $01 until nop ;",0 
5439			 
5439			; Game 3 
5439			 
5439			; Vert scroller ski game - avoid the trees! 
5439			 
5439			; v0 score (ie turns) 
5439			; v1 player pos 
5439			; v2 left wall 
5439			; v3 right wall 
5439			 
5439			; Draw side walls randomly 
5439			 
5439 .. 00		game3w:   db ": vsw v2@ $04 at \"|\" . v3@ $04 at \"|\" . nop ;", 0 
5467			 
5467			; Draw player 
5467 .. 00		game3p:   db ": vsp v1@ $01 at \"V\" . nop ; ", 0 
5485			 
5485			; TODO Get Key 
5485			 
5485			; TODO Move left right 
5485			 
5485			; scroll and move walls a bit 
5485			 
5485 .. 00		game3sc:  db ": vsscl v2@ $01 + v2! v3@ $01 - v3! scroll nop ;", 0 
54b6			 
54b6			; main game loop 
54b6			 
54b6 .. 00		game3vsi:    db ": vsi $00 v0! $01 v2! $12 v3! $06 v1! nop ;",0 
54e2 .. 00		game3vs:    db ": vs vsi repeat vsw vsp vsscl $05 pause scroll $01 until nop ;",0 
5521			 
5521			; key board defs 
5521			 
5521 .. 00		keyup:       db ": keyup $05 ;",0 
552f .. 00		keydown:       db ": keydown $0a ;",0 
553f .. 00		keyleft:       db ": keyleft $0b ;",0 
554f .. 00		keyright:       db ": keyright $0c ;",0 
5560 .. 00		keyf1:       db ": keyf1 $10 ;",0 
556e .. 00		keyf2:       db ": keyf2 $11 ;",0 
557c .. 00		keyf3:       db ": keyf3 $12 ;",0 
558a .. 00		keyf4:       db ": keyf4 $13 ;",0 
5598 .. 00		keyf5:       db ": keyf5 $14 ;",0 
55a6 .. 00		keyf6:       db ": keyf6 $15 ;",0 
55b4 .. 00		keyf7:       db ": keyf7 $16 ;",0 
55c2 .. 00		keyf8:       db ": keyf8 $17 ;",0 
55d0 .. 00		keyf9:       db ": keyf9 $18 ;",0 
55de .. 00		keyf10:       db ": keyf10 $19 ;",0 
55ed .. 00		keyf11:       db ": keyf11 $1a ;",0 
55fc .. 00		keyf12:       db ": keyf12 $1b ;",0 
560b			 
560b .. 00		keytab:       db ": keytab $09 ;",0 
561a .. 00		keycr:       db ": keycr $0d ;",0 
5628 .. 00		keyhome:       db ": keyhome $0e ;",0 
5638 .. 00		keyend:       db ": keyend $0f ;",0 
5647 .. 00		keybs:       db ": keybs $08 ;",0 
5655			 
5655			   
5655			 
5655			 
5655			 
5655			; eof 
# End of file forth_autostart.asm
5655			 
5655 .. 00		sprompt1: db "Startup load...",0 
5665 .. 00		sprompt2: db "Run? 1=No *=End #=All",0 
567b			 
567b			 
567b			 
567b			 
567b			forth_startup: 
567b 21 84 47			ld hl, startcmds 
567e 3e 00			ld a, 0 
5680 32 fd e7			ld (os_last_cmd), a    ; tmp var to skip prompts if doing all 
5683			 
5683 e5			.start1:	push hl 
5684 cd 59 0a			call clear_display 
5687 11 55 56			ld de, sprompt1 
568a 3e 00		        ld a, display_row_1 
568c cd 6c 0a			call str_at_display 
568f 11 65 56			ld de, sprompt2 
5692 3e 28		        ld a, display_row_2 
5694 cd 6c 0a			call str_at_display 
5697 e1				pop hl 
5698 e5				push hl 
5699 5e				ld e,(hl) 
569a 23				inc hl 
569b 56				ld d,(hl) 
569c 3e 50		        ld a, display_row_3 
569e cd 6c 0a			call str_at_display 
56a1 cd 7c 0a			call update_display 
56a4			 
56a4			 
56a4 3a fd e7			ld a, (os_last_cmd) 
56a7 fe 00			cp 0 
56a9 28 05			jr z, .startprompt 
56ab cd bf 09			call delay250ms 
56ae 18 24			jr .startdo 
56b0				 
56b0				 
56b0			 
56b0			.startprompt: 
56b0			 
56b0 3e 9f			ld a,display_row_4 + display_cols - 1 
56b2 11 57 1a		        ld de, endprg 
56b5 cd 6c 0a			call str_at_display 
56b8 cd 7c 0a			call update_display 
56bb cd cb 09			call delay1s 
56be cd 2d 5a			call cin_wait 
56c1						 
56c1 fe 2a			cp '*' 
56c3 28 5e			jr z, .startupend1 
56c5 fe 23			cp '#' 
56c7 20 07			jr nz, .startno 
56c9 3e 01			ld a, 1 
56cb 32 fd e7			ld (os_last_cmd),a 
56ce 18 04			jr .startdo 
56d0 fe 31		.startno:	cp '1' 
56d2 28 3a			jr z,.startnxt  
56d4			 
56d4				; exec startup line 
56d4			.startdo:	 
56d4 e1				pop hl 
56d5 e5				push hl 
56d6				 
56d6 5e				ld e,(hl) 
56d7 23				inc hl 
56d8 56				ld d,(hl) 
56d9 eb				ex de,hl 
56da			 
56da e5				push hl 
56db			 
56db 3e 00			ld a, 0 
56dd				;ld a, FORTH_END_BUFFER 
56dd cd ef 10			call strlent 
56e0 23				inc hl   ; include zero term to copy 
56e1 06 00			ld b,0 
56e3 4d				ld c,l 
56e4 e1				pop hl 
56e5 11 d7 e3			ld de, scratch 
56e8 ed b0			ldir 
56ea			 
56ea			 
56ea 21 d7 e3			ld hl, scratch 
56ed cd 98 1e			call forthparse 
56f0 cd d8 1e			call forthexec 
56f3 cd ef 1d			call forthexec_cleanup 
56f6			 
56f6 3e 78			ld a, display_row_4 
56f8 11 fb 17			ld de, endprog 
56fb			 
56fb cd 7c 0a			call update_display		 
56fe			 
56fe 3a fd e7			ld a, (os_last_cmd) 
5701 fe 00			cp 0 
5703 20 09			jr nz, .startnxt 
5705 cd 59 1a			call next_page_prompt 
5708 cd 59 0a		        call clear_display 
570b cd 7c 0a			call update_display		 
570e			 
570e				; move onto next startup line? 
570e			.startnxt: 
570e			 
570e cd bf 09			call delay250ms 
5711 e1				pop hl 
5712			 
5712 23				inc hl 
5713 23				inc hl 
5714			 
5714 e5				push hl 
5715 5e				ld e, (hl) 
5716 23				inc hl 
5717 56				ld d, (hl) 
5718 e1				pop hl 
5719				; TODO replace 0 test 
5719			 
5719 eb				ex de, hl 
571a cd af 0c			call ishlzero 
571d			;	ld a,e 
571d			;	add d 
571d			;	cp 0    ; any left to do? 
571d eb				ex de, hl 
571e c2 83 56			jp nz, .start1 
5721 18 01			jr .startupend 
5723			 
5723 e1			.startupend1: pop hl 
5724			.startupend: 
5724			 
5724 cd 59 0a			call clear_display 
5727 cd 7c 0a			call update_display 
572a c9				ret 
572b			 
572b			 
572b			; stack over and underflow checks 
572b			 
572b			; init the words to detect the under/overflow 
572b			 
572b			chk_stk_init: 
572b				; a vague random number to check so we dont get any "lucky" hits 
572b 3e 2d			ld a, 45 
572d 6f				ld l, a 
572e 00				nop 
572f 3e 17			ld a, 23 
5731 67				ld h, a 
5732			 
5732 22 be e3			ld (chk_word), hl     ; the word we need to check against 
5735			 
5735			;	ld (chk_stund), hl	; stack points.... 
5735 22 00 ef			ld (chk_stovr), hl 
5738 22 02 eb			ld (chk_ret_und), hl 
573b 22 c0 ea			ld (chk_ret_ovr), hl 
573e 22 3e ea			ld (chk_loop_ovr), hl 
5741 22 3c e9			ld (chk_data_ovr), hl 
5744 c9				ret 
5745				 
5745			check_stacks: 
5745				; check all stack words 
5745			 
5745 e5				push hl 
5746 d5				push de 
5747			 
5747			;	ld de,(chk_word) 
5747			;	ld hl, (chk_stund)	; stack points.... 
5747			;	if DEBUG_STK_FAULT 
5747			;		DMARK "FAa" 
5747			;		CALLMONITOR 
5747			;	endif 
5747			;	call cmp16 
5747			;	jp z, .chk_faulta 
5747			; 
5747			;	ld de, sfaultsu 
5747			;	jp .chk_fault 
5747			 
5747 2a 00 ef		.chk_faulta: ld hl, (chk_stovr) 
574a ed 5b be e3		ld de,(chk_word) 
574e				if DEBUG_STK_FAULT 
574e					DMARK "FAb" 
574e					CALLMONITOR 
574e				endif 
574e cd a4 0c			call cmp16 
5751 28 06			jr z, .chk_fault1 
5753 11 f4 57			ld de, sfaultso 
5756 c3 a8 57			jp .chk_fault 
5759			.chk_fault1:  
5759 2a 02 eb			ld hl, (chk_ret_und) 
575c ed 5b be e3		ld de,(chk_word) 
5760				if DEBUG_STK_FAULT 
5760					DMARK "FAU" 
5760					CALLMONITOR 
5760				endif 
5760 cd a4 0c			call cmp16 
5763 ca 6c 57			jp z, .chk_fault2 
5766 11 04 58			ld de, sfaultru 
5769 c3 a8 57			jp .chk_fault 
576c			.chk_fault2:  
576c 2a c0 ea			ld hl, (chk_ret_ovr) 
576f ed 5b be e3		ld de,(chk_word) 
5773				if DEBUG_STK_FAULT 
5773					DMARK "FA1" 
5773					CALLMONITOR 
5773				endif 
5773 cd a4 0c			call cmp16 
5776 ca 7f 57			jp z, .chk_fault3 
5779 11 12 58			ld de, sfaultro 
577c c3 a8 57			jp .chk_fault 
577f			.chk_fault3:  
577f 2a 3e ea			ld hl, (chk_loop_ovr) 
5782 ed 5b be e3		ld de,(chk_word) 
5786				if DEBUG_STK_FAULT 
5786					DMARK "FA2" 
5786					CALLMONITOR 
5786				endif 
5786 cd a4 0c			call cmp16 
5789 ca 92 57			jp z, .chk_fault4 
578c 11 2c 58			ld de, sfaultlo 
578f c3 a8 57			jp .chk_fault 
5792			.chk_fault4:  
5792 2a 3c e9			ld hl, (chk_data_ovr) 
5795 ed 5b be e3		ld de,(chk_word) 
5799				if DEBUG_STK_FAULT 
5799					DMARK "FA3" 
5799					CALLMONITOR 
5799				endif 
5799 cd a4 0c			call cmp16 
579c ca a5 57			jp z, .chk_fault5 
579f 11 46 58			ld de, sfaultdo 
57a2 c3 a8 57			jp .chk_fault 
57a5			 
57a5			 
57a5			.chk_fault5:  
57a5 d1				pop de 
57a6 e1				pop hl 
57a7			 
57a7 c9				ret 
57a8			 
57a8 cd 59 0a		.chk_fault: 	call clear_display 
57ab 3e 28				ld a, display_row_2 
57ad cd 6c 0a				call str_at_display 
57b0 11 d6 57				   ld de, .stackfault 
57b3 3e 00				ld a, display_row_1 
57b5 cd 6c 0a				call str_at_display 
57b8 11 71 ee				    ld de, debug_mark 
57bb 3e 11				ld a, display_row_1+17 
57bd cd 6c 0a				call str_at_display 
57c0 cd 7c 0a				call update_display 
57c3			 
57c3				; prompt before entering montior for investigating issue 
57c3			 
57c3 3e 78			ld a, display_row_4 
57c5 11 fb 17			ld de, endprog 
57c8			 
57c8 cd 7c 0a			call update_display		 
57cb			 
57cb cd 59 1a			call next_page_prompt 
57ce			 
57ce d1				pop de 
57cf e1				pop hl 
57d0 cd 4f 18				call monitor 
57d3 c3 49 17				jp warmstart 
57d6					;jp 0 
57d6					;halt 
57d6			 
57d6			 
57d6			 
57d6 .. 00		.stackfault: 	db "Stack fault:",0 
57e3			 
57e3 .. 00		sfaultsu: 	db	"Stack under flow",0 
57f4 .. 00		sfaultso: 	db	"Stack over flow",0 
5804 .. 00		sfaultru:	db "RTS underflow",0 
5812 .. 00		sfaultro:	db "RTS overflow/LS underflow", 0 
582c .. 00		sfaultlo:	db "LS overflow/DTS underflow", 0 
5846 .. 00		sfaultdo:	db "DTS overflow", 0 
5853			 
5853			 
5853			fault_dsp_under: 
5853 11 65 58			ld de, .dsp_under 
5856 c3 15 59			jp .show_fault 
5859			 
5859			fault_rsp_under: 
5859 11 73 58			ld de, .rsp_under 
585c c3 15 59			jp .show_fault 
585f			fault_loop_under: 
585f 11 81 58			ld de, .loop_under 
5862 c3 15 59			jp .show_fault 
5865			 
5865 .. 00		.dsp_under: db "DSP Underflow",0 
5873 .. 00		.rsp_under: db "RSP Underflow",0 
5881 .. 00		.loop_under: db "LOOP Underflow",0 
5890			 
5890			 
5890 d5			type_faultn: 	push de 
5891 e5					push hl 
5892 cd 59 0a				call clear_display 
5895 11 bc 58				   ld de, .typefaultn 
5898 3e 00				ld a, display_row_1 
589a cd 6c 0a				call str_at_display 
589d 11 71 ee				    ld de, debug_mark 
58a0 3e 11				ld a, display_row_1+17 
58a2 cd 6c 0a				call str_at_display 
58a5 cd 7c 0a				call update_display 
58a8			 
58a8				; prompt before entering montior for investigating issue 
58a8			 
58a8 3e 78			ld a, display_row_4 
58aa 11 fb 17			ld de, endprog 
58ad			 
58ad cd 7c 0a			call update_display		 
58b0			 
58b0 cd 59 1a			call next_page_prompt 
58b3			 
58b3 e5					push hl 
58b4 d5					push de 
58b5 cd 4f 18				call monitor 
58b8 c3 49 17				jp warmstart 
58bb 76					halt 
58bc			 
58bc			 
58bc .. 00		.typefaultn: db "NUM Type Expected TOS!",0 
58d3			 
58d3 d5			type_faults: 	push de 
58d4 e5					push hl 
58d5 cd 59 0a				call clear_display 
58d8 11 fe 58				   ld de, .typefaults 
58db 3e 00				ld a, display_row_1 
58dd cd 6c 0a				call str_at_display 
58e0 11 71 ee				    ld de, debug_mark 
58e3 3e 11				ld a, display_row_1+17 
58e5 cd 6c 0a				call str_at_display 
58e8 cd 7c 0a				call update_display 
58eb			 
58eb				; prompt before entering montior for investigating issue 
58eb			 
58eb 3e 78			ld a, display_row_4 
58ed 11 fb 17			ld de, endprog 
58f0			 
58f0 cd 7c 0a			call update_display		 
58f3			 
58f3 cd 59 1a			call next_page_prompt 
58f6			 
58f6 e1					pop hl 
58f7 d1					pop de 
58f8 cd 4f 18				call monitor 
58fb c3 49 17				jp warmstart 
58fe			 
58fe			 
58fe .. 00		.typefaults: db "STR Type Expected TOS!",0 
5915			 
5915			.show_fault: 	 
5915 d5					push de 
5916 cd 59 0a				call clear_display 
5919 d1					pop de 
591a 3e 00				ld a, display_row_1 
591c cd 6c 0a				call str_at_display 
591f 11 71 ee				    ld de, debug_mark 
5922 3e 11				ld a, display_row_1+17 
5924 cd 6c 0a				call str_at_display 
5927 cd 7c 0a				call update_display 
592a			 
592a				; prompt before entering montior for investigating issue 
592a			 
592a 3e 78			ld a, display_row_4 
592c 11 fb 17			ld de, endprog 
592f			 
592f cd 7c 0a			call update_display		 
5932			 
5932 cd 59 1a			call next_page_prompt 
5935			 
5935 e1					pop hl 
5936 d1					pop de 
5937 cd 4f 18				call monitor 
593a			; do a dump to cli and not warmstart so we preserve all of the uwords.  
593a			; TODO Make optional fault restart to cli or warm boot? 
593a					;jp warmstart 
593a c3 a1 17				jp cli 
593d 76					halt 
593e			 
593e			; handle the auto run of code from files in storage 
593e			 
593e			 
593e			if STORAGE_SE 
593e			 
593e			sprompt3: db "Loading from start-up file?:",0 
593e			sprompt4: db "(Y=Any key/N=No)",0 
593e			 
593e			 
593e			forth_autoload: 
593e			 
593e				; load block 0 of store 1 
593e				 
593e				ld a, $fe      ; bit 0 clear 
593e				ld (spi_device), a 
593e			 
593e				call storage_get_block_0 
593e			 
593e				ld a, (store_page+STORE_0_AUTOFILE) 
593e			 
593e				cp 0 
593e				ret z     ; auto start not enabled 
593e			 
593e				call clear_display 
593e			 
593e				; set bank 
593e			 
593e					ld a, (store_page+STORE_0_BANKRUN) 
593e					ld (spi_device), a 
593e			 
593e				; get file id to load from and get the file name to display 
593e			 
593e					ld a, (store_page+STORE_0_FILERUN) 
593e			 
593e					ld l, 0 
593e					ld h, a 
593e					ld de, store_page 
593e			 
593e					if DEBUG_FORTH_WORDS 
593e						DMARK "ASp" 
593e						CALLMONITOR 
593e					endif 
593e					call storage_read 
593e			 
593e					if DEBUG_FORTH_WORDS 
593e						DMARK "ASr" 
593e						CALLMONITOR 
593e					endif 
593e			 
593e					call ishlzero 
593e					ret z             ; file not found 
593e			 
593e					ld a, display_row_2 + 10 
593e					ld de, store_page+3 
593e					call str_at_display 
593e				 
593e			; 
593e			 
593e				ld a, display_row_1+5 
593e				ld de, sprompt3 
593e				call str_at_display 
593e				ld a, display_row_3+15 
593e				ld de, sprompt4 
593e				call str_at_display 
593e			 
593e				call update_display 
593e			 
593e				call cin_wait 
593e				cp 'n' 
593e				ret z 
593e				cp 'N' 
593e				ret z 
593e			 
593e				call delay1s 
593e			 
593e				ld a, (store_page+2) 
593e				ld (store_openmaxext), a    ; save count of ext 
593e				ld a, 1  
593e				ld (store_openext), a    ; save count of ext 
593e			 
593e			.autof:  
593e				ld l , a 
593e				 
593e				ld a, (store_page) 
593e				ld h, a	 
593e				ld de, store_page 
593e					if DEBUG_FORTH_WORDS 
593e						DMARK "ASl" 
593e						CALLMONITOR 
593e					endif 
593e					call storage_read 
593e				call ishlzero 
593e				ret z 
593e			;	jr z, .autoend 
593e			 
593e					if DEBUG_FORTH_WORDS 
593e						DMARK "ASc" 
593e						CALLMONITOR 
593e					endif 
593e				ld de, store_page+2 
593e				ld a, display_row_4 
593e				call str_at_display 
593e			 
593e				call update_display 
593e				call delay250ms 
593e			 
593e			 
593e			 
593e				ld hl, store_page+2 
593e				call forthparse 
593e				call forthexec 
593e				call forthexec_cleanup 
593e			 
593e				 
593e				ld a, (store_openext) 
593e				inc a 
593e				ld (store_openext), a    ; save count of ext 
593e			 
593e				jr .autof 
593e			;.autofdone: 
593e			; 
593e			;		if DEBUG_FORTH_WORDS 
593e			;			DMARK "ASx" 
593e			;			CALLMONITOR 
593e			;		endif 
593e			;;	call clear_display 
593e			;	ret 
593e			 
593e			 
593e			 
593e			endif 
593e			 
593e			 
593e			; eof 
# End of file forth_kernel.asm
593e			;include "nascombasic.asm" 
593e			 
593e			 
593e			; find out where the code ends if loaded into RAM (for SC114) 
593e			;endofcode:  
593e			;	nop 
593e			 
593e			 
593e			; eof 
593e			 
# End of file main.asm
593e			;include "firmware_lcd_4x40.asm" 
593e			;;include "firmware_lcd_4x20.asm" 
593e			include "firmware_cpm_display.asm" 
593e			 
593e			; Serial display interface for SC114 
593e			 
593e			 
593e			display_row_1: equ 0 
593e			display_row_2: equ display_row_1+display_cols 
593e			display_row_3: equ display_row_2 + display_cols 
593e			display_row_4: equ display_row_3 + display_cols 
593e			 
593e			kLCDWidth:  EQU display_cols             ;Width in characters 
593e			kLCD_Line1: EQU 0x00  
593e			kLCD_Line2: EQU kLCD_Line1+kLCDWidth 
593e			; E1 
593e			kLCD_Line3: EQU kLCD_Line2+kLCDWidth 
593e			kLCD_Line4: EQU kLCD_Line3+kLCDWidth  
593e			 
593e			lcd_init: 
593e				; no init as handled by the SCM bios 
593e c9				ret 
593f			 
593f			 
593f			; low level functions for direct screen writes 
593f			 
593f			; output char at pos? 
593f			fLCD_Str: 
593f			        ;out (SC114_SIO_1_OUT),a 
593f c5				push bc 
5940 d5				push de 
5941 5f				ld e, a 
5942			; TODO Replace with CP/M BIOS call 
5942 0e 02			ld c, $02 
5944 cd 05 00			call 5 
5947 d1				pop de 
5948 c1				pop bc 
5949 c9				ret 
594a			 
594a			; position the cursor on the screen using A as realtive point in screen buffer (i.e. A=(x+(width/y))) 
594a			fLCD_Pos: 
594a				; use ASCII escape to position 
594a			        ;out (SC114_SIO_1_OUT),a 
594a c5				push bc 
594b d5				push de 
594c 5f				ld e, a 
594d 0e 02			ld c, $02 
594f			; TODO Replace with CP/M BIOS call 
594f cd 05 00			call 5 
5952 d1				pop de 
5953 c1				pop bc 
5954			 
5954 c9				ret 
5955			 
5955			; output char at pos 
5955			fLCD_Data: 
5955			      ;  out (SC114_SIO_1_OUT),a 
5955 c5				push bc 
5956 d5				push de 
5957 0e 02			ld c, $02 
5959 5f				ld e, a 
595a			; TODO Replace with CP/M BIOS call 
595a cd 05 00			call 5 
595d d1				pop de 
595e c1				pop bc 
595f			 
595f c9				ret 
5960			 
5960			; ascii cls  
5960			 
5960 1b 5b 48 24	.cls:   db 27, '[', 'H', "$" 
5964			 
5964 0d 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a 0a ..	.clscpm: db 13, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,10,10,10,10,10,"$" 
597b			;.clscpm: db 3, $3c,"$" 
597b			 
597b			; write the frame buffer given in hl to hardware  
597b			write_display: 
597b			 
597b			API: equ 0 
597b			 
597b			if API 
597b				push bc 
597b				ld b, 4 
597b			 
597b			        ld (display_write_tmp), hl 	  
597b			 
597b				; clear and home cursor 
597b			 
597b				ld c, 9 
597b				ld de, .cls 
597b			; TODO Replace with CP/M BIOS call 
597b				call 5 
597b			 
597b			 
597b			.writeln: 
597b			 
597b				ld de, (display_write_tmp) 
597b				ld c, 6 
597b			; TODO Replace with CP/M BIOS call 
597b				rst $30 
597b				ld c, 7 
597b				rst $30 
597b			 
597b				ld hl, (display_write_tmp) 
597b				ld de, display_cols 
597b				add hl,de 
597b				ld (display_write_tmp),hl 
597b			 
597b				djnz  .writeln 
597b			 
597b				pop bc 
597b			 
597b			 
597b				ret 
597b			endif 
597b e5				push hl 
597c c5				push bc 
597d d5				push de 
597e			 
597e			;	ld c, 2 
597e			;	;ld de, .cls 
597e			;	ld a, 27 
597e			;	rst $30 
597e			;	ld c, 2 
597e			;	;ld de, .cls 
597e			;	ld a, '[' 
597e			;	rst $30 
597e			; 
597e			;	ld c, 2 
597e			;	;ld de, .cls 
597e			;	ld a, 'H' 
597e			;	rst $30 
597e			; 
597e			 
597e			 
597e			; lots of CR/LF 
597e			;	ld c, 9 
597e			;	ld de, .clscpm 
597e			;	call 5 
597e			 
597e			; xterm cls 
597e 0e 02			ld c, 2 
5980 1e 1b			ld e, 27 
5982 cd 05 00			call 5 
5985			; cls causes too much flicker 
5985			;	ld c, 2 
5985			;	ld e, 'c' 
5985			;	call 5 
5985			 
5985			; use xterm home instead 
5985 0e 02			ld c, 2 
5987 1e 5b			ld e, '[' 
5989 cd 05 00			call 5 
598c 0e 02			ld c, 2 
598e 1e 48			ld e, 'H' 
5990 cd 05 00			call 5 
5993			LLL: equ 0 
5993			 
5993			if LLL 
5993			 
5993				ld c, 2 
5993				;ld de, .cls 
5993				ld e, 27 
5993			; TODO Replace with CP/M BIOS call 
5993				call 5 
5993			 
5993			 
5993				ld c, 2 
5993				;ld de, .cls 
5993				ld e, '[' 
5993			; TODO Replace with CP/M BIOS call 
5993				call 5 
5993				ld c, 2 
5993				;ld de, .cls 
5993				ld e, '2' 
5993			; TODO Replace with CP/M BIOS call 
5993				call 5 
5993				ld c, 2 
5993				;ld de, .cls 
5993				ld e, 'J' 
5993			; TODO Replace with CP/M BIOS call 
5993				call 5 
5993			 
5993			endif 
5993			 
5993 d1				pop de 
5994 c1				pop bc 
5995 e1				pop hl 
5996			 
5996			 
5996 22 cf eb		        ld (display_write_tmp), hl 	  
5999 3e 00			ld a, kLCD_Line1 
599b			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
599b 06 28			ld b, display_cols 
599d ed 5b cf eb		ld de, (display_write_tmp) 
59a1 cd 24 5a			call write_len_string 
59a4				 
59a4			 
59a4 e5			push hl 
59a5 d5			push de 
59a6 c5			push bc 
59a7 0e 02			ld c, 2 
59a9 1e 0a			ld e, 10 
59ab cd 05 00			call 5 
59ae 0e 02			ld c, 2 
59b0 1e 0d			ld e, 13 
59b2 cd 05 00			call 5 
59b5			; TODO Replace with CP/M BIOS call 
59b5				;rst $30 
59b5 c1			pop bc 
59b6 d1			pop de 
59b7 e1			pop hl 
59b8			 
59b8				 
59b8 2a cf eb			ld hl, (display_write_tmp) 
59bb 11 28 00			ld de, display_cols 
59be 19				add hl,de 
59bf 22 cf eb			ld (display_write_tmp),hl 
59c2			 
59c2				 
59c2 3e 28			ld a, kLCD_Line2 
59c4			        ;    CALL fLCD_Pos       ;Position cursor to location in A 
59c4 06 28			ld b, display_cols 
59c6 ed 5b cf eb		ld de, (display_write_tmp) 
59ca cd 24 5a			call write_len_string 
59cd				 
59cd 2a cf eb			ld hl, (display_write_tmp) 
59d0 11 28 00			ld de, display_cols 
59d3 19				add hl,de 
59d4 22 cf eb			ld (display_write_tmp),hl 
59d7			 
59d7 e5			push hl 
59d8 d5			push de 
59d9 c5			push bc 
59da 0e 07			ld c, 7 
59dc			; TODO Replace with CP/M BIOS call 
59dc				;rst $30 
59dc 0e 02			ld c, 2 
59de 1e 0a			ld e, 10 
59e0 cd 05 00			call 5 
59e3 0e 02			ld c, 2 
59e5 1e 0d			ld e, 13 
59e7 cd 05 00			call 5 
59ea c1			pop bc 
59eb d1			pop de 
59ec e1			pop hl 
59ed			 
59ed				 
59ed 3e 50			ld a, kLCD_Line3 
59ef			         ;   CALL fLCD_Pos       ;Position cursor to location in A 
59ef 06 28			ld b, display_cols 
59f1 ed 5b cf eb		ld de, (display_write_tmp) 
59f5 cd 24 5a			call write_len_string 
59f8				 
59f8 2a cf eb			ld hl, (display_write_tmp) 
59fb 11 28 00			ld de, display_cols 
59fe 19				add hl,de 
59ff 22 cf eb			ld (display_write_tmp),hl 
5a02			 
5a02 e5			push hl 
5a03 d5			push de 
5a04 c5			push bc 
5a05 0e 07			ld c, 7 
5a07			; TODO Replace with CP/M BIOS call 
5a07				;rst $30 
5a07 0e 02			ld c, 2 
5a09 1e 0a			ld e, 10 
5a0b cd 05 00			call 5 
5a0e 0e 02			ld c, 2 
5a10 1e 0d			ld e, 13 
5a12 cd 05 00			call 5 
5a15 c1			pop bc 
5a16 d1			pop de 
5a17 e1			pop hl 
5a18			 
5a18				 
5a18 3e 78			ld a, kLCD_Line4 
5a1a			          ;  CALL fLCD_Pos       ;Position cursor to location in A 
5a1a 06 28			ld b, display_cols 
5a1c ed 5b cf eb		ld de, (display_write_tmp) 
5a20 cd 24 5a			call write_len_string 
5a23 c9					ret 
5a24			 
5a24			 
5a24				; write out a fixed length string given in b from de 
5a24			 
5a24 1a			write_len_string:   LD   A, (DE)        ;Get character from string 
5a25 cd 55 59		            CALL fLCD_Data      ;Write character to display 
5a28 13				inc de 
5a29 10 f9			djnz write_len_string 
5a2b c9				ret 
5a2c			 
5a2c			 
5a2c			; eof 
# End of file firmware_cpm_display.asm
5a2c			;include "firmware_key_5x10.asm" 
5a2c			;;include "firmware_key_4x10.asm" 
5a2c			include "firmware_key_cpm.asm" 
5a2c			; Serial keyboard interface for SC114 
5a2c			 
5a2c			 
5a2c			key_init: 
5a2c				; no init as handled by the SCM bios 
5a2c c9				ret 
5a2d			 
5a2d			 
5a2d			cin_wait: 
5a2d			;	ld a, 0 
5a2d			;	ret 
5a2d			 
5a2d				;in a,(SC114_SIO_1_IN) 
5a2d			        ; Use SCM API to get from whatever console device we are using 
5a2d			 
5a2d			; TODO Replace with CP/M BIOS call 
5a2d c5				push bc 
5a2e 0e 01			ld c, $01 
5a30 cd 05 00			call 5 
5a33 c1				pop bc 
5a34 c9				ret 
5a35			 
5a35			cin: 
5a35			 
5a35			 
5a35 c5				push bc 
5a36			 
5a36				; any key waiting to process? 
5a36			; TODO Replace with CP/M BIOS call 
5a36 0e 06			ld c, $06 
5a38 cd 05 00			call 5 
5a3b 28 0d			jr z, .cin_skip 
5a3d			 
5a3d				; yep, get it 
5a3d			 
5a3d 0e 01			ld c, $01 
5a3f			; TODO Replace with CP/M BIOS call 
5a3f cd 05 00			call 5 
5a42			 
5a42 fe 7f			cp $7f     ; back space 
5a44 20 02			jr nz, .skipbs 
5a46 3e 08			ld a, KEY_BS 
5a48			.skipbs: 
5a48			 
5a48 c1				pop bc 
5a49 c9				ret 
5a4a			.cin_skip: 
5a4a 3e 00			ld a, 0 
5a4c c1				pop bc 
5a4d c9				ret 
5a4e			 
5a4e			 
5a4e			 
5a4e			 
# End of file firmware_key_cpm.asm
5a4e			endofcode:  
5a4e			baseram:  
5a4e 00				nop 
5a4f			 
5a4f			heap_start: equ baseram+15  ; Starting address of heap 
5a4f			free_list:  equ baseram+10      ; Block struct for start of free list (MUST be 4 bytes) 
5a4f			heap_size: equ  heap_end-heap_start      ; Number of bytes available in heap   TODO make all of user ram 
5a4f			;VDU:  EQU     endofcode           ; BASIC Work space 
5a4f			; eof 
5a4f			 
# End of file os_mega_cpm.asm
5a4f
